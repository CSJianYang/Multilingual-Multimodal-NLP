[
    {
        "title": "Remove Duplicates from Sorted Array",
        "question_content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\n\tChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-100 <= nums[i] <= 100\n\tnums is sorted in non-decreasing order.",
        "solutions": [
            {
                "id": 11782,
                "title": "share-my-clean-c-code",
                "content": "    int count = 0;\\n    for(int i = 1; i < n; i++){\\n        if(A[i] == A[i-1]) count++;\\n        else A[i-count] = A[i];\\n    }\\n    return n-count;",
                "solutionTags": [],
                "code": "    int count = 0;\\n    for(int i = 1; i < n; i++){\\n        if(A[i] == A[i-1]) count++;\\n        else A[i-count] = A[i];\\n    }\\n    return n-count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3676877,
                "title": "best-method-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe Intuition is to use two pointers, `i` and `j`, to iterate through the array. The variable `j` is used to keep track of the current index where a unique element should be placed. The initial value of `j` is 1 since the first element in the array is always unique and doesn\\'t need to be changed.\\n\\n# Explanation:\\nThe code starts iterating from `i = 1` because we need to compare each element with its previous element to check for duplicates.\\n\\nThe main logic is inside the `for` loop:\\n1. If the current element `nums[i]` is not equal to the previous element `nums[i - 1]`, it means we have encountered a new unique element.\\n2. In that case, we update `nums[j]` with the value of the unique element at `nums[i]`, and then increment `j` by 1 to mark the next position for a new unique element.\\n3. By doing this, we effectively overwrite any duplicates in the array and only keep the unique elements.\\n\\nOnce the loop finishes, the value of `j` represents the length of the resulting array with duplicates removed.\\n\\nFinally, we return `j` as the desired result.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] != nums[i - 1]){\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[i - 1]) {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        j = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]:\\n                nums[j] = nums[i]\\n                j += 1\\n        return j\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/0a452532-539e-4e22-b67e-e13f2b0179fb_1687605319.248808.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote the post for more questions.**\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] != nums[i - 1]){\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[i - 1]) {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        j = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]:\\n                nums[j] = nums[i]\\n                j += 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107606,
                "title": "py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python",
                "content": "\\n## \\u2705 Method 1: sort in place using `[:]`\\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```\\n\\n\\n**Time Complexity:** `O(n)`\\n**Space Complexity:** `O(1)`\\n\\n\\n### \\u274C Common Wrong Answers:\\n```\\n\\tnums = sorted(set(nums))\\n\\treturn len(nums)\\n```\\n\\xA0`nums =`\\xA0 doesn\\'t replace elements in the original list.\\n `nums[:] =`\\xA0replaces element in place\\n\\nIn short, without `[:]`, we\\'re creating a new list object, which is against what this problem is asking for:\\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n-----------------------\\n##  \\u2705 Method 2: Two-pointers\\n### \\uD83E\\uDD14 Initial Intuition:\\nUse a `slow`  pointer to \"lock\" the \"wanted\" element, and use a `fast` pointer to move forward along the list and look for new unique elements in the list.\\nOr, in other words,  the current `slow` pointer is used to locate the latest unique number for the results, and `fast` is used for iterating and discovery.\\n\\nHave `fast` advanced in every iteration, but `slow` is only advanced when two pointers are onto two different elements. \\n\\nThat means, the elements after `nums[slow]` and before `nums[fast]` are numbers we\\'ve **seen** before and don\\'t need anymore (one copy of these numbers is already saved before the current `slow` (inclusive)).  \\n\\nTherefore, in order to have this newly discovered (unseen) number pointed by the current `fast` to the front of the array for the final answer, we just need to swap this newly discovered number to the location that follows the current `slow` pointer, with one of the **seen** numbers (we don\\'t need it for the answer regardlessly), and then advance the `slow` in the same iteration to lock this new number.\\n\\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tslow, fast = 0, 1\\n\\t\\twhile fast in range(len(nums)):\\n\\t\\t\\tif nums[slow] == nums[fast]:\\n\\t\\t\\t\\tfast += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnums[slow+1] = nums[fast]\\n\\t\\t\\t\\tfast += 1\\n\\t\\t\\t\\tslow += 1\\n\\n\\t\\treturn slow + 1\\n```\\n\\n### \\u2747\\uFE0F Simplified two-pointers with for loops:\\n\\uD83D\\uDCA1 However, observe,  `fast` pointer is simply incremented in every iteration regardless of the conditions, that\\'s just a typical for loop\\'s job.  Therefore, we can simplify this \"two-pointers\" system as follows:\\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tj = 0\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tif nums[j] != nums[i]:\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tnums[j] = nums[i]\\n\\t\\treturn j + 1\\n```\\n\\n**Time Complexity:** `O(n)`\\n**Space Complexity:** `O(1)`\\n\\n-----------------------\\n## Method 3: Using `.pop()`\\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\ti = 1\\n\\t\\twhile i < len(nums):\\n\\t\\t\\tif nums[i] == nums[i - 1]:\\n\\t\\t\\t\\tnums.pop(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti += 1\\n\\t\\treturn len(nums)\\n```\\n-----------------------\\n## Method 4: Using `OrderedDict.fromkeys()`\\n```\\nfrom collections import OrderedDict\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums[:] =  OrderedDict.fromkeys(nums)\\n        return len(nums)\\n```\\n-------------------\\n-----------------------\\nAs a total beginner, I am writing these all out to help myself, and hopefully also help anyone out there who is like me at the same time.\\n\\nPlease upvote\\u2B06\\uFE0F if you find this helpful or worth-reading for beginners in anyway.\\nYour upvote is much more than just supportive to me. \\uD83D\\uDE33\\uD83E\\uDD13\\uD83E\\uDD70\\n\\nIf you find this is not helpful, needs improvement, or is questionable, would you please leave a quick comment below to point out the problem before you decide to downvote? It will be very helpful for me (maybe also others) to learn as a beginner.\\n\\nThank you very much either way \\uD83E\\uDD13.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tnums[:] = sorted(set(nums))\\n\\t\\treturn len(nums)\\n```\n```\\n\\tnums = sorted(set(nums))\\n\\treturn len(nums)\\n```\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tslow, fast = 0, 1\\n\\t\\twhile fast in range(len(nums)):\\n\\t\\t\\tif nums[slow] == nums[fast]:\\n\\t\\t\\t\\tfast += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnums[slow+1] = nums[fast]\\n\\t\\t\\t\\tfast += 1\\n\\t\\t\\t\\tslow += 1\\n\\n\\t\\treturn slow + 1\\n```\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\tj = 0\\n\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\tif nums[j] != nums[i]:\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tnums[j] = nums[i]\\n\\t\\treturn j + 1\\n```\n```\\n\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\ti = 1\\n\\t\\twhile i < len(nums):\\n\\t\\t\\tif nums[i] == nums[i - 1]:\\n\\t\\t\\t\\tnums.pop(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti += 1\\n\\t\\treturn len(nums)\\n```\n```\\nfrom collections import OrderedDict\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums[:] =  OrderedDict.fromkeys(nums)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11780,
                "title": "5-lines-c-java-nicer-loops",
                "content": "I don't like old-style indexed looping. I much prefer the \"enhanced\" (Java) / \"range-based\" (C++) loops, they make things much cleaner.\\n\\n---\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (!i || n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\nAnd to not need the `!i` check in the loop:\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = !nums.empty();\\n        for (int n : nums)\\n            if (n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n---\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i == 0 || n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\nAnd to not need the `i == 0` check in the loop:\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = nums.length > 0 ? 1 : 0;\\n        for (int n : nums)\\n            if (n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "I don't like old-style indexed looping. I much prefer the \"enhanced\" (Java) / \"range-based\" (C++) loops, they make things much cleaner.\\n\\n---\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (!i || n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\nAnd to not need the `!i` check in the loop:\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = !nums.empty();\\n        for (int n : nums)\\n            if (n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n---\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i == 0 || n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\nAnd to not need the `i == 0` check in the loop:\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = nums.length > 0 ? 1 : 0;\\n        for (int n : nums)\\n            if (n > nums[i-1])\\n                nums[i++] = n;\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11757,
                "title": "my-solution-time-o-n-space-o-1",
                "content": "    class Solution {\\n        public:\\n        int removeDuplicates(int A[], int n) {\\n            if(n < 2) return n;\\n            int id = 1;\\n            for(int i = 1; i < n; ++i) \\n                if(A[i] != A[i-1]) A[id++] = A[i];\\n            return id;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        int removeDuplicates(int A[], int n) {\\n            if(n < 2) return n;\\n            int id = 1;\\n            for(int i = 1; i < n; ++i) \\n                if(A[i] != A[i-1]) A[id++] = A[i];\\n            return id;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3496619,
                "title": "simplest-4-line-sol-with-proper-explanation",
                "content": "# Intuition\\nWe can think of using two pointers \\u2018i\\u2019 and \\u2018j\\u2019, we move \\u2018j\\u2019 till we don\\u2019t get a number arr[j] which is different from arr[i]. As we got a unique number we will increase the i pointer and update its value by arr[j]. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake a variable i as 0;\\nUse a for loop by using a variable \\u2018j\\u2019 from 1 to length of the array.\\nIf arr[j] != arr[i], increase \\u2018i\\u2019 and update arr[i] == arr[j].\\n After completion of the loop return i+1, i.e size of the array of unique elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=0;\\n        for(int j=1;j<arr.length;j++){\\n            if(arr[i]!=arr[j]){\\n                i++;\\n                arr[i]=arr[j];\\n            }\\n        }\\n        return i+1;\\n        \\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/87599497-3f81-4882-bf7d-e4e46aab593a_1683459516.4004748.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=0;\\n        for(int j=1;j<arr.length;j++){\\n            if(arr[i]!=arr[j]){\\n                i++;\\n                arr[i]=arr[j];\\n            }\\n        }\\n        return i+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302016,
                "title": "python-solution",
                "content": "Given a sorted array and we need to return the length of the unique elements instead of the entire array. There is no need to delete the duplicate elements also. \\n* Since, our first element is already present at index 0 (**it is a unique element**), we quickly run a for loop for the entire array to scan for unique elements.\\n* If the current element and the next element are the same, then we just keep on going till we find a different element\\n* Once we find a different element, it is inserted at index 1, because, index 0 is taken by the first unique element. \\n* Once this is done, the same scanning is done to find out the next unique element and this element is to be inserted at index 2. This process continues until we are done with unique elements.\\n* **We use a variable (x = 1) which is incremented to the next index whenever we find a unique element and we insert this element at its corresponding index**.\\n```\\nx = 1\\nfor i in range(len(nums)-1):\\n\\tif(nums[i]!=nums[i+1]):\\n\\t\\tnums[x] = nums[i+1]\\n\\t\\tx+=1\\nreturn(x)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nx = 1\\nfor i in range(len(nums)-1):\\n\\tif(nums[i]!=nums[i+1]):\\n\\t\\tnums[x] = nums[i+1]\\n\\t\\tx+=1\\nreturn(x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328708,
                "title": "c-solution-o-n-time-complexity",
                "content": "**Two pointer Approach** \\n**Time Complexity - O(N)**\\n**Space Complexity - O(1)**\\n\\nThe problem has asked to do inplace so we need to modify the given nums vector only \\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int left = 0;\\n        for(int right =1; right< nums.size(); right++){\\n           if(nums[left] != nums[right])\\n               left++;\\n               nums[left] = nums[right];\\n           }\\n    return left+1;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**\\n**comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int left = 0;\\n        for(int right =1; right< nums.size(); right++){\\n           if(nums[left] != nums[right])\\n               left++;\\n               nums[left] = nums[right];\\n           }\\n    return left+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310164,
                "title": "8-lines-two-pointer-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i,j=0,1\\n        while i<=j and j<len(nums):\\n            if nums[i]==nums[j]:\\n                j+=1\\n            else:\\n                nums[i+1]=nums[j]\\n                i+=1\\n        return i+1\\n\\n\\n        \\n```\\n# Consider upvoting if found helpul\\n    \\n![57jfh9.jpg](https://assets.leetcode.com/users/images/42468411-f114-491a-8a3d-e8170fad5d00_1679120730.6341107.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i,j=0,1\\n        while i<=j and j<len(nums):\\n            if nums[i]==nums[j]:\\n                j+=1\\n            else:\\n                nums[i+1]=nums[j]\\n                i+=1\\n        return i+1\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105108,
                "title": "c-easy-solution-using-set",
                "content": "THIS QUESTION IS SOLVED BY USING SET .......\\n 1.First of all we have to create an empty set then we have to store all the element in the set.\\n 2.As we know in set all element appears once...so it is clear that no element is repeated.\\n 3.Then we have to return the size of element and which is present in set but before we have to restore all the element in the nums array.\\n 4.so first of all clear all the element in the nums array using **nums.clear( );**\\n 5.Then in nums array push all the set element.\\n 6.And in last return the size of set.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n    set<int> s; \\n        for(int i =0; i<nums.size(); i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        int ans = s.size();\\n        nums.clear();\\n        for(auto i:s)\\n        {\\n           //int k = *i;\\n           nums.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n    IF MY EFFORTS HELP YOU PLEASE LIKE IT\\uD83D\\uDE0A\\uD83D\\uDE0A\\n  ![image](https://assets.leetcode.com/users/images/e7c564e1-bda7-48f7-860b-8e113d98dc2f_1674818638.3033829.jpeg)\\n\\n \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n    set<int> s; \\n        for(int i =0; i<nums.size(); i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        int ans = s.size();\\n        nums.clear();\\n        for(auto i:s)\\n        {\\n           //int k = *i;\\n           nums.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11751,
                "title": "simple-python-solution-o-n",
                "content": "    class Solution:\\n        # @param a list of integers\\n        # @return an integer\\n        def removeDuplicates(self, A):\\n            if not A:\\n                return 0\\n    \\n            newTail = 0\\n    \\n            for i in range(1, len(A)):\\n                if A[i] != A[newTail]:\\n                    newTail += 1\\n                    A[newTail] = A[i]\\n    \\n            return newTail + 1",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param a list of integers\\n        # @return an integer\\n        def removeDuplicates(self, A):\\n            if not A:\\n                return 0\\n    \\n            newTail = 0\\n    \\n            for i in range(1, len(A)):\\n                if A[i] != A[newTail]:\\n                    newTail += 1\\n                    A[newTail] = A[i]\\n    \\n            return newTail + 1",
                "codeTag": "Java"
            },
            {
                "id": 2693084,
                "title": "c-easy-three-line-solution",
                "content": "```\\n\\tint k=1;\\n\\tfor(int i=1; i<nums.size(); i++)        \\n\\t\\tif(nums[i]!=nums[i-1]) nums[k++] = nums[i];     \\n\\treturn k;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\tint k=1;\\n\\tfor(int i=1; i<nums.size(); i++)        \\n\\t\\tif(nums[i]!=nums[i-1]) nums[k++] = nums[i];     \\n\\treturn k;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983019,
                "title": "java-solution-explanation-runtime-1ms-beats-100",
                "content": "# Approach\\nBy iterating through the array and checking if `nums` at the current index `i` is less than `nums` at `i + 1`, we can find an index for all unique numbers in the array. We can then insert each of these numbers to the beginning of the array, at `addIndex`. `addIndex` starts at 0 as the first element in the array is always unique.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        \\n        int addIndex = 1; //index that unique characters will be inserted at\\n\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            \\n            if(nums[i] < nums[i + 1]){ //if true, num[i + 1] is a new unique number\\n              nums[addIndex] = nums[i + 1];\\n              addIndex++;\\n            }\\n        }\\n        return addIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0)\\n            return 0;\\n        \\n        int addIndex = 1; //index that unique characters will be inserted at\\n\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            \\n            if(nums[i] < nums[i + 1]){ //if true, num[i + 1] is a new unique number\\n              nums[addIndex] = nums[i + 1];\\n              addIndex++;\\n            }\\n        }\\n        return addIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11769,
                "title": "5-lines-java-solution",
                "content": "    public int removeDuplicates(int[] A) {\\n        if (A.length==0) return 0;\\n        int j=0;\\n        for (int i=0; i<A.length; i++)\\n            if (A[i]!=A[j]) A[++j]=A[i];\\n        return ++j;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeDuplicates(int[] A) {\\n        if (A.length==0) return 0;\\n        int j=0;\\n        for (int i=0; i<A.length; i++)\\n            if (A[i]!=A[j]) A[++j]=A[i];\\n        return ++j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248020,
                "title": "my-easy-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let i = 0;\\n    for (let j = 0; j < nums.length; j++) {\\n        if (nums[j] != nums[i]) \\n            nums[++i] = nums[j];\\n    }\\n    return ++i;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let i = 0;\\n    for (let j = 0; j < nums.length; j++) {\\n        if (nums[j] != nums[i]) \\n            nums[++i] = nums[j];\\n    }\\n    return ++i;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342081,
                "title": "100-faster-java-2-approaches-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/11b0c73a-93c2-4070-be5e-0da83168b376_1679806165.9706037.png)\\n\\n# Code\\n```\\npublic int removeDuplicates(int[] nums) {\\n        \\n        int newIndex = 1; // Start with index 1 because the first element is already in place\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\n            if (nums[i] < nums[i+1]) { // If the current element is less than the next element\\n            \\n                nums[newIndex] = nums[i+1]; // Move the next element to the new index\\n                newIndex++; // Increment the new index\\n            }\\n        }\\n    return newIndex; // Return the length of the new subarray\\n\\n\\n\\n---\\nSecond Approach (here we are using extra space for this space complexity will be O(N))\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n\\n        //Insert all array element in the Set. \\n        //Set does not allow duplicates and sets like LinkedHashSet maintains the order of insertion so it will remove duplicates and elements will be printed in the same order in which it is inserted\\n\\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            set.add(nums[i]);\\n        }\\n        //copy unique element back to array\\n        int i = 0;\\n\\n        for(int ele:set){\\n            nums[i++] = ele;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\npublic int removeDuplicates(int[] nums) {\\n        \\n        int newIndex = 1; // Start with index 1 because the first element is already in place\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\n            if (nums[i] < nums[i+1]) { // If the current element is less than the next element\\n            \\n                nums[newIndex] = nums[i+1]; // Move the next element to the new index\\n                newIndex++; // Increment the new index\\n            }\\n        }\\n    return newIndex; // Return the length of the new subarray\\n\\n\\n\\n---\\nSecond Approach (here we are using extra space for this space complexity will be O(N))\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n\\n        //Insert all array element in the Set. \\n        //Set does not allow duplicates and sets like LinkedHashSet maintains the order of insertion so it will remove duplicates and elements will be printed in the same order in which it is inserted\\n\\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            set.add(nums[i]);\\n        }\\n        //copy unique element back to array\\n        int i = 0;\\n\\n        for(int ele:set){\\n            nums[i++] = ele;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508180,
                "title": "c-python-clean-and-simple-solution",
                "content": "**C++ :**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {        \\n\\tint numOfDuplicates = 0;\\n\\n\\tfor(int i = 1; i < nums.size(); ++i)\\n\\t{\\n\\t\\tif(nums[i] == nums[i - 1])\\n\\t\\t\\t++numOfDuplicates;\\n\\t\\telse\\n\\t\\t\\tnums[i - numOfDuplicates] = nums[i];\\n\\t}\\n\\treturn nums.size() - numOfDuplicates;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n\\tduplicates = 0\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i] == nums[i - 1]:\\n\\t\\t\\tduplicates += 1\\n\\t\\telse:\\n\\t\\t\\tnums[i - duplicates] = nums[i]\\n\\n\\treturn len(nums) - duplicates\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {        \\n\\tint numOfDuplicates = 0;\\n\\n\\tfor(int i = 1; i < nums.size(); ++i)\\n\\t{\\n\\t\\tif(nums[i] == nums[i - 1])\\n\\t\\t\\t++numOfDuplicates;\\n\\t\\telse\\n\\t\\t\\tnums[i - numOfDuplicates] = nums[i];\\n\\t}\\n\\treturn nums.size() - numOfDuplicates;\\n}\\n```\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n\\tduplicates = 0\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i] == nums[i - 1]:\\n\\t\\t\\tduplicates += 1\\n\\t\\telse:\\n\\t\\t\\tnums[i - duplicates] = nums[i]\\n\\n\\treturn len(nums) - duplicates\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3416595,
                "title": "c-java-python-javascript-fully-explained-two-pointer",
                "content": "# Intuition:\\nThe problem requires us to remove duplicate elements from a sorted array, i.e., we need to keep only one copy of each element in the array. Since the array is sorted, all duplicate elements will be adjacent to each other, so we can easily remove them by shifting the subsequent elements of the array to the left.\\n\\n# Approach:\\nWe can use two pointers i and j, where i points to the last unique element found so far, and j points to the current element being examined. If nums[i] and nums[j] are equal, we just increment j. Otherwise, we increment i and copy nums[j] to nums[i]. At the end, we return i+1, which represents the length of the modified array.\\n\\n# Complexity:\\n- Time complexity: Since we only traverse the array once, the time complexity of the algorithm is O(n).\\n- Space complexity: The algorithm uses constant extra space, so the space complexity is O(1).\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n  let i = 0;\\n  for (let j = 1; j < nums.length; j++) {\\n    if (nums[i] !== nums[j]) {\\n      i++;\\n      nums[i] = nums[j];\\n    }\\n  }\\n  return i + 1;\\n}\\n\\n```\\n# Java\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.length; j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for j in range(1, len(nums)):\\n            if nums[i] != nums[j]:\\n                i += 1\\n                nums[i] = nums[j]\\n        return i + 1\\n\\n```\\n\\n**THANK YOU**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n  let i = 0;\\n  for (let j = 1; j < nums.length; j++) {\\n    if (nums[i] !== nums[j]) {\\n      i++;\\n      nums[i] = nums[j];\\n    }\\n  }\\n  return i + 1;\\n}\\n\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.length; j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for j in range(1, len(nums)):\\n            if nums[i] != nums[j]:\\n                i += 1\\n                nums[i] = nums[j]\\n        return i + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527963,
                "title": "c-solution-with-full-explanation-using-2pointers",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***Using 2 pointers approach***.\\n- ***i*** will iterate over all elements & ***j*** will be the index off duplicates numbers.\\n- We will replace ***j*** only if we find a number not similar to the j-indexed number.\\n- Increase the value of the unique element every time j increased.\\n- Edge case: if you return 0 while n=0, it will give a run time error.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- ***This uses extra space, which doesn\\u2019t satisfy the condition of the question.***\\n- First, we put all the elements in a set & only unique elements will be stored.\\n- Calculate the size of the set & iterate all elements of nums and replace them with set values.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n<2)\\n            return n;\\n        int ans=1, j=0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]!=nums[j]){\\n                j++;\\n                nums[j]=nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= nums.size();\\n        set <int> a;\\n        for(int i=0; i<n; i++)\\n            a.insert(nums[i]);\\n        \\n        int ans = a.size();\\n        int i=0;\\n        for(auto x:a){\\n            nums[i]=x;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n<2)\\n            return n;\\n        int ans=1, j=0;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]!=nums[j]){\\n                j++;\\n                nums[j]=nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= nums.size();\\n        set <int> a;\\n        for(int i=0; i<n; i++)\\n            a.insert(nums[i]);\\n        \\n        int ans = a.size();\\n        int i=0;\\n        for(auto x:a){\\n            nums[i]=x;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801748,
                "title": "python-c-java-rust-two-pointers-bonus-one-liners-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a two-pointers approach for rearrangement of numbers in a sorted array. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n\\n**Comment.** The strategy here is to iterate over the input array (first pointer) and move its unique elements to the end of deduplicated array. The input array is sorted, thus, during iteration, each unique value appears as the one that differs from the last one. When encountered a new unique value, we also update the position of the end of deduplicated array (second pointer).\\n\\n**Python #1**.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int], k = 1) -> int:\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:            # detect next unique value \\n                nums[k] = nums[i]               # move it to the end of deduplicated array\\n                k += 1                          # update the size of deduplicated array\\n        return k\\n```\\n\\nThere is also a stack-based type of solution that is **O(N\\\\*N)** in time (due to the linear-time *pop*) but still **O(1)** in (additionally allocated) space.\\n\\n**Python #2.**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        for i in reversed(range(1,len(nums))):\\n            if nums[i] == nums[i-1]:\\n                nums.pop(i)\\n        return len(nums)\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/h9Z3qtEL/shared\" frameBorder=\"0\" width=\"800\" height=\"250\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nAs a **BONUS**, I provide a couple of one-liners...\\n\\n**Python #1.** Note that here we use a generator that has **O(1)** space complexity.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = (n for i, n in enumerate(nums) if i == 0 or nums[i-1] != n)\\n```\\n\\n**Python #2.** Well, here it\\'s not an **O(1)**-complexity solution, but very concise...\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int], k = 1) -> int:\\n        nums[:] = sorted(list(set(nums)))\\n```\\n\\n**C++.** The *unique* function returns an iterator to which we can apply *distance* or just subtraction.\\n```\\nclass Solution \\n{\\npublic:\\n    int removeDuplicates(vector<int>& nums, int k = 1)\\n    {\\n\\t\\treturn distance(nums.begin(), unique(nums.begin(), nums.end()));\\n\\t\\t// or just subtract iterators...\\n\\t\\t// return unique(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```\\n\\n**Rust.** Using a built-in *dedup* function.\\n```\\nimpl Solution \\n{\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 \\n    {\\n        nums.dedup(); nums.len() as _\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int], k = 1) -> int:\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:            # detect next unique value \\n                nums[k] = nums[i]               # move it to the end of deduplicated array\\n                k += 1                          # update the size of deduplicated array\\n        return k\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        for i in reversed(range(1,len(nums))):\\n            if nums[i] == nums[i-1]:\\n                nums.pop(i)\\n        return len(nums)\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = (n for i, n in enumerate(nums) if i == 0 or nums[i-1] != n)\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int], k = 1) -> int:\\n        nums[:] = sorted(list(set(nums)))\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int removeDuplicates(vector<int>& nums, int k = 1)\\n    {\\n\\t\\treturn distance(nums.begin(), unique(nums.begin(), nums.end()));\\n\\t\\t// or just subtract iterators...\\n\\t\\t// return unique(nums.begin(), nums.end()) - nums.begin();\\n    }\\n};\\n```\n```\\nimpl Solution \\n{\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 \\n    {\\n        nums.dedup(); nums.len() as _\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11870,
                "title": "simple-1ms-java-solution",
                "content": "    public class Solution\\n    {\\n        public int removeDuplicates(int[] nums)\\n        {\\n            int dupes = 0;\\n            \\n            for (int i = 1; i < nums.length; i++)\\n            {\\n                if (nums[i] == nums[i - 1])\\n                    dupes++;\\n                \\n                nums[i - dupes] = nums[i];\\n            }\\n            \\n            return nums.length - dupes;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public int removeDuplicates(int[] nums)\\n        {\\n            int dupes = 0;\\n            \\n            for (int i = 1; i < nums.length; i++)\\n            {\\n                if (nums[i] == nums[i - 1])\\n                    dupes++;\\n                \\n                nums[i - dupes] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 453327,
                "title": "python-3-100-less-memory-96-faster-only-len-range-called",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        length = 0\\n        if len(nums) == 0: return length\\n        for i in range(1,len(nums)):\\n            if nums[length] < nums[i]:\\n                length += 1\\n                nums[length] = nums[i]\\n        return length+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        length = 0\\n        if len(nums) == 0: return length\\n        for i in range(1,len(nums)):\\n            if nums[length] < nums[i]:\\n                length += 1\\n                nums[length] = nums[i]\\n        return length+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803563,
                "title": "concise-and-simple-one-pass-solution",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int RemoveDuplicates(int[] nums)\\n    {\\n        int i = 1;\\n\\n        foreach (int n in nums)\\n        {\\n            if (nums[i - 1] != n) nums[i++] = n;\\n        }\\n\\n        return i;\\n    }\\n}\\n```\\n\\nThe code is short and probably does not require explanation but here is the main idea: We compare every number in the array with the latest distinct number. If they are not equal, it\\'s a new distinct number and we copy it over to the next position in the array, hence `i++`.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int RemoveDuplicates(int[] nums)\\n    {\\n        int i = 1;\\n\\n        foreach (int n in nums)\\n        {\\n            if (nums[i - 1] != n) nums[i++] = n;\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11802,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var removeDuplicates = function(nums) {\\n        for (i = 0; i < nums.length; i++) {\\n            //Next number is identical to current one\\n            if (nums[i] == nums[i+1]) {\\n                nums.splice(i, 1);\\n                i--;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeDuplicates = function(nums) {\\n        for (i = 0; i < nums.length; i++) {\\n            //Next number is identical to current one\\n            if (nums[i] == nums[i+1]) {\\n                nums.splice(i, 1);\\n                i--;\\n            }\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 2801677,
                "title": "python3-two-pointers-o-n",
                "content": "Since the problem is asking us to remove duplicates **in place**, it seems like the only choice we have is to use a two-pointers approach. Also since the array is sorted, duplicates are grouped together in the array.\\n(1) Using a pointer ```i``` to point to the index where the element will be replaced.\\n(2) Using another pointer, ```j```, to go through the array and check if the jth element is the same as the j-1 element or not. \\n(3) If ```nums[j]!=nums[j-1]```, we should replace nums[i] with nums[j] and move ```i``` forward by 1. This is because ```nums[j]``` is the first element without duplicates before it, and we should keep it in the results. \\n\\nIn the end, ```nums[:i]``` will be the array without any duplicates, so we just return ```i```. Note that ```i``` should start at 1 since ```nums[0]``` will always be there no matter what.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for j in range(1,len(nums)):\\n            if nums[j] != nums[j-1]:\\n                nums[i] = nums[j-1]\\n                i += 1\\n        nums[i] = nums[-1]\\n        return i+1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```i```\n```j```\n```nums[j]!=nums[j-1]```\n```i```\n```nums[j]```\n```nums[:i]```\n```i```\n```i```\n```nums[0]```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for j in range(1,len(nums)):\\n            if nums[j] != nums[j-1]:\\n                nums[i] = nums[j-1]\\n                i += 1\\n        nums[i] = nums[-1]\\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963008,
                "title": "c-image-explanation-no-extra-space",
                "content": "# Intuition\\nsee below image and see code simultenously\\n![Screenshot (1100).png](https://assets.leetcode.com/users/images/0c35867a-faea-467a-bf8f-52b2f9779de4_1693055451.5167916.png)\\n![Screenshot (1102).png](https://assets.leetcode.com/users/images/34d3555a-a035-41d9-99d0-dbe190918df2_1693055498.09549.png)\\n![Screenshot (1103).png](https://assets.leetcode.com/users/images/4c75e55b-07bb-4110-bded-8fc45f099ec6_1693055509.8981445.png)\\n![Screenshot (1104).png](https://assets.leetcode.com/users/images/7dba6b62-2438-4652-a1bd-3e1d82392332_1693055521.2899055.png)\\n![Screenshot (1105).png](https://assets.leetcode.com/users/images/5a46d8d1-e5f0-47a4-8ef8-bd0d7590fa20_1693055532.1642077.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=1) return nums.size();\\n        int position=1;\\n        for(int i=1;i<nums.size();++i){\\n            if(nums[i]!=nums[position-1]){\\n                nums[position]=nums[i];\\n                position++;\\n            }\\n        }\\n        return position;\\n    }\\n};\\n```\\n\\n# Time complexity :- O(n)\\n# space complexity :- O(1);\\n\\n# PLEASE upvote if you like my solution \\n![begging.jpg](https://assets.leetcode.com/users/images/62f0d0c9-5fa5-41b5-8e98-af045e40586f_1693055698.924021.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=1) return nums.size();\\n        int position=1;\\n        for(int i=1;i<nums.size();++i){\\n            if(nums[i]!=nums[position-1]){\\n                nums[position]=nums[i];\\n                position++;\\n            }\\n        }\\n        return position;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12092,
                "title": "java-solution-with-explanation",
                "content": "    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n        \\n            int i = 1; //iterator thru array\\n            int j = 0; //current index\\n            for (; i<nums.length; i++) { \\n                if (nums[i] != nums[j]) { //new number\\n                    j++; //move current index\\n                    nums[j] = nums[i]; //fill current index with new number\\n                } \\n            }\\n        return j+1;\\n       }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n        \\n            int i = 1; //iterator thru array\\n            int j = 0; //current index\\n            for (; i<nums.length; i++) { \\n                if (nums[i] != nums[j]) { //new number\\n                    j++; //move current index\\n                    nums[j] = nums[i]; //fill current index with new number\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1656824,
                "title": "solution-swift-accepted-test-cases",
                "content": "```swift\\nclass Solution {\\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let len = nums.count\\n        guard len > 1 else { return len }\\n        var idx = 0\\n        for n in nums where n != nums[idx] {\\n            idx += 1\\n            nums[idx] = n\\n        }\\n        return idx + 1\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b>  Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test0() {\\n        var array = [1,1,2]\\n        solution.removeDuplicates(&array)\\n        XCTAssertEqual(2, [1,2].count)\\n    }\\n    \\n    /// Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test1() {\\n        var array = [0,0,1,1,1,2,2,3,3,4]\\n        solution.removeDuplicates(&array)\\n        XCTAssertEqual(5, [0,1,2,3,4].count)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let len = nums.count\\n        guard len > 1 else { return len }\\n        var idx = 0\\n        for n in nums where n != nums[idx] {\\n            idx += 1\\n            nums[idx] = n\\n        }\\n        return idx + 1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test0() {\\n        var array = [1,1,2]\\n        solution.removeDuplicates(&array)\\n        XCTAssertEqual(2, [1,2].count)\\n    }\\n    \\n    /// Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test1() {\\n        var array = [0,0,1,1,1,2,2,3,3,4]\\n        solution.removeDuplicates(&array)\\n        XCTAssertEqual(5, [0,1,2,3,4].count)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343351,
                "title": "python3-dictionary-map",
                "content": "# Please Upvote \\uD83D\\uDE07\\nThis is a solution to the \"Remove Duplicates from Sorted Array\" problem, which asks to remove duplicate elements from an input list of integers and return the length of the resulting list.\\n\\nThe solution uses a dictionary to keep track of the frequency of each element in the input list. It then iterates over the input list, and for each element, it checks if it has already been encountered using the dictionary. If the element is encountered for the first time, it is added to the output list and its index is incremented. Finally, the length of the dictionary (which corresponds to the length of the output list) is returned.\\n\\nNote that the solution assumes that the input list is sorted, which is necessary to ensure that duplicate elements appear consecutively.\\n# Python3\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mp=defaultdict(int)\\n        ans=[]\\n        x=0\\n        for i in nums:\\n            mp[i]+=1\\n            if mp[i]==1:\\n                nums[x]=i\\n                x+=1\\n        return len(mp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mp=defaultdict(int)\\n        ans=[]\\n        x=0\\n        for i in nums:\\n            mp[i]+=1\\n            if mp[i]==1:\\n                nums[x]=i\\n                x+=1\\n        return len(mp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067772,
                "title": "go-solution",
                "content": "```\\nfunc removeDuplicates(nums []int) int {\\n    ln := len(nums)\\n    if ln <= 1 {\\n        return ln\\n    }\\n    \\n    j := 0 // points to  the index of last filled position\\n    for i := 1; i < ln; i++ {\\n        if nums[j] != nums[i] {\\n            j++\\n            nums[j] = nums[i]\\n        }\\n    }\\n    \\n    return j + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    ln := len(nums)\\n    if ln <= 1 {\\n        return ln\\n    }\\n    \\n    j := 0 // points to  the index of last filled position\\n    for i := 1; i < ln; i++ {\\n        if nums[j] != nums[i] {\\n            j++\\n            nums[j] = nums[i]\\n        }\\n    }\\n    \\n    return j + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696566,
                "title": "java-simplest-solution-detailed-explaination",
                "content": "Intution - \\nHere we will traverse through the whole given array, but simultaneously keep the pointer of the previous index which is stored.\\nAs we traverse through the arrray, whenever we came across a new integer will compare it with the previous one if both of them are different then will store the new integer in new place and update the pointer. Once the the traversal is complete will have all the unique integer at left side and thats what we want.\\nSimple isn\\'t it..\\nNow lets look at the code.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n      \\n     //Here we declared a pointer to keep the track of previous index\\n      int previous = 0;\\n        \\n        for(int i = 1; i < nums.length; i++)\\n        {\\n            //Condition used - if the integer at i\\'th index is not equal to integer at previous\\'th index then the condition is satisfies i.e both the integer are different\\n            if(nums[i] != nums[previous])\\n            {\\n                //Incresing the previous by one to update its position by 1.\\n                previous++;\\n                \\n                //Inserting the value at i\\'th index to the previous\\'th index\\n                nums[previous] = nums[i];\\n            }\\n        }\\n               \\n       return previous+1;\\n    }\\n}\\n```\\n\\nTime Complexity - O(n).\\nSpace Complexity - O(1).\\n\\n\\nIf Found Helpful Please Upvote.\\nThank You.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n      \\n     //Here we declared a pointer to keep the track of previous index\\n      int previous = 0;\\n        \\n        for(int i = 1; i < nums.length; i++)\\n        {\\n            //Condition used - if the integer at i\\'th index is not equal to integer at previous\\'th index then the condition is satisfies i.e both the integer are different\\n            if(nums[i] != nums[previous])\\n            {\\n                //Incresing the previous by one to update its position by 1.\\n                previous++;\\n                \\n                //Inserting the value at i\\'th index to the previous\\'th index\\n                nums[previous] = nums[i];\\n            }\\n        }\\n               \\n       return previous+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145847,
                "title": "python",
                "content": "\\n\\nTime Complexity O(n)\\nSpace Complexity O(1)\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        if not nums:\\n            return \\n        slow = fast = 0\\n        while fast <= len(nums) - 1:\\n            if nums[fast] != nums[slow]:\\n                nums[slow+1] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow + 1\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        if not nums:\\n            return \\n        slow = fast = 0\\n        while fast <= len(nums) - 1:\\n            if nums[fast] != nums[slow]:\\n                nums[slow+1] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706782,
                "title": "c-java-python3-javascript-solution-faster-than-99",
                "content": "**See the code :\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation)\\u2B50**\\n\\nExample  \\n**C# Solution**  \\u2B06To see other languages please click the link above\\u2B06\\n\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n      \\n        int tmp = nums[0];\\n        int cnt = 1;\\n        \\n        for(int i = 1;i<nums.Length;i++)\\n        {\\n            if(nums[i]>tmp)\\n            {\\n                tmp = nums[i];\\n                nums[cnt] = tmp;\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```\\n\\n**See next problem : \\uD83E\\uDDE1[Zyrastory-Remove Element from Sorted Array](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/)**\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).**\\nThanks!\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n      \\n        int tmp = nums[0];\\n        int cnt = 1;\\n        \\n        for(int i = 1;i<nums.Length;i++)\\n        {\\n            if(nums[i]>tmp)\\n            {\\n                tmp = nums[i];\\n                nums[cnt] = tmp;\\n                cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760800,
                "title": "simple-understandable-python-solution",
                "content": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        position = 1\\n        current = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == current:\\n                continue\\n            current = nums[i]\\n            nums[i], nums[position] = nums[position], nums[i]\\n            position += 1\\n\\n        return position\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        position = 1\\n        current = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == current:\\n                continue\\n            current = nums[i]\\n            nums[i], nums[position] = nums[position], nums[i]\\n            position += 1\\n\\n        return position\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 507271,
                "title": "simple-python-beats-100",
                "content": "Runtime: **64 ms**, faster than **100.00%** of Python3 online submissions for Remove Duplicates from Sorted Array.\\nMemory Usage: **14.5 MB**, less than **97.54%** of Python3 online submissions for Remove Duplicates from Sorted Array.\\n\\n```\\nnums[:] = sorted(set(nums))\\nreturn len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nnums[:] = sorted(set(nums))\\nreturn len(nums)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757771,
                "title": "java-fastest-solution-runtime-1-ms-faster-than-100-00",
                "content": "\\uD83D\\uDC69  If you like this solution, please click UpVote button. If you have any question, feel free write as a comment. Thanks :)\\n\\n```\\nclass Solution {\\n   public int removeDuplicates(int[] nums) {\\n\\t\\tif (nums.length == 0 || nums.length == 1) {\\n\\t\\t\\treturn nums.length;\\n\\t\\t}\\n\\t\\tint j = 0;\\n\\t\\tfor (int i = 0; i < nums.length - 1; i++) {\\n\\t\\t\\tif (nums[i] != nums[i + 1]) {\\n\\t\\t\\t\\tnums[j++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnums[j++] = nums[nums.length - 1];\\n\\t\\treturn j;\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n   public int removeDuplicates(int[] nums) {\\n\\t\\tif (nums.length == 0 || nums.length == 1) {\\n\\t\\t\\treturn nums.length;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 11838,
                "title": "simple-c-o-n-solution",
                "content": "\\n    int removeDuplicates(vector<int>& nums) {\\n        int pos = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (i == 0 || nums[i] != nums[pos - 1])\\n                nums[pos++] = nums[i];\\n        }\\n\\n        return pos;\\n    }",
                "solutionTags": [],
                "code": "\\n    int removeDuplicates(vector<int>& nums) {\\n        int pos = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (i == 0 || nums[i] != nums[pos - 1])\\n                nums[pos++] = nums[i];\\n        }\\n\\n        return pos;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1963813,
                "title": "c-100-simple-solution-o-n",
                "content": "```\\nint removeDuplicates(int* nums, int numsSize){\\n    int new_size = numsSize;\\n    for (int idx = 0, i = 0, j = 1; i < numsSize; idx++, j++) {\\n        while(j < numsSize && nums[i] == nums[j]) {\\n            j++;\\n            new_size--;\\n        }\\n        nums[idx] = nums[j-1];\\n        i = j;\\n    }\\n    return new_size;\\n}\\n```\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(int* nums, int numsSize){\\n    int new_size = numsSize;\\n    for (int idx = 0, i = 0, j = 1; i < numsSize; idx++, j++) {\\n        while(j < numsSize && nums[i] == nums[j]) {\\n            j++;\\n            new_size--;\\n        }\\n        nums[idx] = nums[j-1];\\n        i = j;\\n    }\\n    return new_size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3089539,
                "title": "easy-solution-1ms-beats-100",
                "content": "# Intuition\\nMove elements to their desired index.\\n\\n# Approach\\nFind non-repetitive elements and move them to their desired index.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int p = 0;\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if(nums[p] != nums[i]){\\n                nums[p+1] = nums[i];\\n                p++;\\n            }\\n        }\\n        return p + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int p = 0;\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if(nums[p] != nums[i]){\\n                nums[p+1] = nums[i];\\n                p++;\\n            }\\n        }\\n        return p + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512535,
                "title": "c-solution-o-n-time-complexity",
                "content": "\\t      int i=0;\\n\\t\\t\\tfor(int j=0;j<nums.size();j++){\\n\\t\\t\\t\\tif (nums[i] != nums[j]) i++;\\n\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t}\\n\\t\\t\\treturn i+1;\\n\\t\\t",
                "solutionTags": [],
                "code": "\\t      int i=0;\\n\\t\\t\\tfor(int j=0;j<nums.size();j++){\\n\\t\\t\\t\\tif (nums[i] != nums[j]) i++;\\n\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t}\\n\\t\\t\\treturn i+1;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1529341,
                "title": "java-tc-o-n-sc-o-1-optimized-two-pointers-solution",
                "content": "```java\\n/**\\n * Using 2 pointers.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 1) {\\n            return len;\\n        }\\n\\n        int insertPos = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (nums[i] != nums[insertPos]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Remove Element questions on LeetCode:\\n- [27. Remove Element + Follow Up](https://leetcode.com/problems/remove-element/discuss/1529351/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n- [80. Remove Duplicates from Sorted Array II + Follow Up](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/discuss/1529357/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```java\\n/**\\n * Using 2 pointers.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 1) {\\n            return len;\\n        }\\n\\n        int insertPos = 0;\\n        for (int i = 1; i < len; i++) {\\n            if (nums[i] != nums[insertPos]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350762,
                "title": "c-brute-force-optimal-two-pointer-method-solution-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n    // Brute Force Solution \\n\\t// Time O(NlogN) as map insertion takes O(logN) time and loop runs for N such iterations. Auxiliary Space O(N)\\n    vector<int> ans; \\n    map<int,int> mp; \\n    for(int i = 0; i < nums.size() ; i++){\\n        if(mp[nums[i]]==0)\\n            ans.push_back(nums[i]); // ans vector stores unique elements based on their first occurence in nums vector\\n        mp[nums[i]]++; // mp stores frequency of each unique element in nums vector\\n    }\\n    nums = ans; // ans vector has all unique elements in ascending order.\\n        // These unique elements are overwritten on initial indices of nums array.\\n    return ans.size();\\n}\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Optimal Solution \\n\\t\\t// Time O(N) & Auxiliary Space O(1) \\n        // Two Pointer Method\\n        int len=nums.size();\\n        if(len==0)\\n            return 0;\\n        int p1=0; \\n        for(int p2=1;p2<len;p2++){\\n            if(nums[p1]!=nums[p2]){\\n                // If elements at p1 & p2 not equal, increment p1 and copy \\n                // nums[p2] to nums[p1] so as to concentrate all unique \\n                // elements in ascending order at the initial indices of the vector\\n                p1++;\\n                nums[p1]=nums[p2];\\n            }\\n        }\\n        // p1 location is the final indice of the \\n        // unique element subarray at the beginning of nums vector\\n        return p1+1;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n    // Brute Force Solution \\n\\t// Time O(NlogN) as map insertion takes O(logN) time and loop runs for N such iterations. Auxiliary Space O(N)\\n    vector<int> ans; \\n    map<int,int> mp; \\n    for(int i = 0; i < nums.size() ; i++){\\n        if(mp[nums[i]]==0)\\n            ans.push_back(nums[i]); // ans vector stores unique elements based on their first occurence in nums vector\\n        mp[nums[i]]++; // mp stores frequency of each unique element in nums vector\\n    }\\n    nums = ans; // ans vector has all unique elements in ascending order.\\n        // These unique elements are overwritten on initial indices of nums array.\\n    return ans.size();\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Optimal Solution \\n\\t\\t// Time O(N) & Auxiliary Space O(1) \\n        // Two Pointer Method\\n        int len=nums.size();\\n        if(len==0)\\n            return 0;\\n        int p1=0; \\n        for(int p2=1;p2<len;p2++){\\n            if(nums[p1]!=nums[p2]){\\n                // If elements at p1 & p2 not equal, increment p1 and copy \\n                // nums[p2] to nums[p1] so as to concentrate all unique \\n                // elements in ascending order at the initial indices of the vector\\n                p1++;\\n                nums[p1]=nums[p2];\\n            }\\n        }\\n        // p1 location is the final indice of the \\n        // unique element subarray at the beginning of nums vector\\n        return p1+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902464,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var i = 0\\n\\n        for j in 1..<nums.count {\\n            guard nums[i] != nums[j] else { continue }\\n            i += 1\\n            nums[i] = nums[j]\\n        }\\n        return i + 1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var i = 0\\n\\n        for j in 1..<nums.count {\\n            guard nums[i] != nums[j] else { continue }\\n            i += 1\\n            nums[i] = nums[j]\\n        }\\n        return i + 1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748455,
                "title": "c-two-pointer-approach",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] == nums[i-1]){\\n                j++;\\n            }else{\\n                nums[i-j] = nums[i];\\n            }\\n        }\\n        nums.erase(nums.end()-j , nums.end()); //erasing all the duplicate elements residing at the end part of the array\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] == nums[i-1]){\\n                j++;\\n            }else{\\n                nums[i-j] = nums[i];\\n            }\\n        }\\n        nums.erase(nums.end()-j , nums.end()); //erasing all the duplicate elements residing at the end part of the array\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422268,
                "title": "javascript-solution-beats-100-time-and-100-space",
                "content": "```\\nvar removeDuplicates = function(nums) {\\n    if(nums.length <= 1) {\\n        return nums.length;\\n    }\\n    var k = 1;\\n    for(var i = 1; i < nums.length; i++) {\\n        if(nums[i] != nums[i-1]){\\n            nums[k++] = nums[i];\\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    if(nums.length <= 1) {\\n        return nums.length;\\n    }\\n    var k = 1;\\n    for(var i = 1; i < nums.length; i++) {\\n        if(nums[i] != nums[i-1]){\\n            nums[k++] = nums[i];\\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281013,
                "title": "solution-in-c",
                "content": "Runtime: 16 ms, faster than 91.50% of C online submissions \\nMemory Usage: 9.3 MB, less than 100.00% of C online submissions\\n\\n```int removeDuplicates(int* nums, int numsSize) {\\n    /* ex: [0,0,1,1,1,2,2,3,3,4] \\n     1. loop thru array and compare current element with next element\\n     2. if next is different, then it is unique; else, it\\'s a duplicate.\\n     3. count the number of duplicates between this element and last \\n        unique element \\n     4. replace first instance of duplicate with this unique element\\n     */\\n    if (numsSize == 0) { return 0;}\\n    int count = 1;  // counts the number of unique elements\\n    int j = 0;      // counts the number of duplicates between unique elements\\n    \\n    for (int i=0; i< numsSize-1; i++)  {\\n        if (nums[i] != nums[i+1]) {\\n            count++;\\n            nums[i+1-j] = nums[i+1];\\n        }\\n        else j++;\\n    } \\n    return count;\\n}```\\n",
                "solutionTags": [],
                "code": "```int removeDuplicates(int* nums, int numsSize) {\\n    /* ex: [0,0,1,1,1,2,2,3,3,4] \\n     1. loop thru array and compare current element with next element\\n     2. if next is different, then it is unique; else, it\\'s a duplicate.\\n     3. count the number of duplicates between this element and last \\n        unique element \\n     4. replace first instance of duplicate with this unique element\\n     */\\n    if (numsSize == 0) { return 0;}\\n    int count = 1;  // counts the number of unique elements\\n    int j = 0;      // counts the number of duplicates between unique elements\\n    \\n    for (int i=0; i< numsSize-1; i++)  {\\n        if (nums[i] != nums[i+1]) {\\n            count++;\\n            nums[i+1-j] = nums[i+1];\\n        }\\n        else j++;\\n    } \\n    return count;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802742,
                "title": "java-easy-solution-using-two-pointer-faster-than-80-7-line-code",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int ptr = 1;\\n        for(int i = 0 ; i < nums.length -1 ; i++ ){\\n            if(nums[i] != nums[i + 1]){         //When we get unique No.\\n                nums[ptr] = nums[i+1];          //update previous pointer with new element\\n                ptr++;\\n            }\\n        }\\n        return ptr ;\\n    }\\n}\\n```\\n\\n**Please Upvote**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int ptr = 1;\\n        for(int i = 0 ; i < nums.length -1 ; i++ ){\\n            if(nums[i] != nums[i + 1]){         //When we get unique No.\\n                nums[ptr] = nums[i+1];          //update previous pointer with new element\\n                ptr++;\\n            }\\n        }\\n        return ptr ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11880,
                "title": "python-2-liner-o-n",
                "content": "```\\nfrom collections import OrderedDict\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n\\n        nums[:] =  OrderedDict.fromkeys(nums).keys()\\n        return len(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import OrderedDict\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n\\n        nums[:] =  OrderedDict.fromkeys(nums).keys()\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359998,
                "title": "c-easy-and-readable-solution-faster-than-92-less-than-87",
                "content": "![image.png](https://assets.leetcode.com/users/images/d28a3a9f-c38c-431f-8063-4f5b66566358_1680196913.225682.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int k = 1;\\n        int previouse = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] != previouse)\\n            {\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n            previouse = nums[i];\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int k = 1;\\n        int previouse = nums[0];\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            if (nums[i] != previouse)\\n            {\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n            previouse = nums[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748050,
                "title": "javascript-set-readable-simply-solution",
                "content": "```\\nvar removeDuplicates = function (nums) {\\n      let set = new Set(nums);\\n      nums.length = 0;\\n      nums.push(...set.values())\\n      return set.size;\\n};\\n```\\n\\nOur set can be initiated with the nums array. This will automatically remove all duplicates. We then set nums.length to 0 which will empty the array accordingly.\\n\\nWe do NOT use nums = [] as this would create a new object in memory and we want to empty the existing nums array. \\n\\nFinally, we use the spread operator to push our set values into the original array.",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar removeDuplicates = function (nums) {\\n      let set = new Set(nums);\\n      nums.length = 0;\\n      nums.push(...set.values())\\n      return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774408,
                "title": "rust-0ms-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Remove Duplicates from Sorted Array.\\nMemory Usage: 2.2 MB, less than 80.00% of Rust online submissions for Remove Duplicates from Sorted Array.\\n```\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n        match nums.is_empty() {\\n            true => 0,\\n            false => {\\n                let mut prev = 0;\\n                for i in 1..nums.len() {\\n                    if nums[prev] != nums[i] {\\n                        prev += 1;\\n                        nums[prev] = nums[i];\\n                    }\\n                }\\n                (prev + 1) as i32\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n        match nums.is_empty() {\\n            true => 0,\\n            false => {\\n                let mut prev = 0;\\n                for i in 1..nums.len() {\\n                    if nums[prev] != nums[i] {\\n                        prev += 1;\\n                        nums[prev] = nums[i];\\n                    }\\n                }\\n                (prev + 1) as i32\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359959,
                "title": "efficient-code-in-c-kindly-upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts basically a easy problem you can solve this problem with implementing array.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> First of all take an integer with initialization 1.\\n-> traverse the vector or array from 1 to end.\\n-> if i-1th element is not equal to the ith element \\nthen put ith element to the initialized int position.\\n-> increment the initialized element.\\n-> After ending the loop return the int number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int insert=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]!=nums[i]){\\n                nums[insert]=nums[i];\\n                insert++;\\n            }\\n        }\\n        return insert;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int insert=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]!=nums[i]){\\n                nums[insert]=nums[i];\\n                insert++;\\n            }\\n        }\\n        return insert;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386663,
                "title": "simplest5-line-c-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[ans]){\\n                ans++;\\n                nums[ans]=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[ans]){\\n                ans++;\\n                nums[ans]=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339233,
                "title": "cpp-solution-faster-than-90-solutions-easy-to-understand",
                "content": "\\t//Easy to understand solution. Comment if you have any queries, hope it helps!\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint removeDuplicates(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint size = nums.size(), i = 0, j = 1;\\n        \\n\\t\\t\\tif(size == 0)\\n\\t\\t\\t\\treturn 0;  //Exclude edge case\\n        \\n\\t\\t\\tfor(j = 1; j<size; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//If the numbers are same, do nothing, if different, copy the different new number next to the initial number\\n\\t\\t\\t\\tif(nums[i]!=nums[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\treturn i+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint removeDuplicates(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint size = nums.size(), i = 0, j = 1;\\n        \\n\\t\\t\\tif(size == 0)\\n\\t\\t\\t\\treturn 0;  //Exclude edge case\\n        \\n\\t\\t\\tfor(j = 1; j<size; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//If the numbers are same, do nothing, if different, copy the different new number next to the initial number\\n\\t\\t\\t\\tif(nums[i]!=nums[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ti+=1;\\n\\t\\t\\t\\t\\tnums[i] = nums[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3370285,
                "title": "short-and-clean-code-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for(int j = 1; j < nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                nums[i+1] = nums[j];\\n                i++;\\n            }\\n        }\\n        return (i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for(int j = 1; j < nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                nums[i+1] = nums[j];\\n                i++;\\n            }\\n        }\\n        return (i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801700,
                "title": "golang",
                "content": "```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for j := range nums {\\n        if nums[i] != nums[j] {\\n            i += 1\\n            nums[i] = nums[j]\\n        }\\n    }\\n    return i + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for j := range nums {\\n        if nums[i] != nums[j] {\\n            i += 1\\n            nums[i] = nums[j]\\n        }\\n    }\\n    return i + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801641,
                "title": "daily-leetcoding-challenge-november-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2435487,
                "title": "c-accepted-best-approach-with-good-explanation-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Approach :-**\\n1. Take a variabe \\'i\\' as 0.\\n2. Take a loop and start from j=1 index\\n\\t* Check if arr[i]!=arr[j] then increment i++ and update arr[i]=arr[j]\\n4. At the end return i+1. \\n\\n**~Time Complexity :- O(n)**\\n**Reason-** We are just traverse the given array.\\n\\n**~Space Complexity :- O(1)**\\n**Reason-** We are not using any data structure.\\n\\n**Dry Run :-**\\n\\n![image](https://assets.leetcode.com/users/images/dbe8b574-8cad-44de-ab8d-2933c0b91879_1660672467.3399732.jpeg)\\n\\n**Code :-**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i=0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i=0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994027,
                "title": "100-optimal-solution-o-n-using-basics",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int i = 0;\\n    for (int j = 1; j < nums.length; j++) {\\n        if (nums[j] != nums[i]) {\\n            i++;\\n            nums[i] = nums[j];\\n        }\\n    }\\n    return i + 1;\\n    }\\n}\\n```\\n\\nIf you have any doubt in above code you can comment it down!!!Please Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int i = 0;\\n    for (int j = 1; j < nums.length; j++) {\\n        if (nums[j] != nums[i]) {\\n            i++;\\n            nums[i] = nums[j];\\n        }\\n    }\\n    return i + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419643,
                "title": "python-very-easy-solution-beats-96-01",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        j = 0\\n        for i in range(1, len(nums)):\\n            if nums[j] != nums[i]:\\n                j+=1\\n                nums[j] = nums[i]\\n        return j+1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        j = 0\\n        for i in range(1, len(nums)):\\n            if nums[j] != nums[i]:\\n                j+=1\\n                nums[j] = nums[i]\\n        return j+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354819,
                "title": "python3-2-pointer",
                "content": "```\\ninput = [0,1,1,1,2,2,3,3,4]\\ntail                 fast            nums\\n1                     1      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n1                     2      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n1                     3      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n2                     4      [0, 1, 2, 1, 2, 2, 3, 3, 4]\\n2                     5      [0, 1, 2, 1, 2, 2, 3, 3, 4]\\n3                     6      [0, 1, 2, 3, 2, 2, 3, 3, 4]\\n3                     7      [0, 1, 2, 3, 2, 2, 3, 3, 4]\\n4                     8      [0, 1, 2, 3, 4, 2, 3, 3, 4]\\n```\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) ==0 : return 0\\n        tail = 0\\n        for fast in range(1,len(nums)):\\n            if nums[tail] != nums[fast]:\\n                tail += 1\\n                nums[tail] = nums[fast]\\n        return tail+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ninput = [0,1,1,1,2,2,3,3,4]\\ntail                 fast            nums\\n1                     1      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n1                     2      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n1                     3      [0, 1, 1, 1, 2, 2, 3, 3, 4]\\n2                     4      [0, 1, 2, 1, 2, 2, 3, 3, 4]\\n2                     5      [0, 1, 2, 1, 2, 2, 3, 3, 4]\\n3                     6      [0, 1, 2, 3, 2, 2, 3, 3, 4]\\n3                     7      [0, 1, 2, 3, 2, 2, 3, 3, 4]\\n4                     8      [0, 1, 2, 3, 4, 2, 3, 3, 4]\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) ==0 : return 0\\n        tail = 0\\n        for fast in range(1,len(nums)):\\n            if nums[tail] != nums[fast]:\\n                tail += 1\\n                nums[tail] = nums[fast]\\n        return tail+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208751,
                "title": "python-solution",
                "content": "If `nums` is empty, we return `0`. Otherwise, Initialize `length = 1`, which is the length of the sorted array without duplicates. Initialize two pointers `i = 0`, `j = 1`. Iterate `j` over `range(1, len(nums))`, and if `nums[j] != nums[i]`, we increment `i` by `1`, and swap `nums[i]` and `nums[j]`. It is easy to see the loop invariant that `nums[:i+1]` is always the sorted array `nums[:j+1]` with duplicates removed. Hence when `j` reaches `len(nums)-1`, `nums[:i+1]` is `nums` with duplicates removed.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        length = 1\\n        i = 0\\n        for j in range(1, len(nums)):\\n            if nums[j] != nums[i]:\\n                i += 1\\n                nums[j], nums[i] = nums[i], nums[j]\\n                length += 1\\n        return length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        length = 1\\n        i = 0\\n        for j in range(1, len(nums)):\\n            if nums[j] != nums[i]:\\n                i += 1\\n                nums[j], nums[i] = nums[i], nums[j]\\n                length += 1\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408328,
                "title": "the-simplest-o-n-javascript-typescript-two-pointers-solution",
                "content": "\\n# JavaScript Code\\n```\\nconst removeDuplicates = (nums) => {\\n    let k = 1;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] !== nums[i - 1]) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n};\\n```\\n\\n# TypeScript Code\\n```\\nconst removeDuplicates = (nums: number[]): number => {\\n    let k: number = 1;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] !== nums[i - 1]) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nconst removeDuplicates = (nums) => {\\n    let k = 1;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] !== nums[i - 1]) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n};\\n```\n```\\nconst removeDuplicates = (nums: number[]): number => {\\n    let k: number = 1;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] !== nums[i - 1]) {\\n            nums[k] = nums[i];\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163260,
                "title": "c-easy-approach-o-n-no-extra-space",
                "content": "# Explanation \\nTake a pointer `position` to point the available position for distinct value\\n\\nCheck for each  current value `currValue` whether the element is new or not, if new then place it in `position` and increment the `position` else continue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int n = size(arr);\\n         int position = 0;\\n        int currValue = INT_MIN;\\n        for(int i=0;i<n;i++){\\n\\n        // if current value and arr[i] is not same\\n        // place it in position \\n\\n            if(currValue!=arr[i]){\\n                \\n                currValue= arr[i];\\n                arr[position++] = currValue;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n       return position;\\n    }\\n};\\n```\\n#### Please UPVOTE if you liked the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int n = size(arr);\\n         int position = 0;\\n        int currValue = INT_MIN;\\n        for(int i=0;i<n;i++){\\n\\n        // if current value and arr[i] is not same\\n        // place it in position \\n\\n            if(currValue!=arr[i]){\\n                \\n                currValue= arr[i];\\n                arr[position++] = currValue;\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n       return position;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801656,
                "title": "rust-2-lines",
                "content": "Rust Solution ([3ms](https://leetcode.com/submissions/detail/841044407/)):\\n```rust\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n        nums.dedup();\\n        nums.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n        nums.dedup();\\n        nums.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047203,
                "title": "swift-99-88-performance-with-documentation",
                "content": "First, Obligatory Evidentiary Support.  Submitted 02FEB2021.\\n![image](https://assets.leetcode.com/users/images/149652fd-c8ad-4329-8a64-9e7077a5bf79_1612277690.153362.png)\\n\\nRemoves duplicate values from a sorted array of `Int`s.\\n\\n**Parameter `nums`**: Pointer to array to reduce to unique values\\n**Returns**: The length of the array as `Int` after removing duplicates\\n**PostCondition**: nums is located at the same address, occupying less space.\\n\\tnums contains only the unique values that were previously in nums.\\n\\n**Problem Constraints:**\\n* nums.count is betweeen 0 and 30,000\\n* values in nums will be between -10,000 and +10,000, but since target platform\\nis 64 bit architecture, we gain no performance by only testing the relevant bytes.\\n* Problem requires NO additional array allocation, i.e. operate on nums IN PLACE.\\n* nums is pre-sorted, and must remain sorted after function return.\\n```\\nfunc removeDuplicates(_ nums: inout [Int]) -> Int {\\n    /// nums.count will be used 3 times during function, pre-calculate\\n    /// in stack frame for fewer CPU instructions.\\n    let length = nums.count\\n    guard length > 1 else { return length }\\n    \\n    /// The number of unique values we are keeping\\n    var keep = 1\\n    /// Minimal iterative instructions.\\n    /// Overflow addition operator avoids instructions that unecessarily\\n    /// check for Integer overflow.\\n    for i in 1..<length {\\n        if nums[i &- 1] != nums[i] {\\n          nums[keep] = nums[i]\\n          keep &+= 1\\n        }\\n    }\\n    /// Eliminate all of nums that are not unique.\\n\\t/// (20% faster than nums = Array(nums[0..<keep]).\\n    nums.removeLast(length &- keep)\\n    return keep\\n}\\n```\\n\\nThe above solution is the most performant that I could get while maintaining Swift\\'s safety conventions.  However, I\\'d like to point out that the following code:\\n```\\nfunc removeDuplicates(_ nums: inout [Int]) -> Int {\\n    guard !nums.isEmpty else { return 0 }\\n    nums = Array(Set(nums)).sorted()\\n    return nums.count\\n}\\n```\\nIs more elegant and swifty, but it is **significantly** less algorithmically efficient on the CPU.  Purists for this problem should also be quick to point out that it is an invalid solution and violates the memory constraint of the problem.  It can\\'t be **constant** (i.e: O(1)) space because the size of the `Set` allocation is dependent on the quantity of unique values in the data.\\n\\nCheers",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc removeDuplicates(_ nums: inout [Int]) -> Int {\\n    /// nums.count will be used 3 times during function, pre-calculate\\n    /// in stack frame for fewer CPU instructions.\\n    let length = nums.count\\n    guard length > 1 else { return length }\\n    \\n    /// The number of unique values we are keeping\\n    var keep = 1\\n    /// Minimal iterative instructions.\\n    /// Overflow addition operator avoids instructions that unecessarily\\n    /// check for Integer overflow.\\n    for i in 1..<length {\\n        if nums[i &- 1] != nums[i] {\\n          nums[keep] = nums[i]\\n          keep &+= 1\\n        }\\n    }\\n    /// Eliminate all of nums that are not unique.\\n\\t/// (20% faster than nums = Array(nums[0..<keep]).\\n    nums.removeLast(length &- keep)\\n    return keep\\n}\\n```\n```\\nfunc removeDuplicates(_ nums: inout [Int]) -> Int {\\n    guard !nums.isEmpty else { return 0 }\\n    nums = Array(Set(nums)).sorted()\\n    return nums.count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595721,
                "title": "in-c",
                "content": "```\\nint removeDuplicates(int* nums, int numsSize)\\n{\\n    int i, last = 0;\\n   \\n    if (numsSize <= 1) {\\n        return numsSize;\\n    }\\n     \\n    for (i = 1; i < numsSize; i++) {\\n        if (nums[i-1] < nums[i]) {\\n            nums[++last] = nums[i];\\n        }\\n    }\\n\\n    return last+1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(int* nums, int numsSize)\\n{\\n    int i, last = 0;\\n   \\n    if (numsSize <= 1) {\\n        return numsSize;\\n    }\\n     \\n    for (i = 1; i < numsSize; i++) {\\n        if (nums[i-1] < nums[i]) {\\n            nums[++last] = nums[i];\\n        }\\n    }\\n\\n    return last+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195619,
                "title": "javascript",
                "content": "```\\nvar removeDuplicates = function(nums) {\\n    if(nums.length === 0) {\\n        return 0\\n    }\\n    let result = 1, i = 0, j = 1;\\n    \\n    while(i < nums.length && j < nums.length) {\\n        if(nums[j] === nums[i]) {\\n            j++;\\n        } else {\\n            result += 1;\\n            i++;\\n            nums[i] = nums[j];\\n            j++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    if(nums.length === 0) {\\n        return 0\\n    }\\n    let result = 1, i = 0, j = 1;\\n    \\n    while(i < nums.length && j < nums.length) {\\n        if(nums[j] === nums[i]) {\\n            j++;\\n        } else {\\n            result += 1;\\n            i++;\\n            nums[i] = nums[j];\\n            j++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12058,
                "title": "clean-5-line-java-solution",
                "content": "    public int removeDuplicates(int[] nums) {\\n        int cur = 0 ; \\n        for(int n:nums)\\n            if(n>nums[cur])\\n                nums[++cur] = n;\\n        return cur+1;\\n    }",
                "solutionTags": [],
                "code": "    public int removeDuplicates(int[] nums) {\\n        int cur = 0 ; \\n        for(int n:nums)\\n            if(n>nums[cur])\\n                nums[++cur] = n;\\n        return cur+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3984006,
                "title": "java-runtime-1-ms-beats-97-80",
                "content": "# Intuition\\nMy initial thoughts on this problem involve finding an optimized solution to remove duplicates from a sorted array.\\n\\n# Approach\\nThe chosen approach utilizes a two-pointer technique to efficiently remove duplicates from the sorted array `nums`. The two pointers, `i` and `j`, are initialized to 0 and 1 respectively. \\n\\nThe algorithm proceeds as follows:\\n1. Iterate through the array from index 1 to the end:\\n   - Compare the element at position `i` with the element at position `j-1` (previous distinct element).\\n   - If they are not equal, it means a new distinct element is found.\\n     - Increment the pointer `j` and assign the element at position `i` to position `j`.\\n2. After completing the iteration, the value of `j` represents the index of the last distinct element in the array. Adding 1 to `j` gives the count of distinct elements.\\n\\nThe algorithm effectively removes duplicates from the sorted array while maintaining the relative order of the elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the array once, performing constant-time operations at each step.\\n\\n- Space complexity: O(1)\\n  The algorithm utilizes a constant amount of additional memory space for variables, ensuring that the space complexity remains constant.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n\\n        int j = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[j]) {\\n                j++;\\n                nums[j] = nums[i];\\n            }\\n        }\\n        \\n        return j + 1;\\n        \\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/bf6f2c00-0032-4cf5-a63e-7c4053cc0330_1693477316.9093492.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n\\n        int j = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] != nums[j]) {\\n                j++;\\n                nums[j] = nums[i];\\n            }\\n        }\\n        \\n        return j + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801741,
                "title": "javascript-or-how-to-follow-directions-o-1-space",
                "content": "```\\nvar removeDuplicates = function(nums) {\\n    let end = nums.length;\\n    let remove = function(i) {\\n        for( var j=i; j+1<end; j++ ) {\\n            nums[j] = nums[j+1];\\n        }\\n    };\\n    \\n    var i;\\n    for( i=0; i<end; i++ ) {\\n        while( i<end && nums.indexOf(nums[i]) < i ) {\\n            remove(i);\\n            end--;\\n        }\\n    }\\n    \\n    return end;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    let end = nums.length;\\n    let remove = function(i) {\\n        for( var j=i; j+1<end; j++ ) {\\n            nums[j] = nums[j+1];\\n        }\\n    };\\n    \\n    var i;\\n    for( i=0; i<end; i++ ) {\\n        while( i<end && nums.indexOf(nums[i]) < i ) {\\n            remove(i);\\n            end--;\\n        }\\n    }\\n    \\n    return end;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801649,
                "title": "golang-o-n",
                "content": "```\\nfunc removeDuplicates(nums []int) int {\\n    nextInsertionIndex := 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] != nums[i-1] {\\n            nums[nextInsertionIndex] = nums[i]\\n            nextInsertionIndex++\\n        }\\n    }\\n    \\n    return nextInsertionIndex\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    nextInsertionIndex := 1\\n    \\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] != nums[i-1] {\\n            nums[nextInsertionIndex] = nums[i]\\n            nextInsertionIndex++\\n        }\\n    }\\n    \\n    return nextInsertionIndex\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338649,
                "title": "c-java-python3-javascript-solution-faster-than-99",
                "content": "**See the code :\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation)\\u2B50**\\n\\n**See next problem : \\uD83E\\uDDE1[Zyrastory-Remove Element from Sorted Array](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/)**\\n\\n\\nSubmission detail\\n![image](https://assets.leetcode.com/users/images/e7276a8f-6a26-49c8-a51e-047b138b02d2_1658135504.9480598.png)\\n![image](https://assets.leetcode.com/users/images/ea20f5fb-bcd0-43a5-84a3-12143cea7805_1658135511.9166517.png)\\n![image](https://assets.leetcode.com/users/images/e5ef76b2-1f71-4c37-a38b-ed9f3e56a968_1658135601.5537932.png)\\n![image](https://assets.leetcode.com/users/images/dd1553b9-c286-40e3-84e2-899c0718d796_1658158589.7400055.png)\\n\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nThanks!",
                "solutionTags": [],
                "code": "**See the code :\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-26-remove-duplicates-from-sorted-array-solution-explanation)\\u2B50**\\n\\n**See next problem : \\uD83E\\uDDE1[Zyrastory-Remove Element from Sorted Array](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/)**\\n\\n\\nSubmission detail\\n![image](https://assets.leetcode.com/users/images/e7276a8f-6a26-49c8-a51e-047b138b02d2_1658135504.9480598.png)\\n![image](https://assets.leetcode.com/users/images/ea20f5fb-bcd0-43a5-84a3-12143cea7805_1658135511.9166517.png)\\n![image](https://assets.leetcode.com/users/images/e5ef76b2-1f71-4c37-a38b-ed9f3e56a968_1658135601.5537932.png)\\n![image](https://assets.leetcode.com/users/images/dd1553b9-c286-40e3-84e2-899c0718d796_1658158589.7400055.png)\\n\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nThanks!",
                "codeTag": "Unknown"
            },
            {
                "id": 3400266,
                "title": "intuitive-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 1;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i] != nums[i+1]) nums[j++] = nums[i+1];\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int j = 1;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i] != nums[i+1]) nums[j++] = nums[i+1];\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393931,
                "title": "javascript-multiple-solutions-array-splice-for-loop-while-loop-two-pointers",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n```\\n\\n// Solution 1 : Using Array splice method\\nconst removeDuplicates = (nums) => {\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] == nums[i + 1]) {\\n            nums.splice(i + 1, 1);\\n            i--;\\n        }\\n    }\\n};\\n\\n// Solution 2 : For loop with continue\\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] === nums[i]) continue; // If the elements are equal then continue else copy the unique element by then to \"i+1\" position\\n        nums[++i] = nums[j];\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 3 : For loop \\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] !== nums[i]) { //  If the elements are not equal then copy the unique element by then to \"i+1\" position\\n            nums[++i] = nums[j];\\n        }\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 4 :  While loop\\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    let j = 1;\\n    while (j < nums.length) {\\n        if (nums[j] !== nums[i]) {\\n            nums[++i] = nums[j];\\n        }\\n        j++;\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 5 : Move the duplicate elements\\nconst removeDuplicates = (nums, j = 0) => {\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[j] != nums[i] && i != j) {\\n            nums[++j] = nums[i];\\n        }\\n    }\\n    return ++j;\\n};\\n\\n```\\n\\n***Do upvote if you find this solution useful..***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n\\n// Solution 1 : Using Array splice method\\nconst removeDuplicates = (nums) => {\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] == nums[i + 1]) {\\n            nums.splice(i + 1, 1);\\n            i--;\\n        }\\n    }\\n};\\n\\n// Solution 2 : For loop with continue\\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] === nums[i]) continue; // If the elements are equal then continue else copy the unique element by then to \"i+1\" position\\n        nums[++i] = nums[j];\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 3 : For loop \\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] !== nums[i]) { //  If the elements are not equal then copy the unique element by then to \"i+1\" position\\n            nums[++i] = nums[j];\\n        }\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 4 :  While loop\\nconst removeDuplicates = (nums) => {\\n    if (nums.length === 0) return 0;\\n    let i = 0;\\n    let j = 1;\\n    while (j < nums.length) {\\n        if (nums[j] !== nums[i]) {\\n            nums[++i] = nums[j];\\n        }\\n        j++;\\n    }\\n    return i + 1;\\n}\\n\\n// Solution 5 : Move the duplicate elements\\nconst removeDuplicates = (nums, j = 0) => {\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[j] != nums[i] && i != j) {\\n            nums[++j] = nums[i];\\n        }\\n    }\\n    return ++j;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357483,
                "title": "easy-go-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc removeDuplicates(nums []int) int {\\n    prev := nums[0]\\n    l := 1\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] != prev {\\n            nums[l] = nums[i]\\n            l++\\n        } \\n        prev = nums[i]\\n    }\\n    return l\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    prev := nums[0]\\n    l := 1\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] != prev {\\n            nums[l] = nums[i]\\n            l++\\n        } \\n        prev = nums[i]\\n    }\\n    return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224771,
                "title": "2-liner-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(set(nums))\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(set(nums))\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213663,
                "title": "simple-approach-1ms-efficient-code",
                "content": "# Intuition\\nJust simply swap the duplicate element in the array to the end\\n\\n# Approach\\nTraverse the array if there is any duplicate element with index position\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]!=nums[j]){\\n               nums[j+1]=nums[i];\\n               j++;}\\n        }\\n        return j+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]!=nums[j]){\\n               nums[j+1]=nums[i];\\n               j++;}\\n        }\\n        return j+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874837,
                "title": "easiest-faang-method-ever",
                "content": "\\n# \\uD83D\\uDDEF\\uFE0F Complexity :-\\n- Time complexity: O(n)\\n<!-- Add your time com plexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDDEF\\uFE0F Code :-\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1])\\n                count++;\\n            else\\n                nums[i-count]=nums[i];    \\n        }\\n        return nums.size()-count;\\n    }\\n};\\n```\\n# ***Upvote if it helped you :)***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1])\\n                count++;\\n            else\\n                nums[i-count]=nums[i];    \\n        }\\n        return nums.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801869,
                "title": "o-1-space-complexity-python-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        for i in range(n-1,0,-1):\\n            if(nums[i]==nums[i-1]):\\n                nums.pop(i)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        for i in range(n-1,0,-1):\\n            if(nums[i]==nums[i-1]):\\n                nums.pop(i)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284519,
                "title": "c-optimised-and-easy-solution-two-pointer-approach",
                "content": "*Runtime: 21 ms, faster than 42.77% of C++ online submissions for Remove Duplicates from Sorted Array.\\nMemory Usage: 18.4 MB, less than 36.66% of C++ online submissions for Remove Duplicates from Sorted Array.*\\n\\n**code is availible in comment**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2057010,
                "title": "c-java-c-c-javascript-typescript-solutions-easy-to-understand",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int len = 0;  // Initialize a variable \\'i\\' to keep track of the current position\\n\\n        for (int j = 0; j < nums.size(); j++) {  // Iterate through the vector \\'nums\\'\\n            nums[len++] = nums[j];  // Copy the current element at index \\'j\\' to index \\'i\\' and increment \\'i\\'\\n\\n            // Check for consecutive duplicate elements\\n            while (j < nums.size() - 1 && nums[j] == nums[j + 1])\\n                j++;  // If there are consecutive duplicates, move \\'j\\' to the next distinct element\\n        }\\n        return len;  // Return the new length of the modified vector (i.e., number of unique elements)\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j=0;j<nums.length;j++) {\\n            nums[i++] = nums[j];            \\n            while (j<nums.length-1&&nums[j]==nums[j+1])\\n                 j++;\\n        }\\n        return i;\\n    }\\n}\\n```\\n```csharp []\\n// 1. Space O(N)\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;        \\n        for (int i = 0; i < nums.Length; i++) \\n            if (secondary.Add(nums[i])) \\n                nums[counter++] = nums[i];     \\n        return counter;\\n    }\\n}\\n// 2. Space O(1)\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j=0;j<nums.Length;j++) {\\n            nums[i++] = nums[j];            \\n            while (j<nums.Length-1&&nums[j]==nums[j+1]) \\n                j++;\\n        }\\n        return i;\\n    }\\n}\\n```\\n```C []\\nint removeDuplicates(int* nums, int numsSize){\\n    int i = 0;\\n    for (int j=0;j<numsSize;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<numsSize-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n}\\n```\\n```javascript []\\nvar removeDuplicates = function(nums) {\\n    var i = 0;\\n    for (var j=0;j<nums.length;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<nums.length-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n};\\n```\\n```TypeScript []\\nfunction removeDuplicates(nums: number[]): number {\\n    var i = 0;\\n    for (var j=0;j<nums.length;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<nums.length-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "TypeScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int len = 0;  // Initialize a variable \\'i\\' to keep track of the current position\\n\\n        for (int j = 0; j < nums.size(); j++) {  // Iterate through the vector \\'nums\\'\\n            nums[len++] = nums[j];  // Copy the current element at index \\'j\\' to index \\'i\\' and increment \\'i\\'\\n\\n            // Check for consecutive duplicate elements\\n            while (j < nums.size() - 1 && nums[j] == nums[j + 1])\\n                j++;  // If there are consecutive duplicates, move \\'j\\' to the next distinct element\\n        }\\n        return len;  // Return the new length of the modified vector (i.e., number of unique elements)\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j=0;j<nums.length;j++) {\\n            nums[i++] = nums[j];            \\n            while (j<nums.length-1&&nums[j]==nums[j+1])\\n                 j++;\\n        }\\n        return i;\\n    }\\n}\\n```\n```csharp []\\n// 1. Space O(N)\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;        \\n        for (int i = 0; i < nums.Length; i++) \\n            if (secondary.Add(nums[i])) \\n                nums[counter++] = nums[i];     \\n        return counter;\\n    }\\n}\\n// 2. Space O(1)\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int j=0;j<nums.Length;j++) {\\n            nums[i++] = nums[j];            \\n            while (j<nums.Length-1&&nums[j]==nums[j+1]) \\n                j++;\\n        }\\n        return i;\\n    }\\n}\\n```\n```C []\\nint removeDuplicates(int* nums, int numsSize){\\n    int i = 0;\\n    for (int j=0;j<numsSize;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<numsSize-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n}\\n```\n```javascript []\\nvar removeDuplicates = function(nums) {\\n    var i = 0;\\n    for (var j=0;j<nums.length;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<nums.length-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n};\\n```\n```TypeScript []\\nfunction removeDuplicates(nums: number[]): number {\\n    var i = 0;\\n    for (var j=0;j<nums.length;j++) {\\n        nums[i++] = nums[j];            \\n        while (j<nums.length-1&&nums[j]==nums[j+1]) \\n            j++;\\n    }\\n    return i;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204366,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=1){return n;}\\n        \\n        int left = 0; //everything to the left of left(inclusive) is good\\n        int right = 1;//the current element we are processing\\n        \\n        while(right<=n-1){\\n            if(nums[right] == nums[left]){\\n                right++;\\n            }\\n            else{\\n                nums[left+1] = nums[right];\\n                left++;\\n                right++;\\n            }\\n        }\\n        \\n        return left+1;\\n    }\\n}```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=1){return n;}\\n        \\n        int left = 0; //everything to the left of left(inclusive) is good\\n        int right = 1;//the current element we are processing\\n        \\n        while(right<=n-1){\\n            if(nums[right] == nums[left]){\\n                right++;\\n            }\\n            else{\\n                nums[left+1] = nums[right];\\n                left++;\\n                right++;\\n            }\\n        }\\n        \\n        return left+1;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 530749,
                "title": "javascript-o-n-two-pointers-95-100",
                "content": "```\\nconst removeDuplicates = (nums) => {\\n  let i = 0;\\n  let j = 1;\\n\\n  for (; j < nums.length; j += 1) {\\n    if (nums[j] !== nums[i]) {\\n      i += 1;\\n      nums[i] = nums[j];\\n    }\\n  }\\n\\n  return i + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = (nums) => {\\n  let i = 0;\\n  let j = 1;\\n\\n  for (; j < nums.length; j += 1) {\\n    if (nums[j] !== nums[i]) {\\n      i += 1;\\n      nums[i] = nums[j];\\n    }\\n  }\\n\\n  return i + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12131,
                "title": "c-code-no-trick",
                "content": "Use an index last to record the next written position (i.e. copy a new element to last+1).\\n\\n    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int last=0, i, len=nums.size();\\n            if(!len) return 0;\\n            for(i=0; i<len;++i)\\n            {\\n                if(nums[i]!=nums[last]) nums[++last] = nums[i];\\n            }\\n            return last+1;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int last=0, i, len=nums.size();\\n            if(!len) return 0;\\n            for(i=0; i<len;++i)\\n            {\\n                if(nums[i]!=nums[last]) nums[++last] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3410471,
                "title": "best-solution-in-java-runtime-in-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       int k = 1;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\n            if (nums[i] < nums[i+1]) {\\n\\n                nums[k] = nums[i+1];\\n                k++;\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       int k = 1;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n\\n            if (nums[i] < nums[i+1]) {\\n\\n                nums[k] = nums[i+1];\\n                k++;\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181523,
                "title": "java-best-solution-simple-solution",
                "content": "# Intuition\\n\\n![WhatsApp Image 2023-02-13 at 22.35.08.jpeg](https://assets.leetcode.com/users/images/b7a5dacc-3738-4eba-a60e-265b78c8a617_1676307964.6845708.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cout=1;\\n       for(int i=0;i<nums.length-1;i++){\\n           if(nums[i]!=nums[i+1]){\\n               nums[cout]=nums[i+1];\\n               cout++;\\n           }\\n       }\\n       return cout;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cout=1;\\n       for(int i=0;i<nums.length-1;i++){\\n           if(nums[i]!=nums[i+1]){\\n               nums[cout]=nums[i+1];\\n               cout++;\\n           }\\n       }\\n       return cout;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2804240,
                "title": "remove-duplicates-from-sorted-array-easy-to-analyse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1])\\n        {\\n            nums[k++]=nums[i+1];\\n        }\\n    }\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1])\\n        {\\n            nums[k++]=nums[i+1];\\n        }\\n    }\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801950,
                "title": "in-place-o-n-o-1-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssume the array to be divided into two parts , one without duplicates and one to be computed . Now traverse the array left and see where there is a change in value(arr[i]!=arr[i-1]) (change in value means a new value occurs). If yes, add this to ans array and move forward. To add in ans , we just change value and increase the index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n  if(nums.size()<=1)return 1;\\n\\n           int i  = 1;  //**** next index in ans part \\n           int j = 1;   //*** index to find unique\\n\\n           while(j<nums.size()){\\n             if(nums[j]!=nums[j-1]){  //** whenever a change is seen(means new value occurs)\\n                 nums[i] = nums[j];   //*** put value in ans part\\n                 i++;                  \\n             }\\n               j++;\\n           }\\n\\n        return i;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  if(nums.size()<=1)return 1;\\n\\n           int i  = 1;  //**** next index in ans part \\n           int j = 1;   //*** index to find unique\\n\\n           while(j<nums.size()){\\n             if(nums[j]!=nums[j-1]){  //** whenever a change is seen(means new value occurs)\\n                 nums[i] = nums[j];   //*** put value in ans part\\n                 i++;                  \\n             }\\n               j++;\\n           }\\n\\n        return i;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801717,
                "title": "typescript-two-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    if(nums.length === 1) return 1\\n\\n    let p2 = 0\\n    let p1 = 0\\n\\n    while(p2 < nums.length) {\\n        if(nums[p1] < nums[p2]) {\\n            nums[p1+1] = nums[p2]\\n            p1++\\n        }\\n        p2++\\n    }\\n    return p1 + 1\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    if(nums.length === 1) return 1\\n\\n    let p2 = 0\\n    let p1 = 0\\n\\n    while(p2 < nums.length) {\\n        if(nums[p1] < nums[p2]) {\\n            nums[p1+1] = nums[p2]\\n            p1++\\n        }\\n        p2++\\n    }\\n    return p1 + 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420774,
                "title": "3-simple-steps-in-linked-list-too-without-using-if-else",
                "content": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array** or **even for a Linked List but in linked list we use sentinal nodes**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\nQ1 - \\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j];\\n            for(;j<n && nums[j]==save;j++);\\n            nums[i++]=save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j];\\n            for(;j<n && nums[j]==save;j++);\\n            nums[i++]=save;\\n        }\\n        return i;\\n    }\\n\\t\\n\\n# Q2-> [83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\\n\\n# C++\\n\\n    class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummy= new ListNode(0);\\n        ListNode *ptr= dummy , *q=head;\\n        while(q){\\n            ListNode* node=q;  \\n            while(q and q->val==node->val) q=q->next;\\n            ptr->next= node;\\n            ptr=ptr->next;\\n        }\\n        ptr->next=0;\\n        return dummy->next;\\n    }\\n    };\\n\\t\\n**Type 2 -> When we have to append nodes following a particular count**\\n   \\n# Q1 -> [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n   \\n    \\n    class Solution {\\n    public:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n           int save= nums[j],cnt=0;\\n           for(;j<n && nums[j]==save;j++,cnt++);\\n\\t\\t   nums[i++]=save;\\n           if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n    };\\n\\t   \\n# Q2 -> [82. Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)\\n\\n    class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head){\\n        ListNode *dummy= new ListNode(0);\\n        ListNode *res= dummy; \\n        for(ListNode* ptr=head;ptr;){\\n            int value= ptr->val;\\n            ListNode* node= ptr;\\n            int cnt=0;\\n            while(ptr and ptr->val==value) cnt++, ptr=ptr->next;\\n            if(cnt==1) res->next=node,res=res->next;\\n        }\\n        res->next=0;\\n        return dummy->next;\\n    }\\n\\t};\\n\\n**YOU CAN SEE ALL OF THEM ARE SAME in just three lines wihout if-else.**\\n\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummy= new ListNode(0);\\n        ListNode *ptr= dummy , *q=head;\\n        while(q){\\n            ListNode* node=q;  \\n            while(q and q->val==node->val) q=q->next;\\n            ptr->next= node;\\n            ptr=ptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1953405,
                "title": "kotlin-two-pointer",
                "content": "#### Algorithm: Two Pointer\\n\\n1. Have a counter set to zero \\n2. Iterate through the array starting from index 1 \\n3. When they are equal continue iterating \\n4. When they are not equal \\n5. Increment the counter by one\\n6. Assign the value of arr in index of i to arr in index of the counter\\n\\nTime & Space Complx\\nTC: O(n) We need to iterate at most the end of the array\\nSP: O(1) We are not allocating extra spaces\\n```\\nclass Solution {\\n    fun removeDuplicates(nums: IntArray): Int {\\n        private var counter = 0\\n        \\n        for(i in 1 until nums.size) {\\n            if(nums[counter] != nums[i]) {\\n                counter++\\n                nums[counter] = nums[i]\\n            }\\n        }\\n        return counter + 1\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    fun removeDuplicates(nums: IntArray): Int {\\n        private var counter = 0\\n        \\n        for(i in 1 until nums.size) {\\n            if(nums[counter] != nums[i]) {\\n                counter++\\n                nums[counter] = nums[i]\\n            }\\n        }\\n        return counter + 1\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910449,
                "title": "my-easy-in-place-solution-with-constant-memory-and-linear-time-complexity",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        check = 0\\n        for i in range(1, len(nums)):\\n            if nums[check] != nums[i]:\\n                check+=1\\n                nums[check] = nums[i]\\n        return check+1\\n```\\n**Intution:**\\nSet a pointer \"check\" such that it points to the start of given list.\\nItertate through the given list using pointer \\'i\\'.\\nIf the value at pointer \"check\" is not equal to value at pointer \\'i\\' in list, then simply increment the \"check\" pointer by 1 and assign the value at ith position of list to the check th position of the list.\\nReturn the answer as check+1.\\n**Complexity Analysis:**\\n\\nTime Complexity:\\nO(n) [Linear]\\n\\nSpace Complexity:\\nO(1) [Constant]\\n\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        check = 0\\n        for i in range(1, len(nums)):\\n            if nums[check] != nums[i]:\\n                check+=1\\n                nums[check] = nums[i]\\n        return check+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890576,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n  for (let i = 0; i < nums.length; i++) {\\n      if (nums[i + 1] === nums[i]) { nums.splice(i, 1); i-- }\\n  }\\n\\n  return nums.length\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n  for (let i = 0; i < nums.length; i++) {\\n      if (nums[i + 1] === nums[i]) { nums.splice(i, 1); i-- }\\n  }\\n\\n  return nums.length\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332732,
                "title": "c-simple-solution-with-foreach",
                "content": "```\\n    public int RemoveDuplicates( int[] nums ) \\n    {\\n        var count = ( nums.Length == 0 ? 0 : 1 );\\n        \\n        foreach( var num in nums )\\n            if ( nums[count-1] < num )\\n                nums[count++] = num;\\n                \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int RemoveDuplicates( int[] nums ) \\n    {\\n        var count = ( nums.Length == 0 ? 0 : 1 );\\n        \\n        foreach( var num in nums )\\n            if ( nums[count-1] < num )\\n                nums[count++] = num;\\n                \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947494,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        for j in range(1,len(nums)):\\n            if nums[j]!=nums[i]:\\n                i+=1\\n                nums[i]=nums[j]\\n        return i+1\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        for j in range(1,len(nums)):\\n            if nums[j]!=nums[i]:\\n                i+=1\\n                nums[i]=nums[j]\\n        return i+1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157959,
                "title": "set-having-weird-results",
                "content": "```\\n    let arr = new Set(nums);\\n    nums = [...arr];\\n    return nums.length;\\n```\\n\\nThis when i console log nums it gives be back the valid array, but for some reason when i run through the solution it keeps telling me my array is [1,1] even though console logging has it has [1,2] Any idea why this may be happening?",
                "solutionTags": [],
                "code": "```\\n    let arr = new Set(nums);\\n    nums = [...arr];\\n    return nums.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12049,
                "title": "1ms-java-solution-o-n-time-o-1-space",
                "content": "    public int removeDuplicates(int[] nums) \\n    {\\n        if (nums.length<2)\\n            return nums.length;\\n                \\n        int swapped = 1;\\n        \\n        for (int i=1; i<nums.length;i++)\\n            if(nums[i-1]<nums[i])\\n            {\\n                nums[swapped] = nums[i];\\n                swapped++;\\n            }\\n        \\n        return swapped;\\n    }",
                "solutionTags": [],
                "code": "    public int removeDuplicates(int[] nums) \\n    {\\n        if (nums.length<2)\\n            return nums.length;\\n                \\n        int swapped = 1;\\n        \\n        for (int i=1; i<nums.length;i++)\\n            if(nums[i-1]<nums[i])\\n            {\\n                nums[swapped] = nums[i];\\n                swapped++;\\n            }\\n        \\n        return swapped;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2801928,
                "title": "optimized-and-fast-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0 or n == 1:\\n            return n\\n        j = 1\\n        for i in range(1, n):\\n            if nums[i] != nums[i-1]:\\n                nums[j] = nums[i]\\n                j += 1\\n        return j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n == 0 or n == 1:\\n            return n\\n        j = 1\\n        for i in range(1, n):\\n            if nums[i] != nums[i-1]:\\n                nums[j] = nums[i]\\n                j += 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801900,
                "title": "python-using-sorting",
                "content": "\\n        x=0\\n        l=len(nums)\\n        while x<l-1:\\n            if nums[x]==nums[x+1]:\\n                nums.remove(nums[x+1])\\n            else:\\n                x+=1\\n            l=len(nums)\\n        return len(nums)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "\\n        x=0\\n        l=len(nums)\\n        while x<l-1:\\n            if nums[x]==nums[x+1]:\\n                nums.remove(nums[x+1])\\n            else:\\n                x+=1\\n            l=len(nums)\\n        return len(nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 2801875,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        x=nums[0]\\n        i=0\\n        while i<len(nums)-1:\\n            if x==nums[1+i]:\\n                del nums[1+i]\\n            else:\\n                x=nums[1+i]\\n                i+=1\\n        return i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 1\\n        x=nums[0]\\n        i=0\\n        while i<len(nums)-1:\\n            if x==nums[1+i]:\\n                del nums[1+i]\\n            else:\\n                x=nums[1+i]\\n                i+=1\\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992779,
                "title": "4-lines-of-code-fast-and-easy-solution",
                "content": "The idea is really simple. It is just a two pointers solution where left advances only when a value is encountered for the first time, while right scans the whole array.\\nAt the end, left index will point to the last unique element and I add 1 to obtain the length of the result (as per description we can ignore remaining portion of the array).\\n\\nO(n-1) time complexity because I am starting the for cycle from the second element till the end.\\n\\n```\\nvar removeDuplicates = function(nums) {\\n    let left = 0;    \\n    for(let right=1; right<nums.length; right++)\\n        if(nums[left] != nums[right]) nums[++left] = nums[right];    \\n    return left+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    let left = 0;    \\n    for(let right=1; right<nums.length; right++)\\n        if(nums[left] != nums[right]) nums[++left] = nums[right];    \\n    return left+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525905,
                "title": "python-8-lines",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        last = 0\\n        for num in nums:\\n            if num > nums[last]:\\n                last += 1\\n                nums[last] = num                \\n        return last + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not nums:\\n            return 0\\n        \\n        last = 0\\n        for num in nums:\\n            if num > nums[last]:\\n                last += 1\\n                nums[last] = num                \\n        return last + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404774,
                "title": "js-easy-splice",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction removeDuplicates(nums) {\\n  for (let i = 0; i < nums.length; i++) {\\n    nums.splice(i, nums.lastIndexOf(nums[i]) - i);\\n  }\\n\\n  return nums.length;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction removeDuplicates(nums) {\\n  for (let i = 0; i < nums.length; i++) {\\n    nums.splice(i, nums.lastIndexOf(nums[i]) - i);\\n  }\\n\\n  return nums.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332436,
                "title": "one-liner-c-using-stl-rarest-and-fastest-solution",
                "content": "This is a very unique STL Function that I came to know and so is it\\'s name xD, please upvote if you did not know this function! :)\\n```\\nint removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        return nums.size();\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        return nums.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942382,
                "title": "simple-o-n-solution-with-explanation-in-go",
                "content": "Code\\n====\\n\\n```go\\nfunc removeDuplicates(nums []int) int {\\n\\tif len(nums) <= 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tslow := 0\\n\\tfast := 1\\n\\tn := len(nums)\\n\\n\\tfor fast < n {\\n\\t\\tif nums[fast] == nums[slow] {\\n\\t\\t\\tfast++\\n\\t\\t} else {\\n\\t\\t\\tslow++\\n\\t\\t\\tnums[slow] = nums[fast]\\n\\t\\t}\\n\\t}\\n\\n\\treturn slow + 1\\n}\\n```\\n\\nSolution in mind\\n================\\n\\n-\\tMake use of 2 pointers, a fast and slow moving pointer. Initialise fast to 1 and slow to 0.\\n\\n-\\tWhile fast has not reached the end of array, check if the elements at index fast and slow are same, if yes, move fast forward by 1 place.\\n\\n-\\tIf not, copy the non duplicate element into the position after slow.\\n\\n-\\tOnce fast reaches the end of array, all unique elements will be stored inside the first \"slow\" number of elements in the array.\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc removeDuplicates(nums []int) int {\\n\\tif len(nums) <= 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tslow := 0\\n\\tfast := 1\\n\\tn := len(nums)\\n\\n\\tfor fast < n {\\n\\t\\tif nums[fast] == nums[slow] {\\n\\t\\t\\tfast++\\n\\t\\t} else {\\n\\t\\t\\tslow++\\n\\t\\t\\tnums[slow] = nums[fast]\\n\\t\\t}\\n\\t}\\n\\n\\treturn slow + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 397474,
                "title": "rust-dedup",
                "content": "Most of the solutions were hand-made. They are pretty good. \\nThe std has also provide its own solution in std::vec which was \\'dedup\\'. See the source code for detail implementation from std\\nhttps://doc.rust-lang.org/src/alloc/vec.rs.html#1619-1621\\n\\n```rust\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n      \\n        nums.dedup();\\n        nums.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\\n      \\n        nums.dedup();\\n        nums.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12033,
                "title": "javascript-inplace-solution",
                "content": "    var removeDuplicates = function (nums) {\\n        var i = 0;\\n        nums.forEach(function (elem) {\\n            if (elem !== nums[i]) {\\n                nums[++i] = elem;\\n            }\\n        });\\n        return nums.length && i + 1;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeDuplicates = function (nums) {\\n        var i = 0;\\n        nums.forEach(function (elem) {\\n            if (elem !== nums[i]) {\\n                nums[++i] = elem;\\n            }\\n        });\\n        return nums.length && i + 1;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 12123,
                "title": "my-accepted-python-code-via-while-loop",
                "content": "    class Solution:\\n    # @param a list of integers\\n    # @return an integer\\n    \\n    def removeDuplicates(self, A):\\n        if not A:\\n            return 0\\n        else:\\n            ii,jj=1,1\\n            while jj<len(A):\\n                if A[ii-1]!=A[jj]:\\n                    A[ii]=A[jj]\\n                    ii+=1\\n                jj+=1\\n            return ii\\n\\nthe code use a while loop with two indexes ii and jj. jj went through all elements in A and ii is used to record non-duplicated elements in A. Any comments would be appreciated",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param a list of integers\\n    # @return an integer\\n    \\n    def removeDuplicates(self, A):\\n        if not A:\\n            return 0\\n        else:\\n            ii,jj=1,1\\n            while jj<len(A):\\n                if A[ii-1]!=A[jj]:\\n                    A[ii]=A[jj]\\n                    ii+=1\\n                jj+=1\\n            return ii\\n\\nthe code use a while loop with two indexes ii and jj. jj went through all elements in A and ii is used to record non-duplicated elements in A. Any comments would be appreciated",
                "codeTag": "Java"
            },
            {
                "id": 3675352,
                "title": "easiest-method-by-python-3-language-with-80-beats-and-most-recomended-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]: \\n                nums[ans] = nums[i] \\n                ans += 1\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]: \\n                nums[ans] = nums[i] \\n                ans += 1\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497179,
                "title": "easiest-solution-c-java-python-javascript-typescript",
                "content": "I think it won\\'t need any explanation. However, if you still have any questions, feel free to ask in comments.\\n\\nTC: O(n) \\nSC: O(1)\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ans = 1;\\n        for(int i = 1; i < size(nums); ++i)\\n            if(nums[i] != nums[i - 1])  {  \\n                nums[ans] = nums[i]; \\n                ++ans; \\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int ans = 1;\\n        for(int i = 1; i < nums.length; ++i)\\n            if(nums[i] != nums[i - 1])  {  \\n                nums[ans] = nums[i]; \\n                ++ans; \\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\nPython\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]: \\n                nums[ans] = nums[i] \\n                ans += 1\\n        return ans\\n```\\n\\nJavaScript\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let ans = 1;\\n    for(let i = 1; i < nums.length; ++i)\\n        if(nums[i] != nums[i - 1])  {  \\n            nums[ans] = nums[i]; \\n            ++ans; \\n        }\\n    return ans;\\n};\\n```\\n\\nTypeScript\\n\\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    let ans: number = 1;\\n    for(let i = 1; i < nums.length; ++i)\\n        if(nums[i] != nums[i - 1])  {  \\n            nums[ans] = nums[i]; \\n            ++ans; \\n        }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ans = 1;\\n        for(int i = 1; i < size(nums); ++i)\\n            if(nums[i] != nums[i - 1])  {  \\n                nums[ans] = nums[i]; \\n                ++ans; \\n            }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int ans = 1;\\n        for(int i = 1; i < nums.length; ++i)\\n            if(nums[i] != nums[i - 1])  {  \\n                nums[ans] = nums[i]; \\n                ++ans; \\n            }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans = 1\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i - 1]: \\n                nums[ans] = nums[i] \\n                ans += 1\\n        return ans\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let ans = 1;\\n    for(let i = 1; i < nums.length; ++i)\\n        if(nums[i] != nums[i - 1])  {  \\n            nums[ans] = nums[i]; \\n            ++ans; \\n        }\\n    return ans;\\n};\\n```\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    let ans: number = 1;\\n    for(let i = 1; i < nums.length; ++i)\\n        if(nums[i] != nums[i - 1])  {  \\n            nums[ans] = nums[i]; \\n            ++ans; \\n        }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939797,
                "title": "simple-javascript-solution",
                "content": "loop through array to find duplicate and if we find duplicate will remove it.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = function (nums) {\\n for(let i=0;i<nums.length;){\\n     if(nums[i] ===nums[i+1]){\\n         nums.splice(i,1)\\n     }else{\\n         i++\\n     }\\n }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = function (nums) {\\n for(let i=0;i<nums.length;){\\n     if(nums[i] ===nums[i+1]){\\n         nums.splice(i,1)\\n     }else{\\n         i++\\n     }\\n }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826055,
                "title": "easy-java-solution-using-set-and-arraylist-beats-99-75",
                "content": "# PLEASE UPVOTE IF YOU LIKE IT\\n\\n# Approach\\nPutting elemetns in **SET** so that duplicates can be removed, then filling the array with ****Zeros**** to make the original array empty, after than putting those Set values in ****ArrayList****, after than **sorting** the list in Accending order because the result will be in accending order,now putting the arraylist value in Original array again.\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n         HashSet<Integer> set = new HashSet<>();\\n\\n        for (int num : nums) set.add(num);\\n        Arrays.fill(nums,0);\\n        ArrayList<Integer> list = new ArrayList<>(set);\\n        Collections.sort(list);\\n        for(int i = 0; i < list.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n         HashSet<Integer> set = new HashSet<>();\\n\\n        for (int num : nums) set.add(num);\\n        Arrays.fill(nums,0);\\n        ArrayList<Integer> list = new ArrayList<>(set);\\n        Collections.sort(list);\\n        for(int i = 0; i < list.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803320,
                "title": "c-stl-one-liner-and-hand-rolled-two-pointer-solution-clean-code",
                "content": "# Approach 1: std::unique and std::distance\\n\\nUsing STL functions we can turn this into a one-liner.\\n\\n```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        return distance(begin(nums), unique(begin(nums), end(nums)));\\n    }\\n```\\n\\nNote that for this problem we don\\'t need to erase the end of the vector, if we wanted that the solution would look something like this:\\n\\n```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n        return size(nums);\\n    }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 2: hand rolled two pointer solution\\n\\nThe check for an empty vector is strictly speaking not needed for this problem, but I\\'d add it anyway.\\n\\n```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        if (empty(nums)) return 0;\\n\\n        int w = 1;\\n        for (int i = 1; i < size(nums); ++i)\\n            if (nums[i - 1] != nums[i]) nums[w++] = nums[i];\\n        return w;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        return distance(begin(nums), unique(begin(nums), end(nums)));\\n    }\\n```\n```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n        return size(nums);\\n    }\\n```\n```cpp\\n    static int removeDuplicates(vector<int>& nums) {\\n        if (empty(nums)) return 0;\\n\\n        int w = 1;\\n        for (int i = 1; i < size(nums); ++i)\\n            if (nums[i - 1] != nums[i]) nums[w++] = nums[i];\\n        return w;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801739,
                "title": "c-easy-to-follow-with-explanations-for-remove-duplicates",
                "content": "We have a sorted array and need to \\n(1) return the number of unique elements (length of array - duplicates found) as well as \\n(2) modify the original array of nums so that only the unique elements are at the front of the array for the solution tester.\\n\\nThe algorithm simply compares each value in the nums array with the last known unique number which value is stored in the int  currentVal. \\n\\nWhen we compare the next element in the array with the currentVal (last unique value we found) and they are the same then we know we have another duplicate and can change the value of this number in the nums array to 101. As per constraints no numbers in nums are greater than 100, so any number 101 or higher will end up at the end of the array when resort later.\\n\\nWe loop through nums, either changing the value of duplicates to 101 or updating the int currentVal to represent the last known  unique value in nums. \\n\\nWe keep comparing until we find a unique number at which point we update the current value we are comparing in the array as the new unique number. \\n\\nOnce loop finished we SORT the nums array and all the 101s will endup at the end of the array and are ignored by the solution tester. We also return the size of the array less the number of duplicates we counted along the way (which is the number of unique numbers in nums). \\n\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n    int size=nums.Length;\\n    if (size<2) return nums[0];\\n    int currentVal=nums[0];\\n        int countDup=0;\\n        for (int i=0;i<size-1;i++)\\n        {\\n            if (currentVal == nums[i+1])\\n                {\\n                  // match\\n                    nums[i+1]=101; // will push it out of array when resorted\\n                    countDup++;\\n                }\\n                else \\n                {\\n                    currentVal=nums[i+1];\\n                }\\n        }\\n        Array.Sort(nums);\\n        return size-countDup;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n    int size=nums.Length;\\n    if (size<2) return nums[0];\\n    int currentVal=nums[0];\\n        int countDup=0;\\n        for (int i=0;i<size-1;i++)\\n        {\\n            if (currentVal == nums[i+1])\\n                {\\n                  // match\\n                    nums[i+1]=101; // will push it out of array when resorted\\n                    countDup++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2688808,
                "title": "remove-duplicates-from-sorted-array-time-o-n-space-o-1-solution-in-c-explained",
                "content": "Since, it\\'s given in the problem that the array is sorted, we can use that to our advantage. Remember that when an array is sorted, all the duplicate elements are adjacent to each other.\\n\\nNow, we solve the problem similarly to how we would solve frequency of each unique element in the array. Let\\'s see how it works:\\n\\nAssume an example array `arr = [1, 1, 2, 3, 3, 3, 3]`\\n\\nNow, create a variable called `curr_value` to store the value whose occurrences you\\'re trying to count at this particluar moment. Initialise this variable `curr_value` to the first element of the array (which is 1 in this case). Create another variable `insert_ptr` to represent the index at which each unique element is to be inserted (updated) in the given array. Initialise it with 0 since we start updating or inserting unique elements from 0th index.\\n\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t         |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   curr_value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nThen, start iterating the array `arr` from index 1 and check if the value at this index is equal to the `current_value`.\\n\\n                                           traverse_ptr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t            |\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t         |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   curr_value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nif `curr_value` is equal `arr[traverse_ptr]`, then increment `traverse_ptr`.\\n\\n**Note: You don\\'t need to increase count because we are not concerned with the frequency of the elements. We only need the unique elements. Just iterate the index value.**\\n\\nAnd, if the `curr_value != arr[traverse_ptr]`, then, we have to place the `curr_value` in the `insert_ptr` index and increment it\\'s value.\\n\\n\\nThe simulation of the above process on the given example array would look like:\\n\\nstep 1:\\n\\n                                           traverse_ptr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t            |\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t         |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   curr_value\\nstep 2: Since, `curr_value == arr[traverse_ptr]`, increment `traverse_ptr`\\'s value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t           traverse_ptr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t               |\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t         |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   curr_value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nstep 3: Now, since `curr_value != arr[traverse_ptr]`, we found the first unique element (`curr_value`). Now insert this value at `insert_ptr` index and increment `insert_ptr`. Update the `curr_value` variable with the new element `arr[traverse_ptr]`. Now, `insert_ptr` has a value of 1. The updated array `arr` would look like:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t            traverse_ptr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                  |\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t               |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t         curr_value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\nstep 4: Since, `curr_value != arr[traverse_ptr]` insert the `curr_value` in `insert_ptr` index and increment `insert_ptr`. Update `curr_value` with the new element. The updated array `arr` would look like:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t              traverse_ptr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                     |\\n                                      arr = [1, 1, 2, 3, 3, 3, 3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                  |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t            curr_value\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nstep 5: Repeat this process and you\\'ll observe that we traverse the whole array.\\n\\n**Important: Did you observe how in previous steps the value got inserted only when we encounter a new element (`curr_value != arr[traverse_ptr]`). But for the last unique element in the given array, we don\\'t have such an element. So, after coming out of the loop, we still haven\\'t updated/inserted the last unique element into it\\'s correct place. So we just write one more line of code:\\n`arr[insert_ptr] = curr_value`**\\n\\n****\\n\\n_**Tip**: If the above explanation seems a little un-intuitive or confusing, I\\'d suggest you to take an array of your choice, follow the steps mentioned above by hand on a piece of paper and see what happens after each step. This should make it very clear :)_\\n\\n****\\n\\n\\nImplementation of the above algorithm in C++:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& numbers) {\\n        int insert_ptr   {0};\\n        int traverse_ptr {1};\\n        int curr_value   {numbers[0]};\\n        \\n        while (traverse_ptr < (int)numbers.size()) {\\n\\t\\t    /* when you encounter a new number: \\n\\t\\t\\t   1) insert the old value in it\\'s correct place in array\\n\\t\\t\\t   2) update the curr_value with the new value\\n\\t\\t\\t   3) move the insert_ptr to next index\\n\\t\\t\\t*/\\n            if (curr_value != numbers[traverse_ptr]) {\\n                numbers[insert_ptr] = curr_value;\\n                curr_value = numbers[traverse_ptr];\\n\\t\\t\\t\\t++insert_ptr;\\n            }\\n            ++traverse_ptr;\\n        }\\n\\t\\t\\n        // inserting the last unique element into the array\\n        numbers[insert_ptr] = curr_value;\\n        \\n\\t\\t// since insert_ptr is an index, the no. of elements till that index would be insert_ptr + 1\\n        return insert_ptr + 1;\\n    }\\n};\\n```\\n\\n\\n****\\n\\nExtra: If you want to optimise this code even more for speed, you can:\\n1. Replace\\n```cpp\\nif (curr_value != numbers[traverse_ptr])\\n```\\nwith\\n```cpp\\nif (curr_value ^ numbers[traverse_ptr])\\n```\\n2. Instead of incrementing `insert_ptr` in a separate line, just increment it as:\\n\\n```cpp\\nnumbers[insert_ptr++] = curr_value;\\n```\\n\\nthis will increment the value of `insert_ptr` after assigning `curr_val` to the current value of `insert_ptr`. So you can safely remove\\n```cpp\\n++insert_ptr;\\n```\\n\\n****\\n****\\nI hope this article was helpful. Thanks for reading :)",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& numbers) {\\n        int insert_ptr   {0};\\n        int traverse_ptr {1};\\n        int curr_value   {numbers[0]};\\n        \\n        while (traverse_ptr < (int)numbers.size()) {\\n\\t\\t    /* when you encounter a new number: \\n\\t\\t\\t   1) insert the old value in it\\'s correct place in array\\n\\t\\t\\t   2) update the curr_value with the new value\\n\\t\\t\\t   3) move the insert_ptr to next index\\n\\t\\t\\t*/\\n            if (curr_value != numbers[traverse_ptr]) {\\n                numbers[insert_ptr] = curr_value;\\n                curr_value = numbers[traverse_ptr];\\n\\t\\t\\t\\t++insert_ptr;\\n            }\\n            ++traverse_ptr;\\n        }\\n\\t\\t\\n        // inserting the last unique element into the array\\n        numbers[insert_ptr] = curr_value;\\n        \\n\\t\\t// since insert_ptr is an index, the no. of elements till that index would be insert_ptr + 1\\n        return insert_ptr + 1;\\n    }\\n};\\n```\n```cpp\\nif (curr_value != numbers[traverse_ptr])\\n```\n```cpp\\nif (curr_value ^ numbers[traverse_ptr])\\n```\n```cpp\\nnumbers[insert_ptr++] = curr_value;\\n```\n```cpp\\n++insert_ptr;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659227,
                "title": "python-remove-duplicate-three-ways-very-easy",
                "content": "### Python Remove Duplicate, Three ways\\uFF0Cvery easy\\n\\n- Fist, Python trick, and the most easy one \\uFF1Ause python function \"set()\" to remove duplicate, but it\\u2018s disorder after, so we need to use \"sort()\" to sort it again. \\nThis is not a good way, because it use the sort that make the time complexity > O(n), but it\\'s still working well because Python\\'s \"sort()\" function is code by c, so it\\'s very fast\\n\\t\\n        mlist = list(set(nums))\\n        mlist.sort()\\n        for i in range(len(mlist)):\\n            nums[i] = mlist[i] \\n        return len(mlist)\\n    \\n        \\n-    Second, Just loop the list from beginning to end, and compare two adjacent numbers, if they are the same, then delete one. The the time complexity is O(n).\\nTip\\uFF1Awhen we wanna delete a element of list in Python, if we know the index,  use \"pop(index)\" is better than \"remove (element)\", because pop() time complexity is O(1) and the remove () time complexity is O(n) \\n\\t\\t\\n\\t\\t    if len(nums) == 1: return 1\\n\\t\\t\\t\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(nums)-1:\\n\\t\\t\\t\\tif nums[i] == nums[i+1]:                \\n\\t\\t\\t\\t\\tnums.pop(i+1)  \\n\\t\\t\\t\\telse:    \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn i + 1\\n        \\n        \\n- Trird , double pointer, the most clear\\uFF1AWhen i and j point to the same value, fix pointer i, move pointer j, until the nums[i] != nums[j]. Then assign the value pointed by j to the next element of i. When j loop all the elements of the list, It\\'s finish.\\n\\n        if len(nums) == 1: return 1\\n   \\n        i = 0\\n        j = i + 1\\n\\t\\t\\n        while j < len(nums):\\n            if nums[i] == nums[j]:   \\n                j += 1\\n            else:\\n                i = i + 1\\n                nums[i] = nums[j] \\n                j += 1\\n\\t\\t\\t\\t\\n        return i + 1\\n\\t\\t\\nIf you have any questions or have any better ways, please let me know.",
                "solutionTags": [
                    "Python"
                ],
                "code": "### Python Remove Duplicate, Three ways\\uFF0Cvery easy\\n\\n- Fist, Python trick, and the most easy one \\uFF1Ause python function \"set()\" to remove duplicate, but it\\u2018s disorder after, so we need to use \"sort()\" to sort it again. \\nThis is not a good way, because it use the sort that make the time complexity > O(n), but it\\'s still working well because Python\\'s \"sort()\" function is code by c, so it\\'s very fast\\n\\t\\n        mlist = list(set(nums))\\n        mlist.sort()\\n        for i in range(len(mlist)):\\n            nums[i] = mlist[i] \\n        return len(mlist)\\n    \\n        \\n-    Second, Just loop the list from beginning to end, and compare two adjacent numbers, if they are the same, then delete one. The the time complexity is O(n).\\nTip\\uFF1Awhen we wanna delete a element of list in Python, if we know the index,  use \"pop(index)\" is better than \"remove (element)\", because pop() time complexity is O(1) and the remove () time complexity is O(n) \\n\\t\\t\\n\\t\\t    if len(nums) == 1: return 1\\n\\t\\t\\t\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(nums)-1:\\n\\t\\t\\t\\tif nums[i] == nums[i+1]:                \\n\\t\\t\\t\\t\\tnums.pop(i+1)  \\n\\t\\t\\t\\telse:    \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn i + 1\\n        \\n        \\n- Trird , double pointer, the most clear\\uFF1AWhen i and j point to the same value, fix pointer i, move pointer j, until the nums[i] != nums[j]. Then assign the value pointed by j to the next element of i. When j loop all the elements of the list, It\\'s finish.\\n\\n        if len(nums) == 1: return 1\\n   \\n        i = 0\\n        j = i + 1\\n\\t\\t\\n        while j < len(nums):\\n            if nums[i] == nums[j]:   \\n                j += 1\\n            else:\\n                i = i + 1\\n                nums[i] = nums[j] \\n                j += 1\\n\\t\\t\\t\\t\\n        return i + 1\\n\\t\\t\\nIf you have any questions or have any better ways, please let me know.",
                "codeTag": "Unknown"
            },
            {
                "id": 2563748,
                "title": "98-21-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(n) {\\n    \\n    let j = 0;\\n    \\n    for(let i = 0; i < n.length; i++) {\\n        \\n        if(n[i] !== n[i+1]) {    \\n            n[j++] = n[i];\\n        }\\n    };\\n    \\n    return j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(n) {\\n    \\n    let j = 0;\\n    \\n    for(let i = 0; i < n.length; i++) {\\n        \\n        if(n[i] !== n[i+1]) {    \\n            n[j++] = n[i];\\n        }\\n    };\\n    \\n    return j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549630,
                "title": "python3-solution-with-explanation",
                "content": "nums[:] creates a shallow copy of nums.\\nA shallow copy performs a copy of the original list, but keeps the same id references from the original list. If you were to inspect the id of each object in the list they would return their unique id.\\n\\nAs we are told in the question not to use extra space, we have used slicing method [:].\\n(Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.)\\n\\nsorted(set(nums)) will return the sorted list removing the duplicates (set function is used to remove the duplicates) into the nums array only.\\n\\nCode:\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(set(nums))\\n        return len(nums)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(set(nums))\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360892,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int arr = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i < nums.length - 1 && nums[i] == nums[i + 1]) {\\n                continue;\\n            }\\n            nums[arr] = nums[i];\\n            arr++;\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int arr = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i < nums.length - 1 && nums[i] == nums[i + 1]) {\\n                continue;\\n            }\\n            nums[arr] = nums[i];\\n            arr++;\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185356,
                "title": "python-one-liner",
                "content": "**Two Pointer Solution**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        p1 = 0\\n        p2 = 0\\n        while p2 < len(nums):\\n            if nums[p1] != nums[p2]:\\n                nums[p1+1] = nums[p2]\\n                p1 += 1\\n            p2 += 1\\n        return p1+1\\n```\\n\\n**One liner**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(list(set(nums)))\\n```\\n\\nPlease upvote if it is helpful to you.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        p1 = 0\\n        p2 = 0\\n        while p2 < len(nums):\\n            if nums[p1] != nums[p2]:\\n                nums[p1+1] = nums[p2]\\n                p1 += 1\\n            p2 += 1\\n        return p1+1\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums[:] = sorted(list(set(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846629,
                "title": "remove-duplicates-from-sorted-array-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int pos=1;\\n        \\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                nums[pos++]=nums[i+1];\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```\\n\\nThe first occurence of any element will be unique, hence initialising the variable \\'pos\\' with a value of 1. The next step is to iterate the array and compare \\'i-th\\' place element with \\'i+1-th\\' place element. If they are not unique we can place the new element found at the \\'pos-th\\' index. We are incrementing \\'pos\\' so that we can place the next unique element encountered at the \\'pos+1-th\\' index from that point.\\n\\nIf we were not to move the elements in-place, another naive solution could have been to use Set collections in java as sets do not allow duplicates.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int pos=1;\\n        \\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                nums[pos++]=nums[i+1];\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721303,
                "title": "java-solution-1ms-runtime-100-correct-o-n",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int left = 0, right = 1, k=0, count=0;\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        if(nums.length==2 && nums[0]!=nums[1]){\\n            return 2;\\n        }\\n        if(nums.length==0)\\n            return 0;\\n        while(right<nums.length){\\n            if(nums[left]!=nums[right]){\\n                nums[k] = nums[left];\\n                k++;\\n                count++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        count++;\\n        nums[k] = nums[left];\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int left = 0, right = 1, k=0, count=0;\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        if(nums.length==2 && nums[0]!=nums[1]){\\n            return 2;\\n        }\\n        if(nums.length==0)\\n            return 0;\\n        while(right<nums.length){\\n            if(nums[left]!=nums[right]){\\n                nums[k] = nums[left];\\n                k++;\\n                count++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        count++;\\n        nums[k] = nums[left];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348541,
                "title": "java-simple-0ms-and-100-faster",
                "content": "```\\n public int removeDuplicates(int[] nums) {\\n          int index = 1;\\n\\t        \\n\\t        for(int i=0;i<nums.length-1;i++)\\n\\t        {\\n\\t        \\tif(nums[i] != nums[i+1])\\n\\t        \\t\\tnums[index++] = nums[i+1];\\n\\t        }\\n\\t        \\n\\t        return index;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int removeDuplicates(int[] nums) {\\n          int index = 1;\\n\\t        \\n\\t        for(int i=0;i<nums.length-1;i++)\\n\\t        {\\n\\t        \\tif(nums[i] != nums[i+1])\\n\\t        \\t\\tnums[index++] = nums[i+1];\\n\\t        }\\n\\t        \\n\\t        return index;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141714,
                "title": "python3-beats-99-65-of-submissions",
                "content": "You can make the unique index do double duty as the location of the previous value.\\n\\n```    \\ndef removeDuplicates(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    if len(nums) < 2:\\n        return len(nums)\\n    \\n    j = 0\\n    \\n    for num in nums[1:]:\\n        if num != nums[j]:\\n            j += 1\\n            nums[j] = num\\n    return j+1\\n```",
                "solutionTags": [],
                "code": "```    \\ndef removeDuplicates(self, nums):\\n    \"\"\"\\n    :type nums: List[int]\\n    :rtype: int\\n    \"\"\"\\n    if len(nums) < 2:\\n        return len(nums)\\n    \\n    j = 0\\n    \\n    for num in nums[1:]:\\n        if num != nums[j]:\\n            j += 1\\n            nums[j] = num\\n    return j+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 12051,
                "title": "javascript-148ms",
                "content": "var removeDuplicates = function(nums) {\\n\\n    //two pointers, one pass\\n    var slow = 0;\\n    for (var fast = 0; fast < nums.length; fast++) {\\n        if (nums[slow] !== nums[fast]) {\\n            nums[++slow] = nums[fast];\\n        }\\n    }\\n    return slow+1;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var removeDuplicates = function(nums) {\\n\\n    //two pointers, one pass\\n    var slow = 0;\\n    for (var fast = 0; fast < nums.length; fast++) {\\n        if (nums[slow] !== nums[fast]) {\\n            nums[++slow] = nums[fast];\\n        }\\n    }\\n    return slow+1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 12112,
                "title": "my-c-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            if(nums.size() == 0)\\n                return 0;\\n            int i = 0,j = 1;\\n            while(j < nums.size())\\n            {\\n                if(nums[j] != nums[i])\\n                    nums[++i] = nums[j];\\n                j++;\\n            }\\n            return i + 1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            if(nums.size() == 0)\\n                return 0;\\n            int i = 0,j = 1;\\n            while(j < nums.size())\\n            {\\n                if(nums[j] != nums[i])\\n                    nums[++i] = nums[j];\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 12193,
                "title": "1-line-c-solution",
                "content": "Only 1 line using STL\\n\\n     return unique(A, A+n)-A;\\n\\nThe unique algorithm record the positions of the unique elements, and then remove duplicates using unique_copy(). The above code has a 41 ms time cost.\\n\\nBelow is my 33ms solution without STL.\\n\\n    class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n           int mark=1;\\n           for(int i=1;i<n;i++)\\n            {\\n                if(A[i]!=A[i-1])\\n                    A[mark++]=A[i];\\n            }\\n            return min(mark,n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n           int mark=1;\\n           for(int i=1;i<n;i++)\\n            {\\n                if(A[i]!=A[i-1])\\n                    A[mark++]=A[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3906053,
                "title": "ts-js-98-94-naive-approach-in-o-n",
                "content": "# Intuition\\nStraight forward TS/JS Approach\\n\\n# Approach\\n1) Create a unique set of the array.\\n2) Delete the existing array.\\n3) Add unique items to existing array.\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    let temp = [...new Set(nums)];\\n    nums.length = 0;\\n    nums.push(...temp);\\n    return nums.length;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    let temp = [...new Set(nums)];\\n    nums.length = 0;\\n    nums.push(...temp);\\n    return nums.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602603,
                "title": "optimized-solution-remove-duplicates-from-sorted-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        return nums.size();\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592450,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387148,
                "title": "brute-force-and-optimal-approach-easy-to-understand-c-code",
                "content": "# Brute Force Approach -->\\n# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know the set only keeps the unique elements, So we will insert all the given elements in a set, then we will put them in the array from begining and will increase the index . At last we can return Index, Because it is the number of unique values. \\n# Brute force code\\n```\\nset<int>st;\\nfor(int i=0;i<nums.size();i++){\\n    st.insert(nums[i]);\\n}\\nint idx=0;\\nfor(auto it : st){\\n    nums[idx]=it;\\n    idx++;\\n}\\nreturn idx;\\n``` \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### $$O(nlogn + n)$$  (insert() takes logn time)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### $$O(n)$$ (size of set might be \\'n\\')\\n# Optimal Approach -->\\nWe will use two pointer approach , where at first \\'i\\' pointer will be at first position ans \\'j\\' pointer will be at second position then we will compare both values as they are equal or not. If the values are not equal then \\n```\\nnums[i+1]=nums[j];\\ni++\\n```\\n\\n# Optimal Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i=0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                nums[i+1]=nums[j];\\n                i++;\\n            }\\n        }\\n        return i+1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### $$O(n)$$  (A loop is running from \\'0\\' to \\'n\\')\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### $$O(1)$$ \\n\\n# Please Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nset<int>st;\\nfor(int i=0;i<nums.size();i++){\\n    st.insert(nums[i]);\\n}\\nint idx=0;\\nfor(auto it : st){\\n    nums[idx]=it;\\n    idx++;\\n}\\nreturn idx;\\n```\n```\\nnums[i+1]=nums[j];\\ni++\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i=0;\\n        for(int j=1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                nums[i+1]=nums[j];\\n                i++;\\n            }\\n        }\\n        return i+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373559,
                "title": "simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        char = set()\\n        p = 0\\n        while(p<len(nums)):\\n            if(nums[p] in char):\\n                nums.remove(nums[p])\\n            else:\\n                char.add(nums[p])\\n                p = p+1\\n                \\n        #print(nums)\\n        return len(char)\\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        char = set()\\n        p = 0\\n        while(p<len(nums)):\\n            if(nums[p] in char):\\n                nums.remove(nums[p])\\n            else:\\n                char.add(nums[p])\\n                p = p+1\\n                \\n        #print(nums)\\n        return len(char)\\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337917,
                "title": "best-solution-for-time-complexity-used-two-pointers-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using \"Two Pointers\" method we can achieve to faster code and that will eat less memory\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    if (nums.length === 0) return 0;\\n    \\n    let i = 0;\\n    \\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] !== nums[i]) {\\n            i++;\\n            nums[i] = nums[j];\\n        }\\n    }\\n    \\n    return i + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    if (nums.length === 0) return 0;\\n    \\n    let i = 0;\\n    \\n    for (let j = 1; j < nums.length; j++) {\\n        if (nums[j] !== nums[i]) {\\n            i++;\\n            nums[i] = nums[j];\\n        }\\n    }\\n    \\n    return i + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801967,
                "title": "beginner-friendly-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        \\n         int k=1;\\n        for(int i=1;i<nums.size();++i)\\n        {\\n            if(nums[i]!=nums[i-1])\\n            {\\n                nums[k]=nums[i];\\n                k++;\\n            }\\n            }\\n        return k;\\n    }\\n};\\n```\\n//comment your suggestion",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        \\n         int k=1;\\n        for(int i=1;i<nums.size();++i)\\n        {\\n            if(nums[i]!=nums[i-1])\\n            {\\n                nums[k]=nums[i];\\n                k++;\\n            }\\n            }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801876,
                "title": "easy-solution-two-pointer-approach",
                "content": "IF YOU LIKE THE SOLUTION \\nMAKE SURE TO UPVOTE IT !\\n\\n# Intuition\\nUSE TWO POINTER APPROACH\\n\\n# Approach\\nOne pointer for iterating through array and second one for filling the array according to the requirement .\\n\\n# Complexity\\n- Time complexity: O(N) N : length of array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- With Explanation\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // start with i = 0 for looping and j = 0 for filling unique numbers\\n        int j = 0;\\n        //Start iterating through given array\\n        for(int i = 0; i<nums.length; i++){\\n            int val = nums[i];\\n            // Move the while loop until curr val is repeating , just increase i variable\\n            while(i<nums.length-1 && val == nums[i+1]){\\n                i++;\\n            }\\n            // We came out from while loop it means we went through all the values and our i is at their position of val .\\n            // We simply put that value at j and move j one step a head.\\n\\n            // System.out.println(\" i : \" + i + \" j : \" + j);\\n            nums[j++] = val;\\n        }\\n        // Finally return j\\n        return j;\\n    }\\n}\\n\\n// DRY RUN \\n/* Eg. [0,0,1,1,1,2,2,3,3,4]\\n\\n init i = 0; j = 0;\\n\\n    i : 1 j : 0\\n    i : 4 j : 1\\n    i : 6 j : 2\\n    i : 8 j : 3\\n    i : 9 j : 4\\n\\n    finally j becomes 5;\\n\\n    // Output\\n    [0,1,2,3,4]\\n    */\\n\\n\\n```\\n#  Simplified Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0, j = 0;\\n        for(i = 0;i<nums.length; i++){\\n            int val = nums[i];\\n            while(i<nums.length-1 && val == nums[i+1]){\\n                i++;\\n            }\\n            nums[j++] = val;\\n        }\\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // start with i = 0 for looping and j = 0 for filling unique numbers\\n        int j = 0;\\n        //Start iterating through given array\\n        for(int i = 0; i<nums.length; i++){\\n            int val = nums[i];\\n            // Move the while loop until curr val is repeating , just increase i variable\\n            while(i<nums.length-1 && val == nums[i+1]){\\n                i++;\\n            }\\n            // We came out from while loop it means we went through all the values and our i is at their position of val .\\n            // We simply put that value at j and move j one step a head.\\n\\n            // System.out.println(\" i : \" + i + \" j : \" + j);\\n            nums[j++] = val;\\n        }\\n        // Finally return j\\n        return j;\\n    }\\n}\\n\\n// DRY RUN \\n/* Eg. [0,0,1,1,1,2,2,3,3,4]\\n\\n init i = 0; j = 0;\\n\\n    i : 1 j : 0\\n    i : 4 j : 1\\n    i : 6 j : 2\\n    i : 8 j : 3\\n    i : 9 j : 4\\n\\n    finally j becomes 5;\\n\\n    // Output\\n    [0,1,2,3,4]\\n    */\\n\\n\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0, j = 0;\\n        for(i = 0;i<nums.length; i++){\\n            int val = nums[i];\\n            while(i<nums.length-1 && val == nums[i+1]){\\n                i++;\\n            }\\n            nums[j++] = val;\\n        }\\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765293,
                "title": "python-simple-fast-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        for j in nums:\\n            if j not in nums[:i]:\\n                nums[i]=j\\n                i+=1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        for j in nums:\\n            if j not in nums[:i]:\\n                nums[i]=j\\n                i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691214,
                "title": "simplest-java-solution-using-for-loop-runtime-2-ms",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n                int j=1;\\n        int count = 0;\\n        for(int i = 0;i<nums.length-1;i++){\\n            if(nums[i] != nums[j]){\\n                count++;\\n                nums[count] = nums[j];\\n            }\\n            j++;\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n                int j=1;\\n        int count = 0;\\n        for(int i = 0;i<nums.length-1;i++){\\n            if(nums[i] != nums[j]){\\n                count++;\\n                nums[count] = nums[j];\\n            }\\n            j++;\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690394,
                "title": "simple-java-code-that-beats-100-in-time-complexity",
                "content": "# Intuition\\njust check for the next element, if the next element is not equal to current element place it in the array at index k which starts from 0 and increments \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n               nums[k++]=nums[i];\\n            }\\n        }\\n        nums[k++]=nums[nums.length-1];\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n               nums[k++]=nums[i];\\n            }\\n        }\\n        nums[k++]=nums[nums.length-1];\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606646,
                "title": "python-simplest-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\tl=1\\n\\t\\t\\tfor s in range(1,len(nums)):\\n\\t\\t\\t\\tif nums[s]!=nums[s-1]:\\n\\t\\t\\t\\t\\tnums[l]=nums[s]\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\treturn l",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\tl=1\\n\\t\\t\\tfor s in range(1,len(nums)):\\n\\t\\t\\t\\tif nums[s]!=nums[s-1]:\\n\\t\\t\\t\\t\\tnums[l]=nums[s]\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\treturn l",
                "codeTag": "Java"
            },
            {
                "id": 2599394,
                "title": "java-solution-o-n-100-faster-solution",
                "content": "The Objective of the problem is to move all the non duplicates to the front of the Array\\nGiving that the Array is on Ascending order, taking it to the advantage to solve the problem\\n\\nUsing two pointer algorithm\\nWhere pointer\\n```x```  -  keeps track of **next** non duplicate to handle \\n```y```  - runs throught the array in search of next non duplicate to replace in place of pointer ```x```\\n\\nsince its an ascending array, the search criteria is number should be greater than the previous non duplicate(```x-1```)\\n\\nOnce we found the next non duplicate number replace in place of ```x``` and continue the search until array ends\\n\\nReturn ```x``` though it is incremented at the end, since we start ```x``` pointer from 1 considering the index 0 contains the first non duplicate number and array size is minimum 1.\\n\\n```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n    \\n        int x=1;\\n        \\n        for(int y=x ; y < nums.length; y++)\\n        {\\n            if(nums[y] > nums[x-1])\\n            {\\n                nums[x++]=nums[y];\\n            }\\n        }\\n        return x;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```x```\n```y```\n```x```\n```x-1```\n```x```\n```x```\n```x```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496829,
                "title": "javascript-typescript-very-very-easy-solution",
                "content": "**JS:**\\n\\n```\\nvar removeDuplicates = function(nums) {\\n    let j=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n            nums[j++] = nums[i];\\n        }\\n    };\\n    return j;\\n};\\n```\\n\\n**TS:**\\n\\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    let x:number=0;\\n    for(let i:number=0;i<nums.length;i++)\\n        if(nums[i] !== nums[i+1])\\n            nums[x++] = nums[i]\\n    return x;\\n};\\n```\\n\\n\\nConsider **Upvote** if you find it interesting \\uD83D\\uDE0A",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    let j=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n            nums[j++] = nums[i];\\n        }\\n    };\\n    return j;\\n};\\n```\n```\\nfunction removeDuplicates(nums: number[]): number {\\n    let x:number=0;\\n    for(let i:number=0;i<nums.length;i++)\\n        if(nums[i] !== nums[i+1])\\n            nums[x++] = nums[i]\\n    return x;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463040,
                "title": "python-simple-solution-explained",
                "content": "**Points to keep in mind** \\nAs we are not required to change the size of the array, we cannot simply use the remove or pop method to eliminate the duplicate occurences of elements. \\n\\nHence we have to find a way to put all the unique elements at the starting of the array and move all the duplicate elements to the end of the array.\\n\\nTo do so, we take two pointers i and j pointing at the first element of the array.\\n\\nWe then keep incrementing the j pointer (which moves over all the elements of the array until we find a unique  element) and check if nums[j] is a duplicate value of nums[i] (which is still pointing to the first element of the array).\\n\\nIf it is a duplicate value, we increment j and move to the next element.\\nElse, we change nums[i+1] to nums[j] the non-duplicate element.\\n\\nThis way we are finding all the unique elements and placing them one after the other from the beginning of the array.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        i = 0\\n        j = i\\n        while j < len(nums):\\n            if nums[j] == nums[i]:\\n                j += 1\\n            else:\\n                nums[i+1] = nums[j]\\n                i += 1\\n                \\n        return i + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        i = 0\\n        j = i\\n        while j < len(nums):\\n            if nums[j] == nums[i]:\\n                j += 1\\n            else:\\n                nums[i+1] = nums[j]\\n                i += 1\\n                \\n        return i + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349892,
                "title": "easy-c-solution-0-1-space-complexity-0-n-time-complexity-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ct = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] != nums[i - 1]){\\n                nums[ct++] = nums[i];\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ct = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] != nums[i - 1]){\\n                nums[ct++] = nums[i];\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308426,
                "title": "very-easy-100-java-c-js-c-fully-explained-with-comments-line-by-line",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {  \\n        //Base condition\\n        if (nums.length == 0) return 0;\\n        int j = 0;\\n        // Traverse all elements in loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current element is equal to the next element, we skip..\\n            if (i < nums.length - 1 && nums[i] == nums[i + 1]) {\\n                continue;\\n            }\\n            //update the array in place\\n            nums[j] = nums[i];\\n            j++;\\n        }\\n        return j;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n//Another approach is here...\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        //Base condition\\n        if(nums.empty()) return 0;\\n        //initialize an index\\n        int k = 0;\\n        // Traverse all elements in loop...\\n        for(int i = 1; i < nums.size(); i++){\\n            //if the index element k is not equal to the current element..\\n            if(nums[k] != nums[i])\\n                nums[++k] = nums[i];\\n        }\\n        return k+1;\\n    }\\n};\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar removeDuplicates = function(nums) {\\n    //Base condition\\n    if (nums.length == 0) return 0;\\n    let j = 0;\\n    // Traverse all elements in loop...\\n    for (let i = 0; i < nums.length; i++){\\n        // If the current element is equal to the next element, we skip..\\n        if (i < nums.length - 1 && nums[i] == nums[i + 1]){\\n            continue;\\n        }\\n        //update the array in place\\n        nums[j] = nums[i];\\n        j++;\\n    }\\n    return j;\\n};\\n```\\n\\n# **C Language:**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    //Base condition\\n    if(numsSize == 0) return 0;\\n    //initialize an index\\n    int k = 0;\\n    // Traverse all elements in loop...\\n    for(int i = 1; i < numsSize; i++){\\n        //if the index element k is not equal to the current element..\\n        if(nums[k] != nums[i])\\n            nums[++k] = nums[i];\\n    }\\n    return k+1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {  \\n        //Base condition\\n        if (nums.length == 0) return 0;\\n        int j = 0;\\n        // Traverse all elements in loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current element is equal to the next element, we skip..\\n            if (i < nums.length - 1 && nums[i] == nums[i + 1]) {\\n                continue;\\n            }\\n            //update the array in place\\n            nums[j] = nums[i];\\n            j++;\\n        }\\n        return j;\\n    }\\n}\\n```\n```\\n//Another approach is here...\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        //Base condition\\n        if(nums.empty()) return 0;\\n        //initialize an index\\n        int k = 0;\\n        // Traverse all elements in loop...\\n        for(int i = 1; i < nums.size(); i++){\\n            //if the index element k is not equal to the current element..\\n            if(nums[k] != nums[i])\\n                nums[++k] = nums[i];\\n        }\\n        return k+1;\\n    }\\n};\\n```\n```\\nvar removeDuplicates = function(nums) {\\n    //Base condition\\n    if (nums.length == 0) return 0;\\n    let j = 0;\\n    // Traverse all elements in loop...\\n    for (let i = 0; i < nums.length; i++){\\n        // If the current element is equal to the next element, we skip..\\n        if (i < nums.length - 1 && nums[i] == nums[i + 1]){\\n            continue;\\n        }\\n        //update the array in place\\n        nums[j] = nums[i];\\n        j++;\\n    }\\n    return j;\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    //Base condition\\n    if(numsSize == 0) return 0;\\n    //initialize an index\\n    int k = 0;\\n    // Traverse all elements in loop...\\n    for(int i = 1; i < numsSize; i++){\\n        //if the index element k is not equal to the current element..\\n        if(nums[k] != nums[i])\\n            nums[++k] = nums[i];\\n    }\\n    return k+1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219039,
                "title": "100-fast-solution-java",
                "content": "```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int index = 1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]!=nums[i-1]){\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        int index = 1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]!=nums[i-1]){\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145907,
                "title": "c-solution-with-and-without-using-stl",
                "content": "C++ has STL function **unique( )** which removes all consecutive duplicates. You can use it to complete the program in 2 lines.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int idx = unique(nums.begin(), nums.end()) - nums.begin();\\n        return idx;\\n    }\\n};\\n```\\nIf you don\\'t want to use STL then here is a O(n) program.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        if (n==0 || n==1)\\n            return n;\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]!=nums[i+1]){\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        nums[j++]=nums[n-1];\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int idx = unique(nums.begin(), nums.end()) - nums.begin();\\n        return idx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        if (n==0 || n==1)\\n            return n;\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]!=nums[i+1]){\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        nums[j++]=nums[n-1];\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050025,
                "title": "c-faster-than-100-full-explanation-with-code",
                "content": "we are given an array (sorted ascending order) and we have to remove all duplicates from it.\\nsolution T: O(n) and S: O(1)\\n\\nIn this approach we will use two pointer first one is i (see in code) which store current index of answer array and j (loop pointer) through which we will traverse whole array.\\n\\nhere answer array is not different array but it is final array after removing all duplicates starting from index 0 in given array.\\n\\nif last element of our answer array is same as current element of given array we will not store it at i+1 position otherwise we will store it.\\n\\nif you like this solution and explaination then please upvote it.\\nThank you.\\n\\n\\n```\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size(),i=0;\\n        \\n        for(int j=1;j<n;j++)\\n        {\\n            if(nums[i]!=nums[j])\\n            {\\n                i++;\\n                nums[i]=nums[j];\\n               \\n            }\\n        }\\n        return i+1;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size(),i=0;\\n        \\n        for(int j=1;j<n;j++)\\n        {\\n            if(nums[i]!=nums[j])\\n            {\\n                i++;\\n                nums[i]=nums[j];\\n               \\n            }\\n        }\\n        return i+1;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895047,
                "title": "python-code-work-in-o-n",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res = 1\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[res-1]:\\n                nums[res] = nums[i]\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res = 1\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[res-1]:\\n                nums[res] = nums[i]\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364660,
                "title": "98-76-faster-python-o-1-beginner-friendly-with-comments",
                "content": "Simple, Replacing Algo\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        index = 1\\n        for i in range(1,len(nums)):\\n            if(nums[i-1]!=nums[i]):\\n                nums[index] = nums[i]\\n                index+=1\\n        return index\\n  ```\\n \\n![image](https://assets.leetcode.com/users/images/fda22889-d4d2-450f-ae8d-0fbd79ac0a63_1627323206.621853.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        index = 1\\n        for i in range(1,len(nums)):\\n            if(nums[i-1]!=nums[i]):\\n                nums[index] = nums[i]\\n                index+=1\\n        return index\\n  ```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566956,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1747010,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1566413,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1567170,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568003,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1774620,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568320,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1567354,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568140,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1564850,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1566956,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1747010,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1566413,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1567170,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568003,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1774620,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568320,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1567354,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1568140,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1564850,
                "content": [
                    {
                        "username": "nvythedead",
                        "content": "They don\\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\\n\\nJust FYI, this sh_t drove me crazy..."
                    },
                    {
                        "username": "NotAMoose",
                        "content": "Thank you, was ripping my hair out "
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You have to return the correct length of the de-duped array. But when you do the array itself has to be sorted with uniques at the front. You can slice off the extra ones yourself but the judge script is going to do it for you anyway so it\\'s less efficient."
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Nothing stopping you from setting a new array length yourself before returning the length. I didn\\'t realize I didn\\'t have to do it until you said so. Makes sense, though, since you return an int but the output is still an array."
                    },
                    {
                        "username": "Shmormius",
                        "content": "Oh my god, I was going to lose it, I knew something was weird but I couldn\\'t figure out what."
                    },
                    {
                        "username": "NovaVirusXander",
                        "content": "OMG... I was literally going \"Dafuq is going on\" for like 10 mins. Ty so much man #broFist"
                    },
                    {
                        "username": "imanulhuq",
                        "content": "Thank you\\nI was gone mad "
                    },
                    {
                        "username": "emily971133",
                        "content": "if I assign the correct list to the original list (nums), it still responses error...\\nso it seems that we really need to mutate the value of original list(nums)"
                    },
                    {
                        "username": "kuvi41",
                        "content": "Drove me crazy too. Thank god I read this comment, Or else I would have wasted another day. "
                    },
                    {
                        "username": "abobakr",
                        "content": "I don\\'t think. They check the array `nums`  try even without return any thing you will pass some test"
                    },
                    {
                        "username": "Levidps",
                        "content": "Agree! Personally I\\'m not a fan that it actually mutates the original value. This is fine for a problem here but in a real project I\\'d rather avoid this mutation..."
                    },
                    {
                        "username": "Aleton",
                        "content": "[@Stefano-Buzzoni](/Stefano-Buzzoni) You modify the nums array, but you only return k."
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "So in the end what do I have to return? Wheter I return either K or the res array it gives me error"
                    },
                    {
                        "username": "TYork",
                        "content": "Poorly worded then"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "Maybe that is why my solution is not working here but it works in my code editor"
                    },
                    {
                        "username": "venusli370306",
                        "content": "I was on a train and this question buzzed me this whole way. "
                    },
                    {
                        "username": "roman-smal",
                        "content": "whereas in JS you should remove duplicates \\uD83E\\uDD2F"
                    },
                    {
                        "username": "FE_Developer2022",
                        "content": "Thanks man, this is why leetcode sucks. I\\'m heading back to hackerrank"
                    },
                    {
                        "username": "saraahmed2693",
                        "content": "You saved my day! It was driving me crazy!!\\nThank you so much"
                    },
                    {
                        "username": "mukadas026",
                        "content": "seriously man, thanks\\nthey didn\\'t make that very clear in the instructions\\nplus, in the console they don\\'t output what I return, which imo is kinda weird"
                    },
                    {
                        "username": "nrrahul4",
                        "content": "Crazy fellazz.. Thanks man.. You saved my time."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Thanks for that bud!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "user1306Qa",
                        "content": "Thank you.. these instructions smh"
                    },
                    {
                        "username": "madmonkey95",
                        "content": "\"non-decreasing order\"... just call it ascending. What\\'s with the purposely confusing text?"
                    },
                    {
                        "username": "yunyxue",
                        "content": "Non-decreasing means the next value can be the same as the current one, so [1,1] is also a non-decreasing-order list"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "[@Arshad-Siddiqui](/Arshad-Siddiqui) L to my English teacher he never told me"
                    },
                    {
                        "username": "Arshad-Siddiqui",
                        "content": "Increasing indicates that the values are always higher than the last. In this case the next value might be the same so it isn\\'t increasing. Saying non-decreasing is more descriptive."
                    },
                    {
                        "username": "NischayAgrawal",
                        "content": "Damn !! never knew this. Thanks discussion section."
                    },
                    {
                        "username": "Salman4M",
                        "content": "there is difference between them. For example you have \\'a\\' list .                          a = [1,2,2,3,4,5,6,7,8] .  There are two \\'2\\' and if you say it is  sorted by ascending it isn\\'t. Because 2 is equal to other 2 . So it means there is no ascending between them. If you say non - decreasing order then this rule suits to that list. "
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "The term comes from mathematical analysis. They\\'re using very precise language to avoid any ambiguities. Non-decreasing means a[i+1] >= a[i] rather than (strictly) increasing which would mean a[i+1] > a[i]. You can read up on it here: https://en.wikipedia.org/wiki/Monotonic_function"
                    },
                    {
                        "username": "ReeceBailey",
                        "content": "fr tho :kek:"
                    },
                    {
                        "username": "AJC2k19",
                        "content": "it got to me too but i had to think about it. They\\'re just being very formal specifying non-decreasing since ascending by definition implies increasing; however in an array [1,1,2,2] the second 1 is not greater than than the first. non-decreasing definition holds true here."
                    },
                    {
                        "username": "mrcogllrdo",
                        "content": "[@KovDimaY](/KovDimaY) if that were the case then the majority of filters in the wild for organizing info would have \"non-decreasing\" instead of \"ascending\" as an option to account for duplicates. I have never seen \"non-decreasing\" except today...kinda seems like you came up with that strict definition of ascending out of nowhere."
                    },
                    {
                        "username": "w0rkerbee",
                        "content": "[@KovDimaY](/KovDimaY) the expected answers r literallyin ascending order....."
                    },
                    {
                        "username": "ArthurSPrado",
                        "content": "non-decreasing order = !(decreasing-order) = ascending.  Everything non decreasing is ascending. What\\'s with the purposely confusing mind?"
                    },
                    {
                        "username": "laurentiucozma12",
                        "content": "[@KovDimaY](/KovDimaY) I\\'m pretty sure everyone here including me thinks [1,2,2,3,4,4,5] is ascending and \"non-decreasing\" just makes it more confusing. Idk where you took the definition, if there is something official somewhere for those words please let me know."
                    },
                    {
                        "username": "mewsxd",
                        "content": "i laughed so loud because i was so angry when i read it lmaoo"
                    },
                    {
                        "username": "jdx-code",
                        "content": "haha.. I read that twice to convince myself.. lol"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "\"Non-decreasing\" order and \"ascending\" are different things. \"Ascending\" means that each next element should be strictly bigger than previous. For example: [1,2,3,4,5]. \"Non-decreasing\" means that several elements in a row can be equal, but next one cannot be smaller than previous. For example: [1,2,2,3,4,4,5]. Each \"ascending\" order is \"non-decreasing\" but not each \"non-decreasing\" is \"ascending\". Normally is used to emphasise that numbers can be repeated and kinda prepare us for that."
                    },
                    {
                        "username": "jungle_jim",
                        "content": "The problem says to return the number, _k_, elements after removing duplicates. I get an error returning an integer in Python. I also get an error returning an array with non-repeating _k_ elements and repeating elements after. Which is _also_ supposed to be acceptable."
                    },
                    {
                        "username": "mukadas026",
                        "content": "the instructions got me a bit confused for a while too, they just want `k` to be an integer (length of the sorted part of the array)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "augustooalcides",
                        "content": "nums vector is passed by reference, so you can modify it by just removing the duplicate numbers"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "[@abhinav__19](/abhinav__19)  the instructions on this are horrible. You should just be returning the length of the array after it has been cleaned up. BUT, be sure you are modify nums and not creating a second array, because it is checking nums to make sure you removed the duplicates from it."
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Same here"
                    },
                    {
                        "username": "gutta",
                        "content": "hi is there any error in question in question they asked to return size of array after removing duplicates but in output they are showing array.\\ncould you recitify it guys"
                    },
                    {
                        "username": "0xsahilv",
                        "content": "actually they want us to sort array in a way so that all unique elements get to first "
                    },
                    {
                        "username": "rohitmallya",
                        "content": "I too feel the same"
                    },
                    {
                        "username": "zetlian",
                        "content": "[@abdurrahman6489](/abdurrahman6489) still doesnt work for me\\n"
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "And me! I\\'m 75 questions in and no issues - then I hit this one and boom! Sure there\\'s a problem here."
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Return the length of the sorted array.\\nThey will verify the same with their function.\\nYour function should return len(nums[:sorted_elements])"
                    },
                    {
                        "username": "Yeyenash",
                        "content": "I have exactly the same question! Who can explain this to us? \\uD83D\\uDE2D"
                    },
                    {
                        "username": "abdurrahman6489",
                        "content": "in the function it is type int. return the value of K. only\\n"
                    },
                    {
                        "username": "iq45y8i",
                        "content": "Answer is expecting an Array (duplicate removed). But the function has return type as int (single element). Please clarify"
                    },
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "They want you to modify nums but not return it. It is still ebing tested how nums is structured afterwards tho. What you are supposed to return is the length of the sorted part!"
                    },
                    {
                        "username": "shekhaman213",
                        "content": "Array (nums) is passed by reference in the function removeDuplicates , hence any changes in array will be reflected to the nums through its whole scope (outside the function as well)"
                    },
                    {
                        "username": "taychap",
                        "content": "Also note that the question is asking you to mutate the array passed into the function, not return it"
                    },
                    {
                        "username": "Nousie_94",
                        "content": "Answer is expecting the integer \"k\", which is meant in the description."
                    },
                    {
                        "username": "quantupus",
                        "content": "This is a terribly worded question and should be removed, also it is a ridiculously easy problem with a simple list(set(nums)) in python, but this doesn\\'t work due to weird test case things. Please remove this question from leetcode"
                    },
                    {
                        "username": "Coder_Rick",
                        "content": "[@falguni_mutha](/falguni_mutha) I try to solve this easy question using java Set that working fine in intelliJ text editor but here does not work due to the test cases.... "
                    },
                    {
                        "username": "jlgarcia_",
                        "content": "While I partly agree with you, doing `list(set(nums))` creates a new object. Thus, it doesn\\'t mutate the initial list itself, but creates a new one. The output still is the same tho."
                    },
                    {
                        "username": "falguni_mutha",
                        "content": "oh oh oh. I literally t=did this. The question is absolutely terrible. If the wanted the modified array ask for that. The test cases are so stupid"
                    },
                    {
                        "username": "ogorbatchev",
                        "content": "Hey guys, \\n\\nI just finished the exercice and by looking at some solutions, and worse, the solution given by leetcode .. it doesn\\'t remove the duplicate from the array. \\n\\nI mean you have the pointer to this array, and the function name is REMOVE DUPLICATES, the solution clearly doesn\\'t remove them but just put the values in the beginning of the array. \\n\\nMeh, i wanted to say it :p\\nI am furstrated to see this solution that doesn\\'t actually solve the problem \\uD83D\\uDE05\\n\\nWish you guys a good day/night!"
                    },
                    {
                        "username": "therohitbansal4",
                        "content": "Good afternoon /evening \\uD83D\\uDE05"
                    },
                    {
                        "username": "syx_data",
                        "content": "describe:\\nyou must do this by modifying the input array in-place with O(1) extra memory\\uFF0Cwhat does o(1)exrea memory mean\\n"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "[@Nousie_94](/Nousie_94) dude then why return len(list(set(nums))) does not work its senseless"
                    },
                    {
                        "username": "antoniojsp",
                        "content": "when you see 0(1), it means that the memory used would be the same if the array has 10 elements or one million."
                    },
                    {
                        "username": "Nousie_94",
                        "content": "that means, that you are not allowed to allocate new memory which space depends on the number of elements.\\n\\nIn other words: No matter how many elements in \"nums\" are, your code is not allowed to use more memory (except frorm the array \"nums\" itself, of course)."
                    },
                    {
                        "username": "hem_ajet",
                        "content": "![image](https://assets.leetcode.com/users/yhemanth_teja/image_1557658638.png)\\n"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@rajdeepbiswas](/rajdeepbiswas) its working fine without that also!\\n"
                    },
                    {
                        "username": "rajdeepbiswas",
                        "content": "Late comment: is there an usage of the ptr variable that I am missing?"
                    },
                    {
                        "username": "ak_ghoul",
                        "content": "There\\'s this thing on leetcode that we are not allowed to write main function. There can be various ways possible to write code on basis of how things are at main function.\\n*I am having a problem to write code without seeing the main function. *\\nCan somebody tell me how to view it?"
                    },
                    {
                        "username": "bm9avan",
                        "content": " public static void main(String[] args) {\\n        int[] arr ={1,1,2,3};\\n        int i=removeDuplicates(arr);\\n        System.out.println(Arrays.toString(arr)+\"  \"+ i);\\n    }\\njust assume there is nothing execpt declares required values to call given function and print answer"
                    },
                    {
                        "username": "suatozkaya",
                        "content": "[@aryanabraham](/aryanabraham) Hi, this is actually how object oriented programming is implemented. In a real project you do not see what is happening outside of your object. You must code in such a way that, your object should encapsulate the method and just work as expected like here."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "aryanabraham",
                        "content": "Hey ak_ghoul!\\nLeetCode doesn\\'t  let you view the main function; only the function that does the prescribed task is viewable/editable. This is reminiscent of the type of problems one gets in most technical interviews. \\n\\nHappy LeetCoding!"
                    }
                ]
            },
            {
                "id": 1574154,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1568596,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1574115,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1571066,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1769129,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1571065,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1845122,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1659297,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1576384,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1570551,
                "content": [
                    {
                        "username": "praveensbj8",
                        "content": "This is the javascript solution I tried which is correct but terminal showing wrong answer, Please help.\\n\\nSolution : [1,1,2].filter((n,i,nums) => nums.indexOf(n) === i).length;"
                    },
                    {
                        "username": "user5181l",
                        "content": "We need to return the same array. in filter and map function was create the new array of results so it will get the wrong answer.\nSo we can use foreach function or for function to get the correct ans."
                    },
                    {
                        "username": "kirti_9",
                        "content": "Because output should also return \\'_\\' underscore symbol as per the length of duplicates in it.\\nfor example: [ 1,1,2 ]\\nouput: [ 1,2,_ ]\\nhere we have 1 extra duplicate so need to return the underscore instead of that duplicate"
                    },
                    {
                        "username": "sameergaikwad222",
                        "content": "i tried this solution which gives me right ans but leetcode saying it is giving me wrong ans\\nreturn nums = [... new Set(nums)]; \\njust one liner code. :("
                    },
                    {
                        "username": "YogiKnight",
                        "content": "Same thing is happening to me but for the python version"
                    },
                    {
                        "username": "AksharGoyal",
                        "content": "Is the process broken? I am converting the nums to a set then a list again but it\\'s showing me something else\\n![image](https://assets.leetcode.com/users/images/a3130a38-5248-4d5d-9595-91eee80039de_1626070452.4349406.png)\\n"
                    },
                    {
                        "username": "anuraggupta29",
                        "content": "The description says \\'It doesn\\'t matter what you leave behind that length\\', but it is not accepting my python solution.\\nIt says you answer [1,2,None], expected answer [1,2]. Any Ideas?"
                    },
                    {
                        "username": "idklol8",
                        "content": "It looks like in this instance, you\\'re retuning 3 when it\\'s expecting a 2, so the grader is looking at the first 3 elements in the array."
                    },
                    {
                        "username": "rufengch",
                        "content": "Input: `[1, 1]`\\nExpected: `[1]`\\n\\nIsn't this wrong? \\n\\nIt says `It doesn't matter what you leave beyond the new length.`"
                    },
                    {
                        "username": "d4mir",
                        "content": "expected [1] with k = 1, elements after first elements don\\'t show up since they don\\'t matter"
                    },
                    {
                        "username": "sukelali",
                        "content": "Is there any way to reduce the O(n) of this solution ?\\n\\n    public class Solution {\\n        public int RemoveDuplicates(int[] nums) {\\n\\n            int insertIndex = 1;\\n\\n            for(int i = 1; i < nums.Length; i++)\\n            {\\n                if(nums[i-1] != nums[i])\\n                {\\n                    nums[insertIndex] = nums[i];\\n\\n                    insertIndex++;\\n                }\\n            }\\n\\n            return insertIndex;\\n\\n        }\\n    }"
                    },
                    {
                        "username": "KimFarida",
                        "content": "Use two pointers. Using a while loop, first initailze your stop to the end of the array and intialize i to zero. and k = i + 1. \\nYou should have while i < j and k < j .\\nSo youre checking nums[i] and the the value after it, nums[k]. If they are same, keep increasing k till they are not. else, in the case they are not, take the value of nums[k] and put it in nums[i + 1]. You can then increase i.\\nYou can now return i + 1\\n(which is the index of i plus one, being that i starts from 0)\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        j = len(nums)\\n        k = i + 1\\n\\n        while i < j and k < j:\\n            if nums[i] == nums[k]:\\n                k+=1\\n            else:\\n                nums[i+1] = nums[k]\\n                i += 1\\n        return i + 1\\nActually took me a while to get it. This is my second time solving this problem "
                    },
                    {
                        "username": "zhxlee",
                        "content": "why len(set(nums)) is wrong?"
                    },
                    {
                        "username": "sana479",
                        "content": "[@kBrostoff](/kBrostoff) I sorted nums then did len(set(nums)). It actually works perfectly on pycharm  "
                    },
                    {
                        "username": "Jvidal1997",
                        "content": "[@kBrostoff](/kBrostoff) No it doesn\\'t, but a set can\\'t contain duplicates. So the length of it returns the number of unique chars.\\n\\nThe problem here is it will return the integer effectively, but it doesn\\'t modify the list. Essentially the duplicates need to be pushed to the end before returning the number of unique characters."
                    },
                    {
                        "username": "kBrostoff",
                        "content": "Python\\'s `set` doesn\\'t maintain order."
                    },
                    {
                        "username": "FeYaroslava",
                        "content": "If you code fails even the first test in situation like\\nyou answer [1,2], expected answer [1,2] or similar:\\n\\n1. You must modify the array \"nums\" without overwriting the data to another variable.\\n2. Your code should use O(1) memory. \\n3. You must return the length of the sorted array (the number of unique digits in the array).\\n\\nI hope this helps."
                    },
                    {
                        "username": "Bobzero",
                        "content": "They should probably change the title for this question.. \\nAsking someone to remove duplicates and then tell him to return an integer value which will decide the correct length of the rearranged array is kind of cheating though..."
                    },
                    {
                        "username": "kallolmedhi24",
                        "content": "exactly\\n"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5ba3e386-b61c-4326-9c13-25ddea8f93db_1644804878.1030195.jpeg)\\n"
                    },
                    {
                        "username": "user7753pC",
                        "content": "![image](https://assets.leetcode.com/users/images/599daee3-6748-4ea4-89ec-3bf24d6e6684_1628841560.093207.png)\\n\\nHave anyone experienced leetcode behaves weirdly? \\nMy output is correct as per console.log but  seems they output is bit off\\n"
                    },
                    {
                        "username": "dinesh_kamani",
                        "content": "Actually as per my observation, You are not supposed to take new array as it is mentioned in the question, infact when you go with this approach u will get more than O(1) space complexity, which actually violates the given condition!!!"
                    }
                ]
            },
            {
                "id": 1569419,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1567171,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1958808,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1679856,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1570883,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1575906,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1573038,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1572752,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1967605,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1680066,
                "content": [
                    {
                        "username": "sbookworm",
                        "content": "When I using go to implement the solution, the expect result in the test case checking is an array, but the problem should return a int, What\\'s the matter?"
                    },
                    {
                        "username": "user3803Ce",
                        "content": "Your solution returns an int and the problem\\'s main function \\'cuts\\' array nums using your returned value, creating output array of new length (your returned value)"
                    },
                    {
                        "username": "zombieprocess",
                        "content": "The problem states:\\n\\n> Do not allocate extra space for another array, you must do this in\\n> place with constant memory.\\n\\nIsn't it true that the size of an Java array is fixed when you allocate it?   How can the requirement of not allocating extra space for another array in place with constant memory be satisfied?"
                    },
                    {
                        "username": "charlescolfer",
                        "content": " Do yourself a favor and read the comments from people who spent hours deciphering the hieroglyphics they left for us... \\n\\nClassic terrible Quality Control from Leetcode - the Description is simply incorrect and misleading. You will spend more time understanding what the English on screen is asking you to do, rather than the logic. "
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=aM4B1syX4sc)\\nhttps://www.youtube.com/watch?v=aM4B1syX4sc\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "dikshantgupta30",
                        "content": "Ok , so in this questions we need to calculate the length of the unique elements in the array and also update the array as per the length calculated.\\n\\nSuppose we have array [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] which is given in question .Now we need to first find the length of unique elements present in the array which is 5 . Now we need to update the array 5 times or the first 5 indices in such a way that we only got 5 unique elements on the first 5 indices in the array. \\n\\n**===>> So number of unique elements present in the array is the number of indices at which unique elements is present**"
                    },
                    {
                        "username": "wannaBeDarKnight",
                        "content": "![image](https://assets.leetcode.com/users/images/d1e30f3f-3fdf-47c4-a37a-c18666c418a3_1635576673.8389168.png)\\n"
                    },
                    {
                        "username": "CoderDes",
                        "content": "Have the same issue. In different environment there is a correct answer. How to handle that issue?"
                    },
                    {
                        "username": "joybhallaa",
                        "content": "I\\'m using sets in javascript, and it\\'s passing the test cases but the formatting of the output is different ! and that\\'s normal array behaviour ! smh "
                    },
                    {
                        "username": "ly2015CNTJ",
                        "content": "It\\'s a non-sence problem at all."
                    },
                    {
                        "username": "lasomu",
                        "content": "terrible problem description. I had to look at answer to figure out what the problem is."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "what a garbage! \n\n**misleading explained:**\n\n1.  You need to modiify the `nums`  list. Not reassign it or slice.  **Literally run a for-loop over it and use `.replace()`**\n2. Then you need to return an `int` instead of a `list`, a **number of unique elements** in `nums`. \n\nConclusion:\n\n**Worth your time?**  Not at all, instead of one item you need to return two. The one is displayed, the other one is hidden.\n**Check the solution?** Sure. Old Greek poem says, if there's a constant mismatch between your output and the expexcted result, you better check the solution. \n"
                    },
                    {
                        "username": "cjanowiak",
                        "content": "I missed the requirement to return k, returned nothing instead, and my submission was accepted for all test cases. Seems like the judge is not actually checking the return value of the function, just the values in the array after running it. (Python 3)"
                    }
                ]
            },
            {
                "id": 1841460,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1792941,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1573121,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1572293,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1574735,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 2056809,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 2054869,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1961019,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1954873,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1925134,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "I mean this question was obviously easy. The thing is how we implement it. I used swapping but swapping was not necessary at all. Just replace the repeating with next unique and greater one. so it took me around 15 min to solve which not good considering a easy problems. But why do people hate this question .I don\\'t know."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If I remove the for loop, it no longer works, despite the fact that the result it returns having nothing to do with the for loop. \"removeDuplicates=nums=>{\\n    let nums2 = Array.from(new Set(nums))\\n    console.log(nums2)\\n    const len = nums.length;\\n    for(i = 0; i < len - 1; i++) {\\n      if(i > nums.length - 1) {\\n        break;\\n      }\\n      if (nums[i] === nums[i + 1]) {\\n        nums.splice(i, 1);\\n        i--;\\n      }\\n    }\\n    console.log(nums)\\n    console.log(nums2.length)\\n    console.log(nums.length)\\n    return nums2.length\\n}\". If it\\'s so easy why don\\'t explain the question and why my code isn\\'t working?"
                    },
                    {
                        "username": "AmarilloSlim",
                        "content": "Hi everyone!\\n\\nI don\\'t understand, what  i must to return. When i return lenght of removed duplicates array, Leetcode raise error, that he expected to see array like [1,2,3], but when i retern array like [1,2,3] Leetcode raise error that i must return integer. Please explain me, what i must to return.\\nThanx."
                    },
                    {
                        "username": "roman-smal",
                        "content": "you should return a length of the array you\\'ve got. For example for\\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\\n\\nSo for JS you should return arr.length which is 5, whereas the input array \\'nums\\' should be mutated to [0,1,2,3,4]. I suppose for some other languages it should be changed into [0,1,2,3,4,_,_,_,_,_]. JL"
                    },
                    {
                        "username": "Manviel",
                        "content": "var myArray = [1, 2, 1];\\nlet unique = [...new Set(myArray)];\\n[1, 2]"
                    },
                    {
                        "username": "ozzymoron",
                        "content": "This doesn\\'t work because you created a new array. Requirement is O(1). Spread operator makes it O(n)"
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "same issue.\\nvar removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nnot sure why not working. "
                    },
                    {
                        "username": "rgonzalezp",
                        "content": "I know it actually works on tests cases, but most of the solutions I have seen here just replace the first values of the array and not actually remove duplicates, anyone agrees?"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tnums[:] = sorted(set(nums))\\n\\treturn len(nums)\\n\\n"
                    },
                    {
                        "username": "alinapenkina00",
                        "content": "Can't understand why my solution is wrong. It returns correct expected result in my IDE, but wrong in LeetCode compiler.\n```   \n     public int removeDuplicates(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            set.add(nums[I]);\n        }\n        return set.size();\n    }"
                    },
                    {
                        "username": "isydor",
                        "content": "you must remove the duplicates in-place - means changing the nums itself not creating a new variable."
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "Having the same issue"
                    },
                    {
                        "username": "madhav_varshney",
                        "content": "I think there is something wrong with the Leetcode\\'s editor. \\n```\\nvar removeDuplicates = function(nums) {\\n    nums = [...new Set(nums)];\\n    return nums.length;\\n};\\n```\\nThis code giving me correct answer on other online editor but here I am getting wrong answer.\\n\\nAnyone facing same?"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "The question description is not correct, they want you to place the unique elements at the front of the array and place the duplicate ones at the end (no matter in what order). And they want you to return the length of uniquely placed elements only!"
                    },
                    {
                        "username": "Saad03",
                        "content": "\\n      \\nguys can someone tell me where i went wrong. code works fine in jupyter notebook but having errors here\\n\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        nums=set(nums)\\n        nums= list(nums)\\n        return nums\\n"
                    },
                    {
                        "username": "ganesh009",
                        "content": "why this is failing?\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        x= set(nums)\\n        nums = list(x)\\n        return len(nums)"
                    }
                ]
            },
            {
                "id": 1921026,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1898524,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1896297,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1872980,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1865447,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1865315,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1862334,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1830708,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1827130,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1827119,
                "content": [
                    {
                        "username": "cubo142",
                        "content": "lmao 15k downvote aigh imma head out"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "It works on my IDE."
                    },
                    {
                        "username": "user1751JL",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n       \\n        nums = [0,0,1,1,1,2,2,3,3,4]\\n        nums=set(nums)\\n        nums=list(nums)\\n        nums=sorted(nums)\\n\\n        return len(nums)\\n\\nwhy this is wrong"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to modify it in place.\\n2. Why are you using a class?"
                    },
                    {
                        "username": "alphazwest",
                        "content": "Am I the only one that thinks \"non-decreasing order\" is a really strange way to say \"increasing\" or \"ascending\" order?"
                    },
                    {
                        "username": "varunnn_23",
                        "content": "keep in mind no duplicate array can be formed"
                    },
                    {
                        "username": "Aarushi_Jain___",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a=[]\\n        for i in nums:\\n            if i not in a:\\n                a.append(i)\\n        nums=a.copy()\\n        k=len(nums)\\n        \\n        return k \\n\\nThis code is giving right answer in other compiler but leetcode is not accepting it...can someone please explain why"
                    },
                    {
                        "username": "rasam1102",
                        "content": "Don\\'t use extra arrays/lists\\nMake changes to nu,s itself"
                    },
                    {
                        "username": "rasam1102",
                        "content": "`remove the duplicates in-place such that each unique element appears only once.`\\nAll those having an issue with the solution, they have clearly said that we have to make changes to the passed array i.e. `nums` itself and then just return the len(nums)"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "Why is this always go wrong?\\nMy program have no problem when I test in my lapto\\n\\nInput nums =[1,1,2]\\nOutput:[1]\\nExpected:[1,2]\\n\\n  int removeDuplicates(vector<int>& nums) {\\n        int count=0;\\n        for(int a=1;a<nums.size();a++)\\n            while(nums[a]==nums[a-1]&&a<nums.size())\\n                nums.erase(nums.begin()+a),count++;\\n        return count;\\n    }\\n\\n"
                    },
                    {
                        "username": "Chenga88",
                        "content": "same for me"
                    },
                    {
                        "username": "tunebaker",
                        "content": "the same result (("
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var removeDuplicates = function(nums) {\\n    //remove the duplicates\\n\\n    nums = [...new Set(nums)]\\n    console.log(nums)\\n    return nums\\n    //return new arr length and the arr\\n};\\n\\ni wrote these code but it always returns an empty array, can someone tell me why?"
                    },
                    {
                        "username": "jakecatron",
                        "content": "I have the same question. This is was my solutions as well."
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "\\n    arr = [...new Set(nums)]\\n    console.log(arr)\\n    return arr\\n};\\n\\nwhy this is not working , i tried on other console and it return the right value but in leet code it returns a empty array"
                    }
                ]
            },
            {
                "id": 1799999,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1750886,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1749407,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1742039,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1740931,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1575627,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1573270,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1573111,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1573068,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1572448,
                "content": [
                    {
                        "username": "toygrr",
                        "content": "I tried solving this using the new Set method to remove duplicate keys, and then convert that into an array.  This does not work for what ever reason, but in my IDE it pops out a correct solution.\\n\\nDoes this have something to do with the version of JavaScript that leetcode uses?"
                    },
                    {
                        "username": "toygrr",
                        "content": "[@idklol8](/idklol8) I see, I\\'ll try a different approach, thanks!"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from within the array without creating a new array. They\\'re checking the array that was passed into the RemoveDuplicates method for the results."
                    },
                    {
                        "username": "samrocksc",
                        "content": "Modifying a param in Javascript is probably the worst thing you could do in production..."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why the test case [1] is giving me Run Time Error.\\nMy code is as follows\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        while(j < n){\\n            nums[i++] = nums[j];\\n            while(j < n && nums[j] == nums[j+1]) j++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "yannicklescure",
                        "content": "This problem is completely bugged from the instructions to the run! \\uD83E\\uDD2E\\nJavascript doesn\\'t accept the return !!! WTF"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "The thing is that you need to mutate the original array instead of returning the new one. This is the most tricky part that creates confusion in this task. And the return has to be just the number until which tests should check the original array that was provided as an input. I hope that helps "
                    },
                    {
                        "username": "deezyto",
                        "content": "You can run a loop and if the number is repeated, remove it from the array using the splice method, then do i-- (not the best js solution but it works);"
                    },
                    {
                        "username": "Preposterone",
                        "content": "I hated this problem."
                    },
                    {
                        "username": "nmehrotra",
                        "content": "Why this question has so many dislikes ? Almost double the likes ."
                    },
                    {
                        "username": "mrpiggy97",
                        "content": "my guess is that the description is way too complicated for what it really asks"
                    },
                    {
                        "username": "dball1126",
                        "content": "Someone from Leetcode needs to fix this problem, the test cases are broken in Ruby\\nRemove Duplicates from Sorted Array\\n\\nSubmission Detail\\n0 / 161 test cases passed.\\nStatus: Runtime Error\\nSubmitted: 1 minute ago\\nRuntime Error Message:\\nLine 55: no implicit conversion of Integer into Array (TypeError) in serializer__.rb (-)\\nLast executed input:\\n[1,1,2]\\nSubmitted Code: 1 minute ago\\n\\nLanguage: ruby  Edit Code  \\n\\n\\nMy code is correct, not to mention the method doesn\\'t even run with just returning NUMS"
                    },
                    {
                        "username": "kymed",
                        "content": "Like they don\\'t actually ever delete an element?? But it says delete in place??"
                    },
                    {
                        "username": "hrneet",
                        "content": "return [...new Set(nums)].length;"
                    },
                    {
                        "username": "yorkshire",
                        "content": "Even though the question requies that the changes are in-place, the judge does not check this (in Python).\\n\\nI can move the unique elements to the front, then append random numbers to the array (actually a list) or delete the junk at the end and it doesn\\'t matter. The judge only checks the array up to the required length.\\n\\nIf there is a requirement in the question, it should be tested in the judge!"
                    }
                ]
            },
            {
                "id": 1571890,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 1571067,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 1568846,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 1572387,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 1571862,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 1571068,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 2076885,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 2074625,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 2070393,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 2069158,
                "content": [
                    {
                        "username": "FlorianFang",
                        "content": "why the return value is \"int\" but the answer is \"int[]\" ??"
                    },
                    {
                        "username": "agreatlord",
                        "content": "auto u = unique(nums.begin(), nums.end());\\nnums.erase(u, nums.end());\\nreturn nums.size();"
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "I got this error:\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[2]\\nExpected:\\t[1,2]\\n\\nBut as the question requests, we are required to return the new length, not the new array, so why the OJ says \"expected [1,2]\" ?"
                    },
                    {
                        "username": "klona926",
                        "content": "def dmove_duplication(nums):\\n    print(list(set(nums)))\\nremove_duplication([1,1,2])\\nremove_duplication([0,0,1,1,1,2,2,3,3,4])"
                    },
                    {
                        "username": "zorndyuke",
                        "content": "I think there is a bug in the Javascript Check.\n\nAs far as I understood, the function should remove duplicates and return the length of the filtered Array.\n\nSo as you can see in the stdout the filtered Array contains the correct, non-duplicate values and the length is 2 like the example says too. But what I don't understand is the \"Your/Expected answer\" section. The description says it want the length as number (also the docblock says it), but why the \"answers\" have the array output format? Also where does it get the [1,1] result? \n\nEither I missunderstand something important or it's just buggy.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)\n(Url to image: https://s3-lc-upload.s3.amazonaws.com/users/zorndyuke/image_1519379846.png)"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "In-place modification is expected from you, if you try to create a separate array, then all the distinct elements will be in your auxiliary array, but the original array sill holds all the elements in the same order as it was before. Leetcode is checking order of elements in your original array, not in your auxiliary array! So try to modify original one!\\n\\nAlso, don\\'t remove the duplicates from the array, just shift them at the end of the array (order doesn\\'t matter for duplicate elements). In the end, return the count that represents, how many distinct elements you shifted to the front of the array!"
                    },
                    {
                        "username": "pandora111",
                        "content": "in removing duplicate, how do I delete an element from int [] in Java?"
                    },
                    {
                        "username": "ksiv",
                        "content": "we don\\'t, just move these. That is for \"K\" it\\'s a length of elements to read from the beginning, the rest just ignored."
                    },
                    {
                        "username": "michalhodulofficial",
                        "content": "LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();\n        for(int i = 0;i<nums.length;i++){\n            linkedHashSet.add(nums[i]);\n        }\n        return linkedHashSet.size();\n\nwhy this doenst work guys ? LinkedHashSet adding just unique numbers and then in return is .size() how much of these records is in hasset,in idea everything work"
                    },
                    {
                        "username": "Elsone",
                        "content": "This question is weird and so confusing. I\\'ve managed to get the right answer. you have to modify nums itself.  "
                    },
                    {
                        "username": "SasonBraha",
                        "content": "This questions is terribly worded. "
                    },
                    {
                        "username": "lukeASB",
                        "content": "The phrasing of this question is dumb. \n\nThe question should just say sort the distinct values in the front of the array and return the length.\n\n"
                    }
                ]
            },
            {
                "id": 2068812,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2068810,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2068569,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2067662,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2065913,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2065909,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2058050,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2057671,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2057431,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2054865,
                "content": [
                    {
                        "username": "6CRIPT",
                        "content": "I dont get why if nums size does not matter why then  `return len(list(set(nums)))` does not work as expected :/"
                    },
                    {
                        "username": "6CRIPT",
                        "content": "I dont get that if the size of nums is not important (the problem says) why  `return len(list(set(nums)))` does not work as expected."
                    },
                    {
                        "username": "Ram33code",
                        "content": "\n    let b = [];\n    for(i=0;i<nums.length;i++)\n    {\n        if(b.indexOf(nums[i]) == -1)\n        {\n            b.push(nums[i]);\n        }\n    }\n    return b;\n\n\nWhy does this code doesn't work ?? Can anyone explain ? tried returning b.length as well. This doesn't  work .."
                    },
                    {
                        "username": "SoftwareDevOne",
                        "content": "This is one of the worse coding challenges in leetcode. It is not known exactly what they are asking for. I have tried to return the size of the array that is ordered... I have tried to return the ordered array but without modifying its size, I have tried to return multiple things guessing what they are asking for. Nothing works. it\\'s awful."
                    },
                    {
                        "username": "njtan142",
                        "content": "So you actually need to return the length of sorted array and then manipulate the nums array itself. Could have been specified but they didn\\'t, which lead to a lot of confusion. A HUGE downvote for me"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "ah yes gotta love my non decreasing order arrays"
                    },
                    {
                        "username": "matiasbett22",
                        "content": "I\\'m trying to use Linq to solve this but it doesnt work, anyone has any idea why?"
                    },
                    {
                        "username": "user9133dZ",
                        "content": "hey guys , i am getting output as [1,2,\\'_\\'] what should i do to fix it. i am using python"
                    },
                    {
                        "username": "tamnguyen79685",
                        "content": "uhm runtime error @@"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I like this, it tests your ability to read and meet real world unit tests that are given to you, much better than all the math problems that plague this site :) I think it's one of the best problems on leetcode, its a more realistic test you could give an interview candidate with a unit test sat beside it."
                    }
                ]
            },
            {
                "id": 2053665,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2049758,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2049457,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2049192,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2048461,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2046665,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2045707,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2045450,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2045055,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2043738,
                "content": [
                    {
                        "username": "sivaunaccepting",
                        "content": "why no one talking about usage of hash set for this question?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "How to replace your duplicated numbers with a character in TypeScript while the array has number type?"
                    },
                    {
                        "username": "harishonfire2000",
                        "content": "can anyone explain why this is not working\\n `var removeDuplicates = function(nums) {\\n    var i= Math.max(...nums)\\n     var a= Math.min(...nums)\\n      var arr=[]\\n     for(var j=a;j<=i;j++){\\n        arr.push(j)\\n     }\\n     \\n   return arr\\n};`"
                    },
                    {
                        "username": "lostghost",
                        "content": "Why the hell is this invalid?\\nInput\\n`[0,0,1,1,1,2,2,3,3,4]`\\nOutput\\n`[0,1,2,3,4,2,2,3,3,4]`\\nExpected\\n`[0,1,2,3,4]`"
                    },
                    {
                        "username": "JWPB",
                        "content": "Can someone tell me, why I can\\'t use here a Python `set` function? It takes care of duplicates automatically, but here it doesn\\'t work. I don\\'t understand."
                    },
                    {
                        "username": "chernosmaga",
                        "content": "I don\\'t get it. They want me to get [1,2] and I got it in IDEA okay, but the output here is [1,1]. How does this even work?"
                    },
                    {
                        "username": "user6593XG",
                        "content": "Question: Could you in theory transform the array into a set and then back?\\n"
                    },
                    {
                        "username": "satardekaraary47",
                        "content": "Hello Guys \\nI don\\'t solve this problem using DSA as I don\\'t study the DSA part yet. I solve this with basics using only loops and if. \\nWe just have to check weather two adjacent numbers are dissimilar or not. if they are dissimilar then we stored the number in new array at 0th position and increase its index. if they are similar then we just iterate the loop until it satisfies the condition. The range in which the condition don\\'t satisfied is the range where numbers are similar. And after total iteration of loops we just stored the last number in the new array . Also to count unique number just count it in the if statement and print at the last."
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "where am i wrong ?\\n\\n\\n public class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        // ArrayList duplicateNums = new ArrayList();\\n\\n        \\n\\n        List<int> result = new List<int>();\\n\\n        // duplicateNums.Add(nums[0]);\\n\\n        int[] duplicateNums = new int[100];\\n        duplicateNums[0] = (nums[0]);\\n        result.Add(nums[0]);\\n        for(int i = 1; i< nums.Length; i++) {\\n            Console.WriteLine(\"Value \" + i + \" \" + nums[i]);\\n            if(!Array.Exists(duplicateNums, e => e ==  nums[i] )) {\\n                Console.WriteLine(\"In exist \"  + nums[i]);\\n                duplicateNums[i] = (nums[i]);\\n                result.Add(nums[i]);\\n            }\\n        }\\n\\n        Console.WriteLine(\"Length is\"+ result.Count);\\n\\n        return result.Count;\\n    }\\n}"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "Here are a few issues in your code:\\n\\nArray Index: You are setting duplicateNums[i] = nums[i];. This will overwrite some elements in the duplicateNums array which should not be the case.\\n\\nArray Initialization: You have initialized duplicateNums as an array of length 100 filled with zeros. This will cause problems if the number 0 exists in the original array.\\n\\nEfficiency: Using Array.Exists() in each iteration would make the code O(n^2), where n is the length of the array."
                    },
                    {
                        "username": "talekarss123",
                        "content": "review the test cases for javascript program, workable program isn\\'t accepting.\\nYou don\\'t decide the approach of code "
                    }
                ]
            },
            {
                "id": 2043616,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2043077,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2037306,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2036620,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2036381,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2033637,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2033196,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2031717,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2029088,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2028520,
                "content": [
                    {
                        "username": "Rich_Lin",
                        "content": "I\\'ve came through some questions including this, that the answer is not the answer.\\nI did everything right but it\\'ll somehow says I\\'m wrong.\\nAfter checking other\\'s answer........I\\'m so confused, like, the output in the description and the actual output they want are different.\\nLike.......what the hell\\nAm i the only one got confused and trying for hours just to realize that?"
                    },
                    {
                        "username": "arsen172317",
                        "content": "guys just remove duplicates and return nums.length"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "they want us to return the size of array in integer but in output the result is in array , what to do?"
                    },
                    {
                        "username": "munnakumar5461",
                        "content": "There is no problem in the given question.\\nyou need to work on in-place array.\\njust remove the unwanted element from the resulted  nums array.\\nit should work."
                    },
                    {
                        "username": "kumarsatish876",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] a) {\\n        int max=a[0];\\n        int j=1;\\n        for(int i=1;i<a.length;i++)\\n        {\\n            if(max<a[i])\\n            {\\n                a[j]=a[i];\\n                j++;\\n                max=a[i];\\n            }\\n        }\\n        return j;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lomag123",
                        "content": "No need to waste your time with this one, skip this sh*tty problem. It is even better to do one push-up than wasting your time with this one. "
                    },
                    {
                        "username": "anikethreddy",
                        "content": "I tried using another variable to get the solution and then assign it to nums but it did not work but when I rearranged nums the code was executed. Any idea on why ?\\nI did try making nums global "
                    },
                    {
                        "username": "AlexandreD13",
                        "content": "Shitty question. Then everyone on the internet says, \"hEre Are the 250 lEEtcOde quEstIons I pracTicEd for mY Google IntervIEw\"."
                    },
                    {
                        "username": "cblakely",
                        "content": "Another terrible question written by an idiot."
                    },
                    {
                        "username": "pratikftw",
                        "content": "Time Wasted . checking my code over and over again but cant figure out that stdout is giving different value and output throwing another value that doesn\\'t even match the expected answer."
                    }
                ]
            },
            {
                "id": 2027697,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2027601,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2019965,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2018686,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2014967,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2014485,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2013979,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2013916,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2013795,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2013355,
                "content": [
                    {
                        "username": "HomieOhmie",
                        "content": "Man, the wording of this problem and the weird error message that pops up on wrong answer to the testcase made this one quite difficult.\\n\\nThe error message \\'TypeError: # is not valid value for the expected return type integer[]\\' only tells you that the obtained nums list, cut by the number of unique elements, is wrong.\\n\\nIt\\'s easy to notice what the error implies if you check the values in the debugger,if you check what you will return, or if you print the values of nums yourself on a small instance of the problem."
                    },
                    {
                        "username": "jglopes91",
                        "content": "Completely confusing question..."
                    },
                    {
                        "username": "u37445",
                        "content": "\"It does not matter what you leave beyond the returned k (hence they are underscores).\"\\n\\nWrong Answer\\nInput: nums =[1,1,2]\\nOutput: [1,2,2]\\nExpected: [1,2]\\n\\n\\nhmmmmmm..........................."
                    },
                    {
                        "username": "the_bobba",
                        "content": "Problems with 50%+ downvotes should be removed..."
                    },
                    {
                        "username": "vinod95359199",
                        "content": "where i did mistake \\n\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<=nums.length-1;++i)\\n        {\\n            for(int j=i+1;j<=nums.length-1;++j)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    \\n                    continue;\\n                }\\n                else{\\n                    count+=nums[i];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Promit_11",
                        "content": "For a question, there is two answers:\n1st one:\nclass Solution:\n def removeDuplicates(self, nums: list[int]) -> int:\n        new = []\n        for i in nums:\n            if i not in new:\n                new.append(i)\n        result = len(nums) - len(new)\n        return result\n2nd One:\nclass Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        j = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[j] = nums[i]\n                 j += 1\n         return j\nBoth codes is giving the same answers. But Leet Code is accepting only 2nd one. For the first one, it is showing the wrong output. If anyone knows, why this is happening please let me know. \nLeet code problem number 26. Remove Duplicates from Sorted Array.\n#Avoid_indentations"
                    },
                    {
                        "username": "Justus7827",
                        "content": "My solution works in Visual Studio but doesn\\'t work the same in leetcode. I pass 17 testcases and get stuck on [ 1, 1, 2 ]. My code in VS removes the duplicate 1 so the array is now [ 1, 2 ] and also returns the correct count for \"k\". However, when I run the solution on here, it says my output was [ 1, 1 ]. Why does it do this?"
                    },
                    {
                        "username": "anvar__cool",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums = list(set(nums))\\n        return len(nums)\\nWhy it\\'s not working? I tried this code in jupyter notebook and it\\'s working, but here it doesn\\'t even change the nums, although if i print nums inside this method, stdout gives correct answer..."
                    },
                    {
                        "username": "n4pw01f",
                        "content": "They want you to move the elements in place for some reason, Set, etc won\\'t work. You have to basically move the elements"
                    },
                    {
                        "username": "ansh_2001",
                        "content": "Just return the number of distinct elements in the array and shift all the distinct elements to the front of array  in ascending order."
                    },
                    {
                        "username": "varshini-S",
                        "content": "why cant we use set over here? can anyone give me a valid reason or did I took the question wrong?\\nSet<Integer> set = new HashSet<>();\\n    for(int i : nums)\\n        set.add(i);\\n    return set.size();"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "ansh_2001",
                        "content": "You can use set here as i also used it in my solution and it cleared all the test cases."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "You don't have to return uniques in `nums`!!!, the catch here is you have to Change the array `nums` such that the first `k` elements of nums contain the unique elements, and then return `k` (number of uniques in `nums`) only!!!\n**Custom Judge** will check first 'K' elements in `nums` to grade your solution!!"
                    }
                ]
            },
            {
                "id": 2011307,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2010196,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2009504,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2008496,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2008402,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2007365,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2007269,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2004835,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2004335,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 2000336,
                "content": [
                    {
                        "username": "NoobCoder1231231231",
                        "content": "Why can\\'t we just create a new list and name it nums?\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@ksiv](/ksiv) Thank you"
                    },
                    {
                        "username": "ksiv",
                        "content": "I think it comes from here \"remove the duplicates in-place \""
                    },
                    {
                        "username": "darthnithin",
                        "content": "So i'm looping backwards through the nums list. My question is why does it take 20 times longer when i do \n `nums.remove(number)`\ninstead of\n`nums[i]`\n\nEdit: I figured it out i think: `remove` searches the list to find the element"
                    },
                    {
                        "username": "n4pw01f",
                        "content": "Horribly worded question"
                    },
                    {
                        "username": "jmiah717",
                        "content": "This is bugged. I keep getting errors on my output being [] when in the debugger it clearly shows my nums string is not empty. Whatever testing you are doing behind the scenes is slicing my array and thus causing the result to be invalid, when it is in fact, a valid entry. I even modified for a single number in the list when I shouldn\\'t have had to for the same reason. \\n"
                    },
                    {
                        "username": "ksiv",
                        "content": "// My solution does not work here:\n \nclass Solution {\n    public  int removeDuplicates(int[] nums) {\n        List<Integer> list = IntStream.of(nums).distinct().boxed().collect(Collectors.toList());\n        nums = list.stream().mapToInt(j->j).toArray();\n\n        return list.size();\n    }\n}\n\n\n/*\nSays output is [1,1]. meaning built-in distinct did not work well. I tried to see what Jave they use System.getProperty(\"java.version\") - but it's not available (unlike GFG).\nWorks fine locally on jdk-11.0.12.7-hotspot */\n\n// p.s. i'm trying to make this commet look as buggy. For some reason the return section is treated as a piece of code :-)"
                    },
                    {
                        "username": "talmeezfaizy",
                        "content": "Question is not clearly explained but by analysing the output I could assess the requirement. \\nYou have to return the integer value of number of unique elements.\\nMain function which is not visible but I could assess from the solution, takes that integer (assume it to be k) and print  first k elements of the nums array which is the final expected output. \\n\\nAs it prints the elements of nums array, hence creating a new array is of no use, because we have to modify the nums array. \\n\\nOne thing is surprising that first I created a different array and assigned it to the nums, but that solution didn\\'t work. So somewhere there is a check which wants us to maintain the space complexity of O(1) and hence modify the nums array itself while traversing it. \\n\\n\\nI can share the logic for it, if someone needs it. "
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "problem is easy, but this description makes its difficult. terribly described. could be written in simple words"
                    },
                    {
                        "username": "DIVYARAJSINH2906",
                        "content": "For this problem when I run my code in intellij that time it's gives me the same output as given in example but I am getting wrong answer anybody can tell me what is happening?\n\n//if length is 1 or 0 it returns same number\nif(nums.length==0 || nums.length==1){\n            return nums.length;\n        }\n        int[] arr=new int[nums.length];\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            while(i<nums.length-1 && nums[i]==nums[i+1]){\n                //just move the nums index to ahead\n                i++;\n            }\n            //after loop end assign the value of last nums index to arr index\n            arr[index]=nums[i];\n            index++;\n        }\n        return index; "
                    },
                    {
                        "username": "JL1172",
                        "content": "why does this not work ? \\nvar removeDuplicates = function(nums) {\\n   let result = [];\\nfor (let i in nums) {\\n    if (result.indexOf(nums[i]) === -1) {\\n        result.push(nums[i]);\\n    }\\n}\\nreturn result;\\n};\\nIt feels like its super simple and when I console.log the result it works just fine and I get a new array with no duplicates. When i return the result It shows up as an empty array. What am I not getting?"
                    },
                    {
                        "username": "stevemcguigan",
                        "content": "Re-read the description. Return the number of elements after de-dupe, not an array"
                    },
                    {
                        "username": "KRATOS_23",
                        "content": "Im so confused. Why cant we just make a HashSet and return its size? What are we doing here?"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "actually you need to modify `nums` aswell, when you return `k`, the `Custom Judge` will check the first `K` elements of `nums` and compare it with the correct output!!"
                    }
                ]
            },
            {
                "id": 1999858,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1998835,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1998649,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1995945,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1994842,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1987838,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1985541,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1978963,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1978531,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1975645,
                "content": [
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Simple Iterative Approach with Detailed Explanation , time: $$O(n)$$, space: $$O(1)$$\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3862998/simple-iterative-o-n-approach-beats-99-9-runtime/"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "The catch here is that you have to filter duplicate and update in the existing array with same memory location."
                    },
                    {
                        "username": "WonderMilk",
                        "content": "I\\'m having some issues here. Not the best at programing, but I could have sworn that the \"nums\" list would be mutable. What I ended up doing in my code was attempting to create a set of the contents from \"nums\", since a set cannot contain duplicates, and then setting \"nums\" equal to the set I created. \\n\\nThe \"Stdout\" when I run the code shows that \"nums\" does indeed get set to a list with no duplicates inside of it, but the output seems to indicate that the \"nums\" list does not actually become altered outside of the function like I thought it would."
                    },
                    {
                        "username": "Nikaspar",
                        "content": "Omg. How I can return len(nums) == 4 if input len(nums) == 10 and They don\\'t really want you to remove the duplicates. Madman\\'s delirium!"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "It\\'s less common to manipulate arrays in-place because modern computers have large amounts of memory and the cost of creating a new array is typically not prohibitive. Additionally, most high-level languages provide built-in functions for removing duplicates from an array or list. The problem requires in-place modification of the array, which goes against the principles of functional programming - so that\\'s not an option. Also, the problem does not specify what should be done in the case of an empty array. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Interesting answer for an interview :)"
                    },
                    {
                        "username": "ycwiz",
                        "content": "they want you to return the number of unique integers . and when you do make changes to the original list of integers make changes as you find unique numbers"
                    },
                    {
                        "username": "prashantverma1357",
                        "content": "pls help me out on this i dont get where im going wrong this was supposed to be so simple T_T\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        le1 = len(nums)\\n        nums = list(set(nums))\\n        le2 = len(nums)\\n        for i in range(le1-le2):\\n            nums.append(\"_\")\\n        return le2\\nim converting the initial list nums into a set then back into a list for appending\\nthe output for list(set([1,1,2]))  should be 1,2 why is it showing 1,1 even if it slices the inital list at the value we are providing ive changed the initial list to have only the unique elements i cant figure this out\\n \\n\\n"
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "        SortedSet<int> temp = new SortedSet<int>(nums);\\n        nums = null;\\n        nums = temp.ToArray();\\n        return temp.Count;\\n\\ndon\\'t worck? "
                    },
                    {
                        "username": "ShadowGreg",
                        "content": "[@Souvik-223](/Souvik-223)  in C#"
                    },
                    {
                        "username": "Souvik-223",
                        "content": "Is it in python? "
                    },
                    {
                        "username": "Souvik-223",
                        "content": "I have uploaded a detailed solution for this confusing problem. The question isn't properly explained here and it might confuse a lot of people. \nCheck out the answer with the explanation and the easiest solution here :- https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3792140/best-solution-in-java-with-1ms-43-89mb-and-proper-explanation-of-the-question/\n\nHope this helps in everyones learning."
                    },
                    {
                        "username": "sangam_verma",
                        "content": "why this ques got more dislikes than likes? \\uD83E\\uDDD0"
                    }
                ]
            },
            {
                "id": 1975448,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1974200,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1973622,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1972787,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1970475,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1970318,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1969214,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1968286,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1966390,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1963833,
                "content": [
                    {
                        "username": "upendra_allagadda",
                        "content": "The example and description confuses you. According to the explanation, the assertion should be stopped by the length of k but it is not."
                    },
                    {
                        "username": "croegen",
                        "content": "I am confused with allmost all proposed solutions. I firstly solved the issue myself but got triggered by realy low score I get. \\nSo most of quickest solutions propose to iterate through array by checking the two elements next to each other.\\nLets say we have const arr = [1, 2, 3, 4, 4, 5, 6];\\nWe itarate to 4th element and then assign arr[4]=arr[5]\\n[1, 2, 3, 4, 5, 5, 6]\\nThen we assign arr[5]=arr[6]\\n[1, 2, 3, 4, 5, 6, 6]\\nOkay, great, how do you remove the last element? Non of solutions have the condition to remove those duplicates from the end, by copying the elements in array we still have the same length? What am I missing here?"
                    },
                    {
                        "username": "croegen",
                        "content": "[@svenyboyyt](/svenyboyyt) Yeah, I got it now, I totally missed the part about truncation of leftovers from array after all iterations before returning of the k."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "If you have n unique elements, the first n elements need to be unique. You don\\'t have to remove the duplicates because it\\'s not in the first n elements, but you can. And then you have to return the length."
                    },
                    {
                        "username": "croegen",
                        "content": "I get it, I missed the part about truncation of leftovers from array after all iterations."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "can i use set?"
                    },
                    {
                        "username": "DenisKutlubaev",
                        "content": "This is one of the best coding problems with a beautiful concise solution. I solved it, but my solution was not this elegant."
                    },
                    {
                        "username": "jw52sc",
                        "content": "Spend almost 1 day to to get different pattern of the solution. But eventually, I believe the question got bug. Till now, I still not able to pass but I get exactly what i want based on my understanding. "
                    },
                    {
                        "username": "Darw",
                        "content": "What should I to return? An integer or an array?"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "integer obviously\\n"
                    },
                    {
                        "username": "Grumpy_Tucker3",
                        "content": "Its a medium level question\\n"
                    },
                    {
                        "username": "ivstefanov",
                        "content": "C++\\n\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <set>\\n\\nstd::pair<std::vector<int>, int> removeDuplicates(const std::vector<int>& nums) {\\n    std::set<int> uniqueNumbers(nums.begin(), nums.end());\\n    std::vector<int> result(uniqueNumbers.begin(), uniqueNumbers.end());\\n    int numDuplicatesDeleted = nums.size() - result.size();\\n    return std::make_pair(result, numDuplicatesDeleted);\\n}\\n\\nint main() {\\n    std::vector<int> nums;\\n    std::vector<int> uniqueNumbers;\\n    int nDuplicatesDeleted = 0;\\n    int nSize = 0;\\n    int temp = 0;\\n    std::cout << \"How many numbers would you insert: \";\\n    std::cin >> nSize;\\n\\n    std::cout << \"\\\\n---Filling the vector---\" << std::endl;\\n    for (int i = 0; i < nSize; i++) {\\n        std::cout << \"Insert number #\" << i + 1 << \": \";\\n        std::cin >> temp;\\n        nums.push_back(temp);\\n    }\\n\\n    std::cout << \"\\\\n---Input vector---\\\\n[ \";\\n    for (int e : nums) {\\n        std::cout << e << \", \";\\n    }\\n    std::cout << \"\\\\b\\\\b ]\" << std::endl;\\n\\n    // Sort input vector\\n    std::sort(nums.begin(), nums.end());\\n\\n    // Delete duplicates\\n    std::pair<std::vector<int>, int> result = removeDuplicates(nums);\\n    uniqueNumbers = result.first;\\n    nDuplicatesDeleted = result.second;\\n\\n    std::cout << \"\\\\n---Output vector---\\\\n[ \";\\n    for (int i = 0; i < uniqueNumbers.size(); i++) {\\n        std::cout << uniqueNumbers[i];\\n        if (i != uniqueNumbers.size() - 1) {\\n            std::cout << \", \";\\n        }\\n    }\\n    for (int i = 0; i < nDuplicatesDeleted; i++) {\\n        std::cout << \", _\";\\n    }\\n    std::cout << \" ]\" << std::endl;\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "How smart you are!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "gcode_it",
                        "content": "my output is correct in IDLE. Yet error here\\n `def removeDuplicates(nums):\\n        \\n       d = {n:0 for n in nums}\\n        arr = [key for key in  d.keys()]\\n        count = len(arr)\\n        for i in range(len(arr), len(nums)):\\n            nums[i] = \\'_\\'\\n            arr.append(nums[i])\\n        \\n        return \\'{}, nums = {}\\'.format(count, arr)`\\n\\n"
                    },
                    {
                        "username": "vladd55k",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        alreadyExist = []\\n        for i in range(len(nums)):\\n            if nums[i] in alreadyExist:\\n                nums[i] = \\'*\\'\\n            else:\\n                alreadyExist.append(nums[i])\\n                k += 1\\n        for item in nums:\\n            if item == \\'*\\':\\n                nums.remove(item)     \\n        return k\\n\\n\\nWhy this thing runs into error? Why this test program say to me that 5 isn`t an integer?"
                    }
                ]
            },
            {
                "id": 1962687,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1960216,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1959695,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1958957,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1958877,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1954555,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1953074,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1951826,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1951575,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1949986,
                "content": [
                    {
                        "username": "tarunaf07",
                        "content": "can someone explain what is wrong with the my java code?\\nit runs fine on my local IDE\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]>nums[i]){\\n                i=j-1;\\n                break;\\n            }\\n        }\\n        list.add(nums[i]);\\n    }\\n    return list.size();\\n    }\\n}"
                    },
                    {
                        "username": "LokeshGl",
                        "content": "I think you are not modifying nums array, but appending it to some other list. The question wants you to manipulate the array in-place. And return the no. of modified elements."
                    },
                    {
                        "username": "SwiftSkilz",
                        "content": "They are not letting me return an array."
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is solution ,\\nhacker ? please fix it and band account them \\n\\nf=open(\"user.out\",\\'w\\')\\nfor l in stdin:\\n    nums = list(set(map(int,l.rstrip()[1:-1].split(\\',\\'))))\\n    for num in nums:\\n        while nums.count(num)>1:nums.remove(num)\\n    nums.sort()\\n    print(str(nums).replace(\\' \\',\\'\\'),file=f)\\nexit()"
                    },
                    {
                        "username": "imran26_96",
                        "content": "Hey Everyone nice to join a new journey with coding please give me some reference to learn and grow thank you :)"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "EXPLANATION: You need to modify the array in place and not assign it to a new array. Then you have to return its length "
                    },
                    {
                        "username": "adityadewhy",
                        "content": "absolute horrible description"
                    },
                    {
                        "username": "skreabin55",
                        "content": "class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        result = []\n        for i in nums:\n            if i not in result:\n                result.append(i)\n\n        return len(result)\n\nwhy is it not working?"
                    },
                    {
                        "username": "Danylo16",
                        "content": "If im not mistaken, there is no need to change an array. You can just make counter. Am i right?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "No. You need to modify the array and return its length."
                    },
                    {
                        "username": "Shahidzbi4213",
                        "content": "what\\'s wrong with that approach?  \\n\\n `nums.toSet().size`\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You need to modify it and then return the length "
                    },
                    {
                        "username": "PoojaSivakumar23",
                        "content": "int count=nums.length>0?1:0;\\n       \\n        int N=nums.length;\\n        for(int i=0;i<N-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        return count; why this code doesnt work"
                    }
                ]
            },
            {
                "id": 1949819,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1949099,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1941413,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1938027,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1934916,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1933565,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1931947,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1930897,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1930872,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1930077,
                "content": [
                    {
                        "username": "slin59587",
                        "content": "OMG! For the life of me that was hard to understand. They want you to modify the nums on the outside of def removeDuplicates(). Inside the removeDuplicates() they want a return of the size of the output. Input: nums = [0,0,1,1,1,2,2,3,3,4] modified to [0,1,2,3,4] make sure the nums on the outside changes. Then removeDuplicates() returns 5."
                    },
                    {
                        "username": "wayne_k",
                        "content": "Ideally, this would be a good solution\\n\\n `import java.util.*;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {       \\n        int len = nums.length;     \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        for (int i : nums){\\n            set.add(i);\\n        }\\n\\n        List<Integer> list = new ArrayList<>(set);\\n        nums = new int[set.size()];\\n\\n        for (int i = 0; i < set.size(); i++){\\n            nums[i] = list.get(i);\\n        }\\n        System.out.println(Arrays.toString(nums));\\n        int k = nums.length;\\n    \\n        return k;        \\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Ideally, this would be a good solution in Solutions section.\\nNot in Discussions."
                    },
                    {
                        "username": "Jerunnon",
                        "content": "Why can\\'t I just use Distinct in C# and return the length of the distincted array?\\n\\n `var distinct = nums.Distinct().ToArray(); `\\n`return distinct.Length;`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Because you have to modify it in place"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "trash ass problem"
                    },
                    {
                        "username": "dinesh1_07",
                        "content": "what is this error \nNameError: globalname 'solution' is not defined"
                    },
                    {
                        "username": "om155bhardwaj",
                        "content": "  int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        set<int>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        k=st.size();\\n        int i=0;\\n        for(auto it:st){\\n            nums[i]=it;\\n            i++;\\n        }\\n        return k;\\n    }\\n\\n\\ncan anyone explain that the function is returing an int that is k ,,then why that last \"for\\'\\' loop is used for , as it just traverses  the set "
                    },
                    {
                        "username": "ukase",
                        "content": "remove duplicate my ass mf "
                    },
                    {
                        "username": "Shubham_Tekawade",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int size1 = nums.size();\\n        //vector<int>store;\\n        int k;\\n        //int j=0;\\n        \\n       \\n        if ( size1 == 0 && size1 == 1)\\n        {\\n            return size1;\\n        }\\n\\n        for (int i=1;i<=size1;i++)\\n        {\\n            if (i!=size1)\\n            {\\n                if (nums[i-1] == nums[i])\\n                {\\n                    nums.erase(nums.begin()+(i-1));\\n                    i--;\\n                    size1--;\\n                } \\n            \\n            }\\n            \\n        }\\n        \\n        k=nums.size();\\n        return k;\\n\\n    }\\n};\\n\\nI am new to c++ ,and getting the below error, but not able to understand what exactly causing it.\\n\\n==21==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==21==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "I\\'m getting a similar issue across all problem posts. I think this is just an issue on leetcodes end. Comment out your code and just do \"return 1\" to see if this still happens."
                    },
                    {
                        "username": "MaxwellVoorhes",
                        "content": "Hey, getting a weird issue where when I try to run my code, I get this error\n\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nThis occurs no matter what I have in the solution. For instance, I only have one line of code that says return 1 and this error shows up. This has been happening for other leetcode problems too."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "there is some issue on leetcode as I have already solved and submitted it but right now if i am trying I am gettng same error ! so chill "
                    },
                    {
                        "username": "rikkyhermanto",
                        "content": "anytime I found a problem stating \"non-decreasing\" instead of using positive term like \"increasing/ascending\",,, I down-voted it."
                    }
                ]
            },
            {
                "id": 1929701,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1927487,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1920057,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1918813,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1918711,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1917810,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1917360,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1917191,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1916721,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1913092,
                "content": [
                    {
                        "username": "user5397PR",
                        "content": "`class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        dic = {}\\n        for i in nums:\\n            if i in dic:\\n                pass\\n            else:\\n                dic[i]=i\\n        nums = list(dic.keys())\\n        return len(dic)`\\n\\nI am using the above code which give incorrect Output in Leetcode for [nums] but it works fine in VS code.  Any idea why this issue?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "1. You have to mutate it.\\n2. I don\\'t know where you got the idea to use a class, it\\'s Python not Java. Although it might work idk, but it\\'s very unnecessary."
                    },
                    {
                        "username": "aditix2008",
                        "content": "There\\'s no such indication that we can\\'t use sets for the same, so can we use LinkedHashSet to solve this? Do we have to use a two pointer approach? "
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify in place so unlikely."
                    },
                    {
                        "username": "Kashif_Khan18",
                        "content": "The test cases expect array and the function is returning single integer. When I tried to return list of integers, I got compile error, and when I use single integer the test cases fail :)"
                    },
                    {
                        "username": "Naman_gupta21",
                        "content": "just for removing the confusion the question want you to return the size of array with unique element also you have to modify nums in  a way that it only has the unique element in same ascending order in simple words remove all the duplicate elments from nums"
                    },
                    {
                        "username": "bugzzbunny007",
                        "content": "can anyone tell me what is the issue in this code?\\n\\nvar removeDuplicates = function(nums) {\\n    const newvalue = new Set(nums);\\n    const result = [...newvalue]\\n    return result\\n};"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to modify it in place and then return the length.\n\n```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(...) nums.splice(i, 0)\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "MaxouMax",
                        "content": "mettez la reponse a chaque lvl pls"
                    },
                    {
                        "username": "githubnikhil",
                        "content": " $shoreArray = [];\\n \\n        foreach($nums as $key =>  $obj){\\n            if(!in_array($obj , $shoreArray)){\\n                array_push($shoreArray,$obj);\\n            }\\n        }\\n my code in php if i run in complier it work well why it is not working here "
                    },
                    {
                        "username": "fedegiovannacci",
                        "content": "I\\'m sorry if this is a noobish solution or idea but why can\\'t I use the following?\\n\\n `var removeDuplicates = function (nums) {\\n    nums = nums.filter((element, index) => {\\n        return nums.indexOf(element) == index\\n    })\\n    return nums.length\\n};`\\n\\nI think this should work but I might have missed something in the instructions; It\\'s mentioned that it doesn\\'t matter what\\'s next to the k unique elements and not having anything at all it\\'s a valid option under my perspective.\\n\\nThanks!"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "```javascript\nlet removeDuplicates = nums => {\n    for(const i in nums){\n        if(nums.indexOf(nums[i]) != i){\n            nums.splice(i)\n        }\n    }\n    return nums.length\n}\n```"
                    },
                    {
                        "username": "Ethan20230515",
                        "content": "I am using Python. If I cannot not just assign the value to 'nums' like 'nums = ......' ?\nBy this way, I can deliver the nums as required but it seem it is not accepted. I don't know why.\n\nwhat I have came up with is this, but I did not get accepted and don't understand why.\n\n `\n\n      \n        set_nums = set(nums)\n        k = len(set_nums)\n        \n        new_nums = list(set_nums)\n        l = []\n\n        for i in nums:\n            if i in set_nums and i in l:\n                new_nums.append(i)\n            else:\n                l.append(i)\n\n        nums = new_nums`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it."
                    },
                    {
                        "username": "444prajwal",
                        "content": "Each unique element will have at least 1 duplicate keep that in mind, test cases like [1,2,2,3] are not part of this, since it is an easy question"
                    }
                ]
            },
            {
                "id": 1912870,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1912043,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1910055,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1909140,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1907856,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1906559,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1902721,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1899825,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1898390,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1894315,
                "content": [
                    {
                        "username": "Sourabhm25678",
                        "content": "I tried it with java 8. The following solution is working in my machine but not here.\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n       Set<Integer> s1 = Arrays.stream(nums).boxed()\\n        .collect(Collectors.toSet());\\n        return s1.size();\\n    }\\n}"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "A_gentle_coder",
                        "content": "Hi all, \\n\\nI have been writing the following solutions, which returns exactly the required k, yet not working:\\n\\n `class Solution:\\n    \\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        interval = range(1, len(nums))\\n\\n        for i in interval:\\n\\n            if nums[i - 1] == nums[i]:\\n\\n                nums[i - 1] = \"_\"\\n\\n        nums_only = [x for x in nums if x != \"_\"]\\n\\n        string_in_nums = [x for x in nums if x == \"_\"]\\n\\n        nums_only_sorted = sorted(nums_only, reverse = False)\\n\\n        nums = nums_only_sorted + string_in_nums\\n\\n        k = len(nums_only_sorted)\\n\\n        return k`\\n\\nnums is defined as required, and k as well. What am I missing? Anyone willing to help?\\n"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "andrewgraham",
                        "content": "Why is this wrong (python):\n\n`nums=list(set(nums))`\n`return len(nums)`"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length"
                    },
                    {
                        "username": "user5428DY",
                        "content": "What is a real life example where you would need to create a solution to a problem like this? "
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "Java\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "My solution in java - O(n) time O(1) space\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int count = nums.length;\\n        int n = nums.length;\\n\\n        int j = 0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] = Integer.MAX_VALUE;\\n                count--;\\n            }\\n        }\\n        Arrays.sort(nums);\\n\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "prathmeshdodia7",
                        "content": "can anyone tell me what is wrong in this code it passes the test case 1 but not in case2\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public static int removeDuplicates(int[] nums) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (!hs.contains(nums[i])) {\\n                hs.add(nums[i]++);\\n                al.add(nums[i]);\\n            }\\n        }\\n\\n        return al.size();\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "Dominik2208F",
                        "content": " List<Integer> lista = new ArrayList<>();\n        int index=-1;\n        for (int numbers : nums) {\n            if(!lista.contains(numbers)) {\n                lista.add(numbers);\n                index++;\n                nums[index] = numbers;\n            }\n        }\n\n            return index+1;\n\n    }"
                    },
                    {
                        "username": "vined",
                        "content": "Why does Python\\'s set() not work? I tried it on my PC and it worked fine"
                    },
                    {
                        "username": "dalviprasad",
                        "content": "Hi All, I am getting wrong answer when I try to run the below code, can someone help me understand where am I going wrong?\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        c = 0\\n        output1 = []\\n        for i in range(0, len(nums)):\\n            if nums[i] not in output1:\\n                output1.append(nums[i])\\n                c += 1\\n        return(c)\\n```"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Why do you have a class there? You can get rid of that, it\\'s not Java. Return is not a function, it\\'s a keyword. `return c`"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "Notice: u don't only have to return the value k but have to remove(not remove literal) duplicate from the array \"nums\" and put it in order from start to k."
                    }
                ]
            },
            {
                "id": 1891925,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1890344,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1889886,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1887031,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1882517,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1880051,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1874967,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1873482,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1872711,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1872433,
                "content": [
                    {
                        "username": "joaocasarin",
                        "content": "I understand that if the given array is [0,0,1,1,1,2,2,3,3,4], I should remove\n1x 0\n2x 1\n1x 2\n1x 3\n\nCorrect?\n\nIf so, the result of amount of removed duplicates is 5, which is the sum of amount of removed of each different number.\nHowever, the tests fail for this code in the LeetCode console:\n\n    function removeDuplicates(nums: number[]): number {\n        const mapping = new Map<number, number>();\n        let count = 0;\n\n        for (let i = 0; i < nums.length; i++) {\n            const num = nums[i];\n            mapping.set(num, (mapping.get(num) || 0) + 1);\n        }\n\n        for (let [k, v] of mapping) {\n            count += v - 1;\n        }\n\n        return count;\n    }\n\nIt does its job when running with Jest, it returns correctly the number 5.... What is wrong, did I misunderstand the problem?"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "You have to mutate it and return the length Also that is not a good solution. And use a for...of."
                    },
                    {
                        "username": "AlexanderBaggett",
                        "content": "in C# this should have been `return nums.Distinct().Count();`\\n\\nBut this obvious solution to remove duplicates from a sorted array and then return it\\'s count doesn\\'t work.\\nWHY? Because this problem is horribly worded. Even the outputs in the result don\\'t make sense. We return an integer, so why on earth are arrays in the output from test cases? Doesn\\'t make sense."
                    },
                    {
                        "username": "rohitpandey006",
                        "content": "Hi can we solve this problem using set in java??"
                    },
                    {
                        "username": "HolyArseny",
                        "content": "Dirty task\\'s description"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "thanks for leet, I solved how sort and replace duplicates with \"_\". \nah, the task wasn't that? no problem, No, I didn't waste any time. Deal with it, author of this sh_t. :*\nHahahaha"
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "The nonduplicates have to be at the start so you can do that as long as they are at the end. Also you have to mutate it and return the length"
                    },
                    {
                        "username": "Jaarabits",
                        "content": "I hate this website ."
                    },
                    {
                        "username": "RudranshShrivastava",
                        "content": "For those who cant return k, and nums\\nYou just have to return k"
                    },
                    {
                        "username": "user1640rw",
                        "content": "Empty temp array with length of source array -> nums =  stream distinct toArray, and remember nums.length to result -> elements of nums to temp in loop -> nums = temp\\n\\nnums = [1,1,2] -> output: [1, 1]\\n\\nhow? In IDEA it works according to given conditions."
                    },
                    {
                        "username": "Hypgnotic",
                        "content": "This problem is very confusing and worded oddly. I thought I had to return an array with the duplicates removed at first. However that was wrong and gave out an error. Then I tried just outputting the given len(nums) of the new list without the duplicates still wrong. However what worked was that the original list had to be mutated and altered to remove it\\'s duplicates and then output the len(nums)."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Question Title: Remove Duplicates from Sorted Array\\nDoes not matches what the code should do, as no duplicates are removed. Duplicates are just replaced by non-duplicate numbers."
                    }
                ]
            },
            {
                "id": 1872241,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1870333,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1870160,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1869490,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1869098,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1868646,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1867076,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1866919,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1866822,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1863347,
                "content": [
                    {
                        "username": "its-raj3",
                        "content": "It\\'s become a really easy type of question , once you have done it before(this type of)."
                    },
                    {
                        "username": "sciguy09",
                        "content": "**Update:** I found out the problem with my code, thanks to [Samwise on StackOverflow](https://stackoverflow.com/a/76075745/8097585). I did `nums = []` before appending and as I understand, it rebinded the local variable `nums` that no longer pointed to the original one. This is solved by doing `nums.clear()` and the program works on $$O(nlogn)$$ time complexity if everything else is the same.\n\nHere is another two liner solution:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n---\n\nI'm not able to pass a lot of testcases. I ran the function as well as my implementation of the code that they say they will use to judge on my local machine and found out that the problem is that `nums` is not updated outside the function `removeDuplicates()` when it is is being called but it is updating within the function. Why is that? Aren't python lists called by assignment when passed in a function?\n\n```\ndef removeDuplicates(nums):\n    nums_ = set(nums)\n    nums = []\n    for i in nums_:\n        nums.append(i)\n    print(nums)\n    # not working even if I do nums = list(set(nums)) instead of all lines above\n    return len(nums)\n\nnums = [1,1,2]\nexpectedNums = [1,2]\n\nk = removeDuplicates(nums)\nif k != len(expectedNums):\n    print(False)\nfor i in range(k):\n    if nums[i] != expectedNums[i]:\n        print(False)\n        print(nums, expectedNums)\n        break\n```\n\n> **Output:**\n> [1, 2]\n> False\n> [1, 1, 2] [1, 2]\n\nEarlier I had used `nums = list(set(nums))` instead of emptying the list and appending all unique elements but even that wasn't working."
                    },
                    {
                        "username": "idklol8",
                        "content": "I\\'m not that familiar with Python, but they\\'re wanting you to modify the values in nums without creating a new array. Using set defeats the purpose of the assignment."
                    },
                    {
                        "username": "shiva-student",
                        "content": "Can you explain why one-liner doesn\\'t work? (using set function)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "[@idklol8](/idklol8) you can do that with two lines:\n\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "sciguy09",
                        "content": "My two liner worked:\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        nums[:] = sorted(set(nums))\n        return len(nums)\n```\n[Link to submission](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/937602429/)\n\n[Courtesy: Samwise on Stackoverflow](https://stackoverflow.com/a/76075745/8097585)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You need to remove the duplicates from the original array you\\'re given without creating a new one. "
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "In this question we have to modify the given array such that all unique elements should be at front.\\nJAVA solution :- \\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = nums.length;\\n        int i = 0, j = 1;\\n        while(j < nums.length) {\\n            if(nums[i] == nums[j]) {\\n                k--;\\n                j++;\\n            } else{\\n                nums[i+1] = nums[j];\\n                i++;\\n                ++j;\\n            }\\n        }\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "WayneHe1221",
                        "content": "This problem seems really weird. The code asked us to return a Int value, but result output display the array given by param. \nIf you are finding the solution, please just try to change the value in array and make it non-duplicated.\nAnd the Int value you returned means the output will split the array from 0 until {your result}. "
                    },
                    {
                        "username": "Okpatu",
                        "content": "Examples are misleading "
                    },
                    {
                        "username": "joeantol",
                        "content": "Something is wrong. As a test for Case 1 I did:\\n\\n` def removeDuplicates(self, nums: List[int]) -> int:\\n\\n        nums = [1,2]\\n        return len(nums)`\\n\\nThe rig claims my output is: [1,1] and therefore incorrect.\\n\\nYet my answer IS correct for Case 1\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "cvollrath97",
                        "content": "This question is simply not worth solving."
                    },
                    {
                        "username": "its-raj3",
                        "content": "it is."
                    },
                    {
                        "username": "antonMechEngineer",
                        "content": "Why if i am testing in my JDK everythink works correct, but litcode execute wrong? "
                    },
                    {
                        "username": "tokeeffe9",
                        "content": "I\\'ve seen solutions but I don\\'t really understand how we can change the array in our method without returning that array.\\nIf we don\\'t return the new  array without duplicates, nums is still the same in the main call"
                    }
                ]
            },
            {
                "id": 1861769,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1859543,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1859132,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1857635,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1856041,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1855463,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1854090,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1853943,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1852116,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1850633,
                "content": [
                    {
                        "username": "charlescolfer",
                        "content": "Everyone says to just read the directions and return K but the results shows the Expected Answer for Case 1 as [1,2] & Case 2 as [0,1,2,3,4] - This is incorrect, or the directions are incorrect. I\\'ve returned both K as an integer representing the number of unique elements, and the array and got both wrong. "
                    },
                    {
                        "username": "idklol8",
                        "content": "you return K, but you also have to remove the duplicate elements from nums.\\n\\nthe return value, K, tells the grader to check the first K elements in nums. "
                    },
                    {
                        "username": "sbjunaid14",
                        "content": "IS this related to set???"
                    },
                    {
                        "username": "shubhi4",
                        "content": "No, just need to alter the array"
                    },
                    {
                        "username": "mcorne_76",
                        "content": "This question is fucking stupid"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        j = 1\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                nums[j] = nums[i + 1]\\n                j += 1\\n        return j\\n```\\nThis way worked\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "AJAYPATIDAR2022",
                        "content": "I am not sure why it is stated in question that the remaining numbers are not important. and in the solution they are slicing away the array marking my result as wrong answer. either remove that slicing part or allow our answers to be true where we keep only unique element and leave the other numbers behind"
                    },
                    {
                        "username": "PavelKovtun",
                        "content": "Hint:\nYou should modify the array passed to you (no need to create a new one)!"
                    },
                    {
                        "username": "eugene_stukalov",
                        "content": "Somehow I had more trouble with this \"easy\" problem than with some \"hard\" problems (when intentionally not using a Java data type trick)."
                    },
                    {
                        "username": "Azkul",
                        "content": "This question was honestly really bad, without the comments to explain how the behind the scenes works there\\'s no way I could solve it even though I solved the actual problem in my IDE. Just remember that you don\\'t need to remove any number in nums, just have the unique numbers sorted at the begining of the list."
                    },
                    {
                        "username": "ahumada1790",
                        "content": "Just in case somebody is doing this in Typescript and for some reason getting a error despite working, trying changing to javascript. I think the typescript compiler may be glitchy."
                    },
                    {
                        "username": "TYork",
                        "content": "class Solution {\\n\\n\\tpublic int removeDuplicates(int[] nums) {\\n\\n\\n\\t\\tArrayList<Integer> foo = new ArrayList<Integer>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i <nums.length;i++) {\\n\\t\\t\\tif(foo.contains(nums[i])){\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tfoo.add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tSystem.out.println(foo.toString());\\n\\n\\t\\treturn foo.size();\\n\\t}\\n}\\n\\t\\t\\n\\n\\nhow in Earth is this wrong? Just another Leetcode jokes."
                    }
                ]
            },
            {
                "id": 1848821,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1842279,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1841345,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1837156,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1830118,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1828220,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1827361,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1827193,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1826933,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1816142,
                "content": [
                    {
                        "username": "Hussain_14",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& a) {\\n         \\n         \\n         int n=a.size();\\n         if(n==1)\\n         return 1;\\n\\n         if(n==2)\\n         {\\n             if(a[0]==a[1])\\n             return 1;\\n             else return 2;\\n         }\\nint j=1;\\n         \\n        for(int i=0;i<n;)\\n        {\\n            int curr=a[i];\\n            while(a[i]==curr and i<n)\\n            i++;\\n            \\n             if(i==n)\\n            return j;\\n            else\\n            if(i<n)\\n            a[j]=a[i],j++;\\n            \\n           \\n        }\\n        return j-1;\\n    }\\n};\\n\\n\\nwhats the error here?"
                    },
                    {
                        "username": "foday_conteh",
                        "content": "I have solved the problem in my default text editor when I redo the same in leetcode I keep getting empty output. But the solution worked in my code editor. Somebody please explain to me why this keeps happening."
                    },
                    {
                        "username": "svenyboyyt",
                        "content": "Whoever came up with this problem is an idiot, it says return k as an array but it's an int, but then it loops through it again? Fuck you"
                    },
                    {
                        "username": "nitsjain",
                        "content": "public int removeDuplicates(int[] nums) {\\n        int count =0;\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n   hs.add(nums[i]);\\n}\\nreturn hs.size();\\n    }\\nThis piece of code is working fine on IDE but test cases are failing on leetcode."
                    },
                    {
                        "username": "Akshat4433",
                        "content": " `var removeDuplicates = function(nums) {\\n    \\n     let i = 0; j = 1;\\n\\n     while (j <= nums.length - 1) {\\n         if (nums[i] == nums[j]) {\\n             j++;\\n         }\\n         else {\\n             nums[i + 1] = nums[j];\\n             i++;\\n             j++;\\n         }\\n     }\\n     \\n};` \\n\\nThe prompt clearly states, there could be anything beyond k, but then why my solution is failing,\\nSome cases \\n\\n[1,1,2] -> [1,2,1]  , its say wrong answer , correct is [1,2] "
                    },
                    {
                        "username": "varshini-S",
                        "content": "why no one is using return len(set(nums)), why cant we use that- i\\'m a complete begineer, correct me If im wrong\\n"
                    },
                    {
                        "username": "nullablepriest",
                        "content": "- \"More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\"\n\nOkay. My case:\nInput: [1,1,2,2,2,2]\nOutput: [1,2,0,0]\nExcpected: [1,2]\nWhy it doesnt work? It doesnt matter what values ​​I put after result - it doesn't work.\n\nBut in the \"case 2\" its work and i have no idea why:\nInput: [0,0,1,1,1,2,2,3,3,4]\nOutput: [0,1,2,3,4]\nExcpected: [0,1,2,3,4]\n\n(I use C#)\n\nUPDATE: Okay. The problem was that I was returning the number of duplicates."
                    },
                    {
                        "username": "clickclickcode",
                        "content": "So, this is an \"easy\" problem? The hard part is really deciphering the task. It says to \"return\" the result, which does absolutely nothing. What they really seem to mean is that they want it logged to the console. For JS - console.log(*insert result here*) or else you seem to have your output be an empty array no matter what you do.\\n\\nI am new to this platform, so I am curious to know if all the task descriptions here are equally misleading or if it is me who lacks experience in reading and solving problems? I mean, honestly, I do lack experience, hence, I\\'m here, but yes, I hope you get where I am going."
                    },
                    {
                        "username": "yewin",
                        "content": "question is not clear, what do they want integer or sorted number array? \\uD83D\\uDE07"
                    },
                    {
                        "username": "criomby",
                        "content": "*There are two options*\n1. **According to the examples given:**\nSort unique values at the front of the array and return the number of unique values in the array (length of unique subsequence)\n2. **My preferred way:**\nRemove duplicates from the array and return the length of the array after removal.\nSince it does not matter if you remove duplicates or just push them to the end of the array, this is way cleaner imo and easier to understand.\n\nThis saved me a lot of time and headache so I hope this helps you understand better what the idea here is."
                    }
                ]
            },
            {
                "id": 1811902,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1810837,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1810460,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1809799,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1807587,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1807529,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1805520,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1804498,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1802656,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1798778,
                "content": [
                    {
                        "username": "arjun259194",
                        "content": "so how should i return both array and k when the function only returns number (Typescript)"
                    },
                    {
                        "username": "idklol8",
                        "content": "You don\\'t need to return the array. You just need to remove the duplicates from the array without creating a new one and return the number of unique elements. The test cases will check the first k items in the array after your function runs."
                    },
                    {
                        "username": "Anshulsoni34",
                        "content": "C++ best approach\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return 0;\\n        }\\n        int i = 0;\\n        for(int j = 1; j<nums.size(); j++){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n            }\\n        }\\n        return i+1;\\n    }\\n};"
                    },
                    {
                        "username": "Udosinachi",
                        "content": "JavaScript has inbuilt functions to solve things like this, which is actually very good."
                    },
                    {
                        "username": "sandagolcea",
                        "content": "find it funny that returning the `length` is not accepted, and you have to return the array `response.length` ..\\nAt this point, just make me return the complete or sliced array?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python question...\\n\\nIt seems that the problem wants two items returned. The first is the length of the unique list and the second is the unique list itself. When you return multiple items in one return statement Python turns the items into a tuple. The problem doesn\\'t want a tuple returned. In python it\\'s easy to turn the tuple into the correct answer:\\n\\nlength, answer = removeDuplicates(nums)\\nprint(f\\'Length = {length}, Output = {answer}\\\\n\\')\\n\\nDoes anyone have an idea as to how to return two items as an integer and a list?\\n\\nThanks in advance...\\n"
                    },
                    {
                        "username": "idklol8",
                        "content": "They only want the length returned. They\\'re looking at the array theyve given you to make sure that you\\'re removing the duplicates in place without creating a new array."
                    },
                    {
                        "username": "iKittyCode",
                        "content": "Make sure to return the length this took me hours to figure out"
                    },
                    {
                        "username": "secretshine1",
                        "content": "var removeDuplicates = function (nums) {\\n    let arr = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let element = nums[i]\\n        if (arr.indexOf(element) === -1) {\\n            arr.push(element);\\n        }\\n    }\\n    return arr;\\n};\\n\\n\\nWhy its not working ?"
                    },
                    {
                        "username": "idklol8",
                        "content": "They want you to remove the duplicates from the original array (nums) without creating a new one. "
                    },
                    {
                        "username": "sainisaurav111",
                        "content": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length == 0){\\n            return 0;\\n        }\\n        int i =0 ; \\n        for(int j=1; j<nums.length ; j++){\\n            if(nums[i] !=nums[j]){\\n                i++;\\n\\n            \\n                nums[i] = nums[j];\\n            }\\n        \\n        }\\n        return (i+1);\\n        \\n    }\\n}\\nThis is the easy method to solve the question ."
                    },
                    {
                        "username": "Pushpajekumar",
                        "content": "/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nconst nums1 = new Set(nums);\\nconst newArray = Array.from(nums1)\\nconst sortedArray = newArray.sort()\\nconst sortedArrayLength = sortedArray.length\\n  return sortedArrayLength\\n};\\n\\nconst  nums = [0,0,1,1,1,2,2,3,3,4]\\n\\nremoveDuplicates(nums)\\n\\n\\nThis Code is working perfectly in my meachine but not here it returns blank array it is not seting the value of nums1"
                    },
                    {
                        "username": "hongying1525",
                        "content": "I don\\'t quite understand, why I cannot just simply use:\\n`list(dict.fromkeys(nums))`"
                    }
                ]
            },
            {
                "id": 1797852,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1791176,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1790068,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1789532,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1788972,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1787081,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1786714,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1783541,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1783133,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1782435,
                "content": [
                    {
                        "username": "Keiku",
                        "content": "Any idea why this code doesn\\'t work? It seems that only 49/361 test cases pass.\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        nums_nodups = []\\n        for n in nums:\\n            # print(\\'n:\\', n)\\n            if n not in nums_nodups:\\n                nums_nodups.append(n)\\n                # print(\\'nums_nodups:\\', nums_nodups)\\n\\n        print(nums_nodups)\\n        return len(nums_nodups)\\n```"
                    },
                    {
                        "username": "Keiku",
                        "content": "[@idklol8](/idklol8) \\n\\nThank you for your reply. I overlooked the condition in the problem statement below.\\n\\n>  Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "idklol8",
                        "content": "You have to remove the duplicates from the original array you\\'re given without creating a new one."
                    },
                    {
                        "username": "neyguu",
                        "content": "How come im getting errors that result weird numbers/letters coming out: \"[I@27fa135a\" "
                    },
                    {
                        "username": "zetlian",
                        "content": "Honestly this one is filled with problems. I\\'m here beating myself over this and struggling just to notice the problem isn\\'t even me."
                    },
                    {
                        "username": "sk38252",
                        "content": "this can be also solve by hashset\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "You need to modify ref value of `nums`, can\\'t reassign"
                    },
                    {
                        "username": "avinashchawla67001",
                        "content": "It is working absolutely fine in Eclipse but leetcode is giving the wrong output while running the code.\\nAny Solution ! \\n\\npublic static int remove(int[] nums) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tArrays.sort(nums);\\n\\t    int exnums[] = new int[nums.length];\\n\\t\\tArrayList<Integer> exnums = new ArrayList<>();\\n\\t\\texnums.add(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\tif(nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\texnums.add(nums[i]);\\n\\t\\t}\\n\\t\\tint k =  exnums.size();\\n\\t\\tint expnums[] = new int[k];\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\texpnums[i] = exnums.get(i) ;\\n\\t\\t}\\n\\t\\treturn expnums.length;\\n\\t}\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int removeDuplicates(int[] nums) {\\n     \\n     int t=0;\\n\\n     for(int i=1;i<nums.length;i++){\\n         if(nums[t] != nums[i]){\\n             nums[t+1]=nums[i];\\n             t++;\\n         }\\n     }\\n\\n     //since t start from 0 \\n     return t+1;\\n\\n\\n    }\\n}`"
                    },
                    {
                        "username": "Siddhantkeshariii",
                        "content": "If we have to return the size of nums then why the test case of the question shows the array?"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "yeah seems confusing. it looks like the array in the test cases is `nums` parameter, and I noticed we need to return the length of the array and mutate the `nums` parameter."
                    },
                    {
                        "username": "Evil_123",
                        "content": "////EASY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n       int n=nums.size(),val=1,k=1;\\n       for(int i=0;i<n-1;i++){\\n         if(nums[i+1]>nums[i]){\\n             k++;\\n             nums[val]=nums[i+1];\\n             val++;\\n         }\\n       }\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "byeongjae-kang",
                        "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    return [...new Set(nums)].length\\n};\\n```\\n\\n`const k = removeDuplicates([...])`\\n\\nMy solution above should be able to return the right value of `k`, do I need to mutate `nums` in order to get pass this task?"
                    }
                ]
            },
            {
                "id": 1781961,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1781175,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1779898,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1777818,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1776936,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1776558,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1774538,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1772364,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1765315,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1765300,
                "content": [
                    {
                        "username": "HondaCivicTypeR",
                        "content": "    def removeDuplicates(self, nums: List[int]) -> int:\\n        first = 0\\n        \\n        for second in range(1, len(nums)):\\n            if nums[first] != nums[second]:\\n                first += 1\\n                nums[first] = nums[second]\\n\\n        return first + 1"
                    },
                    {
                        "username": "merin_roy",
                        "content": "Guys, we not only need to return the length of the resultant list, but also need to update the list in the required format. This problem can be considered as an example for \\'pass by reference\\'. "
                    },
                    {
                        "username": "fuad-hashimi",
                        "content": "hey guys. I wrote a code that ran  with the \"run\" button but as soon as I hit submit the compiler throws a heap-buffer-overflow error for some reason. I tried looking it up online and I found that these types of errors occur when we try to allocate some memory and then access it in a bad way, but I didn\\'t allocate anything in my code. Send help please"
                    },
                    {
                        "username": "SilverWings47",
                        "content": "Can i use language specific methods like JavaScript array methods ?"
                    },
                    {
                        "username": "Geany97",
                        "content": "Asking for an int, test cases verifying an array of integers. Just an array to a set, bad format of question."
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        int j= 0;\\n        int cnt = 1;\\n        while(j<nums.size()-1){\\n            if(nums[j]==nums[j+1]){\\n                j++;\\n            }\\n            else{\\n                \\n                j++;\\n                i = j;\\n                nums[cnt]=nums[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "pushkartiwari6",
                        "content": "good question"
                    },
                    {
                        "username": "SaurabhDhyani",
                        "content": "Why is this not a correct answer :\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            nums = list(set(nums))\\n            return(len(nums))\\nI tested it in vs code and its giving correct count and I also printed the array which is also removing the duplicates."
                    },
                    {
                        "username": "mfliltim",
                        "content": "Am I mistaken or are the expected outputs of the test cases different from the prompt?"
                    },
                    {
                        "username": "uniyalvipin",
                        "content": "`var removeDuplicates = function(nums) {\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i] === nums[i-1]){\\n            nums.splice(i, 1)\\n            i--;\\n        }\\n    }\\n    return nums.length;\\n};`\\n\\nsimple js solution"
                    }
                ]
            },
            {
                "id": 1762825,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1762598,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1762590,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1761896,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1761818,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759251,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759077,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754021,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752867,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752591,
                "content": [
                    {
                        "username": "joeyliu7975",
                        "content": "The description and functions itself is contrast, asking to return `Int` but we are expected to remove array? It\\'s misleading."
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Почему не работает?\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        start_len = len(nums)\n        nums = list(set(nums))\n        return start_len - len(nums)"
                    },
                    {
                        "username": "DenisUstinov",
                        "content": "Где в реальной разработке на Python это используется?"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This is the first question I have seen which has more number of dislikes as compared to likes."
                    },
                    {
                        "username": "ayushyush100",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        newList = []\\n        elist = []\\n        r = 0\\n        for i in nums:\\n            if i not in newList:\\n                newList.append(i)\\n                r += 1\\n        \\n        for a in range(r):\\n            elist.append(a)\\n        \\n        k = r\\n        nums = newList\\n        \\n        return k\\n\\n       \\nWhat is wrong with this code?"
                    },
                    {
                        "username": "nikitapandeyy",
                        "content": "1. initialize index=1 ;try to run loop from 0 to nums.length-1\\n2. then compare nums[i]>nums[i+1]\\n3. then nums[index]=nums[i+1]\\n4. and increase index by 1\\n5.return index"
                    },
                    {
                        "username": "altr3s",
                        "content": " class Solution:\\n    def removeDuplicates(nums: list[int]) -> int:\\n        answer = sorted(list(set(nums)))\\n        return len(answer)\\n\\nfor testing in vscode is correct output, but in leetcode..."
                    },
                    {
                        "username": "Priyamd",
                        "content": "how to swap??\\n"
                    },
                    {
                        "username": "ravitejalvr1",
                        "content": "Why cant we convert nums into set and convert set back to list\\n\\nnums=list(set(nums))\\nreturn len(nums)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752413,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1751762,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1750481,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1750327,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1749524,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1746279,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1745737,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1744071,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1738394,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1737089,
                "content": [
                    {
                        "username": "lazy_n",
                        "content": "why can\\'t we use js sets for this problem \\n"
                    },
                    {
                        "username": "chrisramo1",
                        "content": "I thought this would work?  Python ->\\n\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        a = set()\\n        for x in nums:\\n            a.add(int(x))\\n        return list(a)"
                    },
                    {
                        "username": "YogiKnight",
                        "content": "I have the correct result, stored into the nums array, but when I send the len(nums) it says that numbers I sent are incorrect. Anyone know why this might be the case? Typed below is my code, I know that it is inefficient. When running it with those print statements it shows the correct results. (It would not let me post this in the solution section so I am sorry about that. )\\n\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        for index in range(len(nums)):\\n            if (index < len(nums)):\\n                temp = nums[index]\\n                print(\\'-------\\')\\n                print(\\'Before:\\',nums)\\n                nums = list(filter(lambda char: char != temp, nums))\\n                nums.insert(index, temp)\\n                print(\\'After:\\',nums)\\n        print(\\'-------\\')\\n        print(\\'Result:\\',nums)\\n        return len(nums)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You need to mutate the original array, test cases are using it to check your code. As far as I can see you are reassigning the nums so you are losing the reference, I think this is what causes the problem."
                    },
                    {
                        "username": "bowenclssp",
                        "content": "Hey, does anyone know why the outcome on my vscode differs from the one I receive in the code editor on Leetcode? For instance, on the test case  `nums = [1,1,2]`, my output on vscode is nums[1,2], but on leetcode it returns [1]. Does anyone know why this happen and how I could resolve this? \nMy code is as follows\n ```\nnums = [1,1,1,1,1,1,2]\nnum = nums.copy()\n\ncurrent = num[0]\n\nfor numId in range(1, len(num)):\n    if num[numId] != current:\n        for _ in range(num.count(current) - 1):\n            nums.remove(current)\n        current = num[numId]\n\nreturn len(num) - len(nums)\n```"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        int i=0;\\n        for(int j=0;j<nums.size();j++){\\n            // if(nums[i]==nums[j]){\\n            //     j++;\\n            // }\\n         if(nums[i]!=nums[j]){\\n                i++;\\n                nums[i]=nums[j];\\n            }\\n        }\\n        return (i+1);\\n    }"
                    },
                    {
                        "username": "vhimans7",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums=list(set(nums))\\n        print(nums[0:])\\n\\n???????????????????????"
                    },
                    {
                        "username": "Rthandi",
                        "content": "Is there anyway you could solve this with a HashMap?"
                    },
                    {
                        "username": "SamuelHanneson",
                        "content": "This was the solution I came up with myself, However it passed every test case but the last one (The super long one that goes from -100 to 100 (not pasting here because its too damn long) and this script timed out, is there a way I could make this fast enough so that it wouldn\\'t time out? I\\'ve found another solution but I like this one and I want to know if its salvageable or if it just wont work for exceedingly long lists\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if nums.count(num) is 1:\\n                pass\\n            if nums.count(num) > 1:\\n                while nums.count(num) > 1:\\n                    nums.remove(num)\\n\\n\\n        "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 100% runtime || 100% space || Easy to understand.\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2986997/simple-java-100-runtime-100-space-easy-to-understand/"
                    },
                    {
                        "username": "Elias-Kibret",
                        "content": " `your inline code...your inline code...`\\nconst nums=[0,0,1,1,1,2,2,3,3,4]\\nvar removeDuplicates = function(nums) {\\n    return [...new Set(nums)]\\n};\\nconsole.log(removeDuplicates(nums))\\n\\n// [0, 1, 2, 3, 4]\\n\\n// But it doesn\\'t work"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    }
                ]
            },
            {
                "id": 1736847,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1735389,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1734467,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1734294,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1734275,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1732628,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1732578,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1732075,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1732035,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1731959,
                "content": [
                    {
                        "username": "Vidit_lakhera",
                        "content": "var removeDuplicates = function(nums) {\\n    let result = [];\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i] != nums[i+1]){\\n              result.push(nums[i])\\n        }\\n    }\\n    return result\\n};\\nlet array = [1,1,2]\\nremoveDuplicates(array)  // working on terminal but shows error here pls help to find error"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array, it checks the input not what you return."
                    },
                    {
                        "username": "tneske93",
                        "content": "lmao if this is easdy, im gonna quit my computer science studies."
                    },
                    {
                        "username": "harshtyagi0",
                        "content": "Can anyone tell what is wrong in this code.\\nimport java.util.Set;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        Set<Integer> set = new TreeSet<>();\\n\\t\\tfor(int i =0; i<nums.length; i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n\\t\\treturn set.size();\\n        \\n    }\\n}"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "This code does not mutate the original array. The idea of this task is mutate the original array in the way that it does not have duplicates on the first K positions, and this K is the number that you have to return."
                    },
                    {
                        "username": "brainlessduncan",
                        "content": "The C# problem is asking for me to return an integer. Then it is rejecting this asking for an integer array. I\\'m pretty confident this question has an issue..."
                    },
                    {
                        "username": "charant587",
                        "content": "in this solution i can only remove 2 duplicate items not more than that can anyone tell me solution\\n\\ndef removeDuplicates(self, nums):\\n        k=0\\n        if nums is None:\\n            return k\\n        for i in range (0 , len(nums)-1):\\n            \\n            for s in range (i+1,len(nums)-1):\\n               if nums[i]== nums[s]:\\n                   nums.remove(nums[i])\\n            k=k+1\\n        return k\\n"
                    },
                    {
                        "username": "rajeevkumarsingh5252",
                        "content": "`int removeDuplicates(vector<int>& nums) {`\\n        `map<int,int>mpp;`\\n    `for(int i=0;i<nums.size();i++){`\\n       ` mpp[nums[i]]++;`\\n    `}`\\n    `nums.clear();`\\n   `for(auto it:mpp){`\\n    `//cout<<it.first<<\"           \"<<it.second<<endl;`\\n    `nums.push_back(it.first);`\\n   `} `\\n    `    return nums.size();`\\n    `}`"
                    },
                    {
                        "username": "pratik063",
                        "content": "Haven't gotten into complexities yet but here's the code i wrote in python\n\nnums=sorted(list(set(nums))) \nreturn len(nums) \n\nim getting the output as [1,1] in the first testcase and [0,0,1,1,1] in the second one(obv wrong) \n\nim supposed to get the output as the length of the new array instead im getting these wrong outputs,even though there isnt supposed to be any problem even in the new array itself(verified it in an online compiler) \n\nwhat am i doing wrong?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to mutate the original array that was provided. The idea of this task is not only to return the correct number but also correctly change the input array."
                    },
                    {
                        "username": "paramagnetic3004",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        res=list(dict.fromkeys(nums))\\n        return len(res)\\n\\nwhats wrong in this solution"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "My code works perfectly in my editor but unable to pass your test case:\\nHere is my code if found any errors correct it otherwise \"Leetcode\" should update their testcase.\\n\\n def removeDuplicates(self, nums):\\n        Unique = set()\\n        Len = len(nums)\\n        \\n        for duplicate in range(Len):\\n            Unique.add(nums[duplicate])\\n            \\n        Unq = list(Unique)\\n        return len(Unq)"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "[@KovDimaY](/KovDimaY) Got! the point Thanks:)"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Demaineen",
                        "content": "I got an error in the js/ts checker when I returned [1, 2, 2] from the [1, 1, 2] array. But the answer seems correct. What to do?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You do not have to return array, your return has to be a number, but when executing your code you have to modify the array that was provided as the input. I hope that helps \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 1731933,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1731010,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1730126,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1730024,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1729264,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1728781,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1726562,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1726077,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1726076,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1724473,
                "content": [
                    {
                        "username": "BhushanBK",
                        "content": "JAVA\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]!=nums[i+1])\\n                nums[n++]=nums[i];\\n        }\\n        nums[n++]=nums[nums.length-1];\\n        return n;\\n    }\\n}"
                    },
                    {
                        "username": "trantatxep",
                        "content": "class Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        abc = list(set(nums))\\n        return len(abc)\\n\\nAnyone know why my solution is wrong ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be sure you modify the original array. The tests are running against it. The idea is that you do not only return the correct number but also mutate the provided array so it does not have duplicates."
                    },
                    {
                        "username": "Thedineshk24",
                        "content": "this code is return right array when i use k, but when i use k.length it also gives 2, which is accepted, but leetcode gives [1.1]\\n\\n `var removeDuplicates = function (nums) {\\n  let prev = [];\\n  const k = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== prev) {\\n      k.push(nums[i]);\\n      prev = nums[i];\\n    }\\n  }\\n  return k.length;\\n};`"
                    },
                    {
                        "username": "Gaurav_DSA_MS",
                        "content": "Pythonistas, use set!"
                    },
                    {
                        "username": "prabhanjanmishra60077",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n     for(auto i=nums.begin()+1;i!=nums.end();i++)\\n     {\\n         if(*i==*(i-1))\\n          {\\n              nums.erase(i);\\n              i=i-1;\\n          }\\n     }\\n     return nums.size();\\n    }\\n    \\n};"
                    },
                    {
                        "username": "suvoooo",
                        "content": "Upvote if you think this type of ridiculous, pathetic description of a problem should be considered as a complete joke! Wasted 40 minutes and then had to see the solution to figure out what they actually want behind the scene to happen and not the real answer!!!! "
                    },
                    {
                        "username": "tejasparmar1211999",
                        "content": "var removeDuplicates = function(nums) {\\n    let res=new Set(nums);\\n    let res1=[...res];\\n    return res1;\\n};\\nwhy this solution is not working?\\nit is working in VSCode."
                    },
                    {
                        "username": "user0130y",
                        "content": "I\\'ve noticed all of the solutions are basically returning the number of different elements.  Doesn\\'t the question ask to also return an array with underscores for redundant values as well?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I think the main idea of this problem is to mutate correctly the initial array that was provided in the way that all the first elements are not repeated. The number that we return is kinda redundant I think, it is just not needed. But well, it is the way how the author decided to create this problem \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "biltuandal",
                        "content": " Python code. \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        a = []\\n        l = len(nums)\\n        i = 0\\n        while i<l:\\n            if nums[i] not in a:\\n                a.append(nums[i])\\n                i+=1\\n            else:\\n                nums.pop(i)\\n                l-=1\\n        print(nums)"
                    },
                    {
                        "username": "ankit_996",
                        "content": " int n= nums.length;\\n            int [] nums2 = new int[n];\\n            int j=0;\\n            for (int i=0; i<n; i++){\\n                if (nums[i]!=nums[i+1]){\\n                    nums2[j++]=nums[i];\\n                }\\n            }\\n            nums2[j++]=nums[n-1];\\n//            changing original array\\n            for (int i=0; i<j; i++){\\n                nums[i]=nums2[i];\\n            }\\n            return j;\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1723947,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1723856,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1723002,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1722150,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1721567,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1719047,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1716802,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1715966,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1715850,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1711344,
                "content": [
                    {
                        "username": "akashanand282",
                        "content": "can someone tell me whats wrong with this.....for the testcase [1,1] its showing runtime error.\\n\\nint i = 0, j = 1;\\n       while (i < j && j < nums.size())\\n       {\\n           if (nums[i] == nums[j])\\n           {\\n               j++;\\n           }\\n           if (nums[i] != nums[j])\\n           {\\n               i++;\\n               nums[i] = nums[j];\\n               j++;\\n           }\\n       }\\n       return i+1; "
                    },
                    {
                        "username": "jyotipp98",
                        "content": "I have confusion what i need to return exactly unique array or number of elements in array?"
                    },
                    {
                        "username": "Brayheart",
                        "content": "dude what is happening, my return statements are all returning an empty array even when explicitly returning a string or something. I don\\'t understand how this function is operating, what am I missing here?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "I had the same problem at first and it was freaking me out \\uD83D\\uDE05\\n\\nThe thing is that we do not have to return the array, we have to return just a number of unique elements in the resulting array. But what is the most important is that we have also mutate the provided array in the way that all the repeated elements are removed, so all the first elements in the array are unique. Is a bit confusing the description of the problem, but after I figured it out it kinda makes sense. The most important in this task is to mutate correctly the original array. Good luck! \\uD83D\\uDE4C"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/26_remove_the_duplicates.cpp\\nleave a STAR"
                    },
                    {
                        "username": "charanrai",
                        "content": "C++ clean solution. can be use same logic for many such questions\n\n `    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            \n            if (nums[j] != nums[i]){\n                ++j;\n                swap(nums[j], nums[i]);\n            }\n        }\n        return j+1;\n    }`"
                    },
                    {
                        "username": "aakash_singh1708",
                        "content": "Simple Java Solution Runtime 3 ms\\n `your inline code...your inline code...`public int removeDuplicates(int[] nums) {\\n        LinkedHashSet<Integer> set=new LinkedHashSet<>();\\n        int k=0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tset.add(nums[i]);\\n\\t\\t}\\n        Iterator<Integer> itr=set.iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\t\\t\\tnums[k++]=itr.next();\\n\\t\\t}\\n\\t\\treturn set.size();\\n    }"
                    },
                    {
                        "username": "ColeWheatley",
                        "content": "So I answered it as expected, read the comments, got real lazy and just wrote a for loop rewriting the \"nums\" input over with my output array, then I returned  just the output array\\'s length. Their problem goes back and checks the first \"returned\" entries into the overwritten nums array. GL"
                    },
                    {
                        "username": "shoaib599",
                        "content": "Here we dont have to sort the array we just need to return how many elements are unique in that array so what we\\'ll do here we will keep a pointer j=1 then we will itterate the whole array and we will increase the pointer as we will get any unique element there for eg increase the pointer when nums[i]!=nums[i+1] and at last return the pointer "
                    },
                    {
                        "username": "deepak130797",
                        "content": "very question this is you only have to do push all the elements in set and return the size of set "
                    },
                    {
                        "username": "shruti02",
                        "content": "My solution is taking 92ms.  \\n\\n result = 0\\n        for i in range(len(nums)):\\n            if nums[i] > nums[result]:\\n                result = result + 1\\n                nums[result] = nums[i]\\n        return result + 1"
                    }
                ]
            },
            {
                "id": 1710016,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1706757,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1705214,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1704631,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1698207,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1696994,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1695658,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1693520,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1692065,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1686197,
                "content": [
                    {
                        "username": "vivekchaudhary22",
                        "content": " `class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n     set<int> s(nums.begin(),nums.end());\\n     nums.assign(s.begin(),s.end());\\n     int k=s.size();\\n     return k;\\n    }\\n};`"
                    },
                    {
                        "username": "Pritesh_Bagaria",
                        "content": "nums = list(set(nums))\\nthis works fine in editor but here this solution is not getting accepted and shows different o/p. can somebody throw some light on this?"
                    },
                    {
                        "username": "Kamal_Moha",
                        "content": "My code executes and returns the correct answer, but Leetcode refuses for whatever reason & I\\'m just confused\\n ``def removeDuplicates(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        lst = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in nums[i+1:]:\\n                lst.append(nums[i])\\n            i += 1\\n        return lst``\\n\\nI get a TypeError and I don\\'t understand why.\\n\\n`TypeError: [1, 2] is not valid value for the expected return type integer[]\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer[]\");\\nLine 40 in _driver (Solution.py)\\n    _driver()\\nLine 46 in <module> (Solution.py)`\\n\\nPlz help"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2874837/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "reton2008",
                        "content": "The description is tricky, they said removing duplicates return the result as in case 1 but in second case they count the number of unique integers only. so ans hidden in case 2 all other informations are just done for creating confusion."
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\n\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n\n        nums[:] = set(nums)\n\n        nums[:] = sorted(nums)\n\n        return len(nums)"
                    },
                    {
                        "username": "vishnusuresh1995",
                        "content": "Why is expected output [1] when input is [1,1]. Shouldn\\'t the output also be [1,1]. could someone please explain?"
                    },
                    {
                        "username": "izam-mohammed",
                        "content": "I am really confused about this question. What should I return in this. The new array or the length of it ?"
                    },
                    {
                        "username": "SaiSusshanth",
                        "content": "Try making changes to the given array, the judge in this situation checks the array as well as the answer so the values in the array also need to changed."
                    },
                    {
                        "username": "shindepranav820",
                        "content": "Please let me know what is going wrong with my solution.\\n \\nlet expectedNums = []\\n  for (let i = 0; i < nums.length; i++) {\\n      if (!expectedNums.includes(nums[i])) {\\n          expectedNums.push(nums[i])\\n      }\\n  }\\n return expectedNums.length"
                    },
                    {
                        "username": "ankurdahiya",
                        "content": "my code is working fine on my pc but getting runtime error on leetcode why?\\n\\nc++\\n\\nclass Solution {\\npublic:\\nint removeDuplicates(vector& nums) {\\nif(nums.size()==0){return 0;}\\nint tempnum,k = 0;\\nfor(int i = 0;i<nums.size();i++){\\nk++;\\ntempnum = nums[i];\\nlong long int j = i+1;\\nwhile(!(tempnum<nums[j]) && j<nums.size()){\\nj++;\\n}\\nif(j<nums.size()){\\nnums[i+1] = nums[j];\\n}\\nelse{\\nbreak;\\n}\\n}\\nreturn k;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1684225,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1681972,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1680878,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679929,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679884,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679871,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679713,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679634,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679545,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679495,
                "content": [
                    {
                        "username": "WaterPotato",
                        "content": "class Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n=len(nums)\\n        nums=sorted(nums)\\n        j=1\\n        i=1\\n        while j<n:\\n            if nums[j]==nums[j-1]:\\n                j+=1\\n            else:\\n                nums[i]=nums[j]\\n                j+=1\\n                i+=1\\n        return i\\n\\nI run this python code in my VSC and it really works, but when I run it in leetcode, it cannot pass the checker. Could someone tell me the reason? Thank you!!!"
                    },
                    {
                        "username": "Harsha81",
                        "content": "var removeDuplicates = function(nums) {\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i] === nums[i+1]){\\n            nums.splice(i,1)\\n            i--\\n        }\\n    }\\n   \\n}\\n\\nsmall doubt : \\ncan anyone tell me why it\\'s give me the answer but here I\\'m not even write return in the function if i don\\'t write return the in the function it should give me undefined but it\\'s giving the correct answer in leetcode...but in my VS code it\\'s giving undefined because the return in not there in function....please need explanation"
                    },
                    {
                        "username": "2100520139004",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "\\n \\n     class Solution {\\n       public int removeDuplicates(int[] nums) {\\n         int index = 1;\\n         for(int i=0; i< nums.length - 1 ; i++){\\n            if(nums[i] != nums[i+1]){\\n                nums[index++] = nums[i+1];\\n            }\\n        }\\n        return index;\\n    }\\n}\\n//this is the question asked in many companies like google, facebook  , walmart , microsoft "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Insert all the elements in the ordered set, as it don`t take duplicates.\\nThen clear the array or make a new array and put all the set elements into the new array or the previous array(nums).\\nReturn the size of the nums/the newly created array."
                    },
                    {
                        "username": "user0218d",
                        "content": "wow how smart LOL\\nProblem clearly says not to use additional space"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Please tell me this error corresponds to leetcode main() and not mine . Attempting to solve this\\n\\njava.lang.IllegalArgumentException: -1\\n  at line 568, java.base/java.util.stream.ReferencePipeline.limit\\n\\tat __Serializer__.serialize(Unknown Source)\\n\\tat __Serializer__.serialize(Unknown Source)\\n  at line 89, __Driver__.main"
                    },
                    {
                        "username": "rreocode",
                        "content": "```\\n        slow, fast = 0, 1\\n\\n        while fast < len(nums):\\n            if nums[fast] != nums[slow]:\\n                slow += 1\\n                nums[slow] = nums[fast]\\n            fast += 1\\n```\\nwhy is this not allowed"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You were almost there!\\njust add \\'return slow+1\\' in the end of the method."
                    },
                    {
                        "username": "alistairstpierre",
                        "content": "This makes no sense... "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": " <h1 style=\"color: red;\"> It\\'s not that difficult, go through the problem statement again </h1>"
                    },
                    {
                        "username": "rupamkarmakarcr7",
                        "content": "i guess the Examples of test cases are not explained correctly that's why we are facing problem while solving with python\nas the examples says its returning an int but in test cases its returning the new list (after removing the duplicate elements). "
                    }
                ]
            },
            {
                "id": 1679489,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1679381,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1679288,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1676898,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1676822,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1671285,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1668230,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1667650,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1667264,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            },
            {
                "id": 1653834,
                "content": [
                    {
                        "username": "yashmondal5006",
                        "content": "please can anyone help me by explaining why are we returning k instead of new nums ??\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "IMO.. this problem want you to use the given array nums. And we have to replace values, not make new array. (in-place)\\nSo, we\\'re needed to changed given array to be sorted and not be duplicated in k elements from the start. "
                    },
                    {
                        "username": "dgonzalesi",
                        "content": "Seems like it dont work in ruby, using one method, using a map, a for any of the options works always send an error, even if i just print the arguments [Screenshot](https://drive.google.com/file/d/19B08axFJg584n4hTbtutCXWqwo1StvPl/view?usp=share_link)"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Used 2 pointer approach with little variation(standard approach)  : )\\n\\n```\\nwhile(j < nums.size()) {\\n   while(j < nums.size() && nums[i] == nums[j]) j++;\\n   if(j == nums.size()) break; \\n   nums[k] = nums[j];\\n   i = j;\\n   k++;\\n}\\n```"
                    },
                    {
                        "username": "sirDavid97",
                        "content": "Small py3 solution:\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=len(list(dict.fromkeys(nums)))\\n        new_nums = list(dict.fromkeys(nums))\\n        for i in range(0 , len(new_nums)):\\n            while new_nums[i] != nums[i]:\\n                nums.pop(i)\\n                nums.append(\\'_\\')\\n        return k"
                    },
                    {
                        "username": "rahulSrivastava05",
                        "content": "Efficient Approach : \\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() == 0) return 0;\\n        int res = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] != nums[res-1]){\\n                nums[res] = nums[i];\\n                res++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-duplicates-from-sorted-array-problem-solution.html)"
                    },
                    {
                        "username": "DevyaniVashishth",
                        "content": "var removeDuplicates = function(nums) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length - 1; i++){\\nif(nums[i] !== nums[i + 1]){\\narr.push(nums[i])\\n\\n}\\n    }\\n     arr.push(nums[nums.length - 1]);\\n     // let  l = arr.length;\\n     return arr;\\n};     this code is working fine on freecodecamp console... but here it shows error. i dont know  why is that so, if someone could help me out. i ll be gratefful"
                    },
                    {
                        "username": "blackishigh",
                        "content": "My solution\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int kIndex = 0;\\n        int kValue = nums[0];\\n        for(int point = 0 ; point < nums.length -1  ; point ++) {\\n            if(kValue < nums[point+1]) {\\n                int nowKValue = nums[point+1];\\n                nums[point + 1] =  kValue;\\n                nums[kIndex + 1] = nowKValue;\\n                kValue = nowKValue;\\n                kIndex ++ ;\\n            }\\n        }\\n        return kIndex + 1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Odegaa",
                        "content": "if (nums.length <= 1) {\\n            return nums.length;\\n        }\\n\\n        Arrays.sort(nums);\\n        List<Integer> duplicateNumbers = new ArrayList<>();\\n\\n        for (int num : nums) {\\n            duplicateNumbers.add(num);\\n        }\\n\\n        for (int i = 0; i < duplicateNumbers.size(); i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    duplicateNumbers.remove(nums[i]);\\n                }\\n            }\\n        }\\n        int [] newArray = new int[duplicateNumbers.size()];\\n\\n        for (int i = 0; i < newArray.length; i++) {\\n            newArray[i] = duplicateNumbers.get(i);\\n        }\\n\\n        return newArray.length;\\n\\n\\nWHY??\\n"
                    },
                    {
                        "username": "valibraimi",
                        "content": "Its easy but needed simpler explanation but overall was easy to solve, it took 6 mins or less."
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Ladder II",
        "question_content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 40434,
                "title": "c-solution-using-standard-bfs-method-no-dfs-or-backtracking",
                "content": "I have struggled with this problem for a long time because nearly all the solution on the web is too long or too tricky and can hardly be remembered during the interview.\\n\\nIn fact, this problem can be solved with a very standard BFS process, whose structure could haven been written by you for many many times (using while loop and a queue).\\nThe following code is written in a very standard BFS method, which is easy to memorize. \\n\\nThe only tricky thing you need to remember is this is a BFS of paths not words!\\nSo the element is the queue is a vector. That's it.\\n\\n```\\n    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {\\n        //very interesting problem\\n        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!\\n        //Then the queue becomes a queue of paths.\\n        vector<vector<string>> ans;\\n        queue<vector<string>> paths;\\n        wordList.insert(endWord);\\n        paths.push({beginWord});\\n        int level = 1;\\n        int minLevel = INT_MAX;\\n        \\n        //\"visited\" records all the visited nodes on this level\\n        //these words will never be visited again after this level \\n        //and should be removed from wordList. This is guaranteed\\n        // by the shortest path.\\n        unordered_set<string> visited; \\n        \\n        while (!paths.empty()) {\\n            vector<string> path = paths.front();\\n            paths.pop();\\n            if (path.size() > level) {\\n                //reach a new level\\n                for (string w : visited) wordList.erase(w);\\n                visited.clear();\\n                if (path.size() > minLevel)\\n                    break;\\n                else\\n                    level = path.size();\\n            }\\n            string last = path.back();\\n            //find next words in wordList by changing\\n            //each element from 'a' to 'z'\\n            for (int i = 0; i < last.size(); ++i) {\\n                string news = last;\\n                for (char c = 'a'; c <= 'z'; ++c) {\\n                    news[i] = c;\\n                    if (wordList.find(news) != wordList.end()) {\\n                    //next word is in wordList\\n                    //append this word to path\\n                    //path will be reused in the loop\\n                    //so copy a new path\\n                        vector<string> newpath = path;\\n                        newpath.push_back(news);\\n                        visited.insert(news);\\n                        if (news == endWord) {\\n                            minLevel = level;\\n                            ans.push_back(newpath);\\n                        }\\n                        else\\n                            paths.push(newpath);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {\\n        //very interesting problem\\n        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!\\n        //Then the queue becomes a queue of paths.\\n        vector<vector<string>> ans;\\n        queue<vector<string>> paths;\\n        wordList.insert(endWord);\\n        paths.push({beginWord});\\n        int level = 1;\\n        int minLevel = INT_MAX;\\n        \\n        //\"visited\" records all the visited nodes on this level\\n        //these words will never be visited again after this level \\n        //and should be removed from wordList. This is guaranteed\\n        // by the shortest path.\\n        unordered_set<string> visited; \\n        \\n        while (!paths.empty()) {\\n            vector<string> path = paths.front();\\n            paths.pop();\\n            if (path.size() > level) {\\n                //reach a new level\\n                for (string w : visited) wordList.erase(w);\\n                visited.clear();\\n                if (path.size() > minLevel)\\n                    break;\\n                else\\n                    level = path.size();\\n            }\\n            string last = path.back();\\n            //find next words in wordList by changing\\n            //each element from 'a' to 'z'\\n            for (int i = 0; i < last.size(); ++i) {\\n                string news = last;\\n                for (char c = 'a'; c <= 'z'; ++c) {\\n                    news[i] = c;\\n                    if (wordList.find(news) != wordList.end()) {\\n                    //next word is in wordList\\n                    //append this word to path\\n                    //path will be reused in the loop\\n                    //so copy a new path\\n                        vector<string> newpath = path;\\n                        newpath.push_back(news);\\n                        visited.insert(news);\\n                        if (news == endWord) {\\n                            minLevel = level;\\n                            ans.push_back(newpath);\\n                        }\\n                        else\\n                            paths.push(newpath);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40475,
                "title": "my-concise-java-solution-based-on-bfs-and-dfs",
                "content": "**Explanation**\\n\\nThe basic idea is:\\n\\n1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node's next level neighbors to HashMap;\\n\\n2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. \\n\\n```\\npublic List<List<String>> findLadders(String start, String end, List<String> wordList) {\\n   HashSet<String> dict = new HashSet<String>(wordList);\\n   List<List<String>> res = new ArrayList<List<String>>();         \\n   HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node\\n   HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node\\n   ArrayList<String> solution = new ArrayList<String>();\\n\\n   dict.add(start);          \\n   bfs(start, end, dict, nodeNeighbors, distance);                 \\n   dfs(start, end, dict, nodeNeighbors, distance, solution, res);   \\n   return res;\\n}\\n\\n// BFS: Trace every node's distance from the start node (level by level).\\nprivate void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {\\n  for (String str : dict)\\n      nodeNeighbors.put(str, new ArrayList<String>());\\n\\n  Queue<String> queue = new LinkedList<String>();\\n  queue.offer(start);\\n  distance.put(start, 0);\\n\\n  while (!queue.isEmpty()) {\\n      int count = queue.size();\\n      boolean foundEnd = false;\\n      for (int i = 0; i < count; i++) {\\n          String cur = queue.poll();\\n          int curDistance = distance.get(cur);                \\n          ArrayList<String> neighbors = getNeighbors(cur, dict);\\n\\n          for (String neighbor : neighbors) {\\n              nodeNeighbors.get(cur).add(neighbor);\\n              if (!distance.containsKey(neighbor)) {// Check if visited\\n                  distance.put(neighbor, curDistance + 1);\\n                  if (end.equals(neighbor))// Found the shortest path\\n                      foundEnd = true;\\n                  else\\n                      queue.offer(neighbor);\\n                  }\\n              }\\n          }\\n\\n          if (foundEnd)\\n              break;\\n      }\\n  }\\n\\n// Find all next level nodes.    \\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\\n  ArrayList<String> res = new ArrayList<String>();\\n  char chs[] = node.toCharArray();\\n\\n  for (char ch ='a'; ch <= 'z'; ch++) {\\n      for (int i = 0; i < chs.length; i++) {\\n          if (chs[i] == ch) continue;\\n          char old_ch = chs[i];\\n          chs[i] = ch;\\n          if (dict.contains(String.valueOf(chs))) {\\n              res.add(String.valueOf(chs));\\n          }\\n          chs[i] = old_ch;\\n      }\\n\\n  }\\n  return res;\\n}\\n\\n// DFS: output all paths with the shortest distance.\\nprivate void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {\\n    solution.add(cur);\\n    if (end.equals(cur)) {\\n       res.add(new ArrayList<String>(solution));\\n    } else {\\n       for (String next : nodeNeighbors.get(cur)) {            \\n            if (distance.get(next) == distance.get(cur) + 1) {\\n                 dfs(next, end, dict, nodeNeighbors, distance, solution, res);\\n            }\\n        }\\n    }           \\n   solution.remove(solution.size() - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<String>> findLadders(String start, String end, List<String> wordList) {\\n   HashSet<String> dict = new HashSet<String>(wordList);\\n   List<List<String>> res = new ArrayList<List<String>>();         \\n   HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node\\n   HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node\\n   ArrayList<String> solution = new ArrayList<String>();\\n\\n   dict.add(start);          \\n   bfs(start, end, dict, nodeNeighbors, distance);                 \\n   dfs(start, end, dict, nodeNeighbors, distance, solution, res);   \\n   return res;\\n}\\n\\n// BFS: Trace every node's distance from the start node (level by level).\\nprivate void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {\\n  for (String str : dict)\\n      nodeNeighbors.put(str, new ArrayList<String>());\\n\\n  Queue<String> queue = new LinkedList<String>();\\n  queue.offer(start);\\n  distance.put(start, 0);\\n\\n  while (!queue.isEmpty()) {\\n      int count = queue.size();\\n      boolean foundEnd = false;\\n      for (int i = 0; i < count; i++) {\\n          String cur = queue.poll();\\n          int curDistance = distance.get(cur);                \\n          ArrayList<String> neighbors = getNeighbors(cur, dict);\\n\\n          for (String neighbor : neighbors) {\\n              nodeNeighbors.get(cur).add(neighbor);\\n              if (!distance.containsKey(neighbor)) {// Check if visited\\n                  distance.put(neighbor, curDistance + 1);\\n                  if (end.equals(neighbor))// Found the shortest path\\n                      foundEnd = true;\\n                  else\\n                      queue.offer(neighbor);\\n                  }\\n              }\\n          }\\n\\n          if (foundEnd)\\n              break;\\n      }\\n  }\\n\\n// Find all next level nodes.    \\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\\n  ArrayList<String> res = new ArrayList<String>();\\n  char chs[] = node.toCharArray();\\n\\n  for (char ch ='a'; ch <= 'z'; ch++) {\\n      for (int i = 0; i < chs.length; i++) {\\n          if (chs[i] == ch) continue;\\n          char old_ch = chs[i];\\n          chs[i] = ch;\\n          if (dict.contains(String.valueOf(chs))) {\\n              res.add(String.valueOf(chs));\\n          }\\n          chs[i] = old_ch;\\n      }\\n\\n  }\\n  return res;\\n}\\n\\n// DFS: output all paths with the shortest distance.\\nprivate void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {\\n    solution.add(cur);\\n    if (end.equals(cur)) {\\n       res.add(new ArrayList<String>(solution));\\n    } else {\\n       for (String next : nodeNeighbors.get(cur)) {            \\n            if (distance.get(next) == distance.get(cur) + 1) {\\n                 dfs(next, end, dict, nodeNeighbors, distance, solution, res);\\n            }\\n        }\\n    }           \\n   solution.remove(solution.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40482,
                "title": "python-simple-bfs-layer-by-layer",
                "content": "```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n\\n        wordList = set(wordList)\\n        res = []\\n        layer = {}\\n        layer[beginWord] = [[beginWord]]\\n\\n        while layer:\\n            newlayer = collections.defaultdict(list)\\n            for w in layer:\\n                if w == endWord: \\n                    res.extend(k for k in layer[w])\\n                else:\\n                    for i in range(len(w)):\\n                        for c in 'abcdefghijklmnopqrstuvwxyz':\\n                            neww = w[:i]+c+w[i+1:]\\n                            if neww in wordList:\\n                                newlayer[neww]+=[j+[neww] for j in layer[w]]\\n\\n            wordList -= set(newlayer.keys())\\n            layer = newlayer\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n\\n        wordList = set(wordList)\\n        res = []\\n        layer = {}\\n        layer[beginWord] = [[beginWord]]\\n\\n        while layer:\\n            newlayer = collections.defaultdict(list)\\n            for w in layer:\\n                if w == endWord: \\n                    res.extend(k for k in layer[w])\\n                else:\\n                    for i in range(len(w)):\\n                        for c in 'abcdefghijklmnopqrstuvwxyz':\\n                            neww = w[:i]+c+w[i+1:]\\n                            if neww in wordList:\\n                                newlayer[neww]+=[j+[neww] for j in layer[w]]\\n\\n            wordList -= set(newlayer.keys())\\n            layer = newlayer\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269012,
                "title": "python-bfs-backtrack-greatly-improved-by-bi-directional-bfs",
                "content": "An intuitive solution is to use BFS to find shorterst transformation path from begin word to end word. A valid transformation is to change any one character and transformed word should be in the a word list.\\n\\nWhat is tricker than #127 is that we need to find all shortest paths. Thus, we need to build a search tree during BFS and backtrack along that tree to restore all shortest paths. \\nSo we can\\'t stop BFS once we found a transformed word is endword but instead finishing searching is this BFS layer since there could be more than one shortest path.\\nAnd we still need to rule out all node that we have searched previously. Meanwhile if two nodes have a same child node, we need to add that child node to both node\\'s children list as we need to backtrack all valid paths. So unlike a regular BFS, we can\\'t use a \"seen\" set but a more like \"explored\" set. Otherwise, e.g. tree: {x->z, y->z}, z won\\'t be added to y\\'s children list if x is visited first and z is already seen in x\\'s search.\\n```\\ndef findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, q, nq = False, {beginWord}, set()\\n\\twhile q and not found:\\n\\t\\twords -= set(q)\\n\\t\\tfor x in q:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y == endWord: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[x].add(y)\\n\\t\\tq, nq = nq, set()\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n\\treturn bt(beginWord)\\n```\\nThat\\'s single one-way BFS which cost more than 2500ms. BFS\\'t time complexity is O(b^d) where  b is branch factor and d is depth. So if we go with a bi-directional way, expanding from both being word and end word, and choosing the queue (\\'begin\\' queue or \\'end\\' queue) with smaller size in each expansion, the branch factor will be greatly reduced.\\nAnd bi-directional BFS reducing running time from 2500ms to 100ms!\\n```\\ndef findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, bq, eq, nq, rev = False, {beginWord}, {endWord}, set(), False\\n\\twhile bq and not found:\\n\\t\\twords -= set(bq)\\n\\t\\tfor x in bq:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y in eq: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[y].add(x) if rev else tree[x].add(y)\\n\\t\\tbq, nq = nq, set()\\n\\t\\tif len(bq) > len(eq): \\n\\t\\t\\tbq, eq, rev = eq, bq, not rev\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n\\treturn bt(beginWord)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, q, nq = False, {beginWord}, set()\\n\\twhile q and not found:\\n\\t\\twords -= set(q)\\n\\t\\tfor x in q:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y == endWord: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[x].add(y)\\n\\t\\tq, nq = nq, set()\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n\\treturn bt(beginWord)\\n```\n```\\ndef findLadders(beginWord, endWord, wordList):\\n\\ttree, words, n = collections.defaultdict(set), set(wordList), len(beginWord)\\n\\tif endWord not in wordList: return []\\n\\tfound, bq, eq, nq, rev = False, {beginWord}, {endWord}, set(), False\\n\\twhile bq and not found:\\n\\t\\twords -= set(bq)\\n\\t\\tfor x in bq:\\n\\t\\t\\tfor y in [x[:i]+c+x[i+1:] for i in range(n) for c in string.ascii_lowercase]:\\n\\t\\t\\t\\tif y in words:\\n\\t\\t\\t\\t\\tif y in eq: \\n\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\t\\tnq.add(y)\\n\\t\\t\\t\\t\\ttree[y].add(x) if rev else tree[x].add(y)\\n\\t\\tbq, nq = nq, set()\\n\\t\\tif len(bq) > len(eq): \\n\\t\\t\\tbq, eq, rev = eq, bq, not rev\\n\\tdef bt(x): \\n\\t\\treturn [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)]\\n\\treturn bt(beginWord)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1359027,
                "title": "c-python-bfs-level-by-level-with-picture-clean-concise",
                "content": "**Idea**\\n- This problem is an advanced version of **[127. Word Ladder](https://leetcode.com/problems/word-ladder/)**, I highly recommend solving it first if you haven\\'t solved it yet.\\n- To find the shortest path from `beginWord` to `endWord`, we need to use BFS.\\n- To find neighbors of a `word`, we just try to change each position from the original `word`, each position we try to change letters from `a..z`, the neighbors are valid if and only if they\\'re existed in the `wordList`.\\n- The problem is required to output the answer sequence paths, so we need to store sequences path so far while doing bfs.\\n\\t- Let `level[word]` is the all possible sequence paths which start from `beginWord` and end at `word`. \\n\\t- Then `level[endWord]` is our answer.\\n\\n![image](https://assets.leetcode.com/users/images/b922ec67-ab63-4768-beb5-ad108083c4c9_1627123895.1947684.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/6pRoqS4A/shared\" frameBorder=\"0\" width=\"100%\" height=\"720\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * 26 * W^2 + A)`, where `N <= 1000` is number of words  in `wordList`, `W <= 5` is length of each words, `A` is total number of sequences.\\n\\t- BFS costs `O(E + V)`, where `E` is number of edges, `V` is number of vertices.\\n\\t- Because words need to be existed in the `wordList`, so there is total `N` words, it\\'s also the number of vertices.\\n\\t- To find neighbors for a `word`, it costs `O(26 * W * W)`, in the worst case, we have to find the neighbors of `N` words, so there is total `O(N * 26 * W^2)` edges.\\n- Space: `O(N*W + A)`\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- This problem is an advanced version of **[127. Word Ladder](https://leetcode.com/problems/word-ladder/)**, I highly recommend solving it first if you haven\\'t solved it yet.\\n- To find the shortest path from `beginWord` to `endWord`, we need to use BFS.\\n- To find neighbors of a `word`, we just try to change each position from the original `word`, each position we try to change letters from `a..z`, the neighbors are valid if and only if they\\'re existed in the `wordList`.\\n- The problem is required to output the answer sequence paths, so we need to store sequences path so far while doing bfs.\\n\\t- Let `level[word]` is the all possible sequence paths which start from `beginWord` and end at `word`. \\n\\t- Then `level[endWord]` is our answer.\\n\\n![image](https://assets.leetcode.com/users/images/b922ec67-ab63-4768-beb5-ad108083c4c9_1627123895.1947684.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/6pRoqS4A/shared\" frameBorder=\"0\" width=\"100%\" height=\"720\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * 26 * W^2 + A)`, where `N <= 1000` is number of words  in `wordList`, `W <= 5` is length of each words, `A` is total number of sequences.\\n\\t- BFS costs `O(E + V)`, where `E` is number of edges, `V` is number of vertices.\\n\\t- Because words need to be existed in the `wordList`, so there is total `N` words, it\\'s also the number of vertices.\\n\\t- To find neighbors for a `word`, it costs `O(26 * W * W)`, in the worst case, we have to find the neighbors of `N` words, so there is total `O(N * 26 * W^2)` edges.\\n- Space: `O(N*W + A)`\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 2421786,
                "title": "c-using-bfs-and-backtracking-no-tle",
                "content": "This solution relies on first finding the shortest transformation length between the beginWord and endWord strings and then performing a recursive backtrack to find all possible paths of the same length.\\n\\nWe start by checking if endWord is in the wordList; if it isn\\'t, we cannot have a path from beginWord to endWord. Then, we perform a breadth-first search on our \"graph\" of words. The vertices in this graph are defined by words in our wordList, while edges between two vertices exist if we canTransform the words into each other (i.e. change one of the letters to arrive at a new word). While performing this search, we keep track of the parents of each word (this will allow us to recursively construct all valid paths later on). In this problem, since we are keeping track of a directed series of transformations, if we transform string a into string b, we say that a is a parent of b, and we track this in our parents map, which stores all the parents we encounter for a particular word. Note that we only care about relevant parents on the shortest path to a word, since we are trying to find the shortest path from source to destination, and once we have encountered a word, if we encounter it again on a longer path this new path cannot be the shortest path from beginWord to endWord.\\n\\nNow, once we find the endWord, we keep track of the shortestpath length in variable. Note that once we find this, since we are keeping track of a word\\'s parent at the time the word is queued in traverse, all possible parents that have a shortest path length for endWord must already be accounted for.\\n\\nFinally, we recursively trace back through each node\\'s parents (starting at endWord) and construct all valid paths. At each function call, we go through all possible parents for a given word, and if we arrive at the beginWord in the correct amount of steps, we add the path to our answer. Since we construct these paths in reverse order, we must invert them all at the end.\\n\\n\\t// BFS gives TLE if we store path while traversing because whenever we find a better visit time for a word, we have to clear/make a new path vector everytime. \\n\\t// The idea is to first use BFS to search from beginWord to endWord and generate the word-to-children mapping at the same time. \\n\\t// Then, use DFS (backtracking) to generate the transformation sequences according to the mapping. \\n\\t// The reverse DFS allows us to only make the shortest paths, never having to clear a whole sequence when we encounter better result in BFS\\n\\t// No string operations are done, by dealing with indices instead.\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool able(string s,string t){\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n            c+=(s[i]!=t[i]);\\n        return c==1;\\n    }\\n    void bfs(vector<vector<int>> &g,vector<int> parent[],int n,int start,int end){\\n        vector <int> dist(n,1005);\\n        queue <int> q;\\n        q.push(start);\\n        parent[start]={-1};\\n        dist[start]=0;\\n        while(!q.empty()){\\n            int x=q.front();\\n            q.pop();\\n            for(int u:g[x]){\\n                if(dist[u]>dist[x]+1){\\n                    dist[u]=dist[x]+1;\\n                    q.push(u);\\n                    parent[u].clear();\\n                    parent[u].push_back(x);\\n                }\\n                else if(dist[u]==dist[x]+1)\\n                    parent[u].push_back(x);\\n            }\\n        }\\n    }\\n    void shortestPaths(vector<vector<int>> &Paths, vector<int> &path, vector<int> parent[],int node){\\n        if(node==-1){\\n            // as parent of start was -1, we\\'ve completed the backtrack\\n            Paths.push_back(path);\\n            return ;\\n        }\\n        for(auto u:parent[node]){\\n            path.push_back(u);\\n            shortestPaths(Paths,path,parent,u);\\n            path.pop_back();\\n        }\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        // start and end are indices of beginWord and endWord\\n        int n=wordList.size(),start=-1,end=-1;\\n        vector<vector<string>> ANS;\\n        for(int i=0;i<n;i++){\\n            if(wordList[i]==beginWord)\\n                start=i;\\n            if(wordList[i]==endWord)\\n                end=i;\\n        }\\n        \\n        // if endWord doesn\\'t exist, return empty list\\n        if(end==-1)\\n            return ANS;\\n        \\n        // if beginWord doesn\\'t exist, add it in start of WordList\\n        if(start==-1){\\n            wordList.emplace(wordList.begin(),beginWord);\\n            start=0;\\n            end++;\\n            n++;\\n        }\\n        // for each word, we\\'re making adjency list of neighbour words (words that can be made with one letter change)\\n        // Paths will store all the shortest paths (formed later by backtracking)\\n        vector<vector<int>> g(n,vector<int>()),Paths;\\n        \\n        // storing possible parents for each word (to backtrack later), path is the current sequence (while backtracking)\\n        vector<int> parent[n],path;\\n        \\n        // creating adjency list for each pair of words in the wordList (including beginword)\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(able(wordList[i],wordList[j])){\\n                    g[i].push_back(j);\\n                    g[j].push_back(i);\\n                }\\n        \\n        bfs(g,parent,n,start,end); \\n        \\n        // backtracking to make shortestpaths\\n        shortestPaths(Paths,path,parent,end);\\n        for(auto u:Paths){\\n            vector <string> now;\\n            for(int i=0;i<u.size()-1;i++)\\n                now.push_back(wordList[u[i]]);\\n            reverse(now.begin(),now.end());\\n            now.push_back(wordList[end]);\\n            ANS.push_back(now);\\n        }\\n        return ANS;\\n    }\\n\\t}; \\n\\t\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community).**\\n\\n**HAPPY CODING:)**\\n\\n*Any suggestions and improvements are always welcome*\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool able(string s,string t){\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n            c+=(s[i]!=t[i]);\\n        return c==1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 40447,
                "title": "share-two-similar-java-solution-that-accpted-by-oj",
                "content": "The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. \\n\\nThe first step BFS is quite important. I summarized three tricks\\n\\n1) Using a **MAP** to store the min ladder of each word, or use a **SET** to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That's why I have two similar solutions. \\n\\n\\n2) Use **Character iteration** to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.\\n\\n\\n3) One word is allowed to be inserted into the queue only **ONCE**. See my comments.\\n\\n\\n    public class Solution {\\n    \\tMap<String,List<String>> map;\\n    \\tList<List<String>> results;\\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {   \\t\\n            results= new ArrayList<List<String>>();\\n            if (dict.size() == 0)\\n    \\t\\t\\treturn results;\\n            \\n            int min=Integer.MAX_VALUE;\\n            \\n            Queue<String> queue= new ArrayDeque<String>();\\n            queue.add(start);\\n            \\n    \\t\\tmap = new HashMap<String,List<String>>();\\n    \\t\\t\\n    \\t\\tMap<String,Integer> ladder = new HashMap<String,Integer>();\\n    \\t\\tfor (String string:dict)\\n    \\t\\t    ladder.put(string, Integer.MAX_VALUE);\\n    \\t\\tladder.put(start, 0);\\n    \\t\\t\\t\\t\\n    \\t\\tdict.add(end);\\n    \\t\\t//BFS: Dijisktra search\\n    \\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t   \\n    \\t\\t\\tString word = queue.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tint step = ladder.get(word)+1;//'step' indicates how many steps are needed to travel to one word. \\n    \\t\\t\\t\\n    \\t\\t\\tif (step>min) break;\\n    \\t\\t\\t\\n    \\t\\t\\tfor (int i = 0; i < word.length(); i++){\\n    \\t\\t\\t   StringBuilder builder = new StringBuilder(word); \\n    \\t\\t\\t\\tfor (char ch='a';  ch <= 'z'; ch++){\\n    \\t\\t\\t\\t\\tbuilder.setCharAt(i,ch);\\n    \\t\\t\\t\\t\\tString new_word=builder.toString();\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (ladder.containsKey(new_word)) {\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t    if (step>ladder.get(new_word))//Check if it is the shortest path to one word.\\n    \\t\\t\\t\\t\\t    \\tcontinue;\\n    \\t\\t\\t\\t\\t    else if (step<ladder.get(new_word)){\\n    \\t\\t\\t\\t\\t    \\tqueue.add(new_word);\\n    \\t\\t\\t\\t\\t    \\tladder.put(new_word, step);\\n    \\t\\t\\t\\t\\t    }else;// It is a KEY line. If one word already appeared in one ladder,\\n    \\t\\t\\t\\t\\t          // Do not insert the same word inside the queue twice. Otherwise it gets TLE.\\n    \\t\\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\t    if (map.containsKey(new_word)) //Build adjacent Graph\\n    \\t\\t\\t\\t\\t    \\tmap.get(new_word).add(word);\\n    \\t\\t\\t\\t\\t    else{\\n    \\t\\t\\t\\t\\t    \\tList<String> list= new LinkedList<String>();\\n    \\t\\t\\t\\t\\t    \\tlist.add(word);\\n    \\t\\t\\t\\t\\t    \\tmap.put(new_word,list);\\n    \\t\\t\\t\\t\\t    \\t//It is possible to write three lines in one:\\n    \\t\\t\\t\\t\\t    \\t//map.put(new_word,new LinkedList<String>(Arrays.asList(new String[]{word})));\\n    \\t\\t\\t\\t\\t    \\t//Which one is better?\\n    \\t\\t\\t\\t\\t    }\\n    \\t\\t\\t\\t\\t    \\n    \\t\\t\\t\\t\\t    if (new_word.equals(end))\\n    \\t\\t\\t\\t\\t    \\tmin=step;\\n    \\n    \\t\\t\\t\\t\\t}//End if dict contains new_word\\n    \\t\\t\\t\\t}//End:Iteration from 'a' to 'z'\\n    \\t\\t\\t}//End:Iteration from the first to the last\\n    \\t\\t}//End While\\n    \\n        \\t//BackTracking\\n    \\t\\tLinkedList<String> result = new LinkedList<String>();\\n    \\t\\tbackTrace(end,start,result);\\n    \\n    \\t\\treturn results;        \\n        }\\n        private void backTrace(String word,String start,List<String> list){\\n        \\tif (word.equals(start)){\\n        \\t\\tlist.add(0,start);\\n        \\t\\tresults.add(new ArrayList<String>(list));\\n        \\t\\tlist.remove(0);\\n        \\t\\treturn;\\n        \\t}\\n        \\tlist.add(0,word);\\n        \\tif (map.get(word)!=null)\\n        \\t\\tfor (String s:map.get(word))\\n        \\t\\t\\tbackTrace(s,start,list);\\n        \\tlist.remove(0);\\n        }\\n    }\\n\\n\\nAnother solution using two sets. This is similar to the answer in the  most viewed thread. While I found my solution more readable and efficient. \\n\\n    public class Solution {\\n    \\tList<List<String>> results;\\n    \\tList<String> list;\\n    \\tMap<String,List<String>> map;\\n    \\t    public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n    \\t        results= new ArrayList<List<String>>();\\n    \\t        if (dict.size() == 0)\\n    \\t\\t\\t\\treturn results;\\n    \\t        \\n    \\t        int curr=1,next=0;\\t        \\n    \\t        boolean found=false;\\t        \\n    \\t        list = new LinkedList<String>();\\t       \\n    \\t\\t\\tmap = new HashMap<String,List<String>>();\\n    \\t\\t\\t\\n    \\t\\t\\tQueue<String> queue= new ArrayDeque<String>();\\n    \\t\\t\\tSet<String> unvisited = new HashSet<String>(dict);\\n    \\t\\t\\tSet<String> visited = new HashSet<String>();\\n    \\t\\t\\t\\n    \\t\\t\\tqueue.add(start);\\t\\t\\t\\n    \\t\\t\\tunvisited.add(end);\\n    \\t\\t\\tunvisited.remove(start);\\n    \\t\\t\\t//BFS\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t   \\n    \\t\\t\\t\\tString word = queue.poll();\\n    \\t\\t\\t\\tcurr--;\\t\\t\\t\\t\\n    \\t\\t\\t\\tfor (int i = 0; i < word.length(); i++){\\n    \\t\\t\\t\\t   StringBuilder builder = new StringBuilder(word); \\n    \\t\\t\\t\\t\\tfor (char ch='a';  ch <= 'z'; ch++){\\n    \\t\\t\\t\\t\\t\\tbuilder.setCharAt(i,ch);\\n    \\t\\t\\t\\t\\t\\tString new_word=builder.toString();\\t\\n    \\t\\t\\t\\t\\t\\tif (unvisited.contains(new_word)){\\n    \\t\\t\\t\\t\\t\\t\\t//Handle queue\\n    \\t\\t\\t\\t\\t\\t\\tif (visited.add(new_word)){//Key statement,Avoid Duplicate queue insertion\\n    \\t\\t\\t\\t\\t\\t\\t\\tnext++;\\n    \\t\\t\\t\\t\\t\\t\\t\\tqueue.add(new_word);\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\tif (map.containsKey(new_word))//Build Adjacent Graph\\n    \\t\\t\\t\\t\\t\\t\\t\\tmap.get(new_word).add(word);\\n    \\t\\t\\t\\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\t\\t\\t\\tList<String> l= new LinkedList<String>();\\n    \\t\\t\\t\\t\\t\\t\\t\\tl.add(word);\\n    \\t\\t\\t\\t\\t\\t\\t\\tmap.put(new_word, l);\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\tif (new_word.equals(end)&&!found) found=true;\\t\\t\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\t}//End:Iteration from 'a' to 'z'\\n    \\t\\t\\t\\t}//End:Iteration from the first to the last\\n    \\t\\t\\t\\tif (curr==0){\\n    \\t\\t\\t\\t\\tif (found) break;\\n    \\t\\t\\t\\t\\tcurr=next;\\n    \\t\\t\\t\\t\\tnext=0;\\n    \\t\\t\\t\\t\\tunvisited.removeAll(visited);\\n    \\t\\t\\t\\t\\tvisited.clear();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}//End While\\n    \\n    \\t\\t\\tbackTrace(end,start);\\n    \\t\\t\\t\\n    \\t\\t\\treturn results;        \\n    \\t    }\\n    \\t    private void backTrace(String word,String start){\\n    \\t    \\tif (word.equals(start)){\\n    \\t    \\t\\tlist.add(0,start);\\n    \\t    \\t\\tresults.add(new ArrayList<String>(list));\\n    \\t    \\t\\tlist.remove(0);\\n    \\t    \\t\\treturn;\\n    \\t    \\t}\\n    \\t    \\tlist.add(0,word);\\n    \\t    \\tif (map.get(word)!=null)\\n    \\t    \\t\\tfor (String s:map.get(word))\\n    \\t    \\t\\t\\tbackTrace(s,start);\\n    \\t    \\tlist.remove(0);\\n    \\t    }\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\tMap<String,List<String>> map;\\n    \\tList<List<String>> results;\\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {   \\t\\n            results= new ArrayList<List<String>>();\\n            if (dict.size() == 0)\\n    \\t\\t\\treturn results;\\n            \\n            int min=Integer.MAX_VALUE;\\n            \\n            Queue<String> queue= new ArrayDeque<String>();\\n            queue.add(start);\\n            \\n    \\t\\tmap = new HashMap<String,List<String>>();\\n    \\t\\t\\n    \\t\\tMap<String,Integer> ladder = new HashMap<String,Integer>();\\n    \\t\\tfor (String string:dict)\\n    \\t\\t    ladder.put(string, Integer.MAX_VALUE);\\n    \\t\\tladder.put(start, 0);\\n    \\t\\t\\t\\t\\n    \\t\\tdict.add(end);\\n    \\t\\t//BFS: Dijisktra search\\n    \\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t   \\n    \\t\\t\\tString word = queue.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tint step = ladder.get(word)+1;//'step' indicates how many steps are needed to travel to one word. \\n    \\t\\t\\t\\n    \\t\\t\\tif (step>min) break;\\n    \\t\\t\\t\\n    \\t\\t\\tfor (int i = 0; i < word.length(); i++){\\n    \\t\\t\\t   StringBuilder builder = new StringBuilder(word); \\n    \\t\\t\\t\\tfor (char ch='a';  ch <= 'z'; ch++){\\n    \\t\\t\\t\\t\\tbuilder.setCharAt(i,ch);\\n    \\t\\t\\t\\t\\tString new_word=builder.toString();\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (ladder.containsKey(new_word)) {\\n    \\t\\t\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\t    if (step>ladder.get(new_word))//Check if it is the shortest path to one word.\\n    \\t\\t\\t\\t\\t    \\tcontinue;\\n    \\t\\t\\t\\t\\t    else if (step<ladder.get(new_word)){\\n    \\t\\t\\t\\t\\t    \\tqueue.add(new_word);\\n    \\t\\t\\t\\t\\t    \\tladder.put(new_word, step);\\n    \\t\\t\\t\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 490116,
                "title": "three-python-solutions-only-bfs-bfs-dfs-bibfs-dfs",
                "content": "Solution 1, BFS, directly store the path in queue. 318 ms,  18.7 MB\\nSolution 2, BFS to build graph (parents), DFS to get the shortest path, 356 ms,  20.6 MB\\nSolution 3, biBFS to build graph (parents), DFS to get the shortest path, 224 ms,  18.9 MB\\nNote that: propocessing words as below will greatly improve the algorithm speed. \\n``` python\\n# Dictionary to hold combination of words that can be formed,\\n# from any given word. By changing one letter at a time.\\nall_combo_dict = collections.defaultdict(list)\\nfor word in wordList:\\n\\tfor i in range(L):\\n\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n```\\n\\n``` python \\n## Solution 1\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Shortest path, BFS\\n\\tans = []\\n\\tqueue = collections.deque()\\n\\tqueue.append((beginWord, [beginWord]))\\n\\tvisited = set([beginWord])\\n\\t\\n\\twhile queue and not ans:\\n\\t\\t# print(queue)\\n\\t\\tlength = len(queue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword, path = queue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == endWord:\\n\\t\\t\\t\\t\\t\\t# path.append(endword)\\n\\t\\t\\t\\t\\t\\tans.append(path+[endWord])\\n\\t\\t\\t\\t\\tif nextWord not in visited:\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tqueue.append((nextWord, path+[nextWord]))\\n\\t\\tvisited = visited.union(localVisited)\\n\\treturn ans\\n```\\n\\n```python \\n## Solution 2\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\t\"\"\"\\n\\t:type beginWord: str\\n\\t:type endWord: str\\n\\t:type wordList: List[str]\\n\\t:rtype: List[List[str]]\\n\\t\"\"\"\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Build graph, BFS\\n\\t# ans = []\\n\\tqueue = collections.deque()\\n\\tqueue.append(beginWord)\\n\\tparents = collections.defaultdict(set)\\n\\tvisited = set([beginWord])\\n\\tfound = False \\n\\tdepth = 0\\n\\twhile queue and not found:\\n\\t\\tdepth += 1 \\n\\t\\tlength = len(queue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword = queue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == word:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif nextWord not in visited:\\n\\t\\t\\t\\t\\t\\tparents[nextWord].add(word)\\n\\t\\t\\t\\t\\t\\tif nextWord == endWord:    \\n\\t\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tqueue.append(nextWord)\\n\\t\\tvisited = visited.union(localVisited)\\n\\t# print(parents)\\n\\t# Search path, DFS\\n\\tans = []\\n\\tdef dfs(node, path, d):\\n\\t\\tif d == 0:\\n\\t\\t\\tif path[-1] == beginWord:\\n\\t\\t\\t\\tans.append(path[::-1])\\n\\t\\t\\treturn \\n\\t\\tfor parent in parents[node]:\\n\\t\\t\\tpath.append(parent)\\n\\t\\t\\tdfs(parent, path, d-1)\\n\\t\\t\\tpath.pop()\\n\\tdfs(endWord, [endWord], depth)\\n\\treturn ans\\n```\\n\\n``` python\\n## Solution 3\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\t\"\"\"\\n\\t:type beginWord: str\\n\\t:type endWord: str\\n\\t:type wordList: List[str]\\n\\t:rtype: List[List[str]]\\n\\t\"\"\"\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Build graph, bi-BFS\\n\\t# ans = []\\n\\tbqueue = collections.deque()\\n\\tbqueue.append(beginWord)\\n\\tequeue = collections.deque()\\n\\tequeue.append(endWord)\\n\\tbvisited = set([beginWord])\\n\\tevisited = set([endWord])\\n\\trev = False \\n\\t#graph\\n\\tparents = collections.defaultdict(set)\\n\\tfound = False \\n\\tdepth = 0\\n\\twhile bqueue and not found:\\n\\t\\tdepth += 1 \\n\\t\\tlength = len(bqueue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword = bqueue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == word:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif nextWord not in bvisited:\\n\\t\\t\\t\\t\\t\\tif not rev:\\n\\t\\t\\t\\t\\t\\t\\tparents[nextWord].add(word)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tparents[word].add(nextWord)\\n\\t\\t\\t\\t\\t\\tif nextWord in evisited:    \\n\\t\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tbqueue.append(nextWord)\\n\\t\\tbvisited = bvisited.union(localVisited)\\n\\t\\tbqueue, bvisited, equeue, evisited, rev = equeue, evisited, bqueue, bvisited, not rev\\n\\t# print(parents)\\n\\t# print(depth)\\n\\t# Search path, DFS\\n\\tans = []\\n\\tdef dfs(node, path, d):\\n\\t\\tif d == 0:\\n\\t\\t\\tif path[-1] == beginWord:\\n\\t\\t\\t\\tans.append(path[::-1])\\n\\t\\t\\treturn \\n\\t\\tfor parent in parents[node]:\\n\\t\\t\\tpath.append(parent)\\n\\t\\t\\tdfs(parent, path, d-1)\\n\\t\\t\\tpath.pop()\\n\\tdfs(endWord, [endWord], depth)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "``` python\\n# Dictionary to hold combination of words that can be formed,\\n# from any given word. By changing one letter at a time.\\nall_combo_dict = collections.defaultdict(list)\\nfor word in wordList:\\n\\tfor i in range(L):\\n\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n```\n``` python \\n## Solution 1\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Shortest path, BFS\\n\\tans = []\\n\\tqueue = collections.deque()\\n\\tqueue.append((beginWord, [beginWord]))\\n\\tvisited = set([beginWord])\\n\\t\\n\\twhile queue and not ans:\\n\\t\\t# print(queue)\\n\\t\\tlength = len(queue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword, path = queue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == endWord:\\n\\t\\t\\t\\t\\t\\t# path.append(endword)\\n\\t\\t\\t\\t\\t\\tans.append(path+[endWord])\\n\\t\\t\\t\\t\\tif nextWord not in visited:\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tqueue.append((nextWord, path+[nextWord]))\\n\\t\\tvisited = visited.union(localVisited)\\n\\treturn ans\\n```\n```python \\n## Solution 2\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\t\"\"\"\\n\\t:type beginWord: str\\n\\t:type endWord: str\\n\\t:type wordList: List[str]\\n\\t:rtype: List[List[str]]\\n\\t\"\"\"\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Build graph, BFS\\n\\t# ans = []\\n\\tqueue = collections.deque()\\n\\tqueue.append(beginWord)\\n\\tparents = collections.defaultdict(set)\\n\\tvisited = set([beginWord])\\n\\tfound = False \\n\\tdepth = 0\\n\\twhile queue and not found:\\n\\t\\tdepth += 1 \\n\\t\\tlength = len(queue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword = queue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == word:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif nextWord not in visited:\\n\\t\\t\\t\\t\\t\\tparents[nextWord].add(word)\\n\\t\\t\\t\\t\\t\\tif nextWord == endWord:    \\n\\t\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tqueue.append(nextWord)\\n\\t\\tvisited = visited.union(localVisited)\\n\\t# print(parents)\\n\\t# Search path, DFS\\n\\tans = []\\n\\tdef dfs(node, path, d):\\n\\t\\tif d == 0:\\n\\t\\t\\tif path[-1] == beginWord:\\n\\t\\t\\t\\tans.append(path[::-1])\\n\\t\\t\\treturn \\n\\t\\tfor parent in parents[node]:\\n\\t\\t\\tpath.append(parent)\\n\\t\\t\\tdfs(parent, path, d-1)\\n\\t\\t\\tpath.pop()\\n\\tdfs(endWord, [endWord], depth)\\n\\treturn ans\\n```\n``` python\\n## Solution 3\\ndef findLadders(self, beginWord, endWord, wordList):\\n\\t\"\"\"\\n\\t:type beginWord: str\\n\\t:type endWord: str\\n\\t:type wordList: List[str]\\n\\t:rtype: List[List[str]]\\n\\t\"\"\"\\n\\tif not endWord or not beginWord or not wordList or endWord not in wordList \\\\\\n\\t\\tor beginWord == endWord:\\n\\t\\treturn []\\n\\n\\tL = len(beginWord)\\n\\n\\t# Dictionary to hold combination of words that can be formed,\\n\\t# from any given word. By changing one letter at a time.\\n\\tall_combo_dict = collections.defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i in range(L):\\n\\t\\t\\tall_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word)\\n\\n\\t# Build graph, bi-BFS\\n\\t# ans = []\\n\\tbqueue = collections.deque()\\n\\tbqueue.append(beginWord)\\n\\tequeue = collections.deque()\\n\\tequeue.append(endWord)\\n\\tbvisited = set([beginWord])\\n\\tevisited = set([endWord])\\n\\trev = False \\n\\t#graph\\n\\tparents = collections.defaultdict(set)\\n\\tfound = False \\n\\tdepth = 0\\n\\twhile bqueue and not found:\\n\\t\\tdepth += 1 \\n\\t\\tlength = len(bqueue)\\n\\t\\t# print(queue)\\n\\t\\tlocalVisited = set()\\n\\t\\tfor _ in range(length):\\n\\t\\t\\tword = bqueue.popleft()\\n\\t\\t\\tfor i in range(L):\\n\\t\\t\\t\\tfor nextWord in all_combo_dict[word[:i] + \"*\" + word[i+1:]]:\\n\\t\\t\\t\\t\\tif nextWord == word:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif nextWord not in bvisited:\\n\\t\\t\\t\\t\\t\\tif not rev:\\n\\t\\t\\t\\t\\t\\t\\tparents[nextWord].add(word)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tparents[word].add(nextWord)\\n\\t\\t\\t\\t\\t\\tif nextWord in evisited:    \\n\\t\\t\\t\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\t\\t\\tlocalVisited.add(nextWord)\\n\\t\\t\\t\\t\\t\\tbqueue.append(nextWord)\\n\\t\\tbvisited = bvisited.union(localVisited)\\n\\t\\tbqueue, bvisited, equeue, evisited, rev = equeue, evisited, bqueue, bvisited, not rev\\n\\t# print(parents)\\n\\t# print(depth)\\n\\t# Search path, DFS\\n\\tans = []\\n\\tdef dfs(node, path, d):\\n\\t\\tif d == 0:\\n\\t\\t\\tif path[-1] == beginWord:\\n\\t\\t\\t\\tans.append(path[::-1])\\n\\t\\t\\treturn \\n\\t\\tfor parent in parents[node]:\\n\\t\\t\\tpath.append(parent)\\n\\t\\t\\tdfs(parent, path, d-1)\\n\\t\\t\\tpath.pop()\\n\\tdfs(endWord, [endWord], depth)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1358803,
                "title": "word-ladder-ii-no-tle-with-approach-using-bfs",
                "content": "*Due to new testcases, the old solutions are giving TLE*\\n\\n# **APPROACH:**\\nGiven two words (beginWord and endWord), and a dictionary\\u2019s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\\n1. Only one letter can be changed at a time\\n1. Each transformed word must exist in the word list. Note that beginWordis not a transformed word.\\n\\n**MUST DO:** This question is an advanced version of 127. Word Ladder. So try that too.  [Question Link](https://leetcode.com/problems/word-ladder/)\\n\\n**EXAMPLE:** \\nHere is an example of Word Ladder\\n![image](https://assets.leetcode.com/users/images/e94132b3-fa0e-49dd-a261-2f62bd6a2ee6_1627110797.38981.jpeg)\\n\\n\\n\\n**KEEP IN MIND:**\\n* Return an empty list if there is no such transformation sequence.\\n* All words have the same length.\\n* All words contain only lowercase alphabetic characters.\\n* You may assume no duplicates in the word list.\\n* You may assume beginWord and endWord are non-empty and are not the same.\\n\\n\\u274C ***Solution - I (TLE)***\\n\\n<details>\\n<summary> Solution </summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> mp ; \\n        // Record the number of conversions required to reach this string\\n        vector<vector<string>> ans ;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) \\n        {\\n            mp.insert({w,INT_MAX});\\n        }\\n        mp[beginWord]=0;  \\n\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty())\\n        {\\n            auto n = q.front() ;\\n            q.pop() ;\\n\\t\\t\\t//find word and sequence\\n            string w = n.first ;\\n            auto v=n.second ;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord)\\n            {\\n                ans.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i = 0 ; i < w.size() ; i++)\\n            {\\n                string t = w ;\\n                for(char c=\\'a\\' ; c <= \\'z\\' ; c++)\\n                {\\n                    t[i] = c ;\\n                    if(t==w)\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp.find(t)==mp.end())\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp[t]<(int)v.size())\\n                    {\\n                        continue ;\\n                    } \\n                    mp[t] = (int)v.size() ;\\n                    v.push_back(t) ;\\n                    q.push({t,v}) ;\\n                    v.pop_back() ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n</details>\\n\\n<hr>\\n\\n\\u2714\\uFE0F ***Solution - II***\\n```\\nclass Solution {\\npublic:\\n    bool neighbour(string a, string b){\\n        int cnt = 0 ;\\n        for(int i = 0 ; i < a.length() ; i++)\\n        {\\n            if(a[i] != b[i])\\n            {\\n                cnt++ ;\\n            }\\n        }\\n        return cnt == 1 ;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        wordList.insert(wordList.begin(), beginWord);\\n        for(int i = 1 ; i < wordList.size() ; i++)\\n        {\\n            if(wordList[i] == wordList[0]) // string compare\\n            {\\n                wordList[i] = wordList.back() ;\\n                wordList.pop_back() ;\\n                break ;\\n            }\\n        }\\n        map<string, int> wti ; // word to index\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            wti.insert({wordList[i], i}) ;\\n        }\\n        if(!wti.count(endWord)) \\n        {\\n            return {} ;\\n        }\\n        vector<vector<int>> edges(wti.size()) ;\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            for(int j = 0 ; j < wordList.size() ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    if(neighbour(wordList[i], wordList[j]))\\n                    {\\n                        edges[i].push_back(j) ;\\n                    }\\n                }\\n            }\\n        }\\n        // BFS  \\n        int start_node = 0 , target_node = wti[endWord] , r = 0 , min_step = INT_MAX ;\\n        vector<int> vis(wordList.size(), INT_MAX) ;   \\n        vis[start_node] = 0 ;\\n        queue<int> q ;   \\n        q.push(start_node) ;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size() ;\\n            for (int i = 0 ; i < sz ; i++)\\n            {\\n                int fr = q.front() ;  \\n                q.pop() ;\\n                if(fr == target_node)\\n                {\\n                    min_step = min(min_step , r) ;\\n                }\\n                for(int j = 0 ; j < edges[fr].size() ; j++)\\n                {\\n                    int update_node = edges[fr][j] ;\\n                    if(r + 1 < vis[update_node])\\n                    {\\n                        vis[update_node] = r + 1 ;\\n                        q.push(update_node);\\n                    }\\n                }\\n            }\\n            r++ ;\\n        }\\n        if(min_step == INT_MAX)\\n        {\\n            return {} ;\\n        }\\n        queue<vector<string>> q2 ; \\n        q2.push({wordList[target_node]}) ;\\n        r = min_step ;\\n        while(r)\\n        {\\n             int sz  = q2.size() ;\\n             for(int i = 0 ; i < sz ; i++)\\n             {\\n                vector<string> seq = q2.front() ;\\n                q2.pop();\\n                string back = seq.back() ;\\n                int curr = wti[back] ;\\n                for (int j = 0 ; j < edges[curr].size() ; j++)\\n                {\\n                    int new_node = edges[curr][j] ;\\n                    if (vis[new_node] == r - 1)\\n                    {\\n                        seq.push_back(wordList[new_node]) ;\\n                        q2.push(seq) ;\\n                        seq.pop_back() ;\\n                    }\\n                }\\n            }\\n            r-- ;\\n        }\\n        vector<vector<string>> ans;\\n        while(!q2.empty())\\n        {\\n            vector<string> temp = q2.front() ;\\n            q2.pop() ;\\n            reverse(begin(temp) , end(temp)) ;\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> mp ; \\n        // Record the number of conversions required to reach this string\\n        vector<vector<string>> ans ;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) \\n        {\\n            mp.insert({w,INT_MAX});\\n        }\\n        mp[beginWord]=0;  \\n\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty())\\n        {\\n            auto n = q.front() ;\\n            q.pop() ;\\n\\t\\t\\t//find word and sequence\\n            string w = n.first ;\\n            auto v=n.second ;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord)\\n            {\\n                ans.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i = 0 ; i < w.size() ; i++)\\n            {\\n                string t = w ;\\n                for(char c=\\'a\\' ; c <= \\'z\\' ; c++)\\n                {\\n                    t[i] = c ;\\n                    if(t==w)\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp.find(t)==mp.end())\\n                    {\\n                        continue ;\\n                    }\\n                    if(mp[t]<(int)v.size())\\n                    {\\n                        continue ;\\n                    } \\n                    mp[t] = (int)v.size() ;\\n                    v.push_back(t) ;\\n                    q.push({t,v}) ;\\n                    v.pop_back() ;\\n                }\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool neighbour(string a, string b){\\n        int cnt = 0 ;\\n        for(int i = 0 ; i < a.length() ; i++)\\n        {\\n            if(a[i] != b[i])\\n            {\\n                cnt++ ;\\n            }\\n        }\\n        return cnt == 1 ;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        wordList.insert(wordList.begin(), beginWord);\\n        for(int i = 1 ; i < wordList.size() ; i++)\\n        {\\n            if(wordList[i] == wordList[0]) // string compare\\n            {\\n                wordList[i] = wordList.back() ;\\n                wordList.pop_back() ;\\n                break ;\\n            }\\n        }\\n        map<string, int> wti ; // word to index\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            wti.insert({wordList[i], i}) ;\\n        }\\n        if(!wti.count(endWord)) \\n        {\\n            return {} ;\\n        }\\n        vector<vector<int>> edges(wti.size()) ;\\n        for(int i = 0 ; i < wordList.size() ; i++)\\n        {\\n            for(int j = 0 ; j < wordList.size() ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    if(neighbour(wordList[i], wordList[j]))\\n                    {\\n                        edges[i].push_back(j) ;\\n                    }\\n                }\\n            }\\n        }\\n        // BFS  \\n        int start_node = 0 , target_node = wti[endWord] , r = 0 , min_step = INT_MAX ;\\n        vector<int> vis(wordList.size(), INT_MAX) ;   \\n        vis[start_node] = 0 ;\\n        queue<int> q ;   \\n        q.push(start_node) ;\\n        while(!q.empty())\\n        {\\n            int sz  = q.size() ;\\n            for (int i = 0 ; i < sz ; i++)\\n            {\\n                int fr = q.front() ;  \\n                q.pop() ;\\n                if(fr == target_node)\\n                {\\n                    min_step = min(min_step , r) ;\\n                }\\n                for(int j = 0 ; j < edges[fr].size() ; j++)\\n                {\\n                    int update_node = edges[fr][j] ;\\n                    if(r + 1 < vis[update_node])\\n                    {\\n                        vis[update_node] = r + 1 ;\\n                        q.push(update_node);\\n                    }\\n                }\\n            }\\n            r++ ;\\n        }\\n        if(min_step == INT_MAX)\\n        {\\n            return {} ;\\n        }\\n        queue<vector<string>> q2 ; \\n        q2.push({wordList[target_node]}) ;\\n        r = min_step ;\\n        while(r)\\n        {\\n             int sz  = q2.size() ;\\n             for(int i = 0 ; i < sz ; i++)\\n             {\\n                vector<string> seq = q2.front() ;\\n                q2.pop();\\n                string back = seq.back() ;\\n                int curr = wti[back] ;\\n                for (int j = 0 ; j < edges[curr].size() ; j++)\\n                {\\n                    int new_node = edges[curr][j] ;\\n                    if (vis[new_node] == r - 1)\\n                    {\\n                        seq.push_back(wordList[new_node]) ;\\n                        q2.push(seq) ;\\n                        seq.pop_back() ;\\n                    }\\n                }\\n            }\\n            r-- ;\\n        }\\n        vector<vector<string>> ans;\\n        while(!q2.empty())\\n        {\\n            vector<string> temp = q2.front() ;\\n            q2.pop() ;\\n            reverse(begin(temp) , end(temp)) ;\\n            ans.push_back(temp) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40477,
                "title": "super-fast-java-solution-two-end-bfs",
                "content": "Thanks to prime_tang and jianchao.li.fighter!\\n\\n      public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        // hash set for both ends\\n        Set<String> set1 = new HashSet<String>();\\n        Set<String> set2 = new HashSet<String>();\\n        \\n        // initial words in both ends\\n        set1.add(start);\\n        set2.add(end);\\n        \\n        // we use a map to help construct the final result\\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\\n        \\n        // build the map\\n        helper(dict, set1, set2, map, false);\\n        \\n        List<List<String>> res = new ArrayList<List<String>>();\\n        List<String> sol = new ArrayList<String>(Arrays.asList(start));\\n        \\n        // recursively build the final result\\n        generateList(start, end, map, sol, res);\\n        \\n        return res;\\n      }\\n      \\n      boolean helper(Set<String> dict, Set<String> set1, Set<String> set2, Map<String, List<String>> map, boolean flip) {\\n        if (set1.isEmpty()) {\\n          return false;\\n        }\\n        \\n        if (set1.size() > set2.size()) {\\n          return helper(dict, set2, set1, map, !flip);\\n        }\\n        \\n        // remove words on current both ends from the dict\\n        dict.removeAll(set1);\\n        dict.removeAll(set2);\\n        \\n        // as we only need the shortest paths\\n        // we use a boolean value help early termination\\n        boolean done = false;\\n        \\n        // set for the next level\\n        Set<String> set = new HashSet<String>();\\n        \\n        // for each string in end 1\\n        for (String str : set1) {\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            // change one character for every position\\n            for (char ch = 'a'; ch <= 'z'; ch++) {\\n              chars[i] = ch;\\n              \\n              String word = new String(chars);\\n              \\n              // make sure we construct the tree in the correct direction\\n              String key = flip ? word : str;\\n              String val = flip ? str : word;\\n                  \\n              List<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();\\n                  \\n              if (set2.contains(word)) {\\n                done = true;\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              } \\n              \\n              if (!done && dict.contains(word)) {\\n                set.add(word);\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              }\\n            }\\n          }\\n        }\\n        \\n        // early terminate if done is true\\n        return done || helper(dict, set2, set, map, !flip);\\n      }\\n      \\n      void generateList(String start, String end, Map<String, List<String>> map, List<String> sol, List<List<String>> res) {\\n        if (start.equals(end)) {\\n          res.add(new ArrayList<String>(sol));\\n          return;\\n        }\\n        \\n        // need this check in case the diff between start and end happens to be one\\n        // e.g \"a\", \"c\", {\"a\", \"b\", \"c\"}\\n        if (!map.containsKey(start)) {\\n          return;\\n        }\\n        \\n        for (String word : map.get(start)) {\\n          sol.add(word);\\n          generateList(word, end, map, sol, res);\\n          sol.remove(sol.size() - 1);\\n        }\\n      }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "Thanks to prime_tang and jianchao.li.fighter!\\n\\n      public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        // hash set for both ends\\n        Set<String> set1 = new HashSet<String>();\\n        Set<String> set2 = new HashSet<String>();\\n        \\n        // initial words in both ends\\n        set1.add(start);\\n        set2.add(end);\\n        \\n        // we use a map to help construct the final result\\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\\n        \\n        // build the map\\n        helper(dict, set1, set2, map, false);\\n        \\n        List<List<String>> res = new ArrayList<List<String>>();\\n        List<String> sol = new ArrayList<String>(Arrays.asList(start));\\n        \\n        // recursively build the final result\\n        generateList(start, end, map, sol, res);\\n        \\n        return res;\\n      }\\n      \\n      boolean helper(Set<String> dict, Set<String> set1, Set<String> set2, Map<String, List<String>> map, boolean flip) {\\n        if (set1.isEmpty()) {\\n          return false;\\n        }\\n        \\n        if (set1.size() > set2.size()) {\\n          return helper(dict, set2, set1, map, !flip);\\n        }\\n        \\n        // remove words on current both ends from the dict\\n        dict.removeAll(set1);\\n        dict.removeAll(set2);\\n        \\n        // as we only need the shortest paths\\n        // we use a boolean value help early termination\\n        boolean done = false;\\n        \\n        // set for the next level\\n        Set<String> set = new HashSet<String>();\\n        \\n        // for each string in end 1\\n        for (String str : set1) {\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            // change one character for every position\\n            for (char ch = 'a'; ch <= 'z'; ch++) {\\n              chars[i] = ch;\\n              \\n              String word = new String(chars);\\n              \\n              // make sure we construct the tree in the correct direction\\n              String key = flip ? word : str;\\n              String val = flip ? str : word;\\n                  \\n              List<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();\\n                  \\n              if (set2.contains(word)) {\\n                done = true;\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              } \\n              \\n              if (!done && dict.contains(word)) {\\n                set.add(word);\\n                \\n                list.add(val);\\n                map.put(key, list);\\n              }\\n            }\\n          }\\n        }\\n        \\n        // early terminate if done is true\\n        return done || helper(dict, set2, set, map, !flip);\\n      }\\n      \\n      void generateList(String start, String end, Map<String, List<String>> map, List<String> sol, List<List<String>> res) {\\n        if (start.equals(end)) {\\n          res.add(new ArrayList<String>(sol));\\n          return;\\n        }\\n        \\n        // need this check in case the diff between start and end happens to be one\\n        // e.g \"a\", \"c\", {\"a\", \"b\", \"c\"}\\n        if (!map.containsKey(start)) {\\n          return;\\n        }\\n        \\n        for (String word : map.get(start)) {\\n          sol.add(word);\\n          generateList(word, end, map, sol, res);\\n          sol.remove(sol.size() - 1);\\n        }\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 2367587,
                "title": "python-bfs-dfs-with-explanation-why-optimization-is-needed-to-not-tle",
                "content": "**Intuition**\\n\\n1. Most approaches start off with an adjacency list with a pattern node for quick lookups.\\n\\n1. Then we perform **BFS** until we reach an `endWord`. Since the question requires us to return all possible paths, it is very tempting to start constructing the path during our BFS\\n\\ta. **However**, this will always give us TLE. Algorithmically, this feels wrong since we need to explore and hit all the nodes at least once to form our path (i.e. `O(n)`).\\n\\tb. But looking at it more closely, we are creating/destroying paths at every node of a BFS traversal. Space and compute are not free.\\n\\n1. What if we can defer our path creation to later? That\\'s good, but not enough because we would have to start our traversal from `beginWord` all over again.\\n\\n1. What about the **paths** we traversed via BFS? Most of them led to **dead-ends**. If only we don\\'t have to traverse down these paths. **This is the crux of the optimization**. We can do this by traversing in reverse from `endWord` to `beginWord` instead!\\n\\n1. When we perform **BFS** (step 2), we construct a tree where the key is a `child` node and values are `parent` nodes. When `endWord` is found, the `wordTree` will contain a way to traverse from `endWord` to `beginWord`.\\n\\n1. Then we perform **DFS** on the `wordTree` and return our results.\\n\\np.s. this was **HARD** to figure out...rip if anyone ever needs to make this optimization in an interview.\\n\\n**Solution**\\n```\\nclass Solution:\\n\\n    WILDCARD = \".\"\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \"\"\"\\n        Given a wordlist, we perform BFS traversal to generate a word tree where\\n        every node points to its parent node.\\n        \\n        Then we perform a DFS traversal on this tree starting at the endWord.\\n        \"\"\"\\n        if endWord not in wordList:\\n            # end word is unreachable\\n            return []\\n        \\n        # first generate a word tree from the wordlist\\n        word_tree = self.getWordTree(beginWord, endWord, wordList)\\n        \\n        # then generate a word ladder from the word tree\\n        return self.getLadders(beginWord, endWord, word_tree)\\n    \\n    \\n    def getWordTree(self,\\n                    beginWord: str,\\n                    endWord: str,\\n                    wordList: List[str]) -> Dict[str, List[str]]:\\n        \"\"\"\\n        BFS traversal from begin word until end word is encountered.\\n        \\n        This functions constructs a tree in reverse, starting at the endWord.\\n        \"\"\"\\n        # Build an adjacency list using patterns as keys\\n        # For example: \".it\" -> (\"hit\"), \"h.t\" -> (\"hit\"), \"hi.\" -> (\"hit\")\\n        adjacency_list = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                pattern = word[:i] + Solution.WILDCARD + word[i+1:]\\n                adjacency_list[pattern].append(word)\\n        \\n        # Holds the tree of words in reverse order\\n        # The key is an encountered word.\\n        # The value is a list of preceding words.\\n        # For example, we got to beginWord from no other nodes.\\n        # {a: [b,c]} means we got to \"a\" from \"b\" and \"c\"\\n        visited_tree = {beginWord: []}\\n        \\n        # start off the traversal without finding the word\\n        found = False\\n        \\n        q = deque([beginWord])\\n        while q and not found:\\n            n = len(q)\\n            \\n            # keep track of words visited at this level of BFS\\n            visited_this_level = {}\\n\\n            for i in range(n):\\n                word = q.popleft()\\n                \\n                for i in range(len(word)):\\n                    # for each pattern of the current word\\n                    pattern = word[:i] + Solution.WILDCARD + word[i+1:]\\n\\n                    for next_word in adjacency_list[pattern]:\\n                        if next_word == endWord:\\n                            # we don\\'t return immediately because other\\n                            # sequences might reach the endWord in the same\\n                            # BFS level\\n                            found = True\\n                        if next_word not in visited_tree:\\n                            if next_word not in visited_this_level:\\n                                visited_this_level[next_word] = [word]\\n                                # queue up next word iff we haven\\'t visited it yet\\n                                # or already are planning to visit it\\n                                q.append(next_word)\\n                            else:\\n                                visited_this_level[next_word].append(word)\\n            \\n            # add all seen words at this level to the global visited tree\\n            visited_tree.update(visited_this_level)\\n            \\n        return visited_tree\\n    \\n    \\n    def getLadders(self,\\n                   beginWord: str,\\n                   endWord: str,\\n                   wordTree: Dict[str, List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        DFS traversal from endWord to beginWord in a given tree.\\n        \"\"\"\\n        def dfs(node: str) -> List[List[str]]:\\n            if node == beginWord:\\n                return [[beginWord]]\\n            if node not in wordTree:\\n                return []\\n\\n            res = []\\n            parents = wordTree[node]\\n            for parent in parents:\\n                res += dfs(parent)\\n            for r in res:\\n                r.append(node)\\n            return res\\n\\n        return dfs(endWord)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\n    WILDCARD = \".\"\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \"\"\"\\n        Given a wordlist, we perform BFS traversal to generate a word tree where\\n        every node points to its parent node.\\n        \\n        Then we perform a DFS traversal on this tree starting at the endWord.\\n        \"\"\"\\n        if endWord not in wordList:\\n            # end word is unreachable\\n            return []\\n        \\n        # first generate a word tree from the wordlist\\n        word_tree = self.getWordTree(beginWord, endWord, wordList)\\n        \\n        # then generate a word ladder from the word tree\\n        return self.getLadders(beginWord, endWord, word_tree)\\n    \\n    \\n    def getWordTree(self,\\n                    beginWord: str,\\n                    endWord: str,\\n                    wordList: List[str]) -> Dict[str, List[str]]:\\n        \"\"\"\\n        BFS traversal from begin word until end word is encountered.\\n        \\n        This functions constructs a tree in reverse, starting at the endWord.\\n        \"\"\"\\n        # Build an adjacency list using patterns as keys\\n        # For example: \".it\" -> (\"hit\"), \"h.t\" -> (\"hit\"), \"hi.\" -> (\"hit\")\\n        adjacency_list = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                pattern = word[:i] + Solution.WILDCARD + word[i+1:]\\n                adjacency_list[pattern].append(word)\\n        \\n        # Holds the tree of words in reverse order\\n        # The key is an encountered word.\\n        # The value is a list of preceding words.\\n        # For example, we got to beginWord from no other nodes.\\n        # {a: [b,c]} means we got to \"a\" from \"b\" and \"c\"\\n        visited_tree = {beginWord: []}\\n        \\n        # start off the traversal without finding the word\\n        found = False\\n        \\n        q = deque([beginWord])\\n        while q and not found:\\n            n = len(q)\\n            \\n            # keep track of words visited at this level of BFS\\n            visited_this_level = {}\\n\\n            for i in range(n):\\n                word = q.popleft()\\n                \\n                for i in range(len(word)):\\n                    # for each pattern of the current word\\n                    pattern = word[:i] + Solution.WILDCARD + word[i+1:]\\n\\n                    for next_word in adjacency_list[pattern]:\\n                        if next_word == endWord:\\n                            # we don\\'t return immediately because other\\n                            # sequences might reach the endWord in the same\\n                            # BFS level\\n                            found = True\\n                        if next_word not in visited_tree:\\n                            if next_word not in visited_this_level:\\n                                visited_this_level[next_word] = [word]\\n                                # queue up next word iff we haven\\'t visited it yet\\n                                # or already are planning to visit it\\n                                q.append(next_word)\\n                            else:\\n                                visited_this_level[next_word].append(word)\\n            \\n            # add all seen words at this level to the global visited tree\\n            visited_tree.update(visited_this_level)\\n            \\n        return visited_tree\\n    \\n    \\n    def getLadders(self,\\n                   beginWord: str,\\n                   endWord: str,\\n                   wordTree: Dict[str, List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        DFS traversal from endWord to beginWord in a given tree.\\n        \"\"\"\\n        def dfs(node: str) -> List[List[str]]:\\n            if node == beginWord:\\n                return [[beginWord]]\\n            if node not in wordTree:\\n                return []\\n\\n            res = []\\n            parents = wordTree[node]\\n            for parent in parents:\\n                res += dfs(parent)\\n            for r in res:\\n                r.append(node)\\n            return res\\n\\n        return dfs(endWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40458,
                "title": "use-defaultdict-for-traceback-and-easy-writing-20-lines-python-code",
                "content": "    class Solution:\\n    # @param start, a string\\n    # @param end, a string\\n    # @param dict, a set of string\\n    # @return a list of lists of string\\n    def findLadders(self, start, end, dic):\\n        dic.add(end)\\n        level = {start}\\n        parents = collections.defaultdict(set)\\n        while level and end not in parents:\\n            next_level = collections.defaultdict(set)\\n            for node in level:\\n                for char in string.ascii_lowercase:\\n                    for i in range(len(start)):\\n                        n = node[:i]+char+node[i+1:]\\n                        if n in dic and n not in parents:\\n                            next_level[n].add(node)\\n            level = next_level\\n            parents.update(next_level)\\n        res = [[end]]\\n        while res and res[0][0] != start:\\n            res = [[p]+r for r in res for p in parents[r[0]]]\\n        return res\\n\\nEvery level we use the defaultdict to get rid of the duplicates",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param start, a string\\n    # @param end, a string\\n    # @param dict, a set of string\\n    # @return a list of lists of string\\n    def findLadders(self, start, end, dic):\\n        dic.add(end)\\n        level = {start}",
                "codeTag": "Java"
            },
            {
                "id": 352661,
                "title": "simple-python-bfs-solution-similar-problems-listed",
                "content": "Level-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n\\n```\\n    def findLadders(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return []\\n        # BFS visit\\n        curr_level = {beginWord}\\n        parents = collections.defaultdict(list)\\n        while curr_level:\\n            wordList -= curr_level\\n            next_level = set()\\n            for word in curr_level:\\n                for i in range(len(word)):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        if new_word in wordList:\\n                            next_level.add(new_word)\\n                            parents[new_word].append(word)\\n            if endWord in next_level:\\n                break\\n            curr_level = next_level\\n        # DFS reconstruction\\n        res = []\\n        def dfs(word, path):\\n            if word == beginWord:\\n                path.append(word)\\n                res.append(path[::-1])\\n            else:\\n                for p_word in parents[word]:\\n                    dfs(p_word, path + [word])\\n        dfs(endWord, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def findLadders(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return []\\n        # BFS visit\\n        curr_level = {beginWord}\\n        parents = collections.defaultdict(list)\\n        while curr_level:\\n            wordList -= curr_level\\n            next_level = set()\\n            for word in curr_level:\\n                for i in range(len(word)):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        if new_word in wordList:\\n                            next_level.add(new_word)\\n                            parents[new_word].append(word)\\n            if endWord in next_level:\\n                break\\n            curr_level = next_level\\n        # DFS reconstruction\\n        res = []\\n        def dfs(word, path):\\n            if word == beginWord:\\n                path.append(word)\\n                res.append(path[::-1])\\n            else:\\n                for p_word in parents[word]:\\n                    dfs(p_word, path + [word])\\n        dfs(endWord, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2423080,
                "title": "c-no-tle-august-2022-simple-bfs-explained",
                "content": "***Step 1:-***\\nCount the minimum steps required to reach **beginword** from each string present in the word list using simple BFS.\\n\\n**Step 2:-**\\nThen for returning the path, start backtracking from the **endword** and keep moving to words having minimum steps 1 less than the current word.\\n\\n**Do upvote if you like it.**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> res;\\n    vector<string> te;\\n    unordered_map<string, int> mp;\\n    string b;\\n    void dfs(string s)  // Step 2\\n    {\\n        te.push_back(s);\\n        if (s == b)\\n        {\\n            vector<string> x = te;\\n            reverse(x.begin(), x.end());\\n            res.push_back(x);\\n            te.pop_back();\\n            return;\\n        }\\n        int cur = mp[s];\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char c = s[i];\\n            for (char cc = \\'a\\'; cc <= \\'z\\'; cc++)\\n            {\\n                s[i] = cc;\\n                if (mp.count(s) && mp[s] == cur - 1)\\n                    dfs(s);\\n            }\\n            s[i] = c;\\n        }\\n        te.pop_back();\\n        return;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)\\n    {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        b = beginWord;\\n        queue<string> q;\\n        int k = beginWord.size();\\n        q.push({beginWord});\\n        mp[beginWord] = 0;\\n        while (!q.empty())  // Step 1\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                int x = mp[t] + 1;\\n                for (int i = 0; i < k; i++)\\n                {\\n                    string temp = t;\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                    {\\n                        temp[i] = ch;\\n                        if (!mp.count(temp) && dict.count(temp))\\n                            mp[temp] = x, q.push(temp);\\n                    }\\n                }\\n            }\\n        }\\n        if (mp.count(endWord))\\n            dfs(endWord);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> res;\\n    vector<string> te;\\n    unordered_map<string, int> mp;\\n    string b;\\n    void dfs(string s)  // Step 2\\n    {\\n        te.push_back(s);\\n        if (s == b)\\n        {\\n            vector<string> x = te;\\n            reverse(x.begin(), x.end());\\n            res.push_back(x);\\n            te.pop_back();\\n            return;\\n        }\\n        int cur = mp[s];\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char c = s[i];\\n            for (char cc = \\'a\\'; cc <= \\'z\\'; cc++)\\n            {\\n                s[i] = cc;\\n                if (mp.count(s) && mp[s] == cur - 1)\\n                    dfs(s);\\n            }\\n            s[i] = c;\\n        }\\n        te.pop_back();\\n        return;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)\\n    {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        b = beginWord;\\n        queue<string> q;\\n        int k = beginWord.size();\\n        q.push({beginWord});\\n        mp[beginWord] = 0;\\n        while (!q.empty())  // Step 1\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                int x = mp[t] + 1;\\n                for (int i = 0; i < k; i++)\\n                {\\n                    string temp = t;\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                    {\\n                        temp[i] = ch;\\n                        if (!mp.count(temp) && dict.count(temp))\\n                            mp[temp] = x, q.push(temp);\\n                    }\\n                }\\n            }\\n        }\\n        if (mp.count(endWord))\\n            dfs(endWord);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40540,
                "title": "88ms-accepted-c-solution-with-two-end-bfs-68ms-for-word-ladder-and-88ms-for-word-ladder-ii",
                "content": "In order to reduce the running time, we should use two-end BFS to slove the problem.\\n\\nAccepted 68ms c++ solution for [Word Ladder][1].\\n\\n    class Solution {\\n    public:\\n        int ladderLength(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {\\n    \\t\\tif (beginWord == endWord)\\n    \\t\\t\\treturn 1;\\n            std::unordered_set<std::string> words1, words2;\\n    \\t\\twords1.insert(beginWord);\\n    \\t\\twords2.insert(endWord);\\n            dict.erase(beginWord);\\n            dict.erase(endWord);\\n            return ladderLengthHelper(words1, words2, dict, 1);\\n        }\\n    \\n    private:\\n        int ladderLengthHelper(std::unordered_set<std::string> &words1, std::unordered_set<std::string> &words2, std::unordered_set<std::string> &dict, int level) {\\n    \\t\\tif (words1.empty())\\n                return 0;\\n    \\t\\tif (words1.size() > words2.size())\\n    \\t\\t\\treturn ladderLengthHelper(words2, words1, dict, level);\\n            std::unordered_set<std::string> words3;\\n            for (auto it = words1.begin(); it != words1.end(); ++it) {\\n    \\t\\t\\tstd::string word = *it;\\n    \\t\\t\\tfor (auto ch = word.begin(); ch != word.end(); ++ch) {\\n    \\t\\t\\t\\tchar tmp = *ch;\\n                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))\\n    \\t\\t\\t\\t\\tif (*ch != tmp)\\n    \\t\\t\\t\\t\\t\\tif (words2.find(word) != words2.end())\\n                                return level + 1;\\n    \\t\\t\\t\\t\\t\\telse if (dict.find(word) != dict.end()) {\\n                                dict.erase(word);\\n                                words3.insert(word);\\n                            }\\n    \\t\\t\\t\\t*ch = tmp;\\n                }\\n            }\\n            return ladderLengthHelper(words2, words3, dict, level + 1);\\n        }\\n    };\\n\\nAccepted 88ms c++ solution for [Word Ladder II][2].\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > findLadders(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {\\n    \\t\\tstd::vector<std::vector<std::string> > paths;\\n    \\t\\tstd::vector<std::string> path(1, beginWord);\\n    \\t\\tif (beginWord == endWord) {\\n    \\t\\t\\tpaths.push_back(path);\\n    \\t\\t\\treturn paths;\\n    \\t\\t}\\n            std::unordered_set<std::string> words1, words2;\\n    \\t\\twords1.insert(beginWord);\\n    \\t\\twords2.insert(endWord);\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > nexts;\\n    \\t\\tbool words1IsBegin = false;\\n            if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin))\\n    \\t\\t\\tgetPath(beginWord, endWord, nexts, path, paths);\\n    \\t\\treturn paths;\\n        }\\n    private:\\n        bool findLaddersHelper(\\n    \\t\\tstd::unordered_set<std::string> &words1,\\n    \\t\\tstd::unordered_set<std::string> &words2,\\n    \\t\\tstd::unordered_set<std::string> &dict,\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > &nexts,\\n    \\t\\tbool &words1IsBegin) {\\n    \\t\\twords1IsBegin = !words1IsBegin;\\n    \\t\\tif (words1.empty())\\n                return false;\\n    \\t\\tif (words1.size() > words2.size())\\n    \\t\\t\\treturn findLaddersHelper(words2, words1, dict, nexts, words1IsBegin);\\n    \\t\\tfor (auto it = words1.begin(); it != words1.end(); ++it)\\n    \\t\\t\\tdict.erase(*it);\\n    \\t\\tfor (auto it = words2.begin(); it != words2.end(); ++it)\\n    \\t\\t\\tdict.erase(*it);\\n            std::unordered_set<std::string> words3;\\n    \\t\\tbool reach = false;\\n            for (auto it = words1.begin(); it != words1.end(); ++it) {\\n    \\t\\t\\tstd::string word = *it;\\n    \\t\\t\\tfor (auto ch = word.begin(); ch != word.end(); ++ch) {\\n    \\t\\t\\t\\tchar tmp = *ch;\\n                    for (*ch = 'a'; *ch <= 'z'; ++(*ch))\\n    \\t\\t\\t\\t\\tif (*ch != tmp)\\n    \\t\\t\\t\\t\\t\\tif (words2.find(word) != words2.end()) {\\n    \\t\\t\\t\\t\\t\\t\\treach = true;\\n    \\t\\t\\t\\t\\t\\t\\twords1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);\\n    \\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\telse if (!reach && dict.find(word) != dict.end()) {\\n    \\t\\t\\t\\t\\t\\t\\twords3.insert(word);\\n    \\t\\t\\t\\t\\t\\t\\twords1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);\\n                            }\\n    \\t\\t\\t\\t*ch = tmp;\\n                }\\n            }\\n            return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin);\\n        }\\n    \\tvoid getPath(\\n    \\t\\tstd::string beginWord,\\n    \\t\\tstd::string &endWord,\\n    \\t\\tstd::unordered_map<std::string, std::vector<std::string> > &nexts,\\n    \\t\\tstd::vector<std::string> &path,\\n    \\t\\tstd::vector<std::vector<std::string> > &paths) {\\n    \\t\\tif (beginWord == endWord)\\n    \\t\\t\\tpaths.push_back(path);\\n    \\t\\telse\\n    \\t\\t\\tfor (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) {\\n    \\t\\t\\t\\tpath.push_back(*it);\\n    \\t\\t\\t\\tgetPath(*it, endWord, nexts, path, paths);\\n    \\t\\t\\t\\tpath.pop_back();\\n    \\t\\t\\t}\\n    \\t}\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/word-ladder/\\n  [2]: https://leetcode.com/problems/word-ladder-ii/",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int ladderLength(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {\\n    \\t\\tif (beginWord == endWord)\\n    \\t\\t\\treturn 1;\\n            std::unordered_set<std::string> words1, words2;\\n    \\t\\twords1.insert(beginWord);\\n    \\t\\twords2.insert(endWord);\\n            dict.erase(beginWord);\\n            dict.erase(endWord);\\n            return ladderLengthHelper(words1, words2, dict, 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2424910,
                "title": "explanation-with-animation-accepted-without-tle",
                "content": "# Intuition\\nWe just need to record all possible words that can connect from the beginning, level by level, until we hit the end at a level.\\n\\n![image](https://assets.leetcode.com/users/images/a3649dc6-641b-4a8f-a122-f1057458ae66_1660488505.0343473.gif)\\n\\nThen we will traverse backward from end via the words in the record and construct our final ways.\\n\\n**Remember:** we will not record paths, we record only nodes. \\n\\n_____\\n# Explanation\\nFirst, because we traverse level by level, so as soon as we see the end, that is the shortest distance (shortest path) we have from beginning. This is the basic theorem of BFS in an unweighted graph: https://sneeit.com/graph/?tab=documentation#breath-first-search-in-graph\\n\\nWhen we see the end, we know some of the nodes from previous level (which connect to the beginning because we traversed from there) are pointing to the end. We just need to move backward, level by level then we could collect all paths to end from begin\\n_____\\n# Why Other\\'s Solutions Get TLE\\nBecause if there are some nodes point to a same node, their solutions keep computing the same path again and again due to they see those paths are different (from the beginning node). This is the weakness of recording paths, instead of nodes.\\n\\nCheck the red node in the following figure for more information:\\n\\n![image](https://assets.leetcode.com/users/images/494e794a-7c8a-4302-8c1d-4a4f48d7be7e_1660490240.8757915.png)\\n\\nIn summary:\\n1. Other solutions:\\n\\t* Store paths, so every node could be stored multiple times.\\n\\t* Compute the intersections in paths again and again\\n\\t* Paths that does not lead to end also be computed\\n2. My solution:\\n\\t* Store only nodes so every node is store exactly one time\\n\\t* Move backward to compute only the paths that can connect from begin to end\\n\\n_____\\n# Algorithm\\n* **Moving Forward: start from begin**\\n\\t1. Each level, find all connected nodes to the nodes of the current level in the record and add those to the record for the next level.\\n\\t2. Delete node from wordList to prevent revisiting and forming cycles\\n\\t3. Repeat the above steps until we reach end or we add no new nodes to the record for next level\\n\\n* **Moving Backward: start from end**\\n\\t1. Do the same steps as moving forward but this time we will not record nodes but contruct our paths\\n\\t2. Construct paths in reversing order to have paths from begin to end\\n_____\\n\\n# Codes\\n_____\\n\\n## JavaScript\\n\\n```\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    // to check if two words can connect\\n    let connected = (a,b) => {\\n        let c = 0\\n        for (let i = 0; i < a.length && c < 2; i++) {\\n            if (a[i] !== b[i]) c++\\n        }\\n        return c == 1\\n    }\\n\\n    // dictionary to help us search words faster\\n    // and to trackback what word was used\\n    let dict = new Set(wordList);\\n    if (dict.has(endWord) == false) return []\\n\\n    dict.delete(beginWord)\\n    let queue = [beginWord]\\n    let nodes = []\\n\\n    \\n    // find all ways from beginning\\n    // level by level, until reach end at a level\\n    let reached = false;    \\n    while (queue.length && !reached) {\\n        // update nodes of paths for this level\\n        nodes.push(queue.slice())\\n\\n        // access whole level   \\n        let qlen = queue.length;\\n        for (let i = 0; i < qlen && !reached; i++) {\\n\\n            let from = queue.shift();\\n            \\n            // find all nodes that connect to the nodes of this level\\n            for (let to of dict) {                \\n\\n                if (connected(from,to) == false) continue\\n\\n                // if connect\\n                // - and one of them is end word\\n                // - then we can stop moving forward\\n                if (to == endWord) {\\n                    reached = true\\n                    break;\\n                }\\n\\n                // - otherwise,\\n                // - add all connected nodes to the record for the next level\\n                // - and delete them from dict to prevent revisiting to form cycles\\n                queue.push(to)                \\n                dict.delete(to)                \\n            }\\n        }\\n    }\\n\\n    // try but did not find endWord\\n    if (!reached) return []\\n\\n    // move backward to construct paths\\n    // add nodes to paths in reverse order to have paths from begin to end\\n    let ans = [[endWord]]\\n    for (let level = nodes.length - 1; level >= 0; level--) {        \\n        let alen = ans.length\\n        for (let a = 0; a < alen; a++) {\\n            let p = ans.shift()\\n            let last = p[0]            \\n            for (let word of nodes[level]) {                \\n                if (!connected(last, word)) continue                \\n                ans.push([word, ...p])\\n            }\\n        }        \\n    }\\n\\n    return ans\\n}\\n```\\n\\n____\\n## C++\\nThis is my first C++ code. Hope you can suggest optimizations . Thanks.\\n```\\nclass Solution {\\npublic:\\n    bool isConnected(string s,string t){\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n            c+=(s[i]!=t[i]);\\n        return c==1;\\n    }\\n\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;        \\n        vector<vector<string>> nodes;   \\n        unordered_set<string> dict(wordList.begin(),wordList.end());\\n        \\n        if (!dict.count(endWord)) return ans;\\n        dict.erase(beginWord);\\n        \\n        \\n        bool reached = false;\\n        nodes.push_back({beginWord});\\n        \\n        while (dict.size() && !reached) {                        \\n            vector<string> last = nodes.back();\\n            vector<string> curr;\\n                        \\n            for (int i = 0; i < last.size() && !reached; i++) {\\n                unordered_set<string> visited;\\n                string from = last[i];                                \\n                // check all nodes that connect\\n                // to the nodes of the previous level                \\n                for (auto& to : dict) {                    \\n                    if (visited.count(to)) continue;\\n                    if (!isConnected(from, to)) continue;                                        \\n                    // if one of them is \"endWord\" then we can stop \\n                    // because this level is the shortest distance from begin\\n                    if (to == endWord) {                        \\n                        reached = true; \\n                        break;\\n                    }\\n                    \\n                    // otherwise,\\n                    // add nodes for the current level\\n                    curr.push_back(to);   \\n                    visited.insert(to);                    \\n                }   \\n                // delete the visited to prevent forming cycles            \\n                for (auto& visited : visited) {                \\n                    dict.erase(visited);\\n                }\\n            }\\n            \\n            // found endWord this level\\n            if (reached) break;\\n            \\n            // can not add any new nodes to our level\\n            if (!curr.size()) break;\\n            \\n            // otherwise, record all nodes for the current level\\n            nodes.push_back(curr);            \\n        }\\n        \\n        // try but not find\\n        if (reached == false) return ans;\\n        \\n        // move backward\\n        ans.push_back({endWord});          \\n        for (int level = nodes.size() - 1; level >= 0; level--) {                        \\n            int alen = ans.size();\\n            while (alen) {\\n                vector<string> path = ans.back();\\n                ans.pop_back();\\n                string from = path.front();                \\n                for (string &to : nodes[level]) {                    \\n                    if (!isConnected(from, to)) continue;\\n                                        \\n                    vector<string> newpath = path;\\n                    newpath.insert(newpath.begin(), to);\\n                    ans.insert(ans.begin(), newpath);\\n                }    \\n                alen--;\\n            }             \\n        }\\n        return ans;\\n    }\\n};\\n```\\n____\\n## Pseudocode\\n```\\n// Pseudocode\\nfunction findLadders(beginWord, endWord, wordList) {\\n    if (wordList.hasNo(endWord)) return []\\n    wordList.delete(beginWord)\\n\\n    // move forward\\n    queue = [beginWord]\\n    paths = [] // 2D array\\n    reached = false;    \\n    while (queue.length && !reached) {\\n        paths.append(queue) // deep copy\\n        \\n        // need static here to access only the nodes of this level\\n        qlen = queue.length; \\n        for (let i = 0; i < qlen && !reached; i++) {\\n            from = queue.takeFirst()\\n            forEach (to of wordList) {\\n                if (isConnected(from, to)) {                    \\n                    if (to == endWord) {\\n                        reached = true\\n                        break // exit from the forEach\\n                    }\\n                                    \\n                    queue.push(to) \\n                    wordList.delete(to) // delete to preven a cycle \\n                }\\n            }\\n        }\\n    }\\n\\n    // can not reach the end eventually\\n    if (!reached) return []\\n\\n    // move backward\\n    answer = [[endWord]] // 2D array    \\n    for (level = paths.length - 1; level >= 0; level--) {        \\n        path = paths[level]\\n        alen = answer.length\\n        for (a = 0; a < alen; a++) {\\n            p = answer.takeFirst()\\n            last = p[0]\\n            forEach (word of path) {\\n                if (!isConnected(last, word)) {\\n                    answer.append([word, ...p])\\n                }\\n                \\n            }\\n        }        \\n    }\\n\\n    return answer\\n}\\n\\n\\n// to check if two words can connect\\nfunction isConnected(a,b) {\\n    c = 0\\n    for (i = 0; i < a.length && c < 2; i++) {\\n        if (a[i] !== b[i]) c++\\n    }\\n    return c == 1\\n}\\n```\\n\\n____\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    // to check if two words can connect\\n    let connected = (a,b) => {\\n        let c = 0\\n        for (let i = 0; i < a.length && c < 2; i++) {\\n            if (a[i] !== b[i]) c++\\n        }\\n        return c == 1\\n    }\\n\\n    // dictionary to help us search words faster\\n    // and to trackback what word was used\\n    let dict = new Set(wordList);\\n    if (dict.has(endWord) == false) return []\\n\\n    dict.delete(beginWord)\\n    let queue = [beginWord]\\n    let nodes = []\\n\\n    \\n    // find all ways from beginning\\n    // level by level, until reach end at a level\\n    let reached = false;    \\n    while (queue.length && !reached) {\\n        // update nodes of paths for this level\\n        nodes.push(queue.slice())\\n\\n        // access whole level   \\n        let qlen = queue.length;\\n        for (let i = 0; i < qlen && !reached; i++) {\\n\\n            let from = queue.shift();\\n            \\n            // find all nodes that connect to the nodes of this level\\n            for (let to of dict) {                \\n\\n                if (connected(from,to) == false) continue\\n\\n                // if connect\\n                // - and one of them is end word\\n                // - then we can stop moving forward\\n                if (to == endWord) {\\n                    reached = true\\n                    break;\\n                }\\n\\n                // - otherwise,\\n                // - add all connected nodes to the record for the next level\\n                // - and delete them from dict to prevent revisiting to form cycles\\n                queue.push(to)                \\n                dict.delete(to)                \\n            }\\n        }\\n    }\\n\\n    // try but did not find endWord\\n    if (!reached) return []\\n\\n    // move backward to construct paths\\n    // add nodes to paths in reverse order to have paths from begin to end\\n    let ans = [[endWord]]\\n    for (let level = nodes.length - 1; level >= 0; level--) {        \\n        let alen = ans.length\\n        for (let a = 0; a < alen; a++) {\\n            let p = ans.shift()\\n            let last = p[0]            \\n            for (let word of nodes[level]) {                \\n                if (!connected(last, word)) continue                \\n                ans.push([word, ...p])\\n            }\\n        }        \\n    }\\n\\n    return ans\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isConnected(string s,string t){\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n            c+=(s[i]!=t[i]);\\n        return c==1;\\n    }\\n\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;        \\n        vector<vector<string>> nodes;   \\n        unordered_set<string> dict(wordList.begin(),wordList.end());\\n        \\n        if (!dict.count(endWord)) return ans;\\n        dict.erase(beginWord);\\n        \\n        \\n        bool reached = false;\\n        nodes.push_back({beginWord});\\n        \\n        while (dict.size() && !reached) {                        \\n            vector<string> last = nodes.back();\\n            vector<string> curr;\\n                        \\n            for (int i = 0; i < last.size() && !reached; i++) {\\n                unordered_set<string> visited;\\n                string from = last[i];                                \\n                // check all nodes that connect\\n                // to the nodes of the previous level                \\n                for (auto& to : dict) {                    \\n                    if (visited.count(to)) continue;\\n                    if (!isConnected(from, to)) continue;                                        \\n                    // if one of them is \"endWord\" then we can stop \\n                    // because this level is the shortest distance from begin\\n                    if (to == endWord) {                        \\n                        reached = true; \\n                        break;\\n                    }\\n                    \\n                    // otherwise,\\n                    // add nodes for the current level\\n                    curr.push_back(to);   \\n                    visited.insert(to);                    \\n                }   \\n                // delete the visited to prevent forming cycles            \\n                for (auto& visited : visited) {                \\n                    dict.erase(visited);\\n                }\\n            }\\n            \\n            // found endWord this level\\n            if (reached) break;\\n            \\n            // can not add any new nodes to our level\\n            if (!curr.size()) break;\\n            \\n            // otherwise, record all nodes for the current level\\n            nodes.push_back(curr);            \\n        }\\n        \\n        // try but not find\\n        if (reached == false) return ans;\\n        \\n        // move backward\\n        ans.push_back({endWord});          \\n        for (int level = nodes.size() - 1; level >= 0; level--) {                        \\n            int alen = ans.size();\\n            while (alen) {\\n                vector<string> path = ans.back();\\n                ans.pop_back();\\n                string from = path.front();                \\n                for (string &to : nodes[level]) {                    \\n                    if (!isConnected(from, to)) continue;\\n                                        \\n                    vector<string> newpath = path;\\n                    newpath.insert(newpath.begin(), to);\\n                    ans.insert(ans.begin(), newpath);\\n                }    \\n                alen--;\\n            }             \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Pseudocode\\nfunction findLadders(beginWord, endWord, wordList) {\\n    if (wordList.hasNo(endWord)) return []\\n    wordList.delete(beginWord)\\n\\n    // move forward\\n    queue = [beginWord]\\n    paths = [] // 2D array\\n    reached = false;    \\n    while (queue.length && !reached) {\\n        paths.append(queue) // deep copy\\n        \\n        // need static here to access only the nodes of this level\\n        qlen = queue.length; \\n        for (let i = 0; i < qlen && !reached; i++) {\\n            from = queue.takeFirst()\\n            forEach (to of wordList) {\\n                if (isConnected(from, to)) {                    \\n                    if (to == endWord) {\\n                        reached = true\\n                        break // exit from the forEach\\n                    }\\n                                    \\n                    queue.push(to) \\n                    wordList.delete(to) // delete to preven a cycle \\n                }\\n            }\\n        }\\n    }\\n\\n    // can not reach the end eventually\\n    if (!reached) return []\\n\\n    // move backward\\n    answer = [[endWord]] // 2D array    \\n    for (level = paths.length - 1; level >= 0; level--) {        \\n        path = paths[level]\\n        alen = answer.length\\n        for (a = 0; a < alen; a++) {\\n            p = answer.takeFirst()\\n            last = p[0]\\n            forEach (word of path) {\\n                if (!isConnected(last, word)) {\\n                    answer.append([word, ...p])\\n                }\\n                \\n            }\\n        }        \\n    }\\n\\n    return answer\\n}\\n\\n\\n// to check if two words can connect\\nfunction isConnected(a,b) {\\n    c = 0\\n    for (i = 0; i < a.length && c < 2; i++) {\\n        if (a[i] !== b[i]) c++\\n    }\\n    return c == 1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40452,
                "title": "c-very-easy-read-and-understand-solution-compared-to-most-voted",
                "content": "For the most voted solution, it is very complicated.\\nI do a BFS for each path\\nfor example: \\n{hit} -> \\n{hit,hot} ->\\n {hit,hot,dot}/{hit,hot,lot} -> \\n [\"hit\",\"hot\",\"dot\",\"dog\"]/[\"hit\",\"hot\",\"lot\",\"log\"] ->\\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> visit;  //notice we need to clear visited word in list after finish this level of BFS\\n        queue<vector<string>> q;\\n        unordered_set<string> wordlist(wordList.begin(),wordList.end());\\n        q.push({beginWord});\\n        bool flag= false; //to see if we find shortest path\\n        while(!q.empty()){\\n            int size= q.size();\\n            for(int i=0;i<size;i++){            //for this level\\n                vector<string> cur = q.front();\\n                q.pop();\\n                vector<string> newadd =  addWord(cur.back(),wordlist); \\n                for(int j=0;j<newadd.size();j++){   //add a word into path\\n                    vector<string> newline(cur.begin(),cur.end());\\n                    newline.push_back(newadd[j]);\\n                    if(newadd[j]==endWord){       \\n                     flag=true;\\n                    res.push_back(newline);\\n                    }\\n                    visit.insert(newadd[j]);\\n                    q.push(newline);\\n                }\\n            }\\n            if(flag) break;  //do not BFS further \\n            for(auto it=visit.begin();it!=visit.end();it++) wordlist.erase(*it); //erase visited one \\n            visit.clear();\\n        }\\n        return res;\\n    }\\n    \\n    // find words with one char different in dict\\n    // hot->[dot,lot]\\n    vector<string> addWord( string word,unordered_set<string>& wordlist ){\\n        vector<string> res;\\n        for(int i=0;i<word.size();i++){\\n            char s =word[i];\\n            for(char c='a';c<='z';c++){\\n                word[i]=c;\\n                if(wordlist.count(word)) res.push_back(word);\\n            }\\n            word[i]=s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> visit;  //notice we need to clear visited word in list after finish this level of BFS\\n        queue<vector<string>> q;\\n        unordered_set<string> wordlist(wordList.begin(),wordList.end());\\n        q.push({beginWord});\\n        bool flag= false; //to see if we find shortest path\\n        while(!q.empty()){\\n            int size= q.size();\\n            for(int i=0;i<size;i++){            //for this level\\n                vector<string> cur = q.front();\\n                q.pop();\\n                vector<string> newadd =  addWord(cur.back(),wordlist); \\n                for(int j=0;j<newadd.size();j++){   //add a word into path\\n                    vector<string> newline(cur.begin(),cur.end());\\n                    newline.push_back(newadd[j]);\\n                    if(newadd[j]==endWord){       \\n                     flag=true;\\n                    res.push_back(newline);\\n                    }\\n                    visit.insert(newadd[j]);\\n                    q.push(newline);\\n                }\\n            }\\n            if(flag) break;  //do not BFS further \\n            for(auto it=visit.begin();it!=visit.end();it++) wordlist.erase(*it); //erase visited one \\n            visit.clear();\\n        }\\n        return res;\\n    }\\n    \\n    // find words with one char different in dict\\n    // hot->[dot,lot]\\n    vector<string> addWord( string word,unordered_set<string>& wordlist ){\\n        vector<string> res;\\n        for(int i=0;i<word.size();i++){\\n            char s =word[i];\\n            for(char c='a';c<='z';c++){\\n                word[i]=c;\\n                if(wordlist.count(word)) res.push_back(word);\\n            }\\n            word[i]=s;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40591,
                "title": "the-fastest-c-solution-56ms",
                "content": "Treat each word as a node of a tree. There are two trees. One tree's root node is \"beginWord\", and the other tree's root node is \"endWord\".\\n\\nThe root node can yield all his children node, and they are the second layer of the tree. The second layer can yield all their children, then we get the third layer of the tree, ... , and so on.\\n\\nWhen one tree yield a new child, we search it in the last layer of the other tree. If we find an identical node in that tree, then we get some ladders connect two roots(\"beginWord\" -> ... -> \"endWord\").\\n\\nAnother thing should be considered is: two(or more) different nodes may yield an identical child. That means the child may have two(or more) parents. For example, \"hit\" and \"hot\" can both yield \"hat\", means \"hat\" has two parents.\\n\\nSo, the data struct of tree-node is:\\n\\n    class Node {\\n    public: \\n        string word;\\n        vectror<Node*> parents;\\n        Node(string w) : word(w) {}\\n    }\\n\\nNote: we don't need a `children` field for `Node` class, because we won't use it.\\n\\nTwo nodes are considered equal when their `word` field are equal. So we introduce an compare function:\\n\\n    bool nodecmp(Node* pa, Node* pb)\\n    {\\n        return pa->word < pb->word;\\n    }\\n\\nThen we use `nodecmp` as the compare function to build a node set.\\n\\n    typedef bool (*NodeCmper) (Node*, Node*);\\n    typedef set<Node*, NodeCmper> NodeSet;\\n    NodeSet layer(nodecmp);\\n\\nThen we can store/search pointers of nodes in node set `layer`.  For example:\\n\\n    Node node1(\"hit\"), node2(\"hot\"), node3(\"hat\");    \\n    layer.insert(&node1);\\n    layer.insert(&node2);\\n    layer.insert(&node3);\\n    auto itr = layer.find(new Node(\"hot\"));\\n    cout << (*itr)->word; // output: hot\\n\\nUsing these data structures, we can solve this problem with bi-direction BFS algorithm. Below is the AC code, and it is very very fast.\\n\\n    class Node;\\n    \\n    typedef vector<string> Ladder;\\n    typedef unordered_set<string> StringSet;\\n    typedef bool (*NodeCmper) (Node*, Node*);\\n    typedef set<Node*, NodeCmper> NodeSet;\\n    \\n    class Node\\n    {\\n    public:\\n        string word;\\n        vector<Node*> parents;\\n    \\n        Node(string w) : word(w) {}\\n        void addparent(Node* parent) { parents.push_back(parent); }\\n    \\n        // Yield all children of this node, and:\\n        //   1) If the child is found in $targetlayer, which means we found ladders that\\n        //      connect BEGIN-WORD and END-WORD, then we get all paths through this node\\n        //      to its ROOT node, and all paths through the target child node to its ROOT\\n        //      node, and combine the two group of paths to a group of ladders, and append\\n        //      these ladders to $ladders.\\n        //   2) Elif the $ladders is empty:\\n        //       2.1) If the child is found in $nextlayer, then get that child, and add\\n        //            this node to its parents.\\n        //       2.2) Else, add the child to nextlayer, and add this node to its parents.\\n        //   3) Else, do nothing.\\n        void yieldchildren(NodeSet& nextlayer, StringSet& wordlist, NodeSet& targetlayer,\\n                           vector<Ladder>& ladders, bool forward)\\n        {\\n            string nextword = word;\\n            for (int i = 0, n = nextword.length(); i < n; i++) {\\n                char oldchar = nextword[i];\\n                for (nextword[i] = 'a'; nextword[i] <= 'z'; nextword[i]++) {\\n                    if (wordlist.count(nextword)) {\\n                        // now we found a valid child-word, let's yield a child.\\n                        Node* child = new Node(nextword);\\n                        yield1(child, nextlayer, targetlayer, ladders, forward);\\n                    }\\n                }\\n                nextword[i] = oldchar;\\n            }\\n        }\\n    \\n        // yield one child, see comment of function `yieldchildren`\\n        void yield1(Node* child, NodeSet& nextlayer, NodeSet& targetlayer,\\n                    vector<Ladder>& ladders, bool forward) {\\n            auto itr = targetlayer.find(child);\\n            if (itr != targetlayer.end()) {\\n                for (Ladder path1 : this->getpaths()) {\\n                    for (Ladder path2 : (*itr)->getpaths()) {\\n                        if (forward) {\\n                            ladders.push_back(path1);\\n                            ladders.back().insert(ladders.back().end(), path2.rbegin(), path2.rend());\\n                        } else {\\n                            ladders.push_back(path2);\\n                            ladders.back().insert(ladders.back().end(), path1.rbegin(), path1.rend());\\n                        }\\n                    }\\n                }\\n            } else if (ladders.empty()) {\\n                auto itr = nextlayer.find(child);\\n                if (itr != nextlayer.end()) {\\n                    (*itr)->addparent(this);\\n                } else {\\n                    child->addparent(this);\\n                    nextlayer.insert(child);\\n                }\\n            }\\n        }\\n    \\n        vector<Ladder> getpaths()\\n        {\\n            vector<Ladder> ladders;\\n            if (parents.empty()) {\\n                ladders.push_back(Ladder(1, word));\\n            } else {\\n                for (Node* parent : parents) {\\n                    for (Ladder ladder : parent->getpaths()) {\\n                        ladders.push_back(ladder);\\n                        ladders.back().push_back(word);\\n                    }\\n                }\\n            }\\n            return ladders;\\n        }\\n    };\\n    \\n    bool nodecmp(Node* pa, Node* pb)\\n    {\\n        return pa->word < pb->word;\\n    }\\n    \\n    class Solution {\\n    public:\\n        vector<Ladder> findLadders(string begin, string end, StringSet& wordlist) {\\n            vector<Ladder> ladders;\\n            Node headroot(begin), tailroot(end);\\n            NodeSet frontlayer(nodecmp), backlayer(nodecmp);\\n            NodeSet *ptr_layerA = &frontlayer, *ptr_layerB = &backlayer;\\n            bool forward = true;\\n    \\n            if (begin == end) {\\n                ladders.push_back(Ladder(1, begin));\\n                return ladders;\\n            }\\n    \\n            frontlayer.insert(&headroot);\\n            backlayer.insert(&tailroot);\\n            wordlist.insert(end);\\n            while (!ptr_layerA->empty() && !ptr_layerB->empty() && ladders.empty()) {\\n                NodeSet nextlayer(nodecmp);\\n                if (ptr_layerA->size() > ptr_layerB->size()) {\\n                    swap(ptr_layerA, ptr_layerB);\\n                    forward = ! forward;\\n                }\\n                for (Node* node : *ptr_layerA) {\\n                    wordlist.erase(node->word);\\n                }\\n                for (Node* node : *ptr_layerA) {\\n                    node->yieldchildren(nextlayer, wordlist, *ptr_layerB, ladders, forward);\\n                }\\n                swap(*ptr_layerA, nextlayer);\\n            }\\n    \\n            return ladders;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Ladder> findLadders(string begin, string end, StringSet& wordlist) {\\n            vector<Ladder> ladders;\\n            Node headroot(begin), tailroot(end);\\n            NodeSet frontlayer(nodecmp), backlayer(nodecmp);\\n            NodeSet *ptr_layerA = &frontlayer, *ptr_layerB = &backlayer;\\n            bool forward = true;\\n    \\n            if (begin == end) {\\n                ladders.push_back(Ladder(1, begin));\\n                return ladders;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2422401,
                "title": "46ms-python-97-faster-working-multiple-solutions-95-memory-efficient-solution",
                "content": "# Don\\'t Forget To Upvote\\n\\n# 1. 97.81% Faster Solution:\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\t\\td = defaultdict(list)\\n\\t\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n\\t\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\t\\treturn []\\n\\n\\t\\t\\t\\tvisited1 = defaultdict(list)\\n\\t\\t\\t\\tq1 = deque([beginWord])\\n\\t\\t\\t\\tvisited1[beginWord] = []\\n\\n\\t\\t\\t\\tvisited2 = defaultdict(list)\\n\\t\\t\\t\\tq2 = deque([endWord])\\n\\t\\t\\t\\tvisited2[endWord] = []\\n\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tdef dfs(v, visited, path, paths):\\n\\t\\t\\t\\t\\tpath.append(v)\\n\\t\\t\\t\\t\\tif not visited[v]:\\n\\t\\t\\t\\t\\t\\tif visited is visited1:\\n\\t\\t\\t\\t\\t\\t\\tpaths.append(path[::-1])\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tpaths.append(path[:])\\n\\t\\t\\t\\t\\tfor u in visited[v]:\\n\\t\\t\\t\\t\\t\\tdfs(u, visited, path, paths)\\n\\t\\t\\t\\t\\tpath.pop()\\n\\n\\t\\t\\t\\tdef bfs(q, visited1, visited2, frombegin):\\n\\t\\t\\t\\t\\tlevel_visited = defaultdict(list)\\n\\t\\t\\t\\t\\tfor _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\tu = q.popleft()\\n\\n\\t\\t\\t\\t\\t\\tfor i in range(len(u)):\\n\\t\\t\\t\\t\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\t\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths1, paths2 = paths2, paths1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor a in paths1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor b in paths2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(a+b)\\n\\t\\t\\t\\t\\t\\t\\t\\telif v not in visited1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif v not in level_visited:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tq.append(v)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlevel_visited[v].append(u)\\n\\t\\t\\t\\t\\tvisited1.update(level_visited)\\n\\n\\t\\t\\t\\twhile q1 and q2 and not ans:\\n\\t\\t\\t\\t\\tif len(q1) <= len(q2):\\n\\t\\t\\t\\t\\t\\tbfs(q1, visited1, visited2, True)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbfs(q2, visited2, visited1, False)\\n\\n\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2. 87% fast solution a little different approach:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\t\\tres = []\\n\\t\\t\\t\\tedge = collections.defaultdict(set)\\n\\t\\t\\t\\twordList = set(wordList)\\n\\t\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\t\\tedge[word[:i] +\\'*\\'+word[i+1:]].add(word)\\n\\t\\t\\t\\tbfsedge = {}\\n\\n\\t\\t\\t\\tdef bfs():\\n\\t\\t\\t\\t\\tminl = 0\\n\\t\\t\\t\\t\\tqueue = set()\\n\\t\\t\\t\\t\\tqueue.add(beginWord)\\n\\t\\t\\t\\t\\twhile queue:\\n\\t\\t\\t\\t\\t\\tnext_queue = set()\\n\\t\\t\\t\\t\\t\\tfor word in queue:\\n\\t\\t\\t\\t\\t\\t\\tif word in wordList:\\n\\t\\t\\t\\t\\t\\t\\t\\twordList.remove(word)\\n\\t\\t\\t\\t\\t\\tbfsedge[minl] = collections.defaultdict(set)\\n\\t\\t\\t\\t\\t\\tfor word in queue:\\n\\t\\t\\t\\t\\t\\t\\tif word == endWord:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn minl\\n\\t\\t\\t\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\t\\t\\t\\tfor w in edge[word[:i]+\\'*\\'+word[i+1:]]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif w in wordList:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnext_queue.add(w)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbfsedge[minl][w].add(word)\\n\\t\\t\\t\\t\\t\\tqueue = next_queue\\n\\t\\t\\t\\t\\t\\tminl += 1\\n\\t\\t\\t\\t\\treturn minl\\n\\n\\t\\t\\t\\tdef dfs(seq, endWord):\\n\\t\\t\\t\\t\\tif seq[-1] == endWord:\\n\\t\\t\\t\\t\\t\\tres.append(seq.copy())\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tfor nextWord in bfsedge[minl-len(seq)][seq[-1]]:\\n\\t\\t\\t\\t\\t\\tif nextWord not in seq:\\n\\t\\t\\t\\t\\t\\t\\tdfs(seq+[nextWord], endWord)\\n\\n\\t\\t\\t\\tminl = bfs()\\n\\t\\t\\t\\tdfs([endWord], beginWord)\\n\\t\\t\\t\\t# reverse the sequence\\n\\t\\t\\t\\tfor sq in res:\\n\\t\\t\\t\\t\\tsq.reverse()\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 3.95% Memory efficient solution:\\n\\t\\tfrom collections import deque\\n\\t\\tclass Solution:\\n\\t\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\t\\tif endWord not in wordList:return []\\n\\t\\t\\t\\twordList.append(beginWord)\\n\\t\\t\\t\\twordList.append(endWord)\\n\\t\\t\\t\\tdistance = {}\\n\\n\\n\\t\\t\\t\\tself.bfs(endWord, distance, wordList)\\n\\n\\t\\t\\t\\tresults = []\\n\\t\\t\\t\\tself.dfs(beginWord, endWord, distance, wordList, [beginWord], results)\\n\\n\\t\\t\\t\\treturn results\\n\\n\\t\\t\\tdef bfs(self, start, distance, w):\\n\\t\\t\\t\\tdistance[start] = 0\\n\\t\\t\\t\\tqueue = deque([start])\\n\\t\\t\\t\\twhile queue:\\n\\t\\t\\t\\t\\tword = queue.popleft()\\n\\t\\t\\t\\t\\tfor next_word in self.get_next_words(word, w):\\n\\t\\t\\t\\t\\t\\tif next_word not in distance:\\n\\t\\t\\t\\t\\t\\t\\tdistance[next_word] = distance[word] + 1\\n\\t\\t\\t\\t\\t\\t\\tqueue.append(next_word)\\n\\n\\t\\t\\tdef get_next_words(self, word, w):\\n\\t\\t\\t\\twords = []\\n\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\tfor c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n\\t\\t\\t\\t\\t\\tnext_word = word[:i] + c + word[i + 1:]\\n\\t\\t\\t\\t\\t\\tif next_word != word and next_word in w:\\n\\t\\t\\t\\t\\t\\t\\twords.append(next_word)\\n\\t\\t\\t\\treturn words\\n\\n\\t\\t\\tdef dfs(self, curt, target, distance, w, path, results):\\n\\t\\t\\t\\tif curt == target:\\n\\t\\t\\t\\t\\tresults.append(list(path))\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tfor word in self.get_next_words(curt, w):\\n\\t\\t\\t\\t\\tif distance[word] != distance[curt] - 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tpath.append(word)\\n\\t\\t\\t\\t\\tself.dfs(word, target, distance, w, path, results)\\n\\t\\t\\t\\t\\tpath.pop()\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution:\\n\\t\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\t\\td = defaultdict(list)\\n\\t\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n\\t\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\t\\treturn []\\n\\n\\t\\t\\t\\tvisited1 = defaultdict(list)\\n\\t\\t\\t\\tq1 = deque([beginWord])\\n\\t\\t\\t\\tvisited1[beginWord] = []\\n\\n\\t\\t\\t\\tvisited2 = defaultdict(list)\\n\\t\\t\\t\\tq2 = deque([endWord])\\n\\t\\t\\t\\tvisited2[endWord] = []\\n\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tdef dfs(v, visited, path, paths):\\n\\t\\t\\t\\t\\tpath.append(v)\\n\\t\\t\\t\\t\\tif not visited[v]:\\n\\t\\t\\t\\t\\t\\tif visited is visited1:\\n\\t\\t\\t\\t\\t\\t\\tpaths.append(path[::-1])\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tpaths.append(path[:])\\n\\t\\t\\t\\t\\tfor u in visited[v]:\\n\\t\\t\\t\\t\\t\\tdfs(u, visited, path, paths)\\n\\t\\t\\t\\t\\tpath.pop()\\n\\n\\t\\t\\t\\tdef bfs(q, visited1, visited2, frombegin):\\n\\t\\t\\t\\t\\tlevel_visited = defaultdict(list)\\n\\t\\t\\t\\t\\tfor _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\tu = q.popleft()\\n\\n\\t\\t\\t\\t\\t\\tfor i in range(len(u)):\\n\\t\\t\\t\\t\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\t\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpaths1, paths2 = paths2, paths1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor a in paths1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor b in paths2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(a+b)\\n\\t\\t\\t\\t\\t\\t\\t\\telif v not in visited1:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif v not in level_visited:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tq.append(v)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlevel_visited[v].append(u)\\n\\t\\t\\t\\t\\tvisited1.update(level_visited)\\n\\n\\t\\t\\t\\twhile q1 and q2 and not ans:\\n\\t\\t\\t\\t\\tif len(q1) <= len(q2):\\n\\t\\t\\t\\t\\t\\tbfs(q1, visited1, visited2, True)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbfs(q2, visited2, visited1, False)\\n\\n\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n# 2. 87% fast solution a little different approach:\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\t\\tres = []\\n\\t\\t\\t\\tedge = collections.defaultdict(set)\\n\\t\\t\\t\\twordList = set(wordList)\\n\\t\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\t\\t\\tedge[word[:i] +\\'*\\'+word[i+1:]].add(word)\\n\\t\\t\\t\\tbfsedge = {}",
                "codeTag": "Java"
            },
            {
                "id": 40549,
                "title": "fast-and-clean-python-c-solution-using-double-bfs-beats-98",
                "content": "If we know source and destination, we can build the word tree by going forward in one direction and backwards in the other. We stop when we have found that a word in the next level of BFS is in the other level, but first we need to update the tree for the words in the current level.\\n\\nThen we build the result by doing a DFS on the tree constructed by the BFS.\\n\\nThe difference between normal and double BFS is that the search changes from `O(k^d)` to `O(k^(d/2) + k^(d/2))`. Same complexity class, right? Yeah, tell it to the Facebook guys that have to search in graphs with hundreds of thousands of nodes. \\n\\n```\\nclass Solution(object):\\n\\n    # Solution using double BFS\\n\\n    def findLadders(self, begin, end, words_list):\\n        \\n        def construct_paths(source, dest, tree):\\n            if source == dest: \\n                return [[source]]\\n            return [[source] + path for succ in tree[source]\\n                                    for path in construct_paths(succ, dest, tree)]\\n\\n        def add_path(tree, word, neigh, is_forw):\\n            if is_forw: tree[word]  += neigh,\\n            else:       tree[neigh] += word,\\n\\n        def bfs_level(this_lev, oth_lev, tree, is_forw, words_set):\\n            if not this_lev: return False\\n            if len(this_lev) > len(oth_lev):\\n                return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set)\\n            for word in (this_lev | oth_lev):\\n                words_set.discard(word)\\n            next_lev, done = set(), False\\n            while this_lev:\\n                word = this_lev.pop()\\n                for c in string.ascii_lowercase:\\n                    for index in range(len(word)):\\n                        neigh = word[:index] + c + word[index+1:]\\n                        if neigh in oth_lev:\\n                            done = True\\n                            add_path(tree, word, neigh, is_forw)                \\n                        if not done and neigh in words_set:\\n                            next_lev.add(neigh)\\n                            add_path(tree, word, neigh, is_forw)\\n            return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set)\\n                            \\n        tree, path, paths = collections.defaultdict(list), [begin], []\\n        is_found = bfs_level(set([begin]), set([end]), tree, True, words_list)\\n        return construct_paths(begin, end, tree)\\n```\\n\\n\\nC++ code:\\n\\n```\\nvoid add_to_tree(map<string, vector<string>>& tree, \\n              string word, \\n              string neigh, \\n              bool forward) {\\n    if (forward) tree[word].push_back(neigh);\\n    else         tree[neigh].push_back(word);\\n\\n}\\n\\nvector<vector<string>> construct_paths(map<string, \\n                                       vector<string>>& tree, \\n                                       string start, \\n                                       string dest) {\\n    if (start == dest) {\\n        vector<string> res = {start};\\n        vector<vector<string>> arr = {res};\\n        return arr;\\n    }\\n    vector<vector<string>> result;\\n\\n    for (auto succ: tree[start]) {\\n        for (auto path: construct_paths(tree, succ, dest)) {\\n            path.insert(path.begin(), start);\\n            result.push_back(path);\\n        }\\n    }\\n    return result;\\n}\\n\\nbool bfs_levels(unordered_set<string>& now, \\n                unordered_set<string>& oth, \\n                bool& forward, \\n                map<string, vector<string>>& tree, \\n                unordered_set<string>& words_list,\\n                vector<char>& alphabet) {\\n\\n    if (not now.size()) return false;\\n    if (now.size() > oth.size()){\\n        forward = not forward;\\n        return bfs_levels(oth, now, forward, tree, words_list, alphabet);\\n    }\\n    for (auto word: now) words_list.erase(word);\\n    for (auto word: oth) words_list.erase(word);\\n    \\n    bool done = false; unordered_set<string> next;\\n\\n    for (string word: now) {\\n        for (int i = 0; i < word.size(); i++) {\\n            for (char c: alphabet) {\\n                auto neigh = word.substr(0, i) + c + word.substr(i+1);\\n                if (oth.count(neigh) > 0) {\\n                    done = true;\\n                    add_to_tree(tree, word, neigh, forward);\\n                }\\n                else {\\n                    if (not done and words_list.count(neigh) > 0) {\\n                        next.insert(neigh);\\n                        add_to_tree(tree, word, neigh, forward);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    forward = not forward;\\n    return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, \\n                                       string endWord, \\n                                       unordered_set<string> &wordList) {\\n\\n        vector<char> alphabet(26);\\n        std::iota(alphabet.begin(), alphabet.end(), 'a');\\n        unordered_set<string> now = {beginWord}, oth = {endWord};\\n        map<string, vector<string>> tree; bool forward = true;\\n        auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet);\\n        return construct_paths(tree, beginWord, endWord);    \\n                                           \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    # Solution using double BFS\\n\\n    def findLadders(self, begin, end, words_list):\\n        \\n        def construct_paths(source, dest, tree):\\n            if source == dest: \\n                return [[source]]\\n            return [[source] + path for succ in tree[source]\\n                                    for path in construct_paths(succ, dest, tree)]\\n\\n        def add_path(tree, word, neigh, is_forw):\\n            if is_forw: tree[word]  += neigh,\\n            else:       tree[neigh] += word,\\n\\n        def bfs_level(this_lev, oth_lev, tree, is_forw, words_set):\\n            if not this_lev: return False\\n            if len(this_lev) > len(oth_lev):\\n                return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set)\\n            for word in (this_lev | oth_lev):\\n                words_set.discard(word)\\n            next_lev, done = set(), False\\n            while this_lev:\\n                word = this_lev.pop()\\n                for c in string.ascii_lowercase:\\n                    for index in range(len(word)):\\n                        neigh = word[:index] + c + word[index+1:]\\n                        if neigh in oth_lev:\\n                            done = True\\n                            add_path(tree, word, neigh, is_forw)                \\n                        if not done and neigh in words_set:\\n                            next_lev.add(neigh)\\n                            add_path(tree, word, neigh, is_forw)\\n            return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set)\\n                            \\n        tree, path, paths = collections.defaultdict(list), [begin], []\\n        is_found = bfs_level(set([begin]), set([end]), tree, True, words_list)\\n        return construct_paths(begin, end, tree)\\n```\n```\\nvoid add_to_tree(map<string, vector<string>>& tree, \\n              string word, \\n              string neigh, \\n              bool forward) {\\n    if (forward) tree[word].push_back(neigh);\\n    else         tree[neigh].push_back(word);\\n\\n}\\n\\nvector<vector<string>> construct_paths(map<string, \\n                                       vector<string>>& tree, \\n                                       string start, \\n                                       string dest) {\\n    if (start == dest) {\\n        vector<string> res = {start};\\n        vector<vector<string>> arr = {res};\\n        return arr;\\n    }\\n    vector<vector<string>> result;\\n\\n    for (auto succ: tree[start]) {\\n        for (auto path: construct_paths(tree, succ, dest)) {\\n            path.insert(path.begin(), start);\\n            result.push_back(path);\\n        }\\n    }\\n    return result;\\n}\\n\\nbool bfs_levels(unordered_set<string>& now, \\n                unordered_set<string>& oth, \\n                bool& forward, \\n                map<string, vector<string>>& tree, \\n                unordered_set<string>& words_list,\\n                vector<char>& alphabet) {\\n\\n    if (not now.size()) return false;\\n    if (now.size() > oth.size()){\\n        forward = not forward;\\n        return bfs_levels(oth, now, forward, tree, words_list, alphabet);\\n    }\\n    for (auto word: now) words_list.erase(word);\\n    for (auto word: oth) words_list.erase(word);\\n    \\n    bool done = false; unordered_set<string> next;\\n\\n    for (string word: now) {\\n        for (int i = 0; i < word.size(); i++) {\\n            for (char c: alphabet) {\\n                auto neigh = word.substr(0, i) + c + word.substr(i+1);\\n                if (oth.count(neigh) > 0) {\\n                    done = true;\\n                    add_to_tree(tree, word, neigh, forward);\\n                }\\n                else {\\n                    if (not done and words_list.count(neigh) > 0) {\\n                        next.insert(neigh);\\n                        add_to_tree(tree, word, neigh, forward);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    forward = not forward;\\n    return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, \\n                                       string endWord, \\n                                       unordered_set<string> &wordList) {\\n\\n        vector<char> alphabet(26);\\n        std::iota(alphabet.begin(), alphabet.end(), 'a');\\n        unordered_set<string> now = {beginWord}, oth = {endWord};\\n        map<string, vector<string>> tree; bool forward = true;\\n        auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet);\\n        return construct_paths(tree, beginWord, endWord);    \\n                                           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421907,
                "title": "java-easy-explanation-commented",
                "content": "Upvote if it helped\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> ans = new ArrayList<>(); \\n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\\n        queue.add(beginWord); // first layer has only beginWord\\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\\n        boolean findEnd = false; // find endWord flag\\n        while (!queue.isEmpty()) { // traverse current layer nodes\\n            String word = queue.remove();\\n            for (String next : wordSet) {\\n                if (isLadder(word, next)) { // is ladder words\\n\\t\\t\\t\\t\\t// construct the reverse graph from endWord\\n                    Set<String> reverseLadders = reverse.computeIfAbsent(next, k -> new HashSet<>());\\n                    reverseLadders.add(word); \\n                    if (endWord.equals(next)) {\\n                        findEnd = true;\\n                    }\\n                    nextLevel.add(next); // store next layer nodes\\n                }\\n            }\\n            if (queue.isEmpty()) { // when current layer is all visited\\n                if (findEnd) break; // if find the endWord, then break the while loop\\n                queue.addAll(nextLevel); // add next layer nodes to queue\\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\\n                nextLevel.clear();\\n            }\\n        }\\n        if (!findEnd) return ans; // if can\\'t reach endWord from startWord, then return ans.\\n        Set<String> path = new LinkedHashSet<>();\\n        path.add(endWord);\\n\\t\\t// traverse reverse graph from endWord to beginWord\\n        findPath(endWord, beginWord, reverse, ans, path); \\n        return ans;\\n    }\\n\\n\\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\\n                                 List<List<String>> ans, Set<String> path) {\\n        Set<String> next = graph.get(endWord);\\n        if (next == null) return;\\n        for (String word : next) {\\n            path.add(word);\\n            if (beginWord.equals(word)) {\\n                List<String> shortestPath = new ArrayList<>(path);\\n                Collections.reverse(shortestPath); // reverse words in shortest path\\n                ans.add(shortestPath); // add the shortest path to ans.\\n            } else {\\n                findPath(word, beginWord, graph, ans, path);\\n            }\\n            path.remove(word);\\n        }\\n    }\\n\\n    private boolean isLadder(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        int diffCount = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\\n            if (diffCount > 1) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> ans = new ArrayList<>(); \\n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\\n        queue.add(beginWord); // first layer has only beginWord\\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\\n        boolean findEnd = false; // find endWord flag\\n        while (!queue.isEmpty()) { // traverse current layer nodes\\n            String word = queue.remove();\\n            for (String next : wordSet) {\\n                if (isLadder(word, next)) { // is ladder words\\n\\t\\t\\t\\t\\t// construct the reverse graph from endWord\\n                    Set<String> reverseLadders = reverse.computeIfAbsent(next, k -> new HashSet<>());\\n                    reverseLadders.add(word); \\n                    if (endWord.equals(next)) {\\n                        findEnd = true;\\n                    }\\n                    nextLevel.add(next); // store next layer nodes\\n                }\\n            }\\n            if (queue.isEmpty()) { // when current layer is all visited\\n                if (findEnd) break; // if find the endWord, then break the while loop\\n                queue.addAll(nextLevel); // add next layer nodes to queue\\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\\n                nextLevel.clear();\\n            }\\n        }\\n        if (!findEnd) return ans; // if can\\'t reach endWord from startWord, then return ans.\\n        Set<String> path = new LinkedHashSet<>();\\n        path.add(endWord);\\n\\t\\t// traverse reverse graph from endWord to beginWord\\n        findPath(endWord, beginWord, reverse, ans, path); \\n        return ans;\\n    }\\n\\n\\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\\n                                 List<List<String>> ans, Set<String> path) {\\n        Set<String> next = graph.get(endWord);\\n        if (next == null) return;\\n        for (String word : next) {\\n            path.add(word);\\n            if (beginWord.equals(word)) {\\n                List<String> shortestPath = new ArrayList<>(path);\\n                Collections.reverse(shortestPath); // reverse words in shortest path\\n                ans.add(shortestPath); // add the shortest path to ans.\\n            } else {\\n                findPath(word, beginWord, graph, ans, path);\\n            }\\n            path.remove(word);\\n        }\\n    }\\n\\n    private boolean isLadder(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        int diffCount = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\\n            if (diffCount > 1) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358881,
                "title": "python-fast-bfs-explained",
                "content": "The idea of this problem is to run bfs, where one step is changing some letter of word. For me easier to separate problem to two parts:\\n\\n1. Create graph of connections `G`.\\n2. Run bfs on this graph with collecting all possible solutions.\\n\\nNow, let us consider steps in more details.\\n\\n1. To create graph of connections for each word, for example `hit`, create patterns `*it, h*t, hi*`. Then iterate over patterns and connect words in our defaultdict `G`.\\n\\n2. We need to run bfs, but we also need to give as answer all possible solutions, so, we need to modify our algorithm a bit. We keep two dictionaries: `deps` for depths of each word and `paths` to keep all possible paths. When we extract element from queue and look at its neighbours, we need to add new element to queue if `deps[neib] == -1`. Also we need to update `paths[neib]` if `deps[neib] == -1 or deps[neib] == deps[w] + `, that is to deal with all ways of optimal length.\\n\\n#### Complexity\\nWe need `O(nk^2)` time to create all possible patterns: for each of `n` words we have `k` patterns with length `k`. Then we will have no more than `O(n*k*26)` possible connections for all pairs of words, each of which has length `k`, so to create `G` we need `O(nk^2*26)` time. In practice thought this number is smaller, because graph can not have this number of connections. For the last part with bfs we have complexity `O(nk^2*26)` again, because this is the number of edges in our graph + `A`, where `A` is number of found solutions, which can be exponential. So, time complexity is `O(nk^2*26 + A)`, space is the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findLadders(self, begW, endW, wordList):\\n        wordList += [begW]\\n        n, k = len(wordList), len(wordList[0])\\n        patterns = defaultdict(set)\\n        for word in wordList:\\n            for ind in range(0, k):\\n                tmp = word[0:ind] + \"*\" + word[ind+1:]\\n                patterns[tmp].add(word)\\n                \\n        G = defaultdict(set)\\n        for elem in patterns.values():\\n            for x, y in permutations(elem, 2):\\n                G[x].add(y)\\n                \\n        deps = {w: -1 for w in wordList}\\n        deps[begW] = 0\\n        paths = defaultdict(list)\\n        paths[begW] = [[begW]]\\n        queue = deque([begW])\\n\\n        while queue:\\n            w = queue.popleft()\\n            if w == endW: return paths[w]\\n            for neib in G[w]:\\n                if deps[neib] == -1 or deps[neib] == deps[w] + 1:\\n                    if deps[neib] == -1:\\n                        queue.append(neib)\\n                        deps[neib] = deps[w] + 1\\n                    for elem in paths[w]:\\n                        paths[neib].append(elem + [neib])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findLadders(self, begW, endW, wordList):\\n        wordList += [begW]\\n        n, k = len(wordList), len(wordList[0])\\n        patterns = defaultdict(set)\\n        for word in wordList:\\n            for ind in range(0, k):\\n                tmp = word[0:ind] + \"*\" + word[ind+1:]\\n                patterns[tmp].add(word)\\n                \\n        G = defaultdict(set)\\n        for elem in patterns.values():\\n            for x, y in permutations(elem, 2):\\n                G[x].add(y)\\n                \\n        deps = {w: -1 for w in wordList}\\n        deps[begW] = 0\\n        paths = defaultdict(list)\\n        paths[begW] = [[begW]]\\n        queue = deque([begW])\\n\\n        while queue:\\n            w = queue.popleft()\\n            if w == endW: return paths[w]\\n            for neib in G[w]:\\n                if deps[neib] == -1 or deps[neib] == deps[w] + 1:\\n                    if deps[neib] == -1:\\n                        queue.append(neib)\\n                        deps[neib] = deps[w] + 1\\n                    for elem in paths[w]:\\n                        paths[neib].append(elem + [neib])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360127,
                "title": "c-solution-using-bfs-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    void DFS(string &beginWord, string &endWord, unordered_map<string, unordered_set<string>>&adj, vector<string>&path){\\n        path.push_back(beginWord);\\n        if(beginWord == endWord){\\n            ans.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        for(auto x : adj[beginWord])\\n            DFS(x, endWord, adj, path);\\n        \\n        path.pop_back(); //pop current word to backtrack\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,unordered_set<string>>adj; //adjacency list\\n        unordered_set<string> dict(wordList.begin(), wordList.end()); //insert all the strings in set\\n        \\n\\t\\t//step-1 => Find min depth using BFS\\n        queue<string>q;  //for BFS Traversal\\n        q.push(beginWord);\\n        unordered_map<string,int>visited;\\n        visited[beginWord] = 0; //start node will always at level 0\\n        \\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            string temp = curr;\\n            \\n            for(int i = 0; i < curr.size(); i++){ //check all characters\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){ //try all possible 26 letters\\n                    if(temp[i] == c) continue;  //skip if letter is same as original word\\n                    temp[i] = c;\\n                    \\n                    if(dict.count(temp) > 0){ // check if new word is present in wordList\\n                        if(visited.count(temp) == 0){ //check if new word was already visited\\n                            visited[temp] = visited[curr] + 1;\\n                            q.push(temp);\\n                            adj[curr].insert(temp);\\n                        }\\n                        else if(visited[temp] == visited[curr] + 1) //if already visited and new word is child\\n                            adj[curr].insert(temp);    \\n                    }\\n                }\\n                temp[i] = curr[i];  //revert back temp to curr\\n            }\\n        }\\n       // step-2 => find all min depth possible paths using DFS\\n        vector<string>path;\\n        DFS(beginWord, endWord, adj, path);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    void DFS(string &beginWord, string &endWord, unordered_map<string, unordered_set<string>>&adj, vector<string>&path){\\n        path.push_back(beginWord);\\n        if(beginWord == endWord){\\n            ans.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        for(auto x : adj[beginWord])\\n            DFS(x, endWord, adj, path);\\n        \\n        path.pop_back(); //pop current word to backtrack\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,unordered_set<string>>adj; //adjacency list\\n        unordered_set<string> dict(wordList.begin(), wordList.end()); //insert all the strings in set\\n        \\n\\t\\t//step-1 => Find min depth using BFS\\n        queue<string>q;  //for BFS Traversal\\n        q.push(beginWord);\\n        unordered_map<string,int>visited;\\n        visited[beginWord] = 0; //start node will always at level 0\\n        \\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            string temp = curr;\\n            \\n            for(int i = 0; i < curr.size(); i++){ //check all characters\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){ //try all possible 26 letters\\n                    if(temp[i] == c) continue;  //skip if letter is same as original word\\n                    temp[i] = c;\\n                    \\n                    if(dict.count(temp) > 0){ // check if new word is present in wordList\\n                        if(visited.count(temp) == 0){ //check if new word was already visited\\n                            visited[temp] = visited[curr] + 1;\\n                            q.push(temp);\\n                            adj[curr].insert(temp);\\n                        }\\n                        else if(visited[temp] == visited[curr] + 1) //if already visited and new word is child\\n                            adj[curr].insert(temp);    \\n                    }\\n                }\\n                temp[i] = curr[i];  //revert back temp to curr\\n            }\\n        }\\n       // step-2 => find all min depth possible paths using DFS\\n        vector<string>path;\\n        DFS(beginWord, endWord, adj, path);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40435,
                "title": "clean-but-the-best-submission-68ms-in-c-well-commented",
                "content": "    class Solution \\n    {\\n        public:\\n            vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &dict) {\\n                vector<vector<string> > paths;\\n                vector<string> path(1, beginWord);\\n                if (beginWord == endWord)  //corner case;\\n                {\\n                    paths.push_back(path);\\n                    return paths;\\n                }\\n                unordered_set<string> forward, backward;\\n                forward.insert(beginWord);\\n                backward.insert(endWord);\\n                unordered_map<string, vector<string> > tree;\\n                bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate;\\n                if (buildTree(forward, backward, dict, tree, reversed))\\n                    getPath(beginWord, endWord, tree, path, paths);\\n                return paths;\\n            }\\n        private:\\n            bool buildTree(unordered_set<string> &forward, unordered_set<string> &backward, unordered_set<string> &dict, unordered_map<string, vector<string> > &tree, bool reversed) \\n            {\\n                if (forward.empty()) return false;\\n                if (forward.size() > backward.size()) \\n                    return buildTree(backward, forward, dict, tree, !reversed);\\n                for (auto &word: forward) dict.erase(word);\\n                for (auto &word: backward) dict.erase(word);\\n                unordered_set<string> nextLevel;\\n                bool done = false; //in case of invalid further searching;\\n                for (auto &it: forward) //traverse each word in the forward -> the current level of the tree;\\n                {\\n                    string word = it;\\n                    for (auto &c: word) \\n                    {\\n                        char c0 = c; //store the original;\\n                        for (c = 'a'; c <= 'z'; ++c) //try each case;\\n                        {\\n                            if (c != c0) //avoid futile checking;\\n                            {\\n                                if (backward.count(word))  //using count is an accelerating method;\\n                                {\\n                                    done = true;\\n                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent;\\n                                }\\n                                else if (!done && dict.count(word))\\n                                {\\n                                    nextLevel.insert(word);\\n                                    !reversed ? tree[it].push_back(word) : tree[word].push_back(it);\\n                                }\\n                            }\\n                        }\\n                        c = c0; //restore the word;\\n                    }\\n                }\\n                return done || buildTree(nextLevel, backward, dict, tree, reversed);\\n            }\\n    \\n            void getPath(string &beginWord, string &endWord, unordered_map<string, vector<string> > &tree, vector<string> &path, vector<vector<string> > &paths) //using reference can accelerate;\\n            {\\n                if (beginWord == endWord) paths.push_back(path); //till the end;\\n                else\\n                {\\n                    for (auto &it: tree[beginWord]) \\n                    {\\n                        path.push_back(it);\\n                        getPath(it, endWord, tree, path, paths); //DFS retrieving the path;\\n                        path.pop_back();\\n                    }\\n                }\\n            }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution \\n    {\\n        public:\\n            vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &dict) {\\n                vector<vector<string> > paths;\\n                vector<string> path(1, beginWord);\\n                if (beginWord == endWord)  //corner case;\\n                {\\n                    paths.push_back(path);\\n                    return paths;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2422074,
                "title": "python-accepted-bfs-solution-with-clean-commented-code",
                "content": "A key observation of this problem is to convert `wordList` into a graph g = (V, E), where the vertices are all words in `wordList` and `beginWord`, and the edges connect all words that differ by one character. The graph representation of the example testcase is shown below:\\n![image](https://assets.leetcode.com/users/images/086d7da1-c1c2-44ff-a722-e78ab4bbebce_1660450284.4108331.png)\\n\\n\\nGiven this graph, we perform a modified BFS traversal to find all shortest paths from start to end words. The psuedo-code for a standard BFS algorithm is:\\n![image](https://assets.leetcode.com/users/images/b69f27e1-c201-417d-912a-69625a1fa2aa_1660449199.540357.png)\\n\\nIn this problem, we modify this algorithm as follows. \\n\\n\\t\"\"\"\\n\\tIn a nutshell, this problem is an advanced graph traversal algorithm. Here, we use BFS to find all shortest paths\\n\\tfrom beginWord to endWord in a constructed graph  g = (V, E). \\n\\t\\t- |V| = k+1 if beginWord is not in wordList and |V| = k otherwise.\\n\\t\\t- an edge (u, v) is in E if and only if wordList[u] and wordList[v] differ by exactly one character.\\n\\tCheck the docstrings for all the necessary methods for an in-depth explanation of this modified BFS algorithm.\\n\\t\"\"\"\\n\\n\\tfrom typing import List\\n\\timport math\\n\\t\\n\\tdef differ(str1, str2):\\n\\t\\t\"\"\"\\n\\t\\tdetermines if two strings differ by one character.\\n\\t\\t\"\"\"\\n\\t\\tdiff = 0\\n\\n\\t\\tfor i in range(len(str1)):\\n\\t\\t\\tif str1[i] != str2[i]:\\n\\t\\t\\t\\tdiff += 1\\n\\n\\t\\treturn diff == 1\\n\\n\\n\\tdef convert(words):\\n\\t\\t\"\"\"\\n\\t\\tconverts words into the adjacency list representation of a graph, as detailed above.\\n\\t\\t\"\"\"\\n\\t\\tedges = []\\n\\t\\tgraph = [[] for _ in range(len(words))]\\n\\n\\t\\tfor i in range(len(words)):\\n\\t\\t\\tfor j in range(i, len(words)):\\n\\t\\t\\t\\tif differ(words[i], words[j]):\\n\\t\\t\\t\\t\\tedges.append([i, j])\\n\\n\\t\\tfor pair in edges:\\n\\t\\t\\tgraph[pair[0]].append(pair[1])\\n\\t\\t\\tgraph[pair[1]].append(pair[0])\\n\\n\\t\\treturn graph\\n\\n\\n\\tdef bfs(graph, start):\\n\\t\\t\"\"\"\\n\\t\\tperforms a modified bfs search on graph with start node start.\\n\\n\\t\\tReturns:\\n\\t\\t\\t- parents, a dictionary that maps each node in the graph to a list of parents that have the shortest distance from the start node.\\n\\n\\t\\tstart is the index such that wordList[start] = beginWord\\n\\t\\t\"\"\"\\n\\t\\tdist = {start: 0}  # dictionary that maps each node in graph to the shortest distance away from start.\\n\\t\\tparents = {start: None}\\n\\n\\t\\tfor i in range(len(graph)):\\n\\t\\t\\tif i != start:\\n\\t\\t\\t\\tdist[i] = math.inf\\n\\t\\t\\t\\tparents[i] = []\\n\\n\\t\\tqueue = [start]\\n\\n\\t\\twhile queue:\\n\\t\\t\\tnode = queue.pop()\\n\\n\\t\\t\\tfor neighbor in graph[node]:\\n\\t\\t\\t\\tif dist[neighbor] == math.inf:  # neighbor has not been visited yet\\n\\t\\t\\t\\t\\tdist[neighbor] = dist[node] + 1\\n\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\t\\t\\t\\t\\tqueue.insert(0, neighbor)\\n\\n\\t\\t\\t\\telse:  # neighbor has been visited!\\n\\t\\t\\t\\t\\tif dist[node] + 1 == dist[neighbor]:\\n\\t\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\t\\t\\t\\t\\telif dist[node] + 1 < dist[neighbor]:  # found a quicker path to neighbor\\n\\t\\t\\t\\t\\t\\tdist[neighbor] = dist[node] + 1\\n\\t\\t\\t\\t\\t\\tparents[neighbor].clear()\\n\\t\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\n\\t\\treturn parents\\n\\n\\n\\tdef findPaths(pathList, currPath, currNode, parents, wordList):\\n\\t\\t\"\"\"\\n\\t\\ttraces back to find all paths from the end node to the start node given the parents dictionary. Returns nothing,\\n\\t\\tbut modifies the input pathList to include all possible paths.\\n\\t\\t\"\"\"\\n\\t\\tif parents[currNode] is None:\\n\\t\\t\\tcurrPath.reverse()\\n\\t\\t\\tpathList.append(currPath)\\n\\n\\t\\tif parents[currNode]:\\n\\t\\t\\tfor parent in parents[currNode]:\\n\\t\\t\\t\\tfindPaths(pathList, currPath + [wordList[parent]], parent, parents, wordList)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\tif beginWord not in wordList:\\n\\t\\t\\t\\twordList.append(beginWord)\\n\\n\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tendIndex = wordList.index(endWord)\\n\\t\\t\\tbeginIndex = wordList.index(beginWord)\\n\\n\\t\\t\\tgraph = convert(wordList)\\n\\t\\t\\tparents = bfs(graph, beginIndex)\\n\\n\\t\\t\\tpathList = []\\n\\t\\t\\tcurrPath = [endWord]\\n\\t\\t\\tfindPaths(pathList, currPath, endIndex, parents, wordList)\\n\\n\\t\\t\\treturn pathList\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "A key observation of this problem is to convert `wordList` into a graph g = (V, E), where the vertices are all words in `wordList` and `beginWord`, and the edges connect all words that differ by one character. The graph representation of the example testcase is shown below:\\n![image](https://assets.leetcode.com/users/images/086d7da1-c1c2-44ff-a722-e78ab4bbebce_1660450284.4108331.png)\\n\\n\\nGiven this graph, we perform a modified BFS traversal to find all shortest paths from start to end words. The psuedo-code for a standard BFS algorithm is:\\n![image](https://assets.leetcode.com/users/images/b69f27e1-c201-417d-912a-69625a1fa2aa_1660449199.540357.png)\\n\\nIn this problem, we modify this algorithm as follows. \\n\\n\\t\"\"\"\\n\\tIn a nutshell, this problem is an advanced graph traversal algorithm. Here, we use BFS to find all shortest paths\\n\\tfrom beginWord to endWord in a constructed graph  g = (V, E). \\n\\t\\t- |V| = k+1 if beginWord is not in wordList and |V| = k otherwise.\\n\\t\\t- an edge (u, v) is in E if and only if wordList[u] and wordList[v] differ by exactly one character.\\n\\tCheck the docstrings for all the necessary methods for an in-depth explanation of this modified BFS algorithm.\\n\\t\"\"\"\\n\\n\\tfrom typing import List\\n\\timport math\\n\\t\\n\\tdef differ(str1, str2):\\n\\t\\t\"\"\"\\n\\t\\tdetermines if two strings differ by one character.\\n\\t\\t\"\"\"\\n\\t\\tdiff = 0\\n\\n\\t\\tfor i in range(len(str1)):\\n\\t\\t\\tif str1[i] != str2[i]:\\n\\t\\t\\t\\tdiff += 1\\n\\n\\t\\treturn diff == 1\\n\\n\\n\\tdef convert(words):\\n\\t\\t\"\"\"\\n\\t\\tconverts words into the adjacency list representation of a graph, as detailed above.\\n\\t\\t\"\"\"\\n\\t\\tedges = []\\n\\t\\tgraph = [[] for _ in range(len(words))]\\n\\n\\t\\tfor i in range(len(words)):\\n\\t\\t\\tfor j in range(i, len(words)):\\n\\t\\t\\t\\tif differ(words[i], words[j]):\\n\\t\\t\\t\\t\\tedges.append([i, j])\\n\\n\\t\\tfor pair in edges:\\n\\t\\t\\tgraph[pair[0]].append(pair[1])\\n\\t\\t\\tgraph[pair[1]].append(pair[0])\\n\\n\\t\\treturn graph\\n\\n\\n\\tdef bfs(graph, start):\\n\\t\\t\"\"\"\\n\\t\\tperforms a modified bfs search on graph with start node start.\\n\\n\\t\\tReturns:\\n\\t\\t\\t- parents, a dictionary that maps each node in the graph to a list of parents that have the shortest distance from the start node.\\n\\n\\t\\tstart is the index such that wordList[start] = beginWord\\n\\t\\t\"\"\"\\n\\t\\tdist = {start: 0}  # dictionary that maps each node in graph to the shortest distance away from start.\\n\\t\\tparents = {start: None}\\n\\n\\t\\tfor i in range(len(graph)):\\n\\t\\t\\tif i != start:\\n\\t\\t\\t\\tdist[i] = math.inf\\n\\t\\t\\t\\tparents[i] = []\\n\\n\\t\\tqueue = [start]\\n\\n\\t\\twhile queue:\\n\\t\\t\\tnode = queue.pop()\\n\\n\\t\\t\\tfor neighbor in graph[node]:\\n\\t\\t\\t\\tif dist[neighbor] == math.inf:  # neighbor has not been visited yet\\n\\t\\t\\t\\t\\tdist[neighbor] = dist[node] + 1\\n\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\t\\t\\t\\t\\tqueue.insert(0, neighbor)\\n\\n\\t\\t\\t\\telse:  # neighbor has been visited!\\n\\t\\t\\t\\t\\tif dist[node] + 1 == dist[neighbor]:\\n\\t\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\t\\t\\t\\t\\telif dist[node] + 1 < dist[neighbor]:  # found a quicker path to neighbor\\n\\t\\t\\t\\t\\t\\tdist[neighbor] = dist[node] + 1\\n\\t\\t\\t\\t\\t\\tparents[neighbor].clear()\\n\\t\\t\\t\\t\\t\\tparents[neighbor].append(node)\\n\\n\\t\\treturn parents\\n\\n\\n\\tdef findPaths(pathList, currPath, currNode, parents, wordList):\\n\\t\\t\"\"\"\\n\\t\\ttraces back to find all paths from the end node to the start node given the parents dictionary. Returns nothing,\\n\\t\\tbut modifies the input pathList to include all possible paths.\\n\\t\\t\"\"\"\\n\\t\\tif parents[currNode] is None:\\n\\t\\t\\tcurrPath.reverse()\\n\\t\\t\\tpathList.append(currPath)\\n\\n\\t\\tif parents[currNode]:\\n\\t\\t\\tfor parent in parents[currNode]:\\n\\t\\t\\t\\tfindPaths(pathList, currPath + [wordList[parent]], parent, parents, wordList)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t\\tif beginWord not in wordList:\\n\\t\\t\\t\\twordList.append(beginWord)\\n\\n\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tendIndex = wordList.index(endWord)\\n\\t\\t\\tbeginIndex = wordList.index(beginWord)\\n\\n\\t\\t\\tgraph = convert(wordList)\\n\\t\\t\\tparents = bfs(graph, beginIndex)\\n\\n\\t\\t\\tpathList = []\\n\\t\\t\\tcurrPath = [endWord]\\n\\t\\t\\tfindPaths(pathList, currPath, endIndex, parents, wordList)\\n\\n\\t\\t\\treturn pathList\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1625441,
                "title": "c-no-tle-by-using-int-to-represent-the-words",
                "content": "**The Judge of the problem has been updated.**\\n\\n* This is a typical BFS problem. We can keep all the paths along with the current nodes, but it will cause TLE.\\n\\n* We can instead keep previous nodes reaching a particular node so that we can traverse back to starting node to get the path.\\n\\n* But this is not enough. New judge forces us to use ```int``` instead of ```string```.\\n\\nSo, I had to update my solution. My new solution uses ```int``` values to represent these words.\\n\\nThe idea is from the user:\\n[szlin21](https://leetcode.com/szlin21/)\\n\\nLet me present the code, step by step.\\n```STEP-1:``` Construct the edges between the adjacent nodes.\\n```STEP-2:``` Apply BFS by keeping previous nodes reaching the current node.\\n```STEP-3:``` Apply DFS to retrieve the paths.\\n\\n*STEP-1: CONSTRUCT EDGES:*\\n```\\nint n = size(wordList), src = -1, dst = -1;\\nfor (int i = 0; i < n; i++) {\\n    if (wordList[i] == beginWord) src = i;\\n    else if (wordList[i] == endWord) dst = i;\\n}\\nif (dst == -1) return ans;\\nif (src == -1) {\\n    wordList.push_back(beginWord);\\n    src = n++;\\n}\\nvector<int> adj[505], parent[505], path = {dst};\\nfor (int i = 0; i < n; i++) {\\n    for (int j = i+1; j < n; j++) {\\n        if (isAdj(wordList[i], wordList[j])) {\\n            adj[i].push_back(j);\\n            adj[j].push_back(i);\\n        }\\n    }\\n}\\n```\\n\\n*STEP-2: APPLY BFS BY KEEPING PREVIOUS NODES:*\\n```\\nvoid bfs(vector<int> adj[], vector<int> parent[], int& src) {\\n    int dist[505] = {};\\n    fill(begin(dist), end(dist), 505);\\n    dist[src] = 0;\\n    queue<int> q;\\n    q.push(src);\\n    parent[src] = {-1};\\n    while (!q.empty()) {\\n        int v = q.front();\\n        q.pop();\\n        for (int u: adj[v]) {\\n            if (dist[u] > dist[v] + 1) {\\n                dist[u] = dist[v] + 1;\\n                q.push(u);\\n                parent[u] = {v};\\n            } else if (dist[u] == dist[v] + 1)\\n                parent[u].push_back(v);\\n        }\\n    }\\n}\\n```\\n\\n*STEP-3: APPLY DFS TO RETRIEVE PATHS:*\\n```\\nvoid dfs(vector<string>& wordList, vector<vector<string>>& ans, vector<int> parent[], vector<int>& path, int v) {\\n    if (v == -1) {\\n        vector<string> tmp(size(path)-1);\\n        transform(rbegin(path)+1, rend(path), begin(tmp), [&] (int& t) { return wordList[t]; });\\n        ans.push_back(move(tmp));\\n        return;\\n    }\\n    for (int u: parent[v]) {\\n        path.push_back(u);\\n        dfs(wordList, ans, parent, path, u);\\n        path.pop_back();\\n    }\\n}\\n```\\n\\n*FULL CODE:*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;\\n        int n = size(wordList), src = -1, dst = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (wordList[i] == beginWord) src = i;\\n            else if (wordList[i] == endWord) dst = i;\\n        }\\n        if (dst == -1) return ans;\\n        if (src == -1) {\\n            wordList.push_back(beginWord);\\n            src = n++;\\n        }\\n        vector<int> adj[505], parent[505], path = {dst};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (isAdj(wordList[i], wordList[j])) {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        bfs(adj, parent, src);\\n        dfs(wordList, ans, parent, path, dst);\\n        return ans;\\n    }\\nprivate:\\n    bool isAdj(string& s1, string& s2) {\\n        int dif = 0;\\n        for (int i = 0; i < size(s1); i++)\\n            dif += s1[i] != s2[i];\\n        return dif == 1;\\n    }\\n    \\n    void bfs(vector<int> adj[], vector<int> parent[], int& src) {\\n        int dist[505] = {};\\n        fill(begin(dist), end(dist), 505);\\n        dist[src] = 0;\\n        queue<int> q;\\n        q.push(src);\\n        parent[src] = {-1};\\n        while (!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n            for (int u: adj[v]) {\\n                if (dist[u] > dist[v] + 1) {\\n                    dist[u] = dist[v] + 1;\\n                    q.push(u);\\n                    parent[u] = {v};\\n                } else if (dist[u] == dist[v] + 1)\\n                    parent[u].push_back(v);\\n            }\\n        }\\n    }\\n    \\n    void dfs(vector<string>& wordList, vector<vector<string>>& ans, vector<int> parent[], vector<int>& path, int v) {\\n        if (v == -1) {\\n            vector<string> tmp(size(path)-1);\\n            transform(rbegin(path)+1, rend(path), begin(tmp), [&] (int& t) { return wordList[t]; });\\n            ans.push_back(move(tmp));\\n            return;\\n        }\\n        for (int u: parent[v]) {\\n            path.push_back(u);\\n            dfs(wordList, ans, parent, path, u);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```int```\n```string```\n```int```\n```STEP-1:```\n```STEP-2:```\n```STEP-3:```\n```\\nint n = size(wordList), src = -1, dst = -1;\\nfor (int i = 0; i < n; i++) {\\n    if (wordList[i] == beginWord) src = i;\\n    else if (wordList[i] == endWord) dst = i;\\n}\\nif (dst == -1) return ans;\\nif (src == -1) {\\n    wordList.push_back(beginWord);\\n    src = n++;\\n}\\nvector<int> adj[505], parent[505], path = {dst};\\nfor (int i = 0; i < n; i++) {\\n    for (int j = i+1; j < n; j++) {\\n        if (isAdj(wordList[i], wordList[j])) {\\n            adj[i].push_back(j);\\n            adj[j].push_back(i);\\n        }\\n    }\\n}\\n```\n```\\nvoid bfs(vector<int> adj[], vector<int> parent[], int& src) {\\n    int dist[505] = {};\\n    fill(begin(dist), end(dist), 505);\\n    dist[src] = 0;\\n    queue<int> q;\\n    q.push(src);\\n    parent[src] = {-1};\\n    while (!q.empty()) {\\n        int v = q.front();\\n        q.pop();\\n        for (int u: adj[v]) {\\n            if (dist[u] > dist[v] + 1) {\\n                dist[u] = dist[v] + 1;\\n                q.push(u);\\n                parent[u] = {v};\\n            } else if (dist[u] == dist[v] + 1)\\n                parent[u].push_back(v);\\n        }\\n    }\\n}\\n```\n```\\nvoid dfs(vector<string>& wordList, vector<vector<string>>& ans, vector<int> parent[], vector<int>& path, int v) {\\n    if (v == -1) {\\n        vector<string> tmp(size(path)-1);\\n        transform(rbegin(path)+1, rend(path), begin(tmp), [&] (int& t) { return wordList[t]; });\\n        ans.push_back(move(tmp));\\n        return;\\n    }\\n    for (int u: parent[v]) {\\n        path.push_back(u);\\n        dfs(wordList, ans, parent, path, u);\\n        path.pop_back();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;\\n        int n = size(wordList), src = -1, dst = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (wordList[i] == beginWord) src = i;\\n            else if (wordList[i] == endWord) dst = i;\\n        }\\n        if (dst == -1) return ans;\\n        if (src == -1) {\\n            wordList.push_back(beginWord);\\n            src = n++;\\n        }\\n        vector<int> adj[505], parent[505], path = {dst};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                if (isAdj(wordList[i], wordList[j])) {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        bfs(adj, parent, src);\\n        dfs(wordList, ans, parent, path, dst);\\n        return ans;\\n    }\\nprivate:\\n    bool isAdj(string& s1, string& s2) {\\n        int dif = 0;\\n        for (int i = 0; i < size(s1); i++)\\n            dif += s1[i] != s2[i];\\n        return dif == 1;\\n    }\\n    \\n    void bfs(vector<int> adj[], vector<int> parent[], int& src) {\\n        int dist[505] = {};\\n        fill(begin(dist), end(dist), 505);\\n        dist[src] = 0;\\n        queue<int> q;\\n        q.push(src);\\n        parent[src] = {-1};\\n        while (!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n            for (int u: adj[v]) {\\n                if (dist[u] > dist[v] + 1) {\\n                    dist[u] = dist[v] + 1;\\n                    q.push(u);\\n                    parent[u] = {v};\\n                } else if (dist[u] == dist[v] + 1)\\n                    parent[u].push_back(v);\\n            }\\n        }\\n    }\\n    \\n    void dfs(vector<string>& wordList, vector<vector<string>>& ans, vector<int> parent[], vector<int>& path, int v) {\\n        if (v == -1) {\\n            vector<string> tmp(size(path)-1);\\n            transform(rbegin(path)+1, rend(path), begin(tmp), [&] (int& t) { return wordList[t]; });\\n            ans.push_back(move(tmp));\\n            return;\\n        }\\n        for (int u: parent[v]) {\\n            path.push_back(u);\\n            dfs(wordList, ans, parent, path, u);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223138,
                "title": "java-bfs-simple-clear-solution-algo-explained-11-ms",
                "content": "**Hit ^Up Vote^ if you like my solution! :)\\nPlease comment below if any doubt!**\\n\\n```\\n/********************************************************************************************\\n    Algo:\\n    1.  Create a Node Class, which will have 2 param, \\n        the word as name & path with traverse history.\\n\\n    2.  Load the wordList to set & create a Node Queue for BFS.\\n        Add the beginWord to the queue.\\n    \\n    3.  Iterate the queue level by level.\\n\\n    4.  Each level create a tempRemoveSet, which will track the words getting used.\\n        And then remove the words from the parent set after every level traversal.\\n        We are doing this because if we remove while adding it to queue the other possibilites\\n        shall not come.\\n        \\n    5.  While traversing, iterate each node from the queue.\\n        Check if the current word is the endWord add the path History of the node to the result.\\n        As, here, we have to find all possiblities we have to keep traversing the all way   \\n        to find all possible paths.\\n        Next, get the next possible wordList which you can jump from here.\\n        Iterate through the list add it to the queue.\\n        Note, here, we are using are passing the current node path history as well \\n        while creating the node object.\\n        \\n    6.  Finally, return the result list.\\n    \\n ********************************************************************************************/\\nclass Solution {\\n        private Set<String> set; // set will congtain the wordList\\n        private Queue<Node> q; // queue to bfs\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> result = new ArrayList<>();\\n        \\n        set = new HashSet<>();\\n        q = new LinkedList<>();\\n        \\n        for(String s : wordList) set.add(s); //add wordList to set\\n       \\n        // if endWord is not in wordList return blank result as no possible path\\n        if(!set.contains(endWord)) return result; \\n        \\n        q.add(new Node(beginWord)); // add the beginNode\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size(); \\n            // tempset to remove the used word all together after every Iteration\\n            Set<String> removeSet = new HashSet<>(); \\n            for(int i=0; i < size; i++){\\n                Node cur = q.poll();\\n                if(cur.name.equals(endWord)) {\\n                    result.add(cur.path); // match found add the path history to the result\\n                }\\n                else{\\n                    List<String> neighbours = getNeighbours(cur.name);\\n                    for(String n : neighbours){\\n                        q.add(new Node(n, cur.path));\\n                        removeSet.add(n); // add the words getting used, later we will delete all.\\n                    }\\n                }\\n            }\\n            set.removeAll(removeSet); // remove the words used in this traversal\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // generate the possible neighbours to traverse\\n    private List<String> getNeighbours(String word){\\n        char[] ch = word.toCharArray();\\n        List<String> words = new ArrayList<>();\\n        // replace each char with from a to z\\n        // and check if thats a valid word\\n        // if valid add to neighbours list\\n        for(int i=0; i < ch.length; i++){\\n            char temp = ch[i];\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++){\\n                ch[i] = j;\\n                String newWord = new String(ch);\\n                if(set.contains(newWord)) words.add(newWord);\\n            }\\n            ch[i] = temp;\\n        }\\n        return words;\\n    }\\n}\\n\\n// Node Class to contain the String word & traversal path\\nclass Node{\\n    String name;\\n    LinkedList<String> path;\\n    \\n    // add the string word as name & add it to path as well\\n    public Node(String name){\\n        this.name = name;\\n        this.path = new LinkedList<>();\\n        this.path.add(name);\\n    }\\n    \\n    // add the name, add path history from parent and then add the current as well.\\n     public Node(String name, LinkedList<String> path){\\n        this.name = name;\\n        this.path = new LinkedList<>();\\n        this.path.addAll(path);\\n        this.path.add(name);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/********************************************************************************************\\n    Algo:\\n    1.  Create a Node Class, which will have 2 param, \\n        the word as name & path with traverse history.\\n\\n    2.  Load the wordList to set & create a Node Queue for BFS.\\n        Add the beginWord to the queue.\\n    \\n    3.  Iterate the queue level by level.\\n\\n    4.  Each level create a tempRemoveSet, which will track the words getting used.\\n        And then remove the words from the parent set after every level traversal.\\n        We are doing this because if we remove while adding it to queue the other possibilites\\n        shall not come.\\n        \\n    5.  While traversing, iterate each node from the queue.\\n        Check if the current word is the endWord add the path History of the node to the result.\\n        As, here, we have to find all possiblities we have to keep traversing the all way   \\n        to find all possible paths.\\n        Next, get the next possible wordList which you can jump from here.\\n        Iterate through the list add it to the queue.\\n        Note, here, we are using are passing the current node path history as well \\n        while creating the node object.\\n        \\n    6.  Finally, return the result list.\\n    \\n ********************************************************************************************/\\nclass Solution {\\n        private Set<String> set; // set will congtain the wordList\\n        private Queue<Node> q; // queue to bfs\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> result = new ArrayList<>();\\n        \\n        set = new HashSet<>();\\n        q = new LinkedList<>();\\n        \\n        for(String s : wordList) set.add(s); //add wordList to set\\n       \\n        // if endWord is not in wordList return blank result as no possible path\\n        if(!set.contains(endWord)) return result; \\n        \\n        q.add(new Node(beginWord)); // add the beginNode\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size(); \\n            // tempset to remove the used word all together after every Iteration\\n            Set<String> removeSet = new HashSet<>(); \\n            for(int i=0; i < size; i++){\\n                Node cur = q.poll();\\n                if(cur.name.equals(endWord)) {\\n                    result.add(cur.path); // match found add the path history to the result\\n                }\\n                else{\\n                    List<String> neighbours = getNeighbours(cur.name);\\n                    for(String n : neighbours){\\n                        q.add(new Node(n, cur.path));\\n                        removeSet.add(n); // add the words getting used, later we will delete all.\\n                    }\\n                }\\n            }\\n            set.removeAll(removeSet); // remove the words used in this traversal\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // generate the possible neighbours to traverse\\n    private List<String> getNeighbours(String word){\\n        char[] ch = word.toCharArray();\\n        List<String> words = new ArrayList<>();\\n        // replace each char with from a to z\\n        // and check if thats a valid word\\n        // if valid add to neighbours list\\n        for(int i=0; i < ch.length; i++){\\n            char temp = ch[i];\\n            for(char j = \\'a\\'; j <= \\'z\\'; j++){\\n                ch[i] = j;\\n                String newWord = new String(ch);\\n                if(set.contains(newWord)) words.add(newWord);\\n            }\\n            ch[i] = temp;\\n        }\\n        return words;\\n    }\\n}\\n\\n// Node Class to contain the String word & traversal path\\nclass Node{\\n    String name;\\n    LinkedList<String> path;\\n    \\n    // add the string word as name & add it to path as well\\n    public Node(String name){\\n        this.name = name;\\n        this.path = new LinkedList<>();\\n        this.path.add(name);\\n    }\\n    \\n    // add the name, add path history from parent and then add the current as well.\\n     public Node(String name, LinkedList<String> path){\\n        this.name = name;\\n        this.path = new LinkedList<>();\\n        this.path.addAll(path);\\n        this.path.add(name);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241584,
                "title": "python-solution",
                "content": "Idea: First do a BFS on the word graph. The purpose of the BFS is two-fold. First, we calculates the distance from `beginWord` to all words in `wordList`. If `endWord` is not in the same connected component as `beginWord`, we `return []`. We store the result in a dictionary `dist`. In particular, we know that the distance `d` from `beginWord` to `endWord` (`dist[endWord]`) is exactly the length of the shortest transformation sequences from `beginWord` to `endWord`. Secondly, we can construct the adjacency list representation of the word graph with the BFS, which is a dictionary `graph` that maps each word to its set of neighbors in the word graph. This facilitates the construction of the shortest transformation sequences using DFS in the next step, because the value corresponding to a particular key will be the set of all the neighbors of the key.\\n\\nNext, we do a DFS starting from `beginWord`. We can use the dictionary `dist` to prune most of the search spaces, because we already know that each of the shortest transformation sequences is of length `dist[endWord] = d`, so that the transformation sequence is of the form `[beginWord, word1, word2, ..., endWord]`, where `dist[beginWord] = 0`, `dist[word1] = 1`, `dist[word2] = 2`, ..., `dist[endWord] = d`. Therefore, we only need to make recursive DFS calls on those neighbors of the current word which are of distance `dist[currentWord]+1` to the `beginWord`. We initialize two lists, `res` which holds the result, and `tmp` which holds all the words in the current DFS subtree. Once the DFS call is on `endWord`, we create a shallow copy of `tmp` and append it to `res`, and return.\\n\\n```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def dfs(word):\\n            tmp.append(word)\\n            if word == endWord:\\n                res.append(list(tmp))\\n                tmp.pop()\\n                return \\n            if word in graph:\\n                for nei in graph[word]:\\n                    if dist[nei] == dist[word]+1:\\n                        dfs(nei)\\n            tmp.pop()\\n\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        q = collections.deque([(beginWord, 0)])\\n        dist = {}\\n        graph = collections.defaultdict(set)\\n        seen = set([beginWord])\\n        while q:\\n            u, d = q.popleft()\\n            dist[u] = d\\n            for i in range(len(u)):\\n                for alph in alphabets:\\n                    if alph != u[i]:\\n                        new = u[:i]+alph+u[i+1:]\\n                        if new in wordSet:\\n                            graph[u].add(new)\\n                            graph[new].add(u)\\n                            if new not in seen:\\n                                q.append((new, d+1))\\n                                seen.add(new)\\n        if endWord not in dist:\\n            return []\\n        res = []\\n        tmp = []\\n        dfs(beginWord)\\n        return res \\n```\\n\\nAnother implementation, in which we do the BFS backwards from `endWord` to `beginWord`.\\n\\n```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\" \\n        def dfs(word):\\n            if word == endWord:\\n                res.append(list(tmp))\\n                return\\n            if word in graph:\\n                for nei in graph[word]:\\n                    if dist[nei] == dist[word]-1:\\n                        tmp.append(nei)\\n                        dfs(nei)\\n                        tmp.pop()\\n        \\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        q = collections.deque([(endWord, 0)])\\n        min_dist = float(\\'inf\\')\\n        seen = set([endWord])\\n        graph = collections.defaultdict(set)\\n        dist = {}\\n        while q:\\n            u, d = q.popleft()\\n            dist[u] = d\\n            for i in range(len(u)):\\n                for alph in alphabets:\\n                    new = u[:i]+alph+u[i+1:]\\n                    if new == beginWord:\\n                        if min_dist > d+1:\\n                            min_dist = d+1\\n                        graph[beginWord].add(u)\\n                    else:                  \\n                        if new in wordSet:\\n                            graph[u].add(new)\\n                            graph[new].add(u)\\n                            if new not in seen:\\n                                seen.add(new)\\n                                q.append((new, d+1))\\n        \\n        if min_dist == float(\\'inf\\'):\\n            return []\\n        res = []\\n        tmp = [beginWord]\\n        for nei in graph[beginWord]:\\n            if dist[nei] == min_dist-1:\\n                tmp.append(nei)\\n                dfs(nei)\\n                tmp.pop()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def dfs(word):\\n            tmp.append(word)\\n            if word == endWord:\\n                res.append(list(tmp))\\n                tmp.pop()\\n                return \\n            if word in graph:\\n                for nei in graph[word]:\\n                    if dist[nei] == dist[word]+1:\\n                        dfs(nei)\\n            tmp.pop()\\n\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        q = collections.deque([(beginWord, 0)])\\n        dist = {}\\n        graph = collections.defaultdict(set)\\n        seen = set([beginWord])\\n        while q:\\n            u, d = q.popleft()\\n            dist[u] = d\\n            for i in range(len(u)):\\n                for alph in alphabets:\\n                    if alph != u[i]:\\n                        new = u[:i]+alph+u[i+1:]\\n                        if new in wordSet:\\n                            graph[u].add(new)\\n                            graph[new].add(u)\\n                            if new not in seen:\\n                                q.append((new, d+1))\\n                                seen.add(new)\\n        if endWord not in dist:\\n            return []\\n        res = []\\n        tmp = []\\n        dfs(beginWord)\\n        return res \\n```\n```\\nclass Solution(object):\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\" \\n        def dfs(word):\\n            if word == endWord:\\n                res.append(list(tmp))\\n                return\\n            if word in graph:\\n                for nei in graph[word]:\\n                    if dist[nei] == dist[word]-1:\\n                        tmp.append(nei)\\n                        dfs(nei)\\n                        tmp.pop()\\n        \\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n        alphabets = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        q = collections.deque([(endWord, 0)])\\n        min_dist = float(\\'inf\\')\\n        seen = set([endWord])\\n        graph = collections.defaultdict(set)\\n        dist = {}\\n        while q:\\n            u, d = q.popleft()\\n            dist[u] = d\\n            for i in range(len(u)):\\n                for alph in alphabets:\\n                    new = u[:i]+alph+u[i+1:]\\n                    if new == beginWord:\\n                        if min_dist > d+1:\\n                            min_dist = d+1\\n                        graph[beginWord].add(u)\\n                    else:                  \\n                        if new in wordSet:\\n                            graph[u].add(new)\\n                            graph[new].add(u)\\n                            if new not in seen:\\n                                seen.add(new)\\n                                q.append((new, d+1))\\n        \\n        if min_dist == float(\\'inf\\'):\\n            return []\\n        res = []\\n        tmp = [beginWord]\\n        for nei in graph[beginWord]:\\n            if dist[nei] == min_dist-1:\\n                tmp.append(nei)\\n                dfs(nei)\\n                tmp.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40572,
                "title": "my-30ms-bidirectional-bfs-and-dfs-based-java-solution",
                "content": "Regarding speed, 30ms solution beats 100% other java solutions.\\n\\nCouple of things that make this solution fast:\\n\\n1) We use Bidirectional BFS which always expand from direction with less nodes\\n\\n2) We use char[] to build string so it would be fast \\n\\n3) Instead of scanning dict each time, we build new string from existing string and check if it is in dict\\n\\nBelow is my commented code.\\n\\n    public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\\n        //we use bi-directional BFS to find shortest path\\n        \\n        Set<String> fwd = new HashSet<String>();\\n        fwd.add(beginWord);\\n        \\n        Set<String> bwd = new HashSet<String>();\\n        bwd.add(endWord);\\n        \\n        Map<String, List<String>> hs = new HashMap<String, List<String>>();\\n        BFS(fwd, bwd, wordList, false, hs);\\n        \\n        List<List<String>> result = new ArrayList<List<String>>();\\n        \\n        //if two parts cannot be connected, then return empty list\\n        if(!isConnected) return result;\\n        \\n        //we need to add start node to temp list as there is no other node can get start node\\n        List<String> temp = new ArrayList<String>();\\n        temp.add(beginWord);\\n        \\n        DFS(result, temp, beginWord, endWord, hs);\\n        \\n        return result;\\n    }\\n    \\n    //flag of whether we have connected two parts\\n    boolean isConnected = false;\\n    \\n    public void BFS(Set<String> forward, Set<String> backward, Set<String> dict, boolean swap, Map<String, List<String>> hs){\\n        \\n        //boundary check\\n        if(forward.isEmpty() || backward.isEmpty()){\\n            return;\\n        }\\n        \\n        //we always do BFS on direction with less nodes\\n        //here we assume forward set has less nodes, if not, we swap them\\n        if(forward.size() > backward.size()){\\n            BFS(backward, forward, dict, !swap, hs);\\n            return;\\n        }\\n        \\n        //remove all forward/backward words from dict to avoid duplicate addition\\n        dict.removeAll(forward);\\n        dict.removeAll(backward);\\n        \\n        //new set contains all new nodes from forward set\\n        Set<String> set3 = new HashSet<String>();\\n        \\n        //do BFS on every node of forward direction\\n        for(String str : forward){\\n            //try to change each char of str\\n            for(int i = 0; i < str.length(); i++){\\n                //try to replace current char with every chars from a to z \\n                char[] ary = str.toCharArray();\\n                for(char j = 'a'; j <= 'z'; j++){\\n                    ary[i] = j;\\n                    String temp = new String(ary);\\n                    \\n                    //we skip this string if it is not in dict nor in backward\\n                    if(!backward.contains(temp) && !dict.contains(temp)){\\n                        continue;\\n                    }\\n                    \\n                    //we follow forward direction    \\n                    String key = !swap? str : temp;\\n                    String val = !swap? temp : str;\\n\\n                    if(!hs.containsKey(key)) hs.put(key, new ArrayList<String>());\\n                    \\n                    //if temp string is in backward set, then it will connect two parts\\n                    if(backward.contains(temp)){\\n                        hs.get(key).add(val);\\n                        isConnected = true;\\n                    }\\n                    \\n                    //if temp is in dict, then we can add it to set3 as new nodes in next layer\\n                    if(!isConnected && dict.contains(temp)){\\n                        hs.get(key).add(val);\\n                        set3.add(temp);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        //to force our path to be shortest, we will not do BFS if we have found shortest path(isConnected = true)\\n        if(!isConnected){\\n            BFS(set3, backward, dict, swap, hs);\\n        }\\n    }\\n    \\n    public void DFS(List<List<String>> result, List<String> temp, String start, String end, Map<String, List<String>> hs){\\n        //we will use DFS, more specifically backtracking to build paths\\n        \\n        //boundary case\\n        if(start.equals(end)){\\n            result.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        //not each node in hs is valid node in shortest path, if we found current node does not have children node,\\n        //then it means it is not in shortest path\\n        if(!hs.containsKey(start)){\\n            return;\\n        }\\n        \\n        for(String s : hs.get(start)){\\n            temp.add(s);\\n            DFS(result, temp, s, end, hs);\\n            temp.remove(temp.size()-1);\\n            \\n        }\\n    }\\n\\n\\nThe main idea is from [awesome solution][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/44110/super-fast-java-solution-two-end-bfs",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Regarding speed, 30ms solution beats 100% other java solutions.\\n\\nCouple of things that make this solution fast:\\n\\n1) We use Bidirectional BFS which always expand from direction with less nodes\\n\\n2) We use char[] to build string so it would be fast \\n\\n3) Instead of scanning dict each time, we build new string from existing string and check if it is in dict\\n\\nBelow is my commented code.\\n\\n    public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\\n        //we use bi-directional BFS to find shortest path\\n        \\n        Set<String> fwd = new HashSet<String>();\\n        fwd.add(beginWord);\\n        \\n        Set<String> bwd = new HashSet<String>();\\n        bwd.add(endWord);\\n        \\n        Map<String, List<String>> hs = new HashMap<String, List<String>>();\\n        BFS(fwd, bwd, wordList, false, hs);\\n        \\n        List<List<String>> result = new ArrayList<List<String>>();\\n        \\n        //if two parts cannot be connected, then return empty list\\n        if(!isConnected) return result;\\n        \\n        //we need to add start node to temp list as there is no other node can get start node\\n        List<String> temp = new ArrayList<String>();\\n        temp.add(beginWord);\\n        \\n        DFS(result, temp, beginWord, endWord, hs);\\n        \\n        return result;\\n    }\\n    \\n    //flag of whether we have connected two parts\\n    boolean isConnected = false;\\n    \\n    public void BFS(Set<String> forward, Set<String> backward, Set<String> dict, boolean swap, Map<String, List<String>> hs){\\n        \\n        //boundary check\\n        if(forward.isEmpty() || backward.isEmpty()){\\n            return;\\n        }\\n        \\n        //we always do BFS on direction with less nodes\\n        //here we assume forward set has less nodes, if not, we swap them\\n        if(forward.size() > backward.size()){\\n            BFS(backward, forward, dict, !swap, hs);\\n            return;\\n        }\\n        \\n        //remove all forward/backward words from dict to avoid duplicate addition\\n        dict.removeAll(forward);\\n        dict.removeAll(backward);\\n        \\n        //new set contains all new nodes from forward set\\n        Set<String> set3 = new HashSet<String>();\\n        \\n        //do BFS on every node of forward direction\\n        for(String str : forward){\\n            //try to change each char of str\\n            for(int i = 0; i < str.length(); i++){\\n                //try to replace current char with every chars from a to z \\n                char[] ary = str.toCharArray();\\n                for(char j = 'a'; j <= 'z'; j++){\\n                    ary[i] = j;\\n                    String temp = new String(ary);\\n                    \\n                    //we skip this string if it is not in dict nor in backward\\n                    if(!backward.contains(temp) && !dict.contains(temp)){\\n                        continue;\\n                    }\\n                    \\n                    //we follow forward direction    \\n                    String key = !swap? str : temp;\\n                    String val = !swap? temp : str;\\n\\n                    if(!hs.containsKey(key)) hs.put(key, new ArrayList<String>());\\n                    \\n                    //if temp string is in backward set, then it will connect two parts\\n                    if(backward.contains(temp)){\\n                        hs.get(key).add(val);\\n                        isConnected = true;\\n                    }\\n                    \\n                    //if temp is in dict, then we can add it to set3 as new nodes in next layer\\n                    if(!isConnected && dict.contains(temp)){\\n                        hs.get(key).add(val);\\n                        set3.add(temp);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        //to force our path to be shortest, we will not do BFS if we have found shortest path(isConnected = true)\\n        if(!isConnected){\\n            BFS(set3, backward, dict, swap, hs);\\n        }\\n    }\\n    \\n    public void DFS(List<List<String>> result, List<String> temp, String start, String end, Map<String, List<String>> hs){\\n        //we will use DFS, more specifically backtracking to build paths\\n        \\n        //boundary case\\n        if(start.equals(end)){\\n            result.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        //not each node in hs is valid node in shortest path, if we found current node does not have children node,\\n        //then it means it is not in shortest path\\n        if(!hs.containsKey(start)){\\n            return;\\n        }\\n        \\n        for(String s : hs.get(start)){\\n            temp.add(s);\\n            DFS(result, temp, s, end, hs);\\n            temp.remove(temp.size()-1);\\n            \\n        }\\n    }\\n\\n\\nThe main idea is from [awesome solution][1]\\n\\n\\n  [1]: https://leetcode.com/discuss/44110/super-fast-java-solution-two-end-bfs",
                "codeTag": "Unknown"
            },
            {
                "id": 241927,
                "title": "c-bfs-dfs",
                "content": "After reading some solutions, I wrote the following one, which was mainly inspired by [this one](https://leetcode.com/problems/word-ladder-ii/discuss/40594/A-concise-solution-using-bfs-and-backtracing). The difference is that the previous solution maps children to parents while I map from parents to children (this makes the DFS more natural). The idea is to first use BFS to search from `beginWord` to `endWord` and generate the word-to-children mapping at the same time. Then, use DFS (backtracking) to generate the transformation sequences according to the mapping.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end()), current, next;\\n        if (dict.find(endWord) == dict.end()) {\\n            return {};\\n        }\\n        unordered_map<string, vector<string>> children;\\n        vector<vector<string>> ladders;\\n        vector<string> ladder;\\n        current.insert(beginWord);\\n        ladder.push_back(beginWord);\\n        while (true) {\\n            for (string word : current) {\\n                dict.erase(word);\\n            }\\n            for (string word : current) {\\n                findChildren(word, next, dict, children);\\n            }\\n            if (next.empty()) {\\n                break;\\n            }\\n            if (next.find(endWord) != next.end()) {\\n                genLadders(beginWord, endWord, children, ladder, ladders);\\n                break;\\n            }\\n            current.clear();\\n            swap(current, next);\\n        }\\n        return ladders;\\n    }\\nprivate:\\n\\n    void findChildren(string word, unordered_set<string>& next, unordered_set<string>& dict, unordered_map<string, vector<string>>& children) {\\n        string parent = word;\\n        for (int i = 0; i < word.size(); i++) {\\n            char t = word[i];\\n            for (int j = 0; j < 26; j++) {\\n                word[i] = \\'a\\' + j;\\n                if (dict.find(word) != dict.end()) {\\n                    next.insert(word);\\n                    children[parent].push_back(word);\\n                }\\n            }\\n            word[i] = t;\\n        }\\n    }\\n\\n    void genLadders(string beginWord, string endWord, unordered_map<string, vector<string>>& children, vector<string>& ladder, vector<vector<string>>& ladders) {\\n        if (beginWord == endWord) {\\n            ladders.push_back(ladder);\\n        } else {\\n            for (string child : children[beginWord]) {\\n                ladder.push_back(child);\\n                genLadders(child, endWord, children, ladder, ladders);\\n                ladder.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\nThe codes can also be written in a graph-theoretic manner.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        if (dict.find(endWord) == dict.end()) {\\n            return {};\\n        }\\n        graph g;\\n        vector<vector<string>> paths;\\n        vector<string> path = {beginWord};\\n        if (buildGraph(g, beginWord, endWord, dict)) {\\n            findPaths(g, beginWord, endWord, path, paths);\\n        }\\n        return paths;\\n    }\\nprivate:\\n    typedef unordered_map<string, vector<string>> graph;\\n    \\n    bool buildGraph(graph& g, string beginWord, string endWord, unordered_set<string>& dict) {\\n        unordered_set<string> todo;\\n        todo.insert(beginWord);\\n        while (!todo.empty()) {\\n            if (todo.find(endWord) != todo.end()) {\\n                return true;\\n            }\\n            for (string word : todo) {\\n                dict.erase(word);\\n            }\\n            unordered_set<string> temp;\\n            for (string word : todo) {\\n                string parent = word;\\n                for (int i = 0; i < word.size(); i++) {\\n                    char c = word[i];\\n                    for (int j = 0; j < 26; j++) {\\n                        word[i] = \\'a\\' + j;\\n                        if (dict.find(word) != dict.end()) {\\n                            temp.insert(word);\\n                            g[parent].push_back(word);\\n                        }\\n                    }\\n                    word[i] = c;\\n                }\\n            }\\n            swap(todo, temp);\\n        }\\n        return false;\\n    }\\n    \\n    void findPaths(graph& g, string beginWord, string endWord, vector<string>& path, vector<vector<string>>& paths) {\\n        if (beginWord == endWord) {\\n            paths.push_back(path);\\n        } else {\\n            for (string child : g[beginWord]) {\\n                path.push_back(child);\\n                findPaths(g, child, endWord, path, paths);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end()), current, next;\\n        if (dict.find(endWord) == dict.end()) {\\n            return {};\\n        }\\n        unordered_map<string, vector<string>> children;\\n        vector<vector<string>> ladders;\\n        vector<string> ladder;\\n        current.insert(beginWord);\\n        ladder.push_back(beginWord);\\n        while (true) {\\n            for (string word : current) {\\n                dict.erase(word);\\n            }\\n            for (string word : current) {\\n                findChildren(word, next, dict, children);\\n            }\\n            if (next.empty()) {\\n                break;\\n            }\\n            if (next.find(endWord) != next.end()) {\\n                genLadders(beginWord, endWord, children, ladder, ladders);\\n                break;\\n            }\\n            current.clear();\\n            swap(current, next);\\n        }\\n        return ladders;\\n    }\\nprivate:\\n\\n    void findChildren(string word, unordered_set<string>& next, unordered_set<string>& dict, unordered_map<string, vector<string>>& children) {\\n        string parent = word;\\n        for (int i = 0; i < word.size(); i++) {\\n            char t = word[i];\\n            for (int j = 0; j < 26; j++) {\\n                word[i] = \\'a\\' + j;\\n                if (dict.find(word) != dict.end()) {\\n                    next.insert(word);\\n                    children[parent].push_back(word);\\n                }\\n            }\\n            word[i] = t;\\n        }\\n    }\\n\\n    void genLadders(string beginWord, string endWord, unordered_map<string, vector<string>>& children, vector<string>& ladder, vector<vector<string>>& ladders) {\\n        if (beginWord == endWord) {\\n            ladders.push_back(ladder);\\n        } else {\\n            for (string child : children[beginWord]) {\\n                ladder.push_back(child);\\n                genLadders(child, endWord, children, ladder, ladders);\\n                ladder.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        if (dict.find(endWord) == dict.end()) {\\n            return {};\\n        }\\n        graph g;\\n        vector<vector<string>> paths;\\n        vector<string> path = {beginWord};\\n        if (buildGraph(g, beginWord, endWord, dict)) {\\n            findPaths(g, beginWord, endWord, path, paths);\\n        }\\n        return paths;\\n    }\\nprivate:\\n    typedef unordered_map<string, vector<string>> graph;\\n    \\n    bool buildGraph(graph& g, string beginWord, string endWord, unordered_set<string>& dict) {\\n        unordered_set<string> todo;\\n        todo.insert(beginWord);\\n        while (!todo.empty()) {\\n            if (todo.find(endWord) != todo.end()) {\\n                return true;\\n            }\\n            for (string word : todo) {\\n                dict.erase(word);\\n            }\\n            unordered_set<string> temp;\\n            for (string word : todo) {\\n                string parent = word;\\n                for (int i = 0; i < word.size(); i++) {\\n                    char c = word[i];\\n                    for (int j = 0; j < 26; j++) {\\n                        word[i] = \\'a\\' + j;\\n                        if (dict.find(word) != dict.end()) {\\n                            temp.insert(word);\\n                            g[parent].push_back(word);\\n                        }\\n                    }\\n                    word[i] = c;\\n                }\\n            }\\n            swap(todo, temp);\\n        }\\n        return false;\\n    }\\n    \\n    void findPaths(graph& g, string beginWord, string endWord, vector<string>& path, vector<vector<string>>& paths) {\\n        if (beginWord == endWord) {\\n            paths.push_back(path);\\n        } else {\\n            for (string child : g[beginWord]) {\\n                path.push_back(child);\\n                findPaths(g, child, endWord, path, paths);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40487,
                "title": "java-solution-with-iteration",
                "content": "Code is about 40 lines, put explanation in comments.\\n\\n    /**\\n     * we are essentially building a graph, from start, BF.\\n     * and at each level we find all reachable words from parent.\\n     * we stop if the current level contains end,\\n     * we return any path whose last node is end.\\n     * \\n     * to achieve BFT, use a deuqe;\\n     * a key improvement is to remove all the words we already reached\\n     * in PREVIOUS LEVEL; we don't need to try visit them again\\n     * in subsequent level, that is guaranteed to be non-optimal solution.\\n     * at each new level, we will removeAll() words reached in previous level from dict.\\n     */\\n    public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        List<List<String>> results = new ArrayList<List<String>>();\\n        dict.add(end);\\n        // instead of storing words we are at, we store the paths.\\n        Deque<List<String>> paths = new LinkedList<List<String>>();\\n        List<String> path0 = new LinkedList<String>();\\n        path0.add(start);\\n        paths.add(path0);\\n        // if we found a path ending at 'end', we will set lastLevel,\\n        // use this data to stop iterating further.\\n        int level = 1, lastLevel = Integer.MAX_VALUE;\\n        Set<String> wordsPerLevel = new HashSet<String>();\\n        while (!paths.isEmpty()) {\\n            List<String> path = paths.pollFirst();\\n            if (path.size() > level) {\\n                dict.removeAll(wordsPerLevel);\\n                wordsPerLevel.clear();\\n                level = path.size();\\n                if (level > lastLevel)\\n                    break; // stop and return\\n            }\\n            //  try to find next word to reach, continuing from the path\\n            String last = path.get(level - 1);\\n            char[] chars = last.toCharArray();\\n            for (int index = 0; index < last.length(); index++) {\\n                char original = chars[index];\\n                for (char c = 'a'; c <= 'z'; c++) {\\n                    chars[index] = c;\\n                    String next = new String(chars);\\n                    if (dict.contains(next)) {\\n                        wordsPerLevel.add(next);\\n                        List<String> nextPath = new LinkedList<String>(path);\\n                        nextPath.add(next);\\n                        if (next.equals(end)) {\\n                            results.add(nextPath);\\n                            lastLevel = level; // curr level is the last level\\n                        } else\\n                            paths.addLast(nextPath);\\n                    }\\n                }\\n                chars[index] = original;\\n            }\\n        }\\n        \\n        return results;\\n    }",
                "solutionTags": [],
                "code": "Code is about 40 lines, put explanation in comments.\\n\\n    /**\\n     * we are essentially building a graph, from start, BF.\\n     * and at each level we find all reachable words from parent.\\n     * we stop if the current level contains end,\\n     * we return any path whose last node is end.\\n     * \\n     * to achieve BFT, use a deuqe;\\n     * a key improvement is to remove all the words we already reached\\n     * in PREVIOUS LEVEL; we don't need to try visit them again\\n     * in subsequent level, that is guaranteed to be non-optimal solution.\\n     * at each new level, we will removeAll() words reached in previous level from dict.\\n     */\\n    public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n        List<List<String>> results = new ArrayList<List<String>>();\\n        dict.add(end);\\n        // instead of storing words we are at, we store the paths.\\n        Deque<List<String>> paths = new LinkedList<List<String>>();\\n        List<String> path0 = new LinkedList<String>();\\n        path0.add(start);\\n        paths.add(path0);\\n        // if we found a path ending at 'end', we will set lastLevel,\\n        // use this data to stop iterating further.\\n        int level = 1, lastLevel = Integer.MAX_VALUE;\\n        Set<String> wordsPerLevel = new HashSet<String>();\\n        while (!paths.isEmpty()) {\\n            List<String> path = paths.pollFirst();\\n            if (path.size() > level) {\\n                dict.removeAll(wordsPerLevel);\\n                wordsPerLevel.clear();\\n                level = path.size();\\n                if (level > lastLevel)\\n                    break; // stop and return\\n            }\\n            //  try to find next word to reach, continuing from the path\\n            String last = path.get(level - 1);\\n            char[] chars = last.toCharArray();\\n            for (int index = 0; index < last.length(); index++) {\\n                char original = chars[index];\\n                for (char c = 'a'; c <= 'z'; c++) {\\n                    chars[index] = c;\\n                    String next = new String(chars);\\n                    if (dict.contains(next)) {\\n                        wordsPerLevel.add(next);\\n                        List<String> nextPath = new LinkedList<String>(path);\\n                        nextPath.add(next);\\n                        if (next.equals(end)) {\\n                            results.add(nextPath);\\n                            lastLevel = level; // curr level is the last level\\n                        } else\\n                            paths.addLast(nextPath);\\n                    }\\n                }\\n                chars[index] = original;\\n            }\\n        }\\n        \\n        return results;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40595,
                "title": "share-my-130-ms-python-solution",
                "content": "Main idea:\\n\\n1. Use character flipping\\n\\n2. Two-end BFS\\n\\n3. defaultdict(list) for easy writing to keep track of paths\\n\\nI also use set intersection to determine if we are done\\n\\n    from collections import defaultdict\\n    class Solution:\\n        # @param start, a string\\n        # @param end, a string\\n        # @param dict, a set of string\\n        # @return a list of lists of string\\n        def findLadders(self, start, end, dict):\\n            wordLen = len(start)\\n            front, back = defaultdict(list), defaultdict(list)\\n            front[start].append([start])\\n            back[end].append([end])\\n            # remove start from dict, add end to dict if it is not there\\n            dict.discard(start)\\n            if end not in dict:\\n                dict.add(end)\\n            forward, result = True, []\\n            while front:\\n                # get all valid transformations\\n                nextSet = defaultdict(list)\\n                for word, paths in front.items():\\n                    for index in range(wordLen):\\n                        for ch in 'abcdefghijklmnopqrstuvwxyz':\\n                            nextWord = word[:index] + ch + word[index+1:]\\n                            if nextWord in dict:\\n                                # update paths\\n                                if forward:\\n                                    # append next word to path\\n                                    nextSet[nextWord].extend([path + [nextWord] for path in paths])\\n                                else:\\n                                    # add next word in front of path\\n                                    nextSet[nextWord].extend([[nextWord] + path for path in paths])\\n                front = nextSet\\n                common = set(front) & set(back)\\n                if common:\\n                    # path is through\\n                    if not forward:\\n                        # switch front and back if we were searching backward\\n                        front, back = back, front\\n                    result.extend([head + tail[1:] for word in common for head in front[word] for tail in back[word]])\\n                    return result\\n    \\n                if len(front) > len(back):\\n                    # swap front and back for better performance (smaller nextSet)\\n                    front, back, forward = back, front, not forward\\n    \\n                # remove transformations from wordDict to avoid cycles\\n                dict -= set(front)\\n    \\n            return []",
                "solutionTags": [
                    "Python"
                ],
                "code": "Main idea:\\n\\n1. Use character flipping\\n\\n2. Two-end BFS\\n\\n3. defaultdict(list) for easy writing to keep track of paths\\n\\nI also use set intersection to determine if we are done\\n\\n    from collections import defaultdict\\n    class Solution:\\n        # @param start, a string\\n        # @param end, a string\\n        # @param dict, a set of string\\n        # @return a list of lists of string\\n        def findLadders(self, start, end, dict):\\n            wordLen = len(start)\\n            front, back = defaultdict(list), defaultdict(list)\\n            front[start].append([start])\\n            back[end].append([end])\\n            # remove start from dict, add end to dict if it is not there\\n            dict.discard(start)\\n            if end not in dict:\\n                dict.add(end)\\n            forward, result = True, []\\n            while front:\\n                # get all valid transformations\\n                nextSet = defaultdict(list)\\n                for word, paths in front.items():\\n                    for index in range(wordLen):\\n                        for ch in 'abcdefghijklmnopqrstuvwxyz':\\n                            nextWord = word[:index] + ch + word[index+1:]\\n                            if nextWord in dict:\\n                                # update paths\\n                                if forward:\\n                                    # append next word to path\\n                                    nextSet[nextWord].extend([path + [nextWord] for path in paths])\\n                                else:\\n                                    # add next word in front of path\\n                                    nextSet[nextWord].extend([[nextWord] + path for path in paths])\\n                front = nextSet\\n                common = set(front) & set(back)\\n                if common:\\n                    # path is through\\n                    if not forward:\\n                        # switch front and back if we were searching backward\\n                        front, back = back, front\\n                    result.extend([head + tail[1:] for word in common for head in front[word] for tail in back[word]])\\n                    return result\\n    \\n                if len(front) > len(back):\\n                    # swap front and back for better performance (smaller nextSet)\\n                    front, back, forward = back, front, not forward\\n    \\n                # remove transformations from wordDict to avoid cycles\\n                dict -= set(front)\\n    \\n            return []",
                "codeTag": "Java"
            },
            {
                "id": 2425494,
                "title": "java-solution-88-ms",
                "content": "```\\nclass Solution {\\n    public List<List<String>> ans;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        ans=new ArrayList<>();\\n        \\n        Map<String, List<String>> graph = new HashMap<>();\\n        for(String s: wordList) {\\n            graph.put(s, new ArrayList<>());\\n        }\\n        //if beginword is not in graph then add it\\n        if(!graph.containsKey(beginWord)) {\\n            wordList.add(beginWord);\\n            graph.put(beginWord, new ArrayList<>());\\n        }\\n        \\n        for(String s: wordList) {\\n            for(int i=0;i<s.length();i++) {\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                    String checkWord=s.substring(0, i)+ch+s.substring(i+1);\\n                    if(graph.containsKey(checkWord) && !s.equals(checkWord)) {\\n                        List<String> l=graph.get(s);\\n                        l.add(checkWord);\\n                        graph.put(s, l);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Set<String> visited=new HashSet<>(wordList.size());\\n        Map<String, Integer> distFromStarting = new HashMap<>(); //distance from begin node\\n        //will use it to calculate dfs in reverse order from endWord to beginWord\\n        \\n        //debug\\n        // System.out.println(\"Graph->\"+graph);\\n        \\n        int shortestLength = bfs(beginWord, endWord, graph, visited, distFromStarting); //for shortest path using bfs\\n        if(shortestLength==0) return ans;\\n        \\n        //debug\\n        // System.out.println(distFromStarting);\\n        \\n        //optimised DFS\\n        reverseDFS(endWord, beginWord, new ArrayList<>(), graph, distFromStarting);\\n        return ans;\\n    }\\n    \\n    //from source to destination bfs\\n    public int bfs(String src, String des, Map<String, List<String>> graph, Set<String> visited, Map<String, Integer> distFromStarting) {\\n        List<List<String>> ans=new ArrayList<>();\\n        \\n        Queue<String> queue=new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src);\\n        int level=0;\\n        distFromStarting.put(src, 0);\\n        \\n        while(!queue.isEmpty()) {\\n            int size=queue.size();\\n                \\n            for(int i=0;i<size;i++) {\\n                String cur=queue.remove();\\n                //debug\\n                // System.out.println(ret);\\n                if(cur.equals(des)) {\\n                    return level;\\n                }\\n                for(String n: graph.get(cur)) {\\n                    if(!visited.contains(n)) {\\n                        visited.add(n);\\n                        queue.add(n);\\n                        distFromStarting.put(n, distFromStarting.get(cur)+1);\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        //debug\\n        // System.out.println(ret);\\n        return 0;\\n    }\\n    \\n    public void reverseDFS(String src, String des, List<String> path, Map<String, List<String>> graph, Map<String , Integer> distFromStarting) {\\n        if(src.equals(des)) {\\n            path.add(des);\\n            List<String> list=new ArrayList<>(path);\\n            Collections.reverse(list);\\n            \\n            //debug\\n            // System.out.println(list);\\n            \\n            ans.add(list);\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        \\n        path.add(src);\\n        \\n        //debug\\n        // System.out.println(path);\\n            \\n        for(String next: graph.get(src)) {\\n            // System.out.println(path+\" \"+next);\\n            if(distFromStarting.containsKey(next) && distFromStarting.get(next)+1==distFromStarting.get(src)) {\\n                reverseDFS(next, des, path, graph, distFromStarting);\\n            }\\n        }\\n        \\n        path.remove(path.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> ans;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        ans=new ArrayList<>();\\n        \\n        Map<String, List<String>> graph = new HashMap<>();\\n        for(String s: wordList) {\\n            graph.put(s, new ArrayList<>());\\n        }\\n        //if beginword is not in graph then add it\\n        if(!graph.containsKey(beginWord)) {\\n            wordList.add(beginWord);\\n            graph.put(beginWord, new ArrayList<>());\\n        }\\n        \\n        for(String s: wordList) {\\n            for(int i=0;i<s.length();i++) {\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                    String checkWord=s.substring(0, i)+ch+s.substring(i+1);\\n                    if(graph.containsKey(checkWord) && !s.equals(checkWord)) {\\n                        List<String> l=graph.get(s);\\n                        l.add(checkWord);\\n                        graph.put(s, l);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Set<String> visited=new HashSet<>(wordList.size());\\n        Map<String, Integer> distFromStarting = new HashMap<>(); //distance from begin node\\n        //will use it to calculate dfs in reverse order from endWord to beginWord\\n        \\n        //debug\\n        // System.out.println(\"Graph->\"+graph);\\n        \\n        int shortestLength = bfs(beginWord, endWord, graph, visited, distFromStarting); //for shortest path using bfs\\n        if(shortestLength==0) return ans;\\n        \\n        //debug\\n        // System.out.println(distFromStarting);\\n        \\n        //optimised DFS\\n        reverseDFS(endWord, beginWord, new ArrayList<>(), graph, distFromStarting);\\n        return ans;\\n    }\\n    \\n    //from source to destination bfs\\n    public int bfs(String src, String des, Map<String, List<String>> graph, Set<String> visited, Map<String, Integer> distFromStarting) {\\n        List<List<String>> ans=new ArrayList<>();\\n        \\n        Queue<String> queue=new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src);\\n        int level=0;\\n        distFromStarting.put(src, 0);\\n        \\n        while(!queue.isEmpty()) {\\n            int size=queue.size();\\n                \\n            for(int i=0;i<size;i++) {\\n                String cur=queue.remove();\\n                //debug\\n                // System.out.println(ret);\\n                if(cur.equals(des)) {\\n                    return level;\\n                }\\n                for(String n: graph.get(cur)) {\\n                    if(!visited.contains(n)) {\\n                        visited.add(n);\\n                        queue.add(n);\\n                        distFromStarting.put(n, distFromStarting.get(cur)+1);\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        //debug\\n        // System.out.println(ret);\\n        return 0;\\n    }\\n    \\n    public void reverseDFS(String src, String des, List<String> path, Map<String, List<String>> graph, Map<String , Integer> distFromStarting) {\\n        if(src.equals(des)) {\\n            path.add(des);\\n            List<String> list=new ArrayList<>(path);\\n            Collections.reverse(list);\\n            \\n            //debug\\n            // System.out.println(list);\\n            \\n            ans.add(list);\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        \\n        path.add(src);\\n        \\n        //debug\\n        // System.out.println(path);\\n            \\n        for(String next: graph.get(src)) {\\n            // System.out.println(path+\" \"+next);\\n            if(distFromStarting.containsKey(next) && distFromStarting.get(next)+1==distFromStarting.get(src)) {\\n                reverseDFS(next, des, path, graph, distFromStarting);\\n            }\\n        }\\n        \\n        path.remove(path.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359192,
                "title": "python3-easy-solution-detailed-explanation",
                "content": "## 1. Understanding the problem\\n1. there is a starting word, `beginWord` and an ending word, `endWord`.\\n2. there are a bunch of words in between, following the constrataint that they can\\'t have more than one character different between them.\\n3. the \"bunch of words\" are taken from the `wordList` given.\\n4. Goal: find the *shortest* **paths** from `beginWord` to `endWord`.\\n\\nExample explaination (as taken from question):\\n```\\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\nExplanation: There are 2 shortest transformation sequences:\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\\n```\\n\\nBetween \\'hit\\' and \\'hot\\' there is a single character difference, from \\'i\\' to \\'o\\'. Similarly for \\'dot\\' and \\'dog\\' and then \\'dog\\' and \\'cog\\'. We can\\'t jump the difference in characters - which has to be 1.\\n\\n## 2. Naive Approach\\nWe start from `beginWord`. There are lots of variations that can *spawn* from it. Let\\'s say the word is \\'cat\\'. The variations can be \\'\\\\*at\\' or \\'c\\\\*t\\' or \\'ca\\\\*\\', with \\'\\\\*\\' itself being an alphabet, of one of 26. That\\'s `len(word)*26` variants.\\n\\nWe thus simply need to enumerate all possibilites at all the given steps, keeping the one character change constraint in mind - and *some* of them may reach the desired word, `endWord`. Note that all the possiblities are *not* actually needed because we have a restriction from the list `wordList`.\\n\\nHow can enumerate all the paths? **queue**.\\nHere\\'s a proof of concept:\\n```\\nput the `beginWord` in the queue. \\nwhile the queue is non empty\\n    extract the first element in queue\\n        if it is, we have an answer!\\n    check if its the ending element\\n    find all the *valid* variants of the word\\n    append all those variants in the queue \\n```\\n\\n## 3. Notes\\n- We need to store paths, to return as the answer and not the elements\\n- Yes, those mean a lot of copies :P\\n- We remove the word we have already seen in the queue, from the list. Why? This prevents words already accounted-for, coming back in the queue (to infinity!)\\n\\n## 4. Solution\\n```\\nimport queue\\n\\nclass Solution:\\n    # returns True if w and word are only one character apart\\n    # else returns False\\n    def valid(self, w, word):\\n        diff = 0\\n        for (x, y) in zip(w, word):\\n            if x != y: diff += 1\\n\\n        return True if diff <= 1 else False\\n    \\n    # returns the neighbours\\n    # I kept the name as friends because \\n    # I always have to google the spelling of neighbours\\n    def get_friends(self, word):\\n        return [w for w in self.wordList if self.valid(w, word)]\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        self.wordList = wordList\\n        q = queue.Queue()\\n        ans = []\\n        # keeping the paths instead of the words in the queue\\n        q.put([beginWord]) \\n        \\n        while not q.empty():\\n            path = q.get()\\n            word = path[-1]\\n            if word in self.wordList: self.wordList.remove(word)\\n\\n            if word == endWord:\\n                # the below looks scary, but is trivial\\n                # We are just trying to see if the path is the\\n                # *smallest* possible or not\\n                if (len(ans) and len(path) <= len(ans[-1])) or not len(ans):\\n                        ans.append(path)\\n            \\n            # adding new elements in the list\\n            for w in self.get_friends(word):\\n                q.put(path.copy()+[w])\\n\\n        return ans\\n```\\n\\n## 5. Improving & Optimizing\\nIf you run the above, the space and time complexities are ... sad. Here\\'s one way to make them better. Recall how we are always calling the `self.get_friends(word)` function again and again? What if the same word comes up again and again? We should have a data structure that stores whoose friends are who - and, who all friends we have seen already (`self.wordList` won\\'t cut it. Think Why!)\\n\\nThe last function is changed, the helper functions remain the same.\\n```\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        self.wordList = wordList+[beginWord] # NOTE this change!\\n        q = queue.Queue()\\n        ans = []\\n        q.put([beginWord])\\n        \\n        # storing whoose friend is who, at the very start itself\\n        d = {}\\n        for word in self.wordList:\\n            d[word] = self.get_friends(word) # same as before\\n        # storing who all we have already accounted for\\n        seen = set()\\n        \\n        while not q.empty():\\n            path = q.get()\\n            word = path[-1]\\n            seen.add(word)\\n            \\n            if word == endWord: \\n\\t\\t\\t\\t# thanks to https://leetcode.com/ngzza/ for simpler and cleaner line of code\\n                if not ans or len(path) <= len(ans[-1]:\\n                        ans.append(path)\\n            \\n            for w in d[word]:\\n                # the check, which replaces the self.wordList check\\n                # since the wordList check won\\'t work\\n                if w not in seen:\\n                    q.put(path.copy()+[w])\\n                \\n        \\n        return ans\\n```\\n\\nAny and all comments/constructive criticisms are very welcome!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\nExplanation: There are 2 shortest transformation sequences:\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\\n```\n```\\nput the `beginWord` in the queue. \\nwhile the queue is non empty\\n    extract the first element in queue\\n        if it is, we have an answer!\\n    check if its the ending element\\n    find all the *valid* variants of the word\\n    append all those variants in the queue \\n```\n```\\nimport queue\\n\\nclass Solution:\\n    # returns True if w and word are only one character apart\\n    # else returns False\\n    def valid(self, w, word):\\n        diff = 0\\n        for (x, y) in zip(w, word):\\n            if x != y: diff += 1\\n\\n        return True if diff <= 1 else False\\n    \\n    # returns the neighbours\\n    # I kept the name as friends because \\n    # I always have to google the spelling of neighbours\\n    def get_friends(self, word):\\n        return [w for w in self.wordList if self.valid(w, word)]\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        self.wordList = wordList\\n        q = queue.Queue()\\n        ans = []\\n        # keeping the paths instead of the words in the queue\\n        q.put([beginWord]) \\n        \\n        while not q.empty():\\n            path = q.get()\\n            word = path[-1]\\n            if word in self.wordList: self.wordList.remove(word)\\n\\n            if word == endWord:\\n                # the below looks scary, but is trivial\\n                # We are just trying to see if the path is the\\n                # *smallest* possible or not\\n                if (len(ans) and len(path) <= len(ans[-1])) or not len(ans):\\n                        ans.append(path)\\n            \\n            # adding new elements in the list\\n            for w in self.get_friends(word):\\n                q.put(path.copy()+[w])\\n\\n        return ans\\n```\n```\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        self.wordList = wordList+[beginWord] # NOTE this change!\\n        q = queue.Queue()\\n        ans = []\\n        q.put([beginWord])\\n        \\n        # storing whoose friend is who, at the very start itself\\n        d = {}\\n        for word in self.wordList:\\n            d[word] = self.get_friends(word) # same as before\\n        # storing who all we have already accounted for\\n        seen = set()\\n        \\n        while not q.empty():\\n            path = q.get()\\n            word = path[-1]\\n            seen.add(word)\\n            \\n            if word == endWord: \\n\\t\\t\\t\\t# thanks to https://leetcode.com/ngzza/ for simpler and cleaner line of code\\n                if not ans or len(path) <= len(ans[-1]:\\n                        ans.append(path)\\n            \\n            for w in d[word]:\\n                # the check, which replaces the self.wordList check\\n                # since the wordList check won\\'t work\\n                if w not in seen:\\n                    q.put(path.copy()+[w])\\n                \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423485,
                "title": "python-three-steps-approach",
                "content": "This is an implmentation of a solution provided [here](https://leetcode.com/problems/word-ladder-ii/discuss/2367587/Python-BFS-%2B-DFS-With-Explanation-Why-Optimization-Is-Needed-to-Not-TLE).\\n\\n**Solution**:\\nThe initial instinct is to used BFS to find shortest paths and keep generating partial paths as we go from one level to another. However, this approach would cause TLE because we end up creating and destroying a lot of paths. Thus, we will avoid this problem by performing these three steps:\\n\\n1. **Adjacency List**: We start by generating adjacency list mapped pattern to words. This approach is better than replacing each character in a word with every lower case alphabets because we avoid checking all 26 alphabets for every character. \\n\\n```\\n    i.e.    wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n            adj = {\\n                \\'*ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'], \\n                \\'h*t\\': [\\'hot\\'], \\n                \\'ho*\\': [\\'hot\\'], \\n                \\'d*t\\': [\\'dot\\'], \\n                \\'do*\\': [\\'dot\\', \\'dog\\'], \\n                \\'*og\\': [\\'dog\\', \\'log\\', \\'cog\\'], \\n                \\'d*g\\': [\\'dog\\'], \\n                \\'l*t\\': [\\'lot\\'], \\n                \\'lo*\\': [\\'lot\\', \\'log\\'], \\n                \\'l*g\\': [\\'log\\'], \\n                \\'c*g\\': [\\'cog\\'], \\n                \\'co*\\': [\\'cog\\']\\n            }\\n```\\n\\n2. **BFS**: Using the adjacency list generated in the previous step, we will traverse such list using BFS from beginWord to endWord and built a reversed adjacency list. The reversed adjacency list will map a word to all words that leading to it. \\n\\n\\tIn order to account for all paths leading to a word while preventing adding duplicate next word to the queue, we will use two sets: Visited and VisitedCurrentLevel. \\n\\t\\n\\tVisited set will be used to keep track of all words used in previous levels. Current word that isn\\'t in such set will be added to the reversed adjacency list. \\nNext, the VisitedCurrentLevel will be used to keep track of all words used in the current level. A next word will only be added to a queue if it doesn\\'t exist in such set. \\n    \\n\\tAfter processing each level, we will merge the VisitedCurrentLevel set into the Visited set.\\n\\n```\\n    i.e.    reversedAdj = {\\n                \\'hot\\': [\\'hit\\'], \\n                \\'dot\\': [\\'hot\\'], \\n                \\'lot\\': [\\'hot\\'], \\n                \\'dog\\': [\\'dot\\'], \\n                \\'log\\': [\\'lot\\'], \\n                \\'cog\\': [\\'dog\\', \\'log\\']\\n            }\\n```\\n\\n3. **DFS**: Use dfs to traverse the reversed adjacency list from endWord to beginWord and use a single queue to maintain constructed path. We add a next word to the front of the queue before we recursively go to such word and remove such word from the front of queue as we return. Once, the first word is equal to the beginWord, we have succesfully constructed a path. \\n\\n```\\n    i.e.    res = [\\n                [\\'hit\\', \\'hot\\', \\'dot\\', \\'dog\\', \\'cog\\'], \\n                [\\'hit\\', \\'hot\\', \\'lot\\', \\'log\\', \\'cog\\']\\n            ]\\n```\\n\\n**Complexity**:\\n```\\n\\tTime:\\n\\t\\t1.  AdjacencyList: O(nw) where n is length of wordList and w is the length of each word\\n\\t\\t2.  BFS: O(n)\\n\\t\\t3.  DFS: O(n)\\n\\tSpace:\\n        1. AdjacencyList: O(nw) where n is length of wordList and w is the length of each word\\n        2. BFS: O(n)\\n        3. DFS: O(n)\\n```\\n\\n```\\nfrom collections import defaultdict, deque\\n\\n\\nclass Solution:\\n    def findLadders(\\n        self, beginWord: str, endWord: str, wordList: list[str]\\n    ) -> list[list[str]]:\\n\\n        # 1. Create adjacency list\\n        def adjacencyList():\\n\\n            # Initialize the adjacency list\\n            adj = defaultdict(list)\\n\\n            # Iterate through all words\\n            for word in wordList:\\n\\n                # Iterate through all characters in a word\\n                for i, _ in enumerate(word):\\n\\n                    # Create the pattern\\n                    pattern = word[:i] + \"*\" + word[i + 1 :]\\n\\n                    # Add a word into the adjacency list based on its pattern\\n                    adj[pattern].append(word)\\n\\n            return adj\\n\\n        # 2. Create reversed adjacency list\\n        def bfs(adj):\\n\\n            # Initialize the reversed adjacency list\\n            reversedAdj = defaultdict(list)\\n\\n            # Initialize the queue\\n            queue = deque([beginWord])\\n\\n            # Initialize a set to keep track of used words at previous level\\n            visited = set([beginWord])\\n\\n            while queue:\\n\\n                # Initialize a set to keep track of used words at the current level\\n                visitedCurrentLevel = set()\\n\\n                # Get the number of words at this level\\n                n = len(queue)\\n\\n                # Iterate through all words\\n                for _ in range(n):\\n\\n                    # Pop a word from the front of the queue\\n                    word = queue.popleft()\\n\\n                    # Generate pattern based on the current word\\n                    for i, _ in enumerate(word):\\n\\n                        pattern = word[:i] + \"*\" + word[i + 1 :]\\n\\n                        # Itereate through all next words\\n                        for nextWord in adj[pattern]:\\n\\n                            # If the next word hasn\\'t been used in previous levels\\n                            if nextWord not in visited:\\n\\n                                # Add such word to the reversed adjacency list\\n                                reversedAdj[nextWord].append(word)\\n\\n                                # If the next word hasn\\'t been used in the current level\\n                                if nextWord not in visitedCurrentLevel:\\n\\n                                    # Add such word to the queue\\n                                    queue.append(nextWord)\\n\\n                                    # Mark such word as visited\\n                                    visitedCurrentLevel.add(nextWord)\\n\\n                # Once we done with a level, add all words visited at this level to the visited set\\n                visited.update(visitedCurrentLevel)\\n\\n                # If we visited the endWord, end the search\\n                if endWord in visited:\\n                    break\\n\\n            return reversedAdj\\n\\n        # 3. Construct paths based on the reversed adjacency list using DFS\\n        def dfs(reversedAdj, res, path):\\n\\n            # If the first word in a path is beginWord, we have succesfully constructed a path\\n            if path[0] == beginWord:\\n\\n                # Add such path to the result\\n                res.append(list(path))\\n\\n                return res\\n\\n            # Else, get the first word in a path\\n            word = path[0]\\n\\n            # Find next words using the reversed adjacency list\\n            for nextWord in reversedAdj[word]:\\n\\n                # Add such next word to the path\\n                path.appendleft(nextWord)\\n\\n                # Recursively go to the next word\\n                dfs(reversedAdj, res, path)\\n\\n                # Remove such next word from the path\\n                path.popleft()\\n\\n            # Return the result\\n            return res\\n\\n        # Do all three steps\\n        adj = adjacencyList()\\n        reversedAdj = bfs(adj)\\n        res = dfs(reversedAdj, [], deque([endWord]))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    i.e.    wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n            adj = {\\n                \\'*ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'], \\n                \\'h*t\\': [\\'hot\\'], \\n                \\'ho*\\': [\\'hot\\'], \\n                \\'d*t\\': [\\'dot\\'], \\n                \\'do*\\': [\\'dot\\', \\'dog\\'], \\n                \\'*og\\': [\\'dog\\', \\'log\\', \\'cog\\'], \\n                \\'d*g\\': [\\'dog\\'], \\n                \\'l*t\\': [\\'lot\\'], \\n                \\'lo*\\': [\\'lot\\', \\'log\\'], \\n                \\'l*g\\': [\\'log\\'], \\n                \\'c*g\\': [\\'cog\\'], \\n                \\'co*\\': [\\'cog\\']\\n            }\\n```\n```\\n    i.e.    reversedAdj = {\\n                \\'hot\\': [\\'hit\\'], \\n                \\'dot\\': [\\'hot\\'], \\n                \\'lot\\': [\\'hot\\'], \\n                \\'dog\\': [\\'dot\\'], \\n                \\'log\\': [\\'lot\\'], \\n                \\'cog\\': [\\'dog\\', \\'log\\']\\n            }\\n```\n```\\n    i.e.    res = [\\n                [\\'hit\\', \\'hot\\', \\'dot\\', \\'dog\\', \\'cog\\'], \\n                [\\'hit\\', \\'hot\\', \\'lot\\', \\'log\\', \\'cog\\']\\n            ]\\n```\n```\\n\\tTime:\\n\\t\\t1.  AdjacencyList: O(nw) where n is length of wordList and w is the length of each word\\n\\t\\t2.  BFS: O(n)\\n\\t\\t3.  DFS: O(n)\\n\\tSpace:\\n        1. AdjacencyList: O(nw) where n is length of wordList and w is the length of each word\\n        2. BFS: O(n)\\n        3. DFS: O(n)\\n```\n```\\nfrom collections import defaultdict, deque\\n\\n\\nclass Solution:\\n    def findLadders(\\n        self, beginWord: str, endWord: str, wordList: list[str]\\n    ) -> list[list[str]]:\\n\\n        # 1. Create adjacency list\\n        def adjacencyList():\\n\\n            # Initialize the adjacency list\\n            adj = defaultdict(list)\\n\\n            # Iterate through all words\\n            for word in wordList:\\n\\n                # Iterate through all characters in a word\\n                for i, _ in enumerate(word):\\n\\n                    # Create the pattern\\n                    pattern = word[:i] + \"*\" + word[i + 1 :]\\n\\n                    # Add a word into the adjacency list based on its pattern\\n                    adj[pattern].append(word)\\n\\n            return adj\\n\\n        # 2. Create reversed adjacency list\\n        def bfs(adj):\\n\\n            # Initialize the reversed adjacency list\\n            reversedAdj = defaultdict(list)\\n\\n            # Initialize the queue\\n            queue = deque([beginWord])\\n\\n            # Initialize a set to keep track of used words at previous level\\n            visited = set([beginWord])\\n\\n            while queue:\\n\\n                # Initialize a set to keep track of used words at the current level\\n                visitedCurrentLevel = set()\\n\\n                # Get the number of words at this level\\n                n = len(queue)\\n\\n                # Iterate through all words\\n                for _ in range(n):\\n\\n                    # Pop a word from the front of the queue\\n                    word = queue.popleft()\\n\\n                    # Generate pattern based on the current word\\n                    for i, _ in enumerate(word):\\n\\n                        pattern = word[:i] + \"*\" + word[i + 1 :]\\n\\n                        # Itereate through all next words\\n                        for nextWord in adj[pattern]:\\n\\n                            # If the next word hasn\\'t been used in previous levels\\n                            if nextWord not in visited:\\n\\n                                # Add such word to the reversed adjacency list\\n                                reversedAdj[nextWord].append(word)\\n\\n                                # If the next word hasn\\'t been used in the current level\\n                                if nextWord not in visitedCurrentLevel:\\n\\n                                    # Add such word to the queue\\n                                    queue.append(nextWord)\\n\\n                                    # Mark such word as visited\\n                                    visitedCurrentLevel.add(nextWord)\\n\\n                # Once we done with a level, add all words visited at this level to the visited set\\n                visited.update(visitedCurrentLevel)\\n\\n                # If we visited the endWord, end the search\\n                if endWord in visited:\\n                    break\\n\\n            return reversedAdj\\n\\n        # 3. Construct paths based on the reversed adjacency list using DFS\\n        def dfs(reversedAdj, res, path):\\n\\n            # If the first word in a path is beginWord, we have succesfully constructed a path\\n            if path[0] == beginWord:\\n\\n                # Add such path to the result\\n                res.append(list(path))\\n\\n                return res\\n\\n            # Else, get the first word in a path\\n            word = path[0]\\n\\n            # Find next words using the reversed adjacency list\\n            for nextWord in reversedAdj[word]:\\n\\n                # Add such next word to the path\\n                path.appendleft(nextWord)\\n\\n                # Recursively go to the next word\\n                dfs(reversedAdj, res, path)\\n\\n                # Remove such next word from the path\\n                path.popleft()\\n\\n            # Return the result\\n            return res\\n\\n        # Do all three steps\\n        adj = adjacencyList()\\n        reversedAdj = bfs(adj)\\n        res = dfs(reversedAdj, [], deque([endWord]))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211402,
                "title": "java-clean-bfs-dfs-solution-98-two-way-bfs-with-comments",
                "content": "Before trying this question, make sure to totally digest this question: \\n* [127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/1210829/Java-clean-Two-Way-BFS-Solution-oror-with-Analysis)\\n\\nAlso, it will be nice to \\n1. know how to analyze the Time & Space Complexity of the algorithm. \\n2. understand why and how to use Two-Way BFS \\n\\nNotice when building parentsMap, we start from the endword. We construct the map as follows: \\n``` \\n// Graph\\n               c  ->  d\\n            /\\nstartWord  ->  a  ->  b   ->  endWord\\n            \\\\     /      /\\n               e  ->  f  \\n// parentsMap: \\n\\t\\tb : {endWord}\\n\\t\\tf : {endWord}\\n\\t\\ta : {b}\\n\\t\\te : {b, f}\\nstartWord : {a, e}\\n```\\nNotice we do not traverse those words that\\n1. starting from startWord\\n2. not on any shortest path \\n\\nThus when we perform DFS from the startWord, every step we move is on a valid shortest path. \\n\\n**Analysis of the Time & Space Complexity**\\n\\n1. the Complexity of **findNeighbors()**\\n```\\n// denote M := length of each word\\n//        N := length of wordList(number of words of input)\\nTime Complexity:   O(M^ 2)\\n\\t\\tM      (iterate through the whole word by each char) *\\n\\t\\t26     (26 choices of changing each char) *\\n\\t\\tM      (creating a new String) *\\n\\t   O(1)    (check existance in the HashSet)  \\n\\t\\t\\nSpace Complexity:     O(min(M* N , 26 ^ M))\\n       M * N     list of results at most has N words (all words),  each has M chars\\n\\t  26 ^ M    each char has 26 choices \\n```\\n2. the Complexity of **buildMap()**\\n```\\nTime Complexity:   O(N * M^ 2)\\n\\t\\tN          (each word at most once)   * \\n\\t  O(M^2)       (helper-function findNeighbors()) \\n       \\nSpace Complexity:   O(N^ 2 * M)\\n     O(min(M* N , 26 ^ M))    (helper-function findNeighbors())\\n\\t O(N ^ 2 * M)              consider the following cases\\n\\t \\nstartWord  ->            S_1         ->            S_2          ... ->            S_1          -> endWord\\nstartWord  -> {words with dist == 1} -> {words with dist == 2}  ... -> {words with dist == k}  -> endWord\\n\\t\\t\\t\\t\\tsize = N / k             size = N / k                   size = N / k       \\nConsider middle sets S_i & S_(i+1), if every word in S_i may lead to every word in S_(i+1); \\nThen the total Space Complexity is :\\n\\t\\tN / k                 (number of keys in each layer: )  *\\n\\t\\tN / k                 (number of descendants of each key)  *\\n\\t\\t  M                   (length of each word)  *\\n\\t\\t  k                   (total layers)\\nThus we may need  O(N^2 * M)-Space.\\n```\\n\\n**Solution (One-Way BFS + DFS):** \\n\\n```\\nclass Solution {\\n    private Set<String> dict;\\n    private String beginWord;\\n    private String endWord;\\n    \\n    private Map<String, List<String>> parentsMap = new HashMap<>();\\n    private List<List<String>> paths = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.dict = new HashSet(wordList);\\n        dict.add(beginWord);\\n        \\n        if (!dict.contains(endWord)) return paths;\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        \\n        if (!buildMap()) return paths;\\n  \\n        List<String> curr = new ArrayList<>();\\n        curr.add(beginWord);\\n        \\n        collectAllPaths(beginWord, curr);\\n        \\n        return paths;\\n    }\\n    \\n    private void collectAllPaths(String s, List<String> curr) {\\n        if (s.equals(endWord)) {\\n            paths.add(new ArrayList(curr));\\n            return;\\n        }\\n        \\n        for (String next : parentsMap.get(s)) {\\n            curr.add(next);\\n            collectAllPaths(next, curr);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n    \\n \\n    private boolean buildMap() {\\n        Set<String> backward = new HashSet<>();\\n        backward.add(endWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        boolean found = false;\\n        \\n        while (!backward.isEmpty() && !found) {\\n            Set<String> temp = new HashSet<>();\\n            \\n            for (String s : backward) {\\n                visited.add(s);\\n   \\n                for (String nb : getNext(s)) {\\n                    \\n                    if (backward.contains(nb) || visited.contains(nb)) continue;\\n                    if (beginWord.equals(nb)) found = true;\\n\\n                    temp.add(nb);\\n                    parentsMap.putIfAbsent(nb, new ArrayList<>());\\n                    parentsMap.get(nb).add(s);\\n                }\\n            }\\n            backward = temp;\\n        }\\n        return found;\\n    }\\n    \\n    private List<String> getNext(String s) {\\n        char[] arr = s.toCharArray();\\n        List<String> nbs = new ArrayList<>();\\n   \\n        for (int i = 0; i < arr.length; i++) {\\n            char ch = arr[i];\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (c == ch) continue;\\n                arr[i] = c;\\n                String nb = new String(arr);\\n                if (dict.contains(nb)) nbs.add(nb);\\n            }\\n            arr[i] = ch;\\n        }\\n        \\n        return nbs;\\n    }\\n}\\n```\\n\\nIf you are still interested, we may optimize this using Two-Way BFS. The code is maybe too long for an interview session though: \\n\\n**Solution (Two-Way BFS + DFS):** \\n```\\nclass Solution {\\n    private Set<String> dict;\\n    private String beginWord;\\n    private String endWord;\\n    \\n    // Key: String  Value: parents in the sense that close to beginWord/endWord;\\n    private Map<String, List<String>> forwardMap = new HashMap<>(); \\n    private Map<String, List<String>> backwardMap = new HashMap<>(); \\n    \\n    // Key: String (always appears in a path)  Value: list of String that could be the next String in some paths\\n    private Map<String, List<String>> pathMap = new HashMap<>();\\n    \\n    private Set<String> intersect;\\n    \\n    private List<List<String>> paths = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.dict = new HashSet(wordList);\\n        if (!dict.contains(endWord)) return paths;\\n        \\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        \\n        this.intersect = buildMaps();\\n        if (intersect.size() == 0) return paths;\\n        \\n        trimForwardMap();\\n        trimBackwardMap();\\n        \\n        List<String> curr = new ArrayList<>();\\n        curr.add(beginWord);\\n        collectAllPaths(beginWord, curr);\\n        \\n        return paths;\\n    }\\n    \\n    private void collectAllPaths(String s, List<String> curr) {\\n        if (s.equals(endWord)) {\\n            paths.add(new ArrayList(curr));\\n            return;\\n        }\\n        \\n        for (String next : pathMap.get(s)) {\\n            curr.add(next);\\n            collectAllPaths(next, curr);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n    }\\n    \\n    \\n    private Set<String> buildMaps() {\\n        Set<String> forward = new HashSet<>();\\n        forward.add(beginWord);\\n        \\n        Set<String> backward = new HashSet<>();\\n        backward.add(endWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        Set<String> intersect = new HashSet<>();\\n       \\n        boolean found = false;\\n        boolean reverse = false;   \\n        \\n     \\n        while(!forward.isEmpty() && !found) {\\n            if (forward.size() > backward.size()) {\\n                Set<String> temp = forward;\\n                forward = backward;\\n                backward = temp;\\n                reverse = !reverse;\\n            }\\n            \\n            Set<String> temp = new HashSet<>(); \\n            \\n            for (String s : forward) {\\n                visited.add(s);\\n                \\n                for (String next : getNext(s)) {\\n                    if (forward.contains(next) || visited.contains(next)) continue;\\n                    if (backward.contains(next)) {\\n                        found = true;\\n                        intersect.add(next);\\n                    }\\n                    \\n                    temp.add(next);\\n                    \\n                    if (reverse) {\\n                        backwardMap.putIfAbsent(next, new ArrayList<>());\\n                        backwardMap.get(next).add(s);\\n                    } else {\\n                        forwardMap.putIfAbsent(next, new ArrayList<>());\\n                        forwardMap.get(next).add(s);\\n                    }\\n                }\\n            }\\n            \\n            forward = temp;\\n        }\\n      \\n        return intersect;\\n    }\\n    \\n    private void trimForwardMap() {\\n        Deque<String> queue = new LinkedList<>();\\n        intersect.stream().forEach(s -> queue.offerLast(s));\\n        \\n        Set<String> visited = new HashSet(intersect);\\n        \\n        while (!queue.isEmpty()) {\\n            String s = queue.pollFirst();\\n            if (!forwardMap.containsKey(s)) return;   // reach beginword\\n            \\n            for (String p : forwardMap.get(s)) {\\n                pathMap.putIfAbsent(p, new ArrayList<>());\\n                pathMap.get(p).add(s);\\n                \\n                if (visited.add(p)) queue.offerLast(p);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    private void trimBackwardMap() {\\n        Deque<String> queue = new LinkedList<>();\\n        intersect.stream().forEach(s -> queue.offerLast(s));\\n        \\n        Set<String> visited = new HashSet(intersect);\\n        \\n        while (!queue.isEmpty()) {\\n            String s = queue.pollFirst();\\n            if (!backwardMap.containsKey(s)) return;   // reach endWord\\n            \\n            for (String d : backwardMap.get(s)) {\\n                pathMap.putIfAbsent(s, new ArrayList<>());\\n                pathMap.get(s).add(d);\\n                \\n                if (visited.add(d)) queue.offerLast(d);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    private List<String> getNext(String s) {\\n        char[] arr = s.toCharArray();\\n        List<String> nbs = new ArrayList<>();\\n   \\n        for (int i = 0; i < arr.length; i++) {\\n            char ch = arr[i];\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (c == ch) continue;\\n                arr[i] = c;\\n                String nb = new String(arr);\\n                if (dict.contains(nb)) nbs.add(nb);\\n            }\\n            arr[i] = ch;\\n        }\\n        \\n        return nbs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "``` \\n// Graph\\n               c  ->  d\\n            /\\nstartWord  ->  a  ->  b   ->  endWord\\n            \\\\     /      /\\n               e  ->  f  \\n// parentsMap: \\n\\t\\tb : {endWord}\\n\\t\\tf : {endWord}\\n\\t\\ta : {b}\\n\\t\\te : {b, f}\\nstartWord : {a, e}\\n```\n```\\n// denote M := length of each word\\n//        N := length of wordList(number of words of input)\\nTime Complexity:   O(M^ 2)\\n\\t\\tM      (iterate through the whole word by each char) *\\n\\t\\t26     (26 choices of changing each char) *\\n\\t\\tM      (creating a new String) *\\n\\t   O(1)    (check existance in the HashSet)  \\n\\t\\t\\nSpace Complexity:     O(min(M* N , 26 ^ M))\\n       M * N     list of results at most has N words (all words),  each has M chars\\n\\t  26 ^ M    each char has 26 choices \\n```\n```\\nTime Complexity:   O(N * M^ 2)\\n\\t\\tN          (each word at most once)   * \\n\\t  O(M^2)       (helper-function findNeighbors()) \\n       \\nSpace Complexity:   O(N^ 2 * M)\\n     O(min(M* N , 26 ^ M))    (helper-function findNeighbors())\\n\\t O(N ^ 2 * M)              consider the following cases\\n\\t \\nstartWord  ->            S_1         ->            S_2          ... ->            S_1          -> endWord\\nstartWord  -> {words with dist == 1} -> {words with dist == 2}  ... -> {words with dist == k}  -> endWord\\n\\t\\t\\t\\t\\tsize = N / k             size = N / k                   size = N / k       \\nConsider middle sets S_i & S_(i+1), if every word in S_i may lead to every word in S_(i+1); \\nThen the total Space Complexity is :\\n\\t\\tN / k                 (number of keys in each layer: )  *\\n\\t\\tN / k                 (number of descendants of each key)  *\\n\\t\\t  M                   (length of each word)  *\\n\\t\\t  k                   (total layers)\\nThus we may need  O(N^2 * M)-Space.\\n```\n```\\nclass Solution {\\n    private Set<String> dict;\\n    private String beginWord;\\n    private String endWord;\\n    \\n    private Map<String, List<String>> parentsMap = new HashMap<>();\\n    private List<List<String>> paths = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.dict = new HashSet(wordList);\\n        dict.add(beginWord);\\n        \\n        if (!dict.contains(endWord)) return paths;\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        \\n        if (!buildMap()) return paths;\\n  \\n        List<String> curr = new ArrayList<>();\\n        curr.add(beginWord);\\n        \\n        collectAllPaths(beginWord, curr);\\n        \\n        return paths;\\n    }\\n    \\n    private void collectAllPaths(String s, List<String> curr) {\\n        if (s.equals(endWord)) {\\n            paths.add(new ArrayList(curr));\\n            return;\\n        }\\n        \\n        for (String next : parentsMap.get(s)) {\\n            curr.add(next);\\n            collectAllPaths(next, curr);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n    \\n \\n    private boolean buildMap() {\\n        Set<String> backward = new HashSet<>();\\n        backward.add(endWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        boolean found = false;\\n        \\n        while (!backward.isEmpty() && !found) {\\n            Set<String> temp = new HashSet<>();\\n            \\n            for (String s : backward) {\\n                visited.add(s);\\n   \\n                for (String nb : getNext(s)) {\\n                    \\n                    if (backward.contains(nb) || visited.contains(nb)) continue;\\n                    if (beginWord.equals(nb)) found = true;\\n\\n                    temp.add(nb);\\n                    parentsMap.putIfAbsent(nb, new ArrayList<>());\\n                    parentsMap.get(nb).add(s);\\n                }\\n            }\\n            backward = temp;\\n        }\\n        return found;\\n    }\\n    \\n    private List<String> getNext(String s) {\\n        char[] arr = s.toCharArray();\\n        List<String> nbs = new ArrayList<>();\\n   \\n        for (int i = 0; i < arr.length; i++) {\\n            char ch = arr[i];\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (c == ch) continue;\\n                arr[i] = c;\\n                String nb = new String(arr);\\n                if (dict.contains(nb)) nbs.add(nb);\\n            }\\n            arr[i] = ch;\\n        }\\n        \\n        return nbs;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Set<String> dict;\\n    private String beginWord;\\n    private String endWord;\\n    \\n    // Key: String  Value: parents in the sense that close to beginWord/endWord;\\n    private Map<String, List<String>> forwardMap = new HashMap<>(); \\n    private Map<String, List<String>> backwardMap = new HashMap<>(); \\n    \\n    // Key: String (always appears in a path)  Value: list of String that could be the next String in some paths\\n    private Map<String, List<String>> pathMap = new HashMap<>();\\n    \\n    private Set<String> intersect;\\n    \\n    private List<List<String>> paths = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.dict = new HashSet(wordList);\\n        if (!dict.contains(endWord)) return paths;\\n        \\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        \\n        this.intersect = buildMaps();\\n        if (intersect.size() == 0) return paths;\\n        \\n        trimForwardMap();\\n        trimBackwardMap();\\n        \\n        List<String> curr = new ArrayList<>();\\n        curr.add(beginWord);\\n        collectAllPaths(beginWord, curr);\\n        \\n        return paths;\\n    }\\n    \\n    private void collectAllPaths(String s, List<String> curr) {\\n        if (s.equals(endWord)) {\\n            paths.add(new ArrayList(curr));\\n            return;\\n        }\\n        \\n        for (String next : pathMap.get(s)) {\\n            curr.add(next);\\n            collectAllPaths(next, curr);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n    }\\n    \\n    \\n    private Set<String> buildMaps() {\\n        Set<String> forward = new HashSet<>();\\n        forward.add(beginWord);\\n        \\n        Set<String> backward = new HashSet<>();\\n        backward.add(endWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        Set<String> intersect = new HashSet<>();\\n       \\n        boolean found = false;\\n        boolean reverse = false;   \\n        \\n     \\n        while(!forward.isEmpty() && !found) {\\n            if (forward.size() > backward.size()) {\\n                Set<String> temp = forward;\\n                forward = backward;\\n                backward = temp;\\n                reverse = !reverse;\\n            }\\n            \\n            Set<String> temp = new HashSet<>(); \\n            \\n            for (String s : forward) {\\n                visited.add(s);\\n                \\n                for (String next : getNext(s)) {\\n                    if (forward.contains(next) || visited.contains(next)) continue;\\n                    if (backward.contains(next)) {\\n                        found = true;\\n                        intersect.add(next);\\n                    }\\n                    \\n                    temp.add(next);\\n                    \\n                    if (reverse) {\\n                        backwardMap.putIfAbsent(next, new ArrayList<>());\\n                        backwardMap.get(next).add(s);\\n                    } else {\\n                        forwardMap.putIfAbsent(next, new ArrayList<>());\\n                        forwardMap.get(next).add(s);\\n                    }\\n                }\\n            }\\n            \\n            forward = temp;\\n        }\\n      \\n        return intersect;\\n    }\\n    \\n    private void trimForwardMap() {\\n        Deque<String> queue = new LinkedList<>();\\n        intersect.stream().forEach(s -> queue.offerLast(s));\\n        \\n        Set<String> visited = new HashSet(intersect);\\n        \\n        while (!queue.isEmpty()) {\\n            String s = queue.pollFirst();\\n            if (!forwardMap.containsKey(s)) return;   // reach beginword\\n            \\n            for (String p : forwardMap.get(s)) {\\n                pathMap.putIfAbsent(p, new ArrayList<>());\\n                pathMap.get(p).add(s);\\n                \\n                if (visited.add(p)) queue.offerLast(p);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    private void trimBackwardMap() {\\n        Deque<String> queue = new LinkedList<>();\\n        intersect.stream().forEach(s -> queue.offerLast(s));\\n        \\n        Set<String> visited = new HashSet(intersect);\\n        \\n        while (!queue.isEmpty()) {\\n            String s = queue.pollFirst();\\n            if (!backwardMap.containsKey(s)) return;   // reach endWord\\n            \\n            for (String d : backwardMap.get(s)) {\\n                pathMap.putIfAbsent(s, new ArrayList<>());\\n                pathMap.get(s).add(d);\\n                \\n                if (visited.add(d)) queue.offerLast(d);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    private List<String> getNext(String s) {\\n        char[] arr = s.toCharArray();\\n        List<String> nbs = new ArrayList<>();\\n   \\n        for (int i = 0; i < arr.length; i++) {\\n            char ch = arr[i];\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (c == ch) continue;\\n                arr[i] = c;\\n                String nb = new String(arr);\\n                if (dict.contains(nb)) nbs.add(nb);\\n            }\\n            arr[i] = ch;\\n        }\\n        \\n        return nbs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933951,
                "title": "python3-word-ladder-ii-simple-bfs",
                "content": "```\\ndef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = collections.defaultdict(set)\\n        l = len(wordList[0])\\n\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return []\\n\\n        wordList.add(beginWord)\\n\\n        def get_matches(word):\\n            return {word[:i]+\\'*\\'+word[i+1:] for i in range(l)}\\n\\n        for word in wordList:\\n            matches = get_matches(word)\\n            for match in matches:\\n                graph[match].add(word)\\n            graph[word] = matches\\n\\n        ans = []\\n        min_path = None\\n        seen = set()\\n\\n        q = collections.deque([(beginWord, 1, [beginWord])])\\n\\n        while q:\\n            word, length, seq = q.popleft()\\n\\n            for w in graph[word]:\\n                if w == endWord and (not min_path or min_path == length+1):\\n                    min_path = length+1\\n                    seq.extend([w])\\n                    ans.append(seq)\\n            \\n                if w not in seen:   \\n                    if w in wordList:\\n                        q.append((w, length, seq+[w]))\\n                    else:\\n                        q.append((w, length+1, seq))\\n            seen.add(word)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = collections.defaultdict(set)\\n        l = len(wordList[0])\\n\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return []\\n\\n        wordList.add(beginWord)\\n\\n        def get_matches(word):\\n            return {word[:i]+\\'*\\'+word[i+1:] for i in range(l)}\\n\\n        for word in wordList:\\n            matches = get_matches(word)\\n            for match in matches:\\n                graph[match].add(word)\\n            graph[word] = matches\\n\\n        ans = []\\n        min_path = None\\n        seen = set()\\n\\n        q = collections.deque([(beginWord, 1, [beginWord])])\\n\\n        while q:\\n            word, length, seq = q.popleft()\\n\\n            for w in graph[word]:\\n                if w == endWord and (not min_path or min_path == length+1):\\n                    min_path = length+1\\n                    seq.extend([w])\\n                    ans.append(seq)\\n            \\n                if w not in seen:   \\n                    if w in wordList:\\n                        q.append((w, length, seq+[w]))\\n                    else:\\n                        q.append((w, length+1, seq))\\n            seen.add(word)\\n\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 683008,
                "title": "c-bfs-with-detailed-explanation-and-illustration",
                "content": "Key points: graph & partial BFS.  DO NOT use matrix to represent a network!!!!\\nThe following content is based on the instance the problem gives.\\nAllow me to show you a picture first:\\n![image](https://assets.leetcode.com/users/charles1791/image_1591935800.png)\\nFor every two words, if they only have one different character, they are called \"neighbors\" and we could draw an edge between them just like the picture shows above. Each number beside the word indicates the number of steps we need to walk starting from the beginWord, namely the distance. Follow the numbers and edges, we could easily find all routes. So our job is to build a network like this and list all the routes (if exist).\\n\\n1. Build a network and store it with vector<int>[]\\n\\tWe need to create a list containing wordList.size() vectors; each vector stores the index of neighbors. (Warning: using matrix would cause \"Time Limit Exceeded\".) For every word, check out whether other words are its neighbors and if yes add their indexs to the vector. \\n\\tThe function of judging neighbors is here:\\n\\t```\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t```\\n\\tTo create a list:\\n\\t```\\n\\twordList.push_back(beginWord);\\n\\tint size = wordList.size();\\n\\tvector<int>* neighbors = new vector<int>[size];\\n\\tint ewordindex = -1;\\n\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t```\\n\\tNow we have an array like this:\\n![image](https://assets.leetcode.com/users/charles1791/image_1591937339.png)\\nIt demonstrates:\\n![image](https://assets.leetcode.com/users/charles1791/image_1591937431.png)\\n\\n2. BFS untill we find the endWord\\nThere\\'s nothing need to say, we just need to memorize each word\\'s precursor, which we would use to create a route. \\n```\\nvector<int> steps(size);//memorize distances\\nqueue<int> line;//BFS\\nsteps[size - 1] = 1;\\nline.push(size - 1);//add the index of the beginWord to the queue\\nprecursor = new vector<int>[size];//a word could have multiple precursors\\nwhile (!line.empty()) {\\n\\tint pos = line.front();\\n\\tline.pop();\\n\\tif (wordList[pos] == endWord)\\n\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\tbreak;\\n\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t//we have never visited here\\n\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t}\\n\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t//we have been here but there\\'s another route to get here having the SAME distance\\n\\t\\t\\t//so this word have multiple precursors\\n\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t}\\n\\n}\\n```\\n\\n3. generate the route\\nUsing precursor to trace back, nothing need to say.\\n\\nHere\\'s my complete code:\\n```\\nclass Solution {\\npublic:\\n\\tvector<int>* precursor;\\n\\tvector<vector<string>> res;\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid generateRoute(vector<string> right, vector<int>& precursor2, vector<string>& wordList) {\\n\\t\\tif (precursor2.size() == 0) {\\n\\t\\t\\tres.push_back(right);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> copy;\\n\\t\\tfor (int i = 0; i < precursor2.size(); i++) {\\n\\t\\t\\tcopy = right;\\n\\t\\t\\t// insert before the begin() cause we are back-tracing.\\n\\t\\t\\tcopy.insert(copy.begin(), wordList[precursor2[i]]);\\n\\t\\t\\tgenerateRoute(copy, precursor[precursor2[i]], wordList);\\n\\t\\t}\\n\\t\\n\\t}\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\twordList.push_back(beginWord);\\n\\t\\tint size = wordList.size();\\n\\t\\tvector<int>* neighbors = new vector<int>[size];\\n\\t\\tint ewordindex = -1;\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> steps(size);//memorize distances\\n\\t\\tqueue<int> line;//BFS\\n\\t\\tsteps[size - 1] = 1;\\n\\t\\tline.push(size - 1);//add the index of the beginWord to the queue\\n\\t\\tprecursor = new vector<int>[size];\\n\\t\\twhile (!line.empty()) {\\n\\t\\t\\tint pos = line.front();\\n\\t\\t\\tline.pop();\\n\\t\\t\\tif (wordList[pos] == endWord)\\n\\t\\t\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\t\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t\\t\\t//we have never visited here\\n\\t\\t\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t\\t\\t//there\\'s another route to get here and it has the SAME distance\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif (ewordindex == -1 || steps[ewordindex] == 0)\\n\\t\\t\\treturn res;\\n\\t\\tvector<string> right{endWord};\\n\\t\\tgenerateRoute(right,precursor[ewordindex] , wordList);\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t```\n```\\n\\twordList.push_back(beginWord);\\n\\tint size = wordList.size();\\n\\tvector<int>* neighbors = new vector<int>[size];\\n\\tint ewordindex = -1;\\n\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t```\n```\\nvector<int> steps(size);//memorize distances\\nqueue<int> line;//BFS\\nsteps[size - 1] = 1;\\nline.push(size - 1);//add the index of the beginWord to the queue\\nprecursor = new vector<int>[size];//a word could have multiple precursors\\nwhile (!line.empty()) {\\n\\tint pos = line.front();\\n\\tline.pop();\\n\\tif (wordList[pos] == endWord)\\n\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\tbreak;\\n\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t//we have never visited here\\n\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t}\\n\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t//we have been here but there\\'s another route to get here having the SAME distance\\n\\t\\t\\t//so this word have multiple precursors\\n\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t}\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tvector<int>* precursor;\\n\\tvector<vector<string>> res;\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid generateRoute(vector<string> right, vector<int>& precursor2, vector<string>& wordList) {\\n\\t\\tif (precursor2.size() == 0) {\\n\\t\\t\\tres.push_back(right);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> copy;\\n\\t\\tfor (int i = 0; i < precursor2.size(); i++) {\\n\\t\\t\\tcopy = right;\\n\\t\\t\\t// insert before the begin() cause we are back-tracing.\\n\\t\\t\\tcopy.insert(copy.begin(), wordList[precursor2[i]]);\\n\\t\\t\\tgenerateRoute(copy, precursor[precursor2[i]], wordList);\\n\\t\\t}\\n\\t\\n\\t}\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\twordList.push_back(beginWord);\\n\\t\\tint size = wordList.size();\\n\\t\\tvector<int>* neighbors = new vector<int>[size];\\n\\t\\tint ewordindex = -1;\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> steps(size);//memorize distances\\n\\t\\tqueue<int> line;//BFS\\n\\t\\tsteps[size - 1] = 1;\\n\\t\\tline.push(size - 1);//add the index of the beginWord to the queue\\n\\t\\tprecursor = new vector<int>[size];\\n\\t\\twhile (!line.empty()) {\\n\\t\\t\\tint pos = line.front();\\n\\t\\t\\tline.pop();\\n\\t\\t\\tif (wordList[pos] == endWord)\\n\\t\\t\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\t\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t\\t\\t//we have never visited here\\n\\t\\t\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t\\t\\t//there\\'s another route to get here and it has the SAME distance\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif (ewordindex == -1 || steps[ewordindex] == 0)\\n\\t\\t\\treturn res;\\n\\t\\tvector<string> right{endWord};\\n\\t\\tgenerateRoute(right,precursor[ewordindex] , wordList);\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388875,
                "title": "javascript-easy-to-understand-solution-using-bfs-dfs",
                "content": "The idea is the following:\\n1. Do BFS from endWord to beginWord, and compute the distance from each word to the endWord. In the meantime, we can also construct the mapping from one word to another, to avoid recomputing the combination again on step 2.\\n2. Do DFS with backtracing from startWord to endWord, and only go further if next word\\'s distance equal current distance + 1\\n\\n```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList);\\n    wordSet.add(beginWord);\\n    \\n    if (!wordSet.has(endWord)) return [];\\n    \\n    const distanceMap = new Map();\\n    const wordMap = new Map();\\n    \\n    // 1. BFS construct distanceMap and wordMap from end to start\\n    const queue = [];\\n    const visited = new Set();\\n    \\n    // Flag to check if we can reach start from end\\n    let reached = false;\\n    \\n    queue.push(endWord);\\n    visited.add(endWord);\\n    let distance = 0;\\n    distanceMap.set(endWord, distance);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        distance++;\\n        for(let i = 0; i < size; i++) {\\n            const word = queue.shift();\\n            for(let w of getNextWords(word, wordSet)) {\\n                // push into wordMap from start to end\\n                // we need to push here before visited check\\n                if (!wordMap.has(w)) wordMap.set(w, []);\\n                wordMap.get(w).push(word);\\n                \\n                if (visited.has(w)) continue;\\n                if (w === beginWord) reached = true;\\n                \\n                // put into distance map\\n                distanceMap.set(w, distance);\\n                \\n                queue.push(w);\\n                visited.add(w);\\n            }\\n        }\\n    }\\n    \\n    // short circuit if can not reach\\n    if (!reached) return [];\\n    \\n    // 2. DFS find path where distance - 1\\n    const result = [];\\n    dfs(result, [beginWord], beginWord, endWord, wordMap, distanceMap);\\n    \\n    return result;\\n};\\n\\nvar dfs = function(result, tmpPath, word, endWord, wordMap, distanceMap) {\\n    if (word === endWord) {\\n        result.push([...tmpPath]);\\n        return;\\n    }\\n    \\n    for (let nextWord of wordMap.get(word)) {\\n        if (distanceMap.get(word) === distanceMap.get(nextWord) + 1) {\\n            tmpPath.push(nextWord);\\n            dfs(result, tmpPath, nextWord, endWord, wordMap, distanceMap);\\n            tmpPath.pop();\\n        }\\n    }\\n}\\n\\nvar getNextWords = function(word, wordSet) {\\n    const result = [];\\n    for (let i = 0; i < word.length; i++) {\\n        let currentCode = word.charCodeAt(i);\\n        for (let c = 97; c <= 122; c++) {\\n            if (c !== currentCode) {\\n                const chars = word.split(\\'\\');\\n                chars[i] = String.fromCharCode(c);\\n                let newWord = chars.join(\\'\\');\\n                if (wordSet.has(newWord)) {\\n                    result.push(newWord);\\n                }\\n            }\\n        }\\n    } \\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList);\\n    wordSet.add(beginWord);\\n    \\n    if (!wordSet.has(endWord)) return [];\\n    \\n    const distanceMap = new Map();\\n    const wordMap = new Map();\\n    \\n    // 1. BFS construct distanceMap and wordMap from end to start\\n    const queue = [];\\n    const visited = new Set();\\n    \\n    // Flag to check if we can reach start from end\\n    let reached = false;\\n    \\n    queue.push(endWord);\\n    visited.add(endWord);\\n    let distance = 0;\\n    distanceMap.set(endWord, distance);\\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        distance++;\\n        for(let i = 0; i < size; i++) {\\n            const word = queue.shift();\\n            for(let w of getNextWords(word, wordSet)) {\\n                // push into wordMap from start to end\\n                // we need to push here before visited check\\n                if (!wordMap.has(w)) wordMap.set(w, []);\\n                wordMap.get(w).push(word);\\n                \\n                if (visited.has(w)) continue;\\n                if (w === beginWord) reached = true;\\n                \\n                // put into distance map\\n                distanceMap.set(w, distance);\\n                \\n                queue.push(w);\\n                visited.add(w);\\n            }\\n        }\\n    }\\n    \\n    // short circuit if can not reach\\n    if (!reached) return [];\\n    \\n    // 2. DFS find path where distance - 1\\n    const result = [];\\n    dfs(result, [beginWord], beginWord, endWord, wordMap, distanceMap);\\n    \\n    return result;\\n};\\n\\nvar dfs = function(result, tmpPath, word, endWord, wordMap, distanceMap) {\\n    if (word === endWord) {\\n        result.push([...tmpPath]);\\n        return;\\n    }\\n    \\n    for (let nextWord of wordMap.get(word)) {\\n        if (distanceMap.get(word) === distanceMap.get(nextWord) + 1) {\\n            tmpPath.push(nextWord);\\n            dfs(result, tmpPath, nextWord, endWord, wordMap, distanceMap);\\n            tmpPath.pop();\\n        }\\n    }\\n}\\n\\nvar getNextWords = function(word, wordSet) {\\n    const result = [];\\n    for (let i = 0; i < word.length; i++) {\\n        let currentCode = word.charCodeAt(i);\\n        for (let c = 97; c <= 122; c++) {\\n            if (c !== currentCode) {\\n                const chars = word.split(\\'\\');\\n                chars[i] = String.fromCharCode(c);\\n                let newWord = chars.join(\\'\\');\\n                if (wordSet.has(newWord)) {\\n                    result.push(newWord);\\n                }\\n            }\\n        }\\n    } \\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40594,
                "title": "a-concise-solution-using-bfs-and-backtracing",
                "content": "the basic idea is referred from url: http://yucoding.blogspot.com/2014/01/leetcode-question-word-ladder-ii.html\\n    \\n    unordered_map<string, vector<string> > mp; // a map indicating a word's previous word list\\n    vector<vector<string> > res;\\n    vector<string> path;\\n     \\n    void output(string &start, string last) {\\n        if (last == start) {\\n            // vector<string> t(path.rbegin(), path.rend());\\n            // res.push_back(t);\\n            reverse(path.begin(), path.end());\\n            res.push_back(path);\\n            reverse(path.begin(), path.end());\\n        }\\n        else {\\n            // backtracing to get path recursively\\n            for (int i = 0; i < mp[last].size(); ++i) {\\n                path.push_back(mp[last][i]);\\n                output(start, mp[last][i]);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    void findNext(string str, unordered_set<string> &dict, unordered_set<string> &next_lev) {\\n        for (int i = 0; i < str.size(); ++i) {\\n            string s = str;\\n            for (char j = 'a'; j <= 'z'; ++j) {\\n                s[i] = j;\\n                if (dict.count(s)) {\\n                    next_lev.insert(s);\\n                    mp[s].push_back(str);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\\n        unordered_set<string> cur_lev;\\n        cur_lev.insert(start);\\n        unordered_set<string> next_lev;\\n        path.push_back(end);\\n         \\n        // expand to get all the next level valid words\\n        while (true) {\\n            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)\\n                dict.erase(*it); //delete previous level words from dict to avoid the cycle\\n             \\n            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)\\n                findNext(*it, dict, next_lev); //find current level words\\n             \\n            if (next_lev.empty()) return res;\\n            \\n            if (next_lev.count(end)) { //if find end string\\n                output(start, end);\\n                return res;\\n            }\\n            \\n            cur_lev = next_lev;\\n            next_lev.clear();\\n        }\\n        \\n        return res;    \\n    }",
                "solutionTags": [],
                "code": "the basic idea is referred from url: http://yucoding.blogspot.com/2014/01/leetcode-question-word-ladder-ii.html\\n    \\n    unordered_map<string, vector<string> > mp; // a map indicating a word's previous word list\\n    vector<vector<string> > res;\\n    vector<string> path;\\n     \\n    void output(string &start, string last) {\\n        if (last == start) {\\n            // vector<string> t(path.rbegin(), path.rend());\\n            // res.push_back(t);\\n            reverse(path.begin(), path.end());\\n            res.push_back(path);\\n            reverse(path.begin(), path.end());\\n        }\\n        else {\\n            // backtracing to get path recursively\\n            for (int i = 0; i < mp[last].size(); ++i) {\\n                path.push_back(mp[last][i]);\\n                output(start, mp[last][i]);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    void findNext(string str, unordered_set<string> &dict, unordered_set<string> &next_lev) {\\n        for (int i = 0; i < str.size(); ++i) {\\n            string s = str;\\n            for (char j = 'a'; j <= 'z'; ++j) {\\n                s[i] = j;\\n                if (dict.count(s)) {\\n                    next_lev.insert(s);\\n                    mp[s].push_back(str);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\\n        unordered_set<string> cur_lev;\\n        cur_lev.insert(start);\\n        unordered_set<string> next_lev;\\n        path.push_back(end);\\n         \\n        // expand to get all the next level valid words\\n        while (true) {\\n            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)\\n                dict.erase(*it); //delete previous level words from dict to avoid the cycle\\n             \\n            for (auto it = cur_lev.begin(); it != cur_lev.end(); it++)\\n                findNext(*it, dict, next_lev); //find current level words\\n             \\n            if (next_lev.empty()) return res;\\n            \\n            if (next_lev.count(end)) { //if find end string\\n                output(start, end);\\n                return res;\\n            }\\n            \\n            cur_lev = next_lev;\\n            next_lev.clear();\\n        }\\n        \\n        return res;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2425225,
                "title": "c-easy-bfs-building-graph-then-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// read this function after reading the main function\\n    unordered_map<string, vector<string>> adj;\\n    void dfs(string node, vector<vector<string>> &ans, vector<string> &curr, string beginWord)\\n    {\\n        if(node == beginWord)\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(string &nbr : adj[node])\\n        {\\n            curr.push_back(nbr);\\n            dfs(nbr, ans, curr, beginWord);\\n            curr.pop_back();\\n        }\\n    }\\n\\t\\n\\t// main function\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        vector<vector<string>> ans;\\n        \\n        unordered_map<string, int> list;\\n\\t\\t// shortest distance to reach the current word\\n        for(string &word : wordList) list[word] = INT_MAX;\\n        \\n\\t\\t// we can never reach endWord in this case\\n        if(list.find(endWord) == list.end()) return ans;\\n        \\n        queue<string> q;\\n        \\n        q.push(beginWord);\\n        int level = 0;\\n        \\n\\t\\t// straight forward BFS\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n\\t\\t\\t// distance to reach the current node (from beginWord)\\n            ++level;\\n            for(int i=0; i<n; ++i)\\n            {\\n                string front = q.front();\\n                q.pop();\\n                \\n\\t\\t\\t\\t// generating all possible words that differ from the current word at a single position\\n                for(int j=0; j<front.size(); ++j)\\n                {\\n                    string newWord = front;\\n                    \\n                    for(char letter=\\'a\\'; letter<=\\'z\\'; ++letter)\\n                    {\\n                        newWord[j] = letter;\\n                        \\n\\t\\t\\t\\t\\t\\t// if the newWord is not visited or is visited on this level then only proceed \\n\\t\\t\\t\\t\\t\\t// o/w there\\'s no sense of proceeding because we have already reached \\n\\t\\t\\t\\t\\t\\t// the word in less no. of steps\\n\\t\\t\\t\\t\\t\\t\\n                        if(newWord != front && list.find(newWord) != list.end() && list[newWord] >= level)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// building the graph in reverse order (we will know the reason for this later)\\n\\t\\t\\t\\t\\t\\t\\t// i.e making a edge between [u, v] in u <-- v this order.\\n                            adj[newWord].push_back(front);\\n                            \\n\\t\\t\\t\\t\\t\\t\\t// the newWord has been discovered in this level only, \\n\\t\\t\\t\\t\\t\\t\\t// since this has been happended the path from this newWord to endWord \\n\\t\\t\\t\\t\\t\\t\\t// will be same for both the cases thus not proceeding any further\\n                            if(list[newWord] == level) continue;\\n                            \\n                            list[newWord] = level;\\n                            \\n                            if(newWord != endWord) q.push(newWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<string> curr({endWord});\\n        dfs(endWord, ans, curr, beginWord);\\n\\t\\t// because all the paths generated from dfs are from endWord->beginWord\\n        for(int i=0; i<ans.size(); ++i) reverse(ans[i].begin(), ans[i].end());\\n        \\n\\t\\t// upd : Why are we building the graph  in the opposite manner ?\\n\\t\\t// it is an unnecessary thing to do. we can acutally build the graph in normal order\\n\\t\\t// and can save our time in reversing them later on which i did.\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\\n* Credits for update @shagunnnn",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// read this function after reading the main function\\n    unordered_map<string, vector<string>> adj;\\n    void dfs(string node, vector<vector<string>> &ans, vector<string> &curr, string beginWord)\\n    {\\n        if(node == beginWord)\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(string &nbr : adj[node])\\n        {\\n            curr.push_back(nbr);\\n            dfs(nbr, ans, curr, beginWord);\\n            curr.pop_back();\\n        }\\n    }\\n\\t\\n\\t// main function\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        vector<vector<string>> ans;\\n        \\n        unordered_map<string, int> list;\\n\\t\\t// shortest distance to reach the current word\\n        for(string &word : wordList) list[word] = INT_MAX;\\n        \\n\\t\\t// we can never reach endWord in this case\\n        if(list.find(endWord) == list.end()) return ans;\\n        \\n        queue<string> q;\\n        \\n        q.push(beginWord);\\n        int level = 0;\\n        \\n\\t\\t// straight forward BFS\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n\\t\\t\\t// distance to reach the current node (from beginWord)\\n            ++level;\\n            for(int i=0; i<n; ++i)\\n            {\\n                string front = q.front();\\n                q.pop();\\n                \\n\\t\\t\\t\\t// generating all possible words that differ from the current word at a single position\\n                for(int j=0; j<front.size(); ++j)\\n                {\\n                    string newWord = front;\\n                    \\n                    for(char letter=\\'a\\'; letter<=\\'z\\'; ++letter)\\n                    {\\n                        newWord[j] = letter;\\n                        \\n\\t\\t\\t\\t\\t\\t// if the newWord is not visited or is visited on this level then only proceed \\n\\t\\t\\t\\t\\t\\t// o/w there\\'s no sense of proceeding because we have already reached \\n\\t\\t\\t\\t\\t\\t// the word in less no. of steps\\n\\t\\t\\t\\t\\t\\t\\n                        if(newWord != front && list.find(newWord) != list.end() && list[newWord] >= level)\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// building the graph in reverse order (we will know the reason for this later)\\n\\t\\t\\t\\t\\t\\t\\t// i.e making a edge between [u, v] in u <-- v this order.\\n                            adj[newWord].push_back(front);\\n                            \\n\\t\\t\\t\\t\\t\\t\\t// the newWord has been discovered in this level only, \\n\\t\\t\\t\\t\\t\\t\\t// since this has been happended the path from this newWord to endWord \\n\\t\\t\\t\\t\\t\\t\\t// will be same for both the cases thus not proceeding any further\\n                            if(list[newWord] == level) continue;\\n                            \\n                            list[newWord] = level;\\n                            \\n                            if(newWord != endWord) q.push(newWord);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<string> curr({endWord});\\n        dfs(endWord, ans, curr, beginWord);\\n\\t\\t// because all the paths generated from dfs are from endWord->beginWord\\n        for(int i=0; i<ans.size(); ++i) reverse(ans[i].begin(), ans[i].end());\\n        \\n\\t\\t// upd : Why are we building the graph  in the opposite manner ?\\n\\t\\t// it is an unnecessary thing to do. we can acutally build the graph in normal order\\n\\t\\t// and can save our time in reversing them later on which i did.\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424809,
                "title": "java-efficient-solution-updated",
                "content": "\\n```\\nclass Solution {\\n    Set<String> set = new HashSet();\\n    String beginWord, endWord;\\n    Map<String, Integer> dist = new HashMap();\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        this.res = new ArrayList();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }\\n        short_path();\\n        if (dist.get(endWord) == null) return res;\\n        List<String> path = new ArrayList();\\n        path.add(endWord);\\n        dfs(endWord, path);\\n        return res;\\n    }\\n    \\n    private void short_path() {\\n        Queue<String> q = new LinkedList();\\n        q.offer(beginWord);\\n        dist.put(beginWord, 0);\\n        while(q.size() > 0) {\\n            String cur = q.poll();\\n            if (cur.equals(endWord) ) break;\\n            char[] charCur = cur.toCharArray();\\n            for (int i = 0; i < cur.length(); i++) {\\n                char c = charCur[i];\\n                for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    charCur[i] = j;\\n                    String s = new String(charCur);\\n                    if (set.contains(s) && dist.get(s) == null) {\\n                        dist.put(s, dist.get(cur) + 1);\\n                        q.offer(s);\\n                    }\\n                    \\n                }\\n                charCur[i] = c;\\n            }\\n        }\\n    }\\n    \\n    private void dfs(String word, List<String> path) {\\n        if (word.equals(beginWord)) {\\n            List list = new ArrayList(path);\\n            Collections.reverse(list);\\n            res.add(list);\\n            return;\\n        }\\n        char[] charCur = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = charCur[i];\\n            for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                charCur[i] = j;\\n                String s = new String(charCur);\\n                if (dist.get(s) != null && dist.get(s) + 1 == dist.get(word)) {\\n                    path.add(s);\\n                    dfs(s, path);\\n                    path.remove(path.size() - 1);\\n                }\\n                    \\n            }\\n            charCur[i] = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> set = new HashSet();\\n    String beginWord, endWord;\\n    Map<String, Integer> dist = new HashMap();\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        this.res = new ArrayList();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }\\n        short_path();\\n        if (dist.get(endWord) == null) return res;\\n        List<String> path = new ArrayList();\\n        path.add(endWord);\\n        dfs(endWord, path);\\n        return res;\\n    }\\n    \\n    private void short_path() {\\n        Queue<String> q = new LinkedList();\\n        q.offer(beginWord);\\n        dist.put(beginWord, 0);\\n        while(q.size() > 0) {\\n            String cur = q.poll();\\n            if (cur.equals(endWord) ) break;\\n            char[] charCur = cur.toCharArray();\\n            for (int i = 0; i < cur.length(); i++) {\\n                char c = charCur[i];\\n                for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    charCur[i] = j;\\n                    String s = new String(charCur);\\n                    if (set.contains(s) && dist.get(s) == null) {\\n                        dist.put(s, dist.get(cur) + 1);\\n                        q.offer(s);\\n                    }\\n                    \\n                }\\n                charCur[i] = c;\\n            }\\n        }\\n    }\\n    \\n    private void dfs(String word, List<String> path) {\\n        if (word.equals(beginWord)) {\\n            List list = new ArrayList(path);\\n            Collections.reverse(list);\\n            res.add(list);\\n            return;\\n        }\\n        char[] charCur = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = charCur[i];\\n            for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                charCur[i] = j;\\n                String s = new String(charCur);\\n                if (dist.get(s) != null && dist.get(s) + 1 == dist.get(word)) {\\n                    path.add(s);\\n                    dfs(s, path);\\n                    path.remove(path.size() - 1);\\n                }\\n                    \\n            }\\n            charCur[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935339,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\\n\\t\\tguard wordList.contains(endWord) else { return [] }\\n        var wordSet = Set(wordList)\\n        var queue: [String] = [beginWord]\\n\\t\\tvar words: [[String]] = []\\n\\t\\tvar isLoopEnd = false\\n\\t\\tvar res:[[String]] = []\\n\\t\\tvar lastWords: [String] = [endWord]\\n\\t\\tvar i = 0\\n\\n        if wordSet.contains(beginWord) { wordSet.remove(beginWord) }\\n\\t\\t\\n        loop: \\n        while queue.count > 0 {\\n\\t\\t\\tvar list: [String] = []\\n\\t\\t\\t\\n            for word in queue {\\n\\t\\t\\t\\tlet next = nextWords(word, &wordSet)\\n                list += next\\n\\t\\t\\t\\tif next.contains(endWord) { isLoopEnd = true }\\n\\t\\t\\t}\\n\\t\\t\\t\\n            if isLoopEnd { break loop } \\n            else {\\n\\t\\t\\t\\tqueue = list\\n\\t\\t\\t\\twords.append(queue)\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\twhile i < words.count - 1 {\\n\\t\\t\\tvar tmp = Set<String>()\\n\\t\\t\\tfor word0 in words[words.count - 1 - i] {\\n\\t\\t\\t\\tfor word1 in lastWords where isNext(word0, word1) { tmp.insert(word0) }\\n\\t\\t\\t}\\n\\t\\t\\tlastWords = Array(tmp)\\n\\t\\t\\twords[words.count - 1 - i] = lastWords\\n\\t\\t\\ti += 1\\n\\t\\t}\\n        \\n\\n\\t\\tfunc backtrack(_ path: [String], _ index: Int) {\\n\\t\\t\\tif index == words.count {\\n                if isNext(path[path.count - 1], endWord) { res.append(path + [endWord]) }\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n            \\n\\t\\t\\tvar path = path\\n\\t\\t\\tfor word in words[index] {\\n\\t\\t\\t\\tif isNext(path[path.count - 1], word) == false { continue }\\n                \\n\\t\\t\\t\\tpath.append(word)\\n\\t\\t\\t\\tbacktrack(path, index + 1)\\n\\t\\t\\t\\tpath.remove(at: path.count - 1)\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tbacktrack([beginWord], 0)\\n\\t\\treturn res\\n\\t}\\n\\n    \\n\\tfunc isNext(_ word0: String, _ word1: String) -> Bool {\\n\\t\\tlet chars0 = Array(word0)\\n\\t\\tlet chars1 = Array(word1)\\n\\t\\tvar count = 0\\n\\t\\t\\n        for i in 0..<word0.count {\\n\\t\\t\\tif chars0[i] != chars1[i] {\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif count > 1 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return count == 1\\n\\t}\\n\\n    \\n\\tfunc nextWords(_ word: String, _ wordSet: inout Set<String>) -> [String] {\\n\\t\\tvar res: [String] = []\\n\\t\\tvar chars = Array(word)\\n\\t\\tlet alphabeta = Array(\"abcdefghijklmnopqrstvuwxyz\")\\n\\t\\t\\n        for (i, char) in chars.enumerated() {\\n\\t\\t\\tfor c in alphabeta {\\n\\t\\t\\t\\tif c == char { continue } \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tchars[i] = c\\n\\t\\t\\t\\t\\tlet string = String(chars)\\n\\t\\t\\t\\t\\tif wordSet.contains(string) {\\n\\t\\t\\t\\t\\t\\tres.append(string)\\n\\t\\t\\t\\t\\t\\twordSet.remove(string)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                chars[i] = char\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return res\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\\n\\t\\tguard wordList.contains(endWord) else { return [] }\\n        var wordSet = Set(wordList)\\n        var queue: [String] = [beginWord]\\n\\t\\tvar words: [[String]] = []\\n\\t\\tvar isLoopEnd = false\\n\\t\\tvar res:[[String]] = []\\n\\t\\tvar lastWords: [String] = [endWord]\\n\\t\\tvar i = 0\\n\\n        if wordSet.contains(beginWord) { wordSet.remove(beginWord) }\\n\\t\\t\\n        loop: \\n        while queue.count > 0 {\\n\\t\\t\\tvar list: [String] = []\\n\\t\\t\\t\\n            for word in queue {\\n\\t\\t\\t\\tlet next = nextWords(word, &wordSet)\\n                list += next\\n\\t\\t\\t\\tif next.contains(endWord) { isLoopEnd = true }\\n\\t\\t\\t}\\n\\t\\t\\t\\n            if isLoopEnd { break loop } \\n            else {\\n\\t\\t\\t\\tqueue = list\\n\\t\\t\\t\\twords.append(queue)\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\twhile i < words.count - 1 {\\n\\t\\t\\tvar tmp = Set<String>()\\n\\t\\t\\tfor word0 in words[words.count - 1 - i] {\\n\\t\\t\\t\\tfor word1 in lastWords where isNext(word0, word1) { tmp.insert(word0) }\\n\\t\\t\\t}\\n\\t\\t\\tlastWords = Array(tmp)\\n\\t\\t\\twords[words.count - 1 - i] = lastWords\\n\\t\\t\\ti += 1\\n\\t\\t}\\n        \\n\\n\\t\\tfunc backtrack(_ path: [String], _ index: Int) {\\n\\t\\t\\tif index == words.count {\\n                if isNext(path[path.count - 1], endWord) { res.append(path + [endWord]) }\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n            \\n\\t\\t\\tvar path = path\\n\\t\\t\\tfor word in words[index] {\\n\\t\\t\\t\\tif isNext(path[path.count - 1], word) == false { continue }\\n                \\n\\t\\t\\t\\tpath.append(word)\\n\\t\\t\\t\\tbacktrack(path, index + 1)\\n\\t\\t\\t\\tpath.remove(at: path.count - 1)\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tbacktrack([beginWord], 0)\\n\\t\\treturn res\\n\\t}\\n\\n    \\n\\tfunc isNext(_ word0: String, _ word1: String) -> Bool {\\n\\t\\tlet chars0 = Array(word0)\\n\\t\\tlet chars1 = Array(word1)\\n\\t\\tvar count = 0\\n\\t\\t\\n        for i in 0..<word0.count {\\n\\t\\t\\tif chars0[i] != chars1[i] {\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif count > 1 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return count == 1\\n\\t}\\n\\n    \\n\\tfunc nextWords(_ word: String, _ wordSet: inout Set<String>) -> [String] {\\n\\t\\tvar res: [String] = []\\n\\t\\tvar chars = Array(word)\\n\\t\\tlet alphabeta = Array(\"abcdefghijklmnopqrstvuwxyz\")\\n\\t\\t\\n        for (i, char) in chars.enumerated() {\\n\\t\\t\\tfor c in alphabeta {\\n\\t\\t\\t\\tif c == char { continue } \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tchars[i] = c\\n\\t\\t\\t\\t\\tlet string = String(chars)\\n\\t\\t\\t\\t\\tif wordSet.contains(string) {\\n\\t\\t\\t\\t\\t\\tres.append(string)\\n\\t\\t\\t\\t\\t\\twordSet.remove(string)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                chars[i] = char\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return res\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431312,
                "title": "python-3-bfs-dfs-backtracking-no-tle",
                "content": "First, I use bfs  and traverser layer by layer but get memory limit exceeded. Then I try to build the link between the child and parent and reconstruct via DFS to avoid store all the paths and computing same path again and again.\\n```\\ndef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = collections.defaultdict(list)\\n        words = set(wordList)\\n        if endWord not in words: return []\\n        words.discard(beginWord)\\n        q = {beginWord}\\n        while q:\\n            nq = set()\\n            for word in q:\\n                for c in \"abcdefghijklmnopqrstuvwxyz\":\\n                    for i in range(len(word)):\\n                        nw = word[:i] + c + word[i+1:]\\n                        if nw in words:\\n                            graph[nw].append(word)\\n                            nq.add(nw)\\n            words -= set(graph.keys())\\n            q = nq\\n            \\n        # use DFS to reconstruct the path from end to begin\\n        def dfs(word):\\n            if word == beginWord:\\n                return [[beginWord]]\\n            res = []\\n            for w in graph[word]:\\n                res += [k + [word] for k in dfs(w)]\\n            return res\\n\\t\\t\\t\\n        return dfs(endWord)",
                "solutionTags": [],
                "code": "First, I use bfs  and traverser layer by layer but get memory limit exceeded. Then I try to build the link between the child and parent and reconstruct via DFS to avoid store all the paths and computing same path again and again.\\n```\\ndef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = collections.defaultdict(list)\\n        words = set(wordList)\\n        if endWord not in words: return []\\n        words.discard(beginWord)\\n        q = {beginWord}\\n        while q:\\n            nq = set()\\n            for word in q:\\n                for c in \"abcdefghijklmnopqrstuvwxyz\":\\n                    for i in range(len(word)):\\n                        nw = word[:i] + c + word[i+1:]\\n                        if nw in words:\\n                            graph[nw].append(word)\\n                            nq.add(nw)\\n            words -= set(graph.keys())\\n            q = nq\\n            \\n        # use DFS to reconstruct the path from end to begin\\n        def dfs(word):\\n            if word == beginWord:\\n                return [[beginWord]]\\n            res = []\\n            for w in graph[word]:\\n                res += [k + [word] for k in dfs(w)]\\n            return res\\n\\t\\t\\t\\n        return dfs(endWord)",
                "codeTag": "Python3"
            },
            {
                "id": 539440,
                "title": "c-two-approaches",
                "content": "# BFS with queue of paths\\n\\n* Runtime: 480 ms, faster than 39.48%\\n* Memory Usage: 178.1 MB, less than 45.00%\\n\\n```c++\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return res;\\n        queue<vector<string>> q;\\n        q.push({beginWord});\\n        d.insert(endWord);\\n        bool flag = false;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            unordered_set<string> visited;\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                string word = curr.back();\\n                q.pop();\\n                for(int j = 0; j < word.size(); j++){\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        auto tmp = word[j];\\n                        word[j] = c;\\n                        if(d.count(word) != 0){\\n                            vector<string> nxt = curr;\\n                            nxt.push_back(word);\\n                            q.push(nxt);\\n                            visited.insert(word);\\n                            if(word == endWord){\\n                                flag = true;\\n                                res.push_back(nxt);\\n                            }\\n                        }\\n                        word[j] = tmp;\\n                    }\\n                }\\n            }\\n            if(flag) break;\\n            for(auto w: visited) d.erase(w);\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n***************************************************************************************************\\n\\n# BFS combined with DFS\\n\\nFirst use BFS to mark distance between `beginWord` and each word in `wordList`, then run DFS to collect the shortest paths. \\n\\n* Runtime: 112 ms, faster than 91.17%\\n* Memory Usage: 21.2 MB, less than 85.00%\\n\\n```c++\\n\\tvoid bfs(string& beginWord, string& endWord, unordered_set<string>& d, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist){\\n        queue<string> q;\\n        q.push(beginWord);\\n        dist[beginWord] = 0;\\n        int lvl = 1;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            unordered_set<string> visited;\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                q.pop();\\n                string nxt = curr;\\n                for(int j = 0; j < nxt.size(); j++){\\n                    auto tmp = nxt[j];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        nxt[j] = c;\\n                        if(d.count(nxt) != 0){\\n                            neighbors[curr].push_back(nxt);\\n                            visited.insert(nxt);\\n                            if(dist.count(nxt) == 0){\\n                                dist[nxt] = lvl;\\n                                q.push(nxt);\\n                            }\\n                        }\\n                    }\\n                    nxt[j] = tmp;\\n                }\\n            }\\n            lvl++;\\n            for(string w: visited) d.erase(w);\\n        }\\n    }\\n    \\n    void dfs(string& curr, string& endWord, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist, vector<string>& path, vector<vector<string>>& res){\\n        path.push_back(curr);\\n        if(curr == endWord){\\n            res.push_back(path);\\n            return;\\n        }\\n        for(auto nxt: neighbors[curr]){\\n            if(dist[nxt] == dist[curr] + 1){\\n                dfs(nxt, endWord, neighbors, dist, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return res;\\n        unordered_map<string, vector<string>> neighbors;\\n        unordered_map<string, int> dist;\\n        bfs(beginWord, endWord, d, neighbors, dist);\\n        vector<string> path;\\n        dfs(beginWord, endWord, neighbors, dist, path, res);\\n        return res;\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```c++\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return res;\\n        queue<vector<string>> q;\\n        q.push({beginWord});\\n        d.insert(endWord);\\n        bool flag = false;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            unordered_set<string> visited;\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                string word = curr.back();\\n                q.pop();\\n                for(int j = 0; j < word.size(); j++){\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        auto tmp = word[j];\\n                        word[j] = c;\\n                        if(d.count(word) != 0){\\n                            vector<string> nxt = curr;\\n                            nxt.push_back(word);\\n                            q.push(nxt);\\n                            visited.insert(word);\\n                            if(word == endWord){\\n                                flag = true;\\n                                res.push_back(nxt);\\n                            }\\n                        }\\n                        word[j] = tmp;\\n                    }\\n                }\\n            }\\n            if(flag) break;\\n            for(auto w: visited) d.erase(w);\\n        }\\n        return res;\\n    }\\n```\n```c++\\n\\tvoid bfs(string& beginWord, string& endWord, unordered_set<string>& d, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist){\\n        queue<string> q;\\n        q.push(beginWord);\\n        dist[beginWord] = 0;\\n        int lvl = 1;\\n        while(!q.empty()){\\n            int q_size = q.size();\\n            unordered_set<string> visited;\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                q.pop();\\n                string nxt = curr;\\n                for(int j = 0; j < nxt.size(); j++){\\n                    auto tmp = nxt[j];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        nxt[j] = c;\\n                        if(d.count(nxt) != 0){\\n                            neighbors[curr].push_back(nxt);\\n                            visited.insert(nxt);\\n                            if(dist.count(nxt) == 0){\\n                                dist[nxt] = lvl;\\n                                q.push(nxt);\\n                            }\\n                        }\\n                    }\\n                    nxt[j] = tmp;\\n                }\\n            }\\n            lvl++;\\n            for(string w: visited) d.erase(w);\\n        }\\n    }\\n    \\n    void dfs(string& curr, string& endWord, unordered_map<string, vector<string>>& neighbors, unordered_map<string, int>& dist, vector<string>& path, vector<vector<string>>& res){\\n        path.push_back(curr);\\n        if(curr == endWord){\\n            res.push_back(path);\\n            return;\\n        }\\n        for(auto nxt: neighbors[curr]){\\n            if(dist[nxt] == dist[curr] + 1){\\n                dfs(nxt, endWord, neighbors, dist, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> res;\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return res;\\n        unordered_map<string, vector<string>> neighbors;\\n        unordered_map<string, int> dist;\\n        bfs(beginWord, endWord, d, neighbors, dist);\\n        vector<string> path;\\n        dfs(beginWord, endWord, neighbors, dist, path, res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379124,
                "title": "c-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019",
                "content": "Sept. 12, 2019 8:49 PM\\nIt is a hard level algorithm. I also like to learn the idea to build a graph using words, and then build a map to contain shortest path to a word.  \\n\\nWhat I like to practice in 2019 is to push myself to learn a few ideas using graph and also write down some analysis, build strong interest on the algorithm analysis and how to solve a hard level algorithm. \\n\\nI learn from my own experience to solve this hard level algorithm starting from 2016. I think that it is better to work on a simplified problems similar to word ladder II first. One of problems is to find all paths, not necessary minimimum length. I should learn how to write simple brute force solution, and using backtracking, marking visit efficiently. [Here](https://github.com/jianminchen/100-hard-level-algorithms-2018-summer-campaign/blob/master/leetcode%20126%20word%20ladder%20II/simple%20version%20for%20interview/DFS%20brute%20force.cs) is my practice in Sept., 2019. \\n\\nThis algorithm is a hard level one. What I do is to study one of discussion post in C#, and then I write down my analysis based on my past experience, debugging. I encourage myself to learn a few ideas to solve this hard level algorithm in 2019. This is the first one, without TLE bug. \\n\\n**Case study**\\n\\nI like to write down how to design the graph, and then apply BFS to build a shortest path map, solve the hard level algorithm. \\n\\nI like to work on the following test cases. \\nsource = \"good\";\\ndest = \"best\";\\n\\nA list of words { \"bood\", \"beod\", \"besd\", \"goot\", \"gost\", \"gest\", \"best\" };\\n\\ntwo paths\\ngood->bood->beod->besd->best\\ngood->goot->gost->gest->best\\n\\nThe above two paths both have minimum length 5. \\n\\n**More detail**\\n\\nEach word with length 4 has four keys. For example, word \"good\" can be searched using the following 4 keys:\\n\"\\\\*ood\"\\n\"g\\\\*od\"\\n\"go\\\\*d\"\\n\"goo\\\\*\". \\n\\nBy going over the start word and all words in dictionary, we can preprocess the graph to build all keys and related words. \\n\\nFor example, \\n\"*ood\" can be searched by changing first char to \\'a\\' to \\'z\\', and \\'g\\' and \\'b\\' are in dictionary. So, \\n\\nKey   = \"*ood\"\\nvalues =  {\"good\",\"bood\"}. \\n\\n**BFS search more detail**\\nGive the above example, start word from \"good\", end word is \"best\", we like to build shorest path from start word to every word encounted in BFS search, first, key is \"good\", then key is \"bood\",\"goot\", and so on. \\n\\nOne highlight is to add more entries for same distance. We can argue that breadth first search, the first one found should have less and equal value, so new one should just check if it is equal or not. \\n\\nThe above logic is shown in the code. I put comment \"reasoning?\". \\n\\n**Time complexity**\\nOne of my practices ran into time-limit-exceeded error. So it reminds me to pay attention to time complexity, and I find this study code and it should have better time complexity since no timeout. \\n\\nAll words in dictionary are preprocessed once to build the graph, with special key containing wild char . This makes the algorithm time efficient specially for large amount words in dictionary. \\n\\nWord dictionary with length = 5 can have maximum words 26^5 = 11,881,376, let us denote using N. So it is important to use algorithm with time complexity O(N), not above O(N). \\n\\n**Here are highlights:**\\n\\n1. Understand that it is important to apply BFS search starting from start word in order to find minimum length of path, and also meet the requirement of TLE concern. \\n2. Preprocess the graph first, go over all words in dictionary to build a hashmap, so it will take O(1) to find all one hop away neighbors in the graph. \\n3. Once the end word is visited, terminate the search in the graph. No need to go further to search. \\n4. Design shortest path for each word visited, the path is defined from begin word to any word visited. To allow multiple path with same distance, argue that those visited and found first should have less and equal length. \\n5. C# code using StringBuilder, operator [], good practice compared to using immutable string. \\n\\n**Some art**\\n\\nI do believe that it is a good idea to come out some very good art to present the process of algorithm design. This hard level algorithm is such an interesting algorithm. I like to start to work on the art to illustrate the problem solving starting from selected test cases, two minimum path from good to best, and then draw a queue, show what is order to get into queue, and then shortestPaths are calculated for each key. The shortest path is from \"good\" to key word. \\n\\nI will think about more later to make the art of diagram more memorable and helpful for me to learn the problem solving. \\n\\n![image](https://assets.leetcode.com/users/jianminchen/image_1568316005.png)\\n\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _126_word_ladder_II\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var source = \"good\";\\n            var dest = \"best\";\\n\\n            var words = new string[] { \"bood\", \"beod\", \"besd\", \"goot\", \"gost\", \"gest\", \"best\" };\\n\\n            var result = FindLadders(source, dest, words);\\n            // two paths\\n            // good->bood->beod->besd->best\\n            // good->goot->gost->gest->best\\n        }\\n\\n        /// <summary>\\n        /// Sept. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/word-ladder-ii/discuss/375730/C-BFS-Solution-faster-than-94-and-less-than-100-memory\\n        /// </summary>\\n        /// <param name=\"beginWord\"></param>\\n        /// <param name=\"endWord\"></param>\\n        /// <param name=\"wordList\"></param>\\n        /// <returns></returns>\\n        public static IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList)\\n        {\\n            var graph = new Dictionary<string, HashSet<string>>();\\n\\n            preprocessGraph(beginWord, graph);\\n\\n            foreach (var word in wordList)\\n            {\\n                preprocessGraph(word, graph);\\n            }\\n\\n            //Queue For BFS\\n            var queue = new Queue<string>();\\n\\n            //Dictionary to store shortest paths to a word\\n            var shortestPaths = new Dictionary<string, IList<IList<string>>>();\\n\\n            queue.Enqueue(beginWord);\\n            // do not confuse () with {} - fix compiler error\\n            shortestPaths[beginWord] = new List<IList<string>>() { new List<string>() { beginWord } };                      \\n\\n            var visited = new HashSet<string>();\\n\\n            while (queue.Count > 0)\\n            {\\n                var visit = queue.Dequeue();\\n\\n                //we can terminate loop once we reached the endWord as all paths leads here already visited in previous level \\n                if (visit.Equals(endWord))\\n                {\\n                    return shortestPaths[endWord];\\n                }\\n                                \\n                if (visited.Contains(visit))\\n                    continue;\\n\\n                visited.Add(visit);\\n\\n                //Transform word to intermediate words and find matches\\n                // case study: var source = \"good\";  \\n                // go over all keys related to visit = \"good\" for example,\\n                // keys: \"*ood\",\"g*od\",\"go*d\",\"goo*\"\\n                for (int i = 0; i < visit.Length; i++)\\n                {\\n                    var sb = new StringBuilder(visit);\\n\\n                    sb[i] = \\'*\\';\\n\\n                    var key = sb.ToString();\\n\\n                    if (!graph.ContainsKey(key))\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    //brute force all adjacent words\\n                    foreach (var neighbor in graph[key])\\n                    {\\n                        if (visited.Contains(neighbor))\\n                        {\\n                            continue; \\n                        }\\n                        \\n                        //fetch all paths leads current word to generate paths to adjacent/child node \\n                        foreach (var path in shortestPaths[visit])\\n                        {\\n                            var newPath = new List<string>(path);\\n\\n                            newPath.Add(neighbor); // path increments one, before it is saved in shortestPaths\\n\\n                            if (!shortestPaths.ContainsKey(neighbor))\\n                            {\\n                                shortestPaths[neighbor] = new List<IList<string>>() { newPath };\\n                            }        // reasoning ? \\n                            else if (shortestPaths[neighbor][0].Count >= newPath.Count) // // we are interested in shortest paths only\\n                            {\\n                                shortestPaths[neighbor].Add(newPath);\\n                            }\\n                        }\\n\\n                        queue.Enqueue(neighbor);                        \\n                    }                                        \\n                }\\n            }\\n\\n            return new List<IList<string>>();\\n        }\\n\\n        /// <summary>\\n        /// Time complexity is biggest challenge. It is a good idea to use O(N) time to preprocess a graph for the search. \\n        /// How to define the graph? It is kind of creative idea to use wildchar * to replace one char for each word.\\n        /// \\n        /// For example word \"hit\" can be written as \"*it\", \"h*t\", \"hi*\". \\n        /// graph[\"*it\"] = new HashSet<string>{\"hit\"}\\n        /// graph[\"h*t\"] = new HashSet<string>{\"hit\"}\\n        /// graph[\"hi*\"] = new HashSet<string>{\"hit\"}\\n        /// \\n        /// git can be written as \"*it\", \"g*t\",\"gi*\"\\n        /// so graph[\"*it\"] = new HashSet<string>{\"hit\",\"git\"}\\n        /// ...\\n        /// \\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <param name=\"graph\"></param>\\n        private static void preprocessGraph(string word, Dictionary<string, HashSet<string>> graph)\\n        {\\n            //For example word hit can be written as *it,h*t,hi*. \\n            //This method genereates a map from each intermediate word to possible words from our wordlist\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                var sb = new StringBuilder(word);\\n                sb[i] = \\'*\\';\\n\\n                var key = sb.ToString();\\n\\n                if (graph.ContainsKey(key))\\n                {\\n                    graph[key].Add(word);\\n                }\\n                else\\n                {\\n                    var set = new HashSet<string>();\\n                    set.Add(word);\\n                    graph[key] = set;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _126_word_ladder_II\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var source = \"good\";\\n            var dest = \"best\";\\n\\n            var words = new string[] { \"bood\", \"beod\", \"besd\", \"goot\", \"gost\", \"gest\", \"best\" };\\n\\n            var result = FindLadders(source, dest, words);\\n            // two paths\\n            // good->bood->beod->besd->best\\n            // good->goot->gost->gest->best\\n        }\\n\\n        /// <summary>\\n        /// Sept. 9, 2019\\n        /// study code\\n        /// https://leetcode.com/problems/word-ladder-ii/discuss/375730/C-BFS-Solution-faster-than-94-and-less-than-100-memory\\n        /// </summary>\\n        /// <param name=\"beginWord\"></param>\\n        /// <param name=\"endWord\"></param>\\n        /// <param name=\"wordList\"></param>\\n        /// <returns></returns>\\n        public static IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList)\\n        {\\n            var graph = new Dictionary<string, HashSet<string>>();\\n\\n            preprocessGraph(beginWord, graph);\\n\\n            foreach (var word in wordList)\\n            {\\n                preprocessGraph(word, graph);\\n            }\\n\\n            //Queue For BFS\\n            var queue = new Queue<string>();\\n\\n            //Dictionary to store shortest paths to a word\\n            var shortestPaths = new Dictionary<string, IList<IList<string>>>();\\n\\n            queue.Enqueue(beginWord);\\n            // do not confuse () with {} - fix compiler error\\n            shortestPaths[beginWord] = new List<IList<string>>() { new List<string>() { beginWord } };                      \\n\\n            var visited = new HashSet<string>();\\n\\n            while (queue.Count > 0)\\n            {\\n                var visit = queue.Dequeue();\\n\\n                //we can terminate loop once we reached the endWord as all paths leads here already visited in previous level \\n                if (visit.Equals(endWord))\\n                {\\n                    return shortestPaths[endWord];\\n                }\\n                                \\n                if (visited.Contains(visit))\\n                    continue;\\n\\n                visited.Add(visit);\\n\\n                //Transform word to intermediate words and find matches\\n                // case study: var source = \"good\";  \\n                // go over all keys related to visit = \"good\" for example,\\n                // keys: \"*ood\",\"g*od\",\"go*d\",\"goo*\"\\n                for (int i = 0; i < visit.Length; i++)\\n                {\\n                    var sb = new StringBuilder(visit);\\n\\n                    sb[i] = \\'*\\';\\n\\n                    var key = sb.ToString();\\n\\n                    if (!graph.ContainsKey(key))\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    //brute force all adjacent words\\n                    foreach (var neighbor in graph[key])\\n                    {\\n                        if (visited.Contains(neighbor))\\n                        {\\n                            continue; \\n                        }\\n                        \\n                        //fetch all paths leads current word to generate paths to adjacent/child node \\n                        foreach (var path in shortestPaths[visit])\\n                        {\\n                            var newPath = new List<string>(path);\\n\\n                            newPath.Add(neighbor); // path increments one, before it is saved in shortestPaths\\n\\n                            if (!shortestPaths.ContainsKey(neighbor))\\n                            {\\n                                shortestPaths[neighbor] = new List<IList<string>>() { newPath };\\n                            }        // reasoning ? \\n                            else if (shortestPaths[neighbor][0].Count >= newPath.Count) // // we are interested in shortest paths only\\n                            {\\n                                shortestPaths[neighbor].Add(newPath);\\n                            }\\n                        }\\n\\n                        queue.Enqueue(neighbor);                        \\n                    }                                        \\n                }\\n            }\\n\\n            return new List<IList<string>>();\\n        }\\n\\n        /// <summary>\\n        /// Time complexity is biggest challenge. It is a good idea to use O(N) time to preprocess a graph for the search. \\n        /// How to define the graph? It is kind of creative idea to use wildchar * to replace one char for each word.\\n        /// \\n        /// For example word \"hit\" can be written as \"*it\", \"h*t\", \"hi*\". \\n        /// graph[\"*it\"] = new HashSet<string>{\"hit\"}\\n        /// graph[\"h*t\"] = new HashSet<string>{\"hit\"}\\n        /// graph[\"hi*\"] = new HashSet<string>{\"hit\"}\\n        /// \\n        /// git can be written as \"*it\", \"g*t\",\"gi*\"\\n        /// so graph[\"*it\"] = new HashSet<string>{\"hit\",\"git\"}\\n        /// ...\\n        /// \\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <param name=\"graph\"></param>\\n        private static void preprocessGraph(string word, Dictionary<string, HashSet<string>> graph)\\n        {\\n            //For example word hit can be written as *it,h*t,hi*. \\n            //This method genereates a map from each intermediate word to possible words from our wordlist\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                var sb = new StringBuilder(word);\\n                sb[i] = \\'*\\';\\n\\n                var key = sb.ToString();\\n\\n                if (graph.ContainsKey(key))\\n                {\\n                    graph[key].Add(word);\\n                }\\n                else\\n                {\\n                    var set = new HashSet<string>();\\n                    set.Add(word);\\n                    graph[key] = set;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143559,
                "title": "the-simplest-javascript-bfs-solution",
                "content": "```\\nvar findLadders=function(beginWord, endWord, wordList){\\n    let results=[]\\n    let visited={}\\n    let steps=Number.MAX_SAFE_INTEGER\\n    let pathq=[[beginWord]]\\n    let wordset=new Set(wordList)\\n    while(pathq.length>0){\\n        let curpath=pathq.shift()\\n        let curword=curpath[curpath.length-1]\\n        if(curpath.length>=steps){\\n                break\\n        }\\n        for(let i = 97; i < 123; i++){\\n            for(let j=0;j<curword.length;j++){\\n            let w=curword.substring(0, j)+String.fromCharCode(i)+curword.substring(j+1)\\n            if(w!==curword&&wordset.has(w)){\\n               if(!visited[w]){\\n                    pathq.push([...curpath,w])\\n                }\\n                if(w===endWord){\\n                    if(curpath.length<steps){\\n                        steps=curpath.length+1\\n                    }\\n                    results.push([...curpath,w])\\n                }\\n            }\\n        }\\n    }\\n        visited[curword]=true\\n    }\\n    return results\\n}",
                "solutionTags": [],
                "code": "```\\nvar findLadders=function(beginWord, endWord, wordList){\\n    let results=[]\\n    let visited={}\\n    let steps=Number.MAX_SAFE_INTEGER\\n    let pathq=[[beginWord]]\\n    let wordset=new Set(wordList)\\n    while(pathq.length>0){\\n        let curpath=pathq.shift()\\n        let curword=curpath[curpath.length-1]\\n        if(curpath.length>=steps){\\n                break\\n        }\\n        for(let i = 97; i < 123; i++){\\n            for(let j=0;j<curword.length;j++){\\n            let w=curword.substring(0, j)+String.fromCharCode(i)+curword.substring(j+1)\\n            if(w!==curword&&wordset.has(w)){\\n               if(!visited[w]){\\n                    pathq.push([...curpath,w])\\n                }\\n                if(w===endWord){\\n                    if(curpath.length<steps){\\n                        steps=curpath.length+1\\n                    }\\n                    results.push([...curpath,w])\\n                }\\n            }\\n        }\\n    }\\n        visited[curword]=true\\n    }\\n    return results\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 40599,
                "title": "input-none-output-none-1-1-test-case-passed-wrong-answer",
                "content": " When I submit the code below, OJ tells me that the input was NONE, output was NONE , 1/1 test case passed and the answer is WRONG. I am not sure how to diagnose this problem . \\n\\nDid anyone else face this issue?\\n\\n    public class Solution {\\n           \\tpublic List<String> getNeighbors(String str, Set<String> dict){\\n        \\t\\tList<String> result = new ArrayList<String>();\\n        \\t\\tfor(int i = 0; i < str.length() ; i++){\\n        \\t\\t\\tfor(int j = 0 ; j < 26 ;j ++){\\n        \\t\\t\\t\\tStringBuilder sb = new StringBuilder(str);\\n        \\t\\t\\t\\tchar c = (char) ('a' + j);\\n        \\t\\t\\t\\tif(str.charAt(i) != c){\\n        \\t\\t\\t\\t\\tsb.setCharAt(i, c);\\n        \\t\\t\\t\\t\\tString s = sb.toString();\\n        \\t\\t\\t\\t\\tif(dict.contains(s)){\\n        \\t\\t\\t\\t\\t\\tresult.add(s);\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn result;\\n        \\t}\\n        \\n        \\tpublic List<List<String>> findLadders(String start, String end, Set<String> wordList) {\\n        \\t\\tList<List<String>> result = new ArrayList<List<String>>();\\n        \\t\\t\\n        \\t\\tQueue<String> wordQueue = new LinkedList<String>();\\n        \\t\\twordQueue.add(start);\\n        \\t\\tSet<String> wordsUsed = new HashSet<String>();\\n        \\t\\twordsUsed.add(start);\\n        \\t\\twordList.add(end);\\n        \\t\\tMap<String,List<String>> incoming = new HashMap<String, List<String>>();\\n        \\t\\t\\n        \\t\\t// build the incoming map \\n        \\t\\twhile(!wordQueue.isEmpty()){\\n        \\t\\t\\tString word = wordQueue.remove();\\n        \\t\\t\\tif(word.equals(end)){\\n        \\t\\t\\t\\tbreak;\\n        \\t\\t\\t}\\n        \\t\\t\\tfor(String neigh : getNeighbors(word, wordList)){\\n        \\t\\t\\t\\tif(!wordsUsed.contains(neigh)){\\n        \\t\\t\\t\\t\\twordsUsed.add(neigh);\\n        \\t\\t\\t\\t\\tif(!incoming.containsKey(neigh)){\\n        \\t\\t\\t\\t\\t\\tincoming.put(neigh, new ArrayList<String>());\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t\\tincoming.get(neigh).add(word);\\n        \\t\\t\\t\\t\\twordQueue.add(neigh);\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\t\\n        \\t\\t//DFS the incoming map to get all the paths\\n        \\t\\tbuildPathsDFS( end,  start,  incoming, result,new ArrayList<String>());\\n        \\t\\t\\n        \\t\\treturn result;\\n        \\t}\\n        \\t\\n        \\tpublic void buildPathsDFS(String start, String end, Map<String,\\n        \\t\\t\\tList<String>> incoming,List<List<String>> result,List<String> curPath){\\n        \\n        \\t\\tif(start.equals(end)){\\n        \\t\\t\\tcurPath.add(end);\\n        \\t\\t\\tList<String> temp = new ArrayList<String>(curPath);\\n        \\t\\t\\tCollections.reverse(temp);\\n        \\t\\t\\tresult.add(temp);\\n        \\t\\t\\tcurPath.remove(end);\\n        \\t\\t\\treturn;\\n        \\t\\t}\\n        \\n        \\t\\tif(incoming.containsKey(start)){\\n        \\t\\t\\tcurPath.add(start);\\n        \\t\\t\\tfor(String next : incoming.get(start)){\\n        \\t\\t\\t\\tbuildPathsDFS(next, end, incoming, result, curPath);\\n        \\t\\t\\t}\\n        \\t\\t\\tcurPath.remove(start);\\n        \\t\\t}\\n        \\t}\\n        \\t\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n           \\tpublic List<String> getNeighbors(String str, Set<String> dict){\\n        \\t\\tList<String> result = new ArrayList<String>();\\n        \\t\\tfor(int i = 0; i < str.length() ; i++){\\n        \\t\\t\\tfor(int j = 0 ; j < 26 ;j ++){\\n        \\t\\t\\t\\tStringBuilder sb = new StringBuilder(str);\\n        \\t\\t\\t\\tchar c = (char) ('a' + j);\\n        \\t\\t\\t\\tif(str.charAt(i) != c){\\n        \\t\\t\\t\\t\\tsb.setCharAt(i, c);\\n        \\t\\t\\t\\t\\tString s = sb.toString();\\n        \\t\\t\\t\\t\\tif(dict.contains(s)){\\n        \\t\\t\\t\\t\\t\\tresult.add(s);\\n        \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 40640,
                "title": "run-time-analysis-for-word-ladder-ii-java",
                "content": "I tried at least 10 methods as well as read at least 10 articles and posts for this problem. I want to summarize what I found here.\\n\\n**Key point to include common word on two paths is to use a set to collect words for current layer and then delete the set from dict after finishing current layer.**\\n\\nMethods: \\n\\n(1) BFS to construct a parent->children map, DFS on the map (MLE).\\n(2) BFS to construct a child->parents map, DFS on the map (600+ ms)\\n(3) BFS to construct a level-by-level tree, DFS with backtrace on the tree (TLE).\\n(4) BFS to construct a level-by-level tree (using List<String>) , DFS avoid backtrace on the tree (1800+ ms).\\n(5) BFS to construct a level-by-level tree (using Set<String>) , DFS with backtrace on the tree (1400+ ms).\\n(6) BFS to construct path (1000+ ms).\\n\\nMethod (2) is most efficient and was most widely used. But actually, I think if memory is big enough, method (1) will be likely to get same run time performance. Because these two methods use map to carry relationship.\\n\\nMethod(3),(4),(5) are my own solutions, it runs so slow because they use List<> to carry the relationship, which can not achieve O(1) visiting a given word.\\n\\nMethod(6) is unique. It doesn't need DFS. The relationship was stored on the path. \\n\\nTo sum up, since you always need to get a word's parent/children list/set, using a map can achieve O(1) run time, map beats other data structure in storing the relationship. \\n\\nAnd for memory use. Storing all the children for a word will always get MLE because a parent can have length*26 children while a child can only have at most 2 or 3 parents. Parent select children first!\\n\\nCodes:\\n\\nMethod(2):\\n\\n    public class Solution {  \\n       public List<List<String>> findLadders(String start, String end, Set<String> dict) {  \\n         List<List<String>> rslt = new ArrayList<List<String>>();  \\n         Map<String, List<String>> parents = new HashMap<String, List<String>>();  \\n         boolean found = false;  \\n           \\n         // initialize  \\n         Set<String> cur_layer = new HashSet<String>();  \\n         cur_layer.add(start);  \\n         if(dict.contains(start)) dict.remove(start);  \\n         dict.add(end);  \\n           \\n         // BFS construct map  \\n         while(!found && !cur_layer.isEmpty()){  \\n           Set<String> new_layer = new HashSet<String>();  \\n           Iterator<String> iter = cur_layer.iterator();  \\n           while(iter.hasNext()){  \\n             String s = iter.next();  \\n             for(String t: neighbors(s, dict)){  \\n                  new_layer.add(t);  \\n                 if(!parents.containsKey(t)){  \\n                   List<String> list = new ArrayList<String>();  \\n                   list.add(s);  \\n                   parents.put(t,list);  \\n                 }else{  \\n                   List<String> list = parents.get(t);  \\n                   list.add(s);  \\n                 }  \\n                 if(t.equals(end)) found = true;  \\n             }  \\n           }  \\n           dict.removeAll(new_layer);  \\n           cur_layer = new_layer;  \\n         }  \\n           \\n         // DFS construct paths  \\n         Stack<String> path = new Stack<String>();  \\n         path.push(end);  \\n         dfs(start, end, path, parents, rslt);  \\n           \\n         return rslt;  \\n       }  \\n         \\n       private void dfs(String start, String s, Stack<String> path, Map<String, List<String>> parents, List<List<String>> rslt){  \\n            // base case  \\n         if(s.equals(start)){  \\n           List<String> list = new ArrayList<String>();  \\n           list.addAll(path);  \\n           Collections.reverse(list);  \\n           rslt.add(list);  \\n           return;  \\n         }  \\n         // edge case  \\n            if(!parents.containsKey(s)) return;  \\n         // recursion  \\n         for(String t: parents.get(s)){  \\n           path.push(t);  \\n           dfs(start, t, path, parents, rslt);  \\n           path.pop();  \\n         }  \\n       }  \\n         \\n       private List<String> neighbors(String s, Set<String> dict){   \\n         List<String> list = new ArrayList<String>();   \\n         char[] chars = s.toCharArray();   \\n         for(int j = 0;j < s.length();j++){   \\n           char original = chars[j];   \\n           for(char c = 'a';c <= 'z';c++){   \\n             chars[j] = c;   \\n             String t = new String(chars);   \\n             if(!t.equals(s) && dict.contains(t)) list.add(t);   \\n           }   \\n           chars[j] = original;   \\n         }   \\n         return list;   \\n       }   \\n     }  \\n\\nMethod (6)\\n\\n    public class Solution {  \\n       public List<List<String>> findLadders(String start, String end, Set<String> dict) {  \\n         List<List<String>> rslt = new ArrayList<List<String>>();  \\n         Deque<List<String>> paths = new LinkedList<List<String>>();  \\n         boolean found = false;  \\n           \\n         // initialize path  \\n         List<String> path = new ArrayList<String>();  \\n         path.add(start);  \\n         paths.offerLast(path);  \\n           \\n         // add end to dictionary, remove start from dict  \\n         dict.add(end);  \\n         if(dict.contains(start)) dict.remove(start);  \\n           \\n         // BFS  \\n         while(!found && !paths.isEmpty()){  \\n           Set<String> set = new HashSet<String>();  \\n           int k = paths.size();  \\n           for(int i = 0;i < k;i++){  \\n             List<String> list = paths.pollFirst();  \\n             String s = list.get(list.size()-1);  \\n             for(String t : neighbors(s, dict)){  \\n               set.add(t);  \\n               List<String> newList = new ArrayList<String>(list);  \\n               newList.add(t);  \\n               paths.offerLast(newList);  \\n               if(t.equals(end)){  \\n                 found = true;  \\n                 rslt.add(newList);  \\n               }  \\n             }  \\n           }  \\n           dict.removeAll(set);  \\n         }  \\n         return rslt;  \\n       }  \\n         \\n       private List<String> neighbors(String s, Set<String> dict){  \\n         List<String> list = new ArrayList<String>();  \\n         char[] chars = s.toCharArray();  \\n         for(int j = 0;j < s.length();j++){  \\n           char original = chars[j];  \\n           for(char c = 'a';c <= 'z';c++){  \\n             chars[j] = c;  \\n             String t = new String(chars);  \\n             if(dict.contains(t)) list.add(t);  \\n           }  \\n           chars[j] = original;  \\n         }  \\n         return list;  \\n       }  \\n     }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {  \\n       public List<List<String>> findLadders(String start, String end, Set<String> dict) {  \\n         List<List<String>> rslt = new ArrayList<List<String>>();  \\n         Map<String, List<String>> parents = new HashMap<String, List<String>>();  \\n         boolean found = false;  \\n           \\n         // initialize  \\n         Set<String> cur_layer = new HashSet<String>();  \\n         cur_layer.add(start);  \\n         if(dict.contains(start)) dict.remove(start);  \\n         dict.add(end);  \\n           \\n         // BFS construct map  \\n         while(!found && !cur_layer.isEmpty()){  \\n           Set<String> new_layer = new HashSet<String>();  \\n           Iterator<String> iter = cur_layer.iterator();  \\n           while(iter.hasNext()){  \\n             String s = iter.next();  \\n             for(String t: neighbors(s, dict)){  \\n                  new_layer.add(t);  \\n                 if(!parents.containsKey(t)){  \\n                   List<String> list = new ArrayList<String>();  \\n                   list.add(s);  \\n                   parents.put(t,list);  \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 40620,
                "title": "python-solution-in-578ms",
                "content": "The trick is use `set` to save the words at each level because different words could ladder to the same word. It was 2580ms using `list`.\\n      \\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\\n    def findLadders(self, start, end, dict):\\n        dict.add(end)\\n        level_tracker = collections.defaultdict(set)\\n        self.parents_tracker = {}\\n        last = {start}\\n        while last and end not in level_tracker:\\n            current = set([])\\n            level_tracker.clear()\\n            for word in last:\\n                for next_word in self.ladder(word, dict):\\n                    if next_word not in self.parents_tracker:\\n                        current.add(next_word)\\n                        level_tracker[next_word].add(word)\\n            self.parents_tracker.update(level_tracker)\\n            last = current\\n        return [] if not last else self.generate_paths(start, end)\\n        \\n    def ladder(self, word, dict):\\n        for i in xrange(len(word)):\\n            for letter in self.alphabet - {word[i]}:\\n                new_word = word[:i] + letter + word[i + 1:]\\n                if new_word in dict:\\n                    yield new_word\\n    \\n    def generate_paths(self, start, end):\\n        ret = [[end]]\\n        while ret[-1][0] != start:\\n            new_ret = []\\n            for path in ret:\\n                for parent in self.parents_tracker[path[0]]:\\n                    new_ret.append([parent] + path)\\n            ret = new_ret\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "The trick is use `set` to save the words at each level because different words could ladder to the same word. It was 2580ms using `list`.\\n      \\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\\n    def findLadders(self, start, end, dict):\\n        dict.add(end)\\n        level_tracker = collections.defaultdict(set)\\n        self.parents_tracker = {}\\n        last = {start}\\n        while last and end not in level_tracker:\\n            current = set([])\\n            level_tracker.clear()\\n            for word in last:\\n                for next_word in self.ladder(word, dict):\\n                    if next_word not in self.parents_tracker:\\n                        current.add(next_word)\\n                        level_tracker[next_word].add(word)\\n            self.parents_tracker.update(level_tracker)\\n            last = current\\n        return [] if not last else self.generate_paths(start, end)\\n        \\n    def ladder(self, word, dict):\\n        for i in xrange(len(word)):\\n            for letter in self.alphabet - {word[i]}:\\n                new_word = word[:i] + letter + word[i + 1:]\\n                if new_word in dict:\\n                    yield new_word\\n    \\n    def generate_paths(self, start, end):\\n        ret = [[end]]\\n        while ret[-1][0] != start:\\n            new_ret = []\\n            for path in ret:\\n                for parent in self.parents_tracker[path[0]]:\\n                    new_ret.append([parent] + path)\\n            ret = new_ret\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2425974,
                "title": "finally-a-solution-that-does-not-gives-tle-python-dfs",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        wordDict = defaultdict(set)\\n        for word in wordList:\\n            if word != beginWord:\\n                for i in range(len(word)):\\n                        wordDict[word[:i] + \"*\" + word[i+1:]].add(word)\\n        queue = deque([beginWord])\\n        visited = {beginWord: 1}\\n        parent_list = defaultdict(set)\\n        ans_path = []\\n        # print(wordDict)\\n        \\n        while queue:\\n            word = queue.popleft()\\n            if word == endWord:             \\n                break\\n            for i in range(len(word)):\\n                for next_word in wordDict[word[:i] + \"*\" + word[i+1:]]:\\n                    if next_word not in visited:\\n                        visited[next_word] = visited[word] + 1\\n                        queue.append(next_word)\\n                        parent_list[next_word].add(word)\\n                    elif visited[next_word] > visited[word]:\\n                        parent_list[next_word].add(word)\\n        \\n        def dfs(word, path):\\n            if word == beginWord:\\n                ans_path.append(path[::-1])\\n            for next_word in parent_list[word]:\\n                dfs(next_word, path+[next_word])\\n        \\n        dfs(endWord, [endWord])\\n        return ans_path\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        wordDict = defaultdict(set)\\n        for word in wordList:\\n            if word != beginWord:\\n                for i in range(len(word)):\\n                        wordDict[word[:i] + \"*\" + word[i+1:]].add(word)\\n        queue = deque([beginWord])\\n        visited = {beginWord: 1}\\n        parent_list = defaultdict(set)\\n        ans_path = []\\n        # print(wordDict)\\n        \\n        while queue:\\n            word = queue.popleft()\\n            if word == endWord:             \\n                break\\n            for i in range(len(word)):\\n                for next_word in wordDict[word[:i] + \"*\" + word[i+1:]]:\\n                    if next_word not in visited:\\n                        visited[next_word] = visited[word] + 1\\n                        queue.append(next_word)\\n                        parent_list[next_word].add(word)\\n                    elif visited[next_word] > visited[word]:\\n                        parent_list[next_word].add(word)\\n        \\n        def dfs(word, path):\\n            if word == beginWord:\\n                ans_path.append(path[::-1])\\n            for next_word in parent_list[word]:\\n                dfs(next_word, path+[next_word])\\n        \\n        dfs(endWord, [endWord])\\n        return ans_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358906,
                "title": "python-slow-but-easy-to-understand-for-beginners",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue in searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```\\n\\n\\nIf you liked this solution, please upvote! :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue in searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40502,
                "title": "ac-python-two-end-bfs-124-ms",
                "content": "Two-end BFS to find the ladders and a recursive DFS to generate the answer\\nidea is the same as word ladder i, [peaceful's solution][1]\\n\\n\\n    def _build(self, parent, path, paths):\\n        if not parent[path[-1]]:\\n            paths.append(path[:])\\n            return\\n        for nextWord in parent[path[-1]]:\\n            path.append(nextWord)\\n            self._build(parent, path, paths)\\n            path.pop()\\n\\n    def buildLadders(self, aWord, bWord, beginWord, parent, ans):\\n        paths = [[], []]\\n        path = [aWord]\\n        self._build(parent, path, paths[0])\\n        path = [bWord]\\n        self._build(parent, path, paths[1])\\n        if paths[0][0][-1] != beginWord:\\n            paths.reverse()\\n        for path in paths[0]:\\n            path.reverse()\\n        for aPath in paths[0]:\\n            for bPath in paths[1]:\\n                ans.append(aPath + bPath)\\n\\n    def findLadders(self, beginWord, endWord, wordList):\\n        fronts = [{beginWord}, {endWord}]\\n        parent = {beginWord: None, endWord: None}\\n        wordList.discard(beginWord)\\n        wordList.discard(endWord)\\n        ans = []\\n        while fronts[0] and fronts[1] and not ans:\\n            if len(fronts[0]) > len(fronts[1]):\\n                fronts.reverse()\\n            newLevel = set()\\n            for word in fronts[0]:\\n                for i in xrange(len(beginWord)):\\n                    for char in string.lowercase:\\n                        newWord = word[:i] + char + word[i + 1:]\\n                        if newWord in fronts[1]:\\n                            self.buildLadders(word, newWord, beginWord, parent, ans)\\n                        if newWord in newLevel:\\n                            parent[newWord].append(word)\\n                        if newWord in wordList:\\n                            newLevel.add(newWord)\\n                            wordList.remove(newWord)\\n                            parent[newWord] = [word]\\n            fronts[0] = newLevel\\n        return ans\\n\\n\\n    # 37 / 37 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 124 ms\\n    # 98.60%\\n\\n\\n  [1]: https://leetcode.com/discuss/63927/python-solution-based-on-two-end-bfs-120ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two-end BFS to find the ladders and a recursive DFS to generate the answer\\nidea is the same as word ladder i, [peaceful's solution][1]\\n\\n\\n    def _build(self, parent, path, paths):\\n        if not parent[path[-1]]:\\n            paths.append(path[:])\\n            return\\n        for nextWord in parent[path[-1]]:\\n            path.append(nextWord)\\n            self._build(parent, path, paths)\\n            path.pop()\\n\\n    def buildLadders(self, aWord, bWord, beginWord, parent, ans):\\n        paths = [[], []]\\n        path = [aWord]\\n        self._build(parent, path, paths[0])\\n        path = [bWord]\\n        self._build(parent, path, paths[1])\\n        if paths[0][0][-1] != beginWord:\\n            paths.reverse()\\n        for path in paths[0]:\\n            path.reverse()\\n        for aPath in paths[0]:\\n            for bPath in paths[1]:\\n                ans.append(aPath + bPath)\\n\\n    def findLadders(self, beginWord, endWord, wordList):\\n        fronts = [{beginWord}, {endWord}]\\n        parent = {beginWord: None, endWord: None}\\n        wordList.discard(beginWord)\\n        wordList.discard(endWord)\\n        ans = []\\n        while fronts[0] and fronts[1] and not ans:\\n            if len(fronts[0]) > len(fronts[1]):\\n                fronts.reverse()\\n            newLevel = set()\\n            for word in fronts[0]:\\n                for i in xrange(len(beginWord)):\\n                    for char in string.lowercase:\\n                        newWord = word[:i] + char + word[i + 1:]\\n                        if newWord in fronts[1]:\\n                            self.buildLadders(word, newWord, beginWord, parent, ans)\\n                        if newWord in newLevel:\\n                            parent[newWord].append(word)\\n                        if newWord in wordList:\\n                            newLevel.add(newWord)\\n                            wordList.remove(newWord)\\n                            parent[newWord] = [word]\\n            fronts[0] = newLevel\\n        return ans\\n\\n\\n    # 37 / 37 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 124 ms\\n    # 98.60%\\n\\n\\n  [1]: https://leetcode.com/discuss/63927/python-solution-based-on-two-end-bfs-120ms",
                "codeTag": "Python3"
            },
            {
                "id": 2429297,
                "title": "c-guaranteed-to-understand-bfs-graph-no-tle-44ms",
                "content": "Finally after a long time trying to understand so many of the codes here, I myself got to understand one code and get accepted.\\n\\nLet me break it down to you. It\\'s easy to understand. No messy codes.\\n\\n**Method 1**: Naive Word Ladder-I continued (TLE) \\u274C \\n(32 / 35 test cases passed) - Best for interview explanation\\n\\n```cpp\\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wlist){\\n    vector<vector<string>> res;\\n    unordered_set<string> wl(begin(wlist), end(wlist));\\n\\n    queue<vector<string>> paths;\\n    paths.push({beginWord});\\n\\t\\n    bool minDepthFound = false;\\n    while(!paths.empty()){\\n        int size = paths.size();\\n\\t\\t\\n\\t\\t// At each BFS level, we store the erased words to check them again only in same level.\\n        unordered_set<string> erasedWordsLevel;\\n\\t\\t\\n\\t\\t//If the best least level found, break\\n        if(minDepthFound) break;\\n\\n        while(size--){\\n            vector<string> path = paths.front(); paths.pop();\\n            string lastString = path.back();\\n            \\n\\t\\t\\tfor(int i=0; i<lastString.size(); i++){\\n                string temp = lastString;\\n                for(char ch=\\'a\\'; ch <= \\'z\\'; ch++){\\n                    temp[i] = ch;\\n                    if(temp == lastString) continue;\\n                    \\n\\t\\t\\t\\t\\t// The word can be in erasedWords at this level OR in original word list.\\n\\t\\t\\t\\t\\tif(wl.count(temp) || erasedWordsLevel.count(temp)){\\n                        path.push_back(temp);\\n                        if(temp == endWord){\\n                            minDepthFound = true;\\n                            res.push_back(path);\\n                        }else{\\n                            paths.push(path);\\n                            wl.erase(temp);\\n                            erasedWordsLevel.insert(temp);\\n                        }\\n                        path.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\nLets analyze why TLE in Method 1.\\n* For each `path` in the `paths` queue, we were taking `path` string array, and appending next possible \"**1-letter different word**\". So there comes chances that \"same words\" originate at each of the bfs levels, so we keep finding the next path for the \"same word\" multiple times.\\n* Keep in mind this TLE occurs in that node/word, even though its overall `path` is unique.\\n\\n**Method 2**: BFS, Build Graph and DFS \\u2705  (It\\'s easy, give it a read)\\n\\n* Instead of me trying to explain, watch this [video from TechDose](https://www.youtube.com/watch?v=mIZJIuMpI2M&ab_channel=TECHDOSE). \\n* No one can teach you better. You will understand it < 15 mins. \\n* Few code changes have to be made to pass the new LC testcases.\\n\\n**Changes made compared to video are:** \\n* We are creating adjacency list in opposite direction. (**beginWord <-- endWord**)\\n* Similarly, we DFS in the opposite direction from endWord to beginWord.\\n* That\\'s it.\\n\\nReason for taking the reverse direction is basically that will be incomplete-path nodes which is added on each level to the adjacency list. So no point of deep DFS on those nodes. \\n\\nConsider it like its difficult to find a node in a big tree from \"parent->child\", but its easier to find parent from \"child->parent\". (Thanks [@skate1512](https://leetcode.com/skate1512/))\\n\\n**BFS + DFS Code**\\n```cpp\\nvector<vector<string>> ans;\\nunordered_map<string, unordered_set<string>> graph;\\nunordered_map<string, int> visited;\\n\\nvector<string> path;\\nvoid dfs(string& startWord, string& endWord){\\n    if(startWord == endWord){\\n        path.push_back(endWord);\\n        reverse(begin(path), end(path)); // store the answer after reversing\\n        ans.push_back(path);\\n        reverse(begin(path), end(path)); // reverse it back cuz backtracking\\n        path.pop_back();\\n        return;\\n    }\\n\\n    path.push_back(startWord);\\n    for(string child: graph[startWord])\\n        dfs(child, endWord);\\n    path.pop_back();\\n}\\n\\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n    unordered_set<string> wl(begin(wordList), end(wordList));\\n    if(!wl.count(endWord) || wl.empty()) return ans;\\n\\n\\t// Visited array stores (string -> bfs level) information\\n    visited[beginWord] = 0; //level 0\\n\\n    queue<string> q;\\n    q.push(beginWord);\\n\\n    while(!q.empty()){\\n        string cur = q.front(); q.pop();\\n        for(int i=0; i < cur.size(); i++){\\n            string temp = cur;\\n            for(char ch=\\'a\\'; ch <= \\'z\\'; ch++){\\n                temp[i] = ch;\\n                if(temp == cur) continue;\\n                if(wl.count(temp)){\\n\\t\\t\\t\\t\\t// Unvisited node, simply add to adjacency list\\n                    if(!visited.count(temp)){\\n                        visited[temp] = 1 + visited[cur];\\n                        graph[temp].insert(cur);  // NOTE: beginWord <- endWord is the direction\\n                        q.push(temp);\\n                    }\\n\\t\\t\\t\\t\\t// direct child nodes check, if both child are at same level, add to adj list, else don\\'t\\n                    else if(visited[temp] == 1 + visited[cur])\\n                        graph[temp].insert(cur);  // NOTE: beginWord <- endWord is the direction\\n                }\\n            }\\n        }\\n    }\\n\\n\\t// Reversely DFS from endWord to beginWord\\n    dfs(endWord, beginWord);\\n    return ans;\\n}\\n```\\n\\n**Upvote and let\\'s learn from each others :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wlist){\\n    vector<vector<string>> res;\\n    unordered_set<string> wl(begin(wlist), end(wlist));\\n\\n    queue<vector<string>> paths;\\n    paths.push({beginWord});\\n\\t\\n    bool minDepthFound = false;\\n    while(!paths.empty()){\\n        int size = paths.size();\\n\\t\\t\\n\\t\\t// At each BFS level, we store the erased words to check them again only in same level.\\n        unordered_set<string> erasedWordsLevel;\\n\\t\\t\\n\\t\\t//If the best least level found, break\\n        if(minDepthFound) break;\\n\\n        while(size--){\\n            vector<string> path = paths.front(); paths.pop();\\n            string lastString = path.back();\\n            \\n\\t\\t\\tfor(int i=0; i<lastString.size(); i++){\\n                string temp = lastString;\\n                for(char ch=\\'a\\'; ch <= \\'z\\'; ch++){\\n                    temp[i] = ch;\\n                    if(temp == lastString) continue;\\n                    \\n\\t\\t\\t\\t\\t// The word can be in erasedWords at this level OR in original word list.\\n\\t\\t\\t\\t\\tif(wl.count(temp) || erasedWordsLevel.count(temp)){\\n                        path.push_back(temp);\\n                        if(temp == endWord){\\n                            minDepthFound = true;\\n                            res.push_back(path);\\n                        }else{\\n                            paths.push(path);\\n                            wl.erase(temp);\\n                            erasedWordsLevel.insert(temp);\\n                        }\\n                        path.pop_back();\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<vector<string>> ans;\\nunordered_map<string, unordered_set<string>> graph;\\nunordered_map<string, int> visited;\\n\\nvector<string> path;\\nvoid dfs(string& startWord, string& endWord){\\n    if(startWord == endWord){\\n        path.push_back(endWord);\\n        reverse(begin(path), end(path)); // store the answer after reversing\\n        ans.push_back(path);\\n        reverse(begin(path), end(path)); // reverse it back cuz backtracking\\n        path.pop_back();\\n        return;\\n    }\\n\\n    path.push_back(startWord);\\n    for(string child: graph[startWord])\\n        dfs(child, endWord);\\n    path.pop_back();\\n}\\n\\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n    unordered_set<string> wl(begin(wordList), end(wordList));\\n    if(!wl.count(endWord) || wl.empty()) return ans;\\n\\n\\t// Visited array stores (string -> bfs level) information\\n    visited[beginWord] = 0; //level 0\\n\\n    queue<string> q;\\n    q.push(beginWord);\\n\\n    while(!q.empty()){\\n        string cur = q.front(); q.pop();\\n        for(int i=0; i < cur.size(); i++){\\n            string temp = cur;\\n            for(char ch=\\'a\\'; ch <= \\'z\\'; ch++){\\n                temp[i] = ch;\\n                if(temp == cur) continue;\\n                if(wl.count(temp)){\\n\\t\\t\\t\\t\\t// Unvisited node, simply add to adjacency list\\n                    if(!visited.count(temp)){\\n                        visited[temp] = 1 + visited[cur];\\n                        graph[temp].insert(cur);  // NOTE: beginWord <- endWord is the direction\\n                        q.push(temp);\\n                    }\\n\\t\\t\\t\\t\\t// direct child nodes check, if both child are at same level, add to adj list, else don\\'t\\n                    else if(visited[temp] == 1 + visited[cur])\\n                        graph[temp].insert(cur);  // NOTE: beginWord <- endWord is the direction\\n                }\\n            }\\n        }\\n    }\\n\\n\\t// Reversely DFS from endWord to beginWord\\n    dfs(endWord, beginWord);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424089,
                "title": "java-graph-bfs-shortest-path-image-explanation",
                "content": "Approach:\\nCreate a graph where indices of the words are the vertices of the graph and an edge exists between two vertices if those 2 words differ by a single letter.\\n\\nConsider below input -\\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nIn my code, beginWord has vertex 0 and words in wordList have vertices = (i+1), so for e.g. vertex of \"hot\" is 1 and that of \"cog\" is 6.\\nThe graph for this input will look as shown in below image -\\n\\n![image](https://assets.leetcode.com/users/images/a40e177c-e89f-4e9a-acd5-3f5f008d06bd_1660473707.6309211.png)\\n\\n\\nIn above graph we can see the vertices and the corresponding words, the src is the beginWord and dest is the endWord. \\nOur answer is **all the shortest paths between beginWord and endWord**.\\nThose two paths are marked by orange and purple crosses in above image.\\n0 -> 1 -> 2 -> 3 -> 6 i.e. [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"]\\n0 -> 1 -> 4 -> 5 -> 6 i.e. [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\\n\\n\\nBelow is the Java code -\\n\\n```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> adj =  new ArrayList<>();\\n    List<List<Integer>> paths = new ArrayList<>();\\n    ArrayList<ArrayList<Integer>> parent = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int w = wordList.size();\\n        int i, j;\\n        \\n        for(i=0;i<w+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(i=0;i<w;i++){\\n            if(checkSingleDiff(beginWord, wordList.get(i)) == 1){\\n                addEdge(0, i+1);\\n            }\\n        }\\n        \\n        for(i=0;i<w;i++){\\n            for(j=i+1;j<w;j++){\\n                if(checkSingleDiff(wordList.get(i), wordList.get(j)) == 1){\\n                    addEdge(i+1, j+1);\\n                }\\n            }\\n        }\\n        \\n        // System.out.println(\"ADJ is\");\\n        // for(i=0;i<adj.size();i++){\\n        //     System.out.print(i + \" -> \");\\n        //     ArrayList<Integer> temp = adj.get(i);\\n        //     for(j=0;j<temp.size();j++){\\n        //         System.out.print(temp.get(j) + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        int beginWordInd = 0;\\n        int endWordInd = -1;\\n        for(i=0;i<w;i++){\\n            if(wordList.get(i).equals(endWord)){\\n                endWordInd = i+1;\\n                break;\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        if(endWordInd != -1){ \\n            ans = getShortestSequences(beginWordInd, endWordInd, w+1, wordList, beginWord);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private List<List<String>> getShortestSequences(int src, int dest, int vertices, List<String> wordList, String beginWord){\\n        ArrayList<Integer> path = new ArrayList<>();\\n        \\n        int i, j;\\n        for(i=0;i<vertices;i++){\\n            parent.add(new ArrayList<>());\\n        }\\n        \\n        BFS(vertices, src, wordList);\\n        \\n        getShortestSequencesUtil(path, vertices, dest);\\n        \\n        // System.out.println(\"Size of paths is \" + paths.size());\\n        for(i=0;i<paths.size();i++){\\n            Collections.reverse(paths.get(i));\\n            paths.set(i, paths.get(i));\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(i=0;i<paths.size();i++){\\n            List<Integer> p = paths.get(i);\\n            ArrayList<String> pp = new ArrayList<>();\\n            for(j=0;j<p.size();j++){\\n                if(p.get(j) == 0){\\n                    pp.add(beginWord);\\n                }\\n                else{\\n                    pp.add(wordList.get(p.get(j) - 1));   \\n                }\\n            }\\n            ans.add(pp);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void getShortestSequencesUtil(ArrayList<Integer> path, int vertices, int dest){\\n        if(dest == -1){\\n            paths.add(new ArrayList<>(path));\\n            return;\\n        }\\n        \\n        for(int p : parent.get(dest)){\\n            path.add(dest);\\n            getShortestSequencesUtil(path, vertices, p);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n    \\n    private void BFS(int vertices, int src, List<String> wordList){\\n        int shortestDist[] = new int[vertices];\\n        Arrays.fill(shortestDist, Integer.MAX_VALUE);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(src);\\n        parent.get(src).clear();\\n        parent.get(src).add(-1);\\n        shortestDist[src] = 0;\\n        \\n        while(q.isEmpty() == false){\\n            int u = q.poll();\\n            for(int v : adj.get(u)){\\n                if(shortestDist[u] + 1 < shortestDist[v]){\\n                    shortestDist[v] = shortestDist[u] + 1;\\n                    q.offer(v);\\n                    parent.get(v).clear();\\n                    parent.get(v).add(u);\\n                }\\n                else if(shortestDist[u] + 1 == shortestDist[v]){\\n                    parent.get(v).add(u);\\n                }\\n            }\\n        }\\n        \\n        // System.out.println(\"Parent is \");\\n        // for(int i=0;i<parent.size();i++){\\n        //     ArrayList<Integer> p = parent.get(i);\\n        //     System.out.print(i + \" -> \");\\n        //     for(int j=0;j<p.size();j++){\\n        //         System.out.print(p.get(j) + \" \");    \\n        //     }\\n        //     System.out.println();\\n        // }\\n        // System.out.println();\\n        \\n        // System.out.println(\"Shortest distance is \");\\n        // for(int i=0;i<shortestDist.length;i++){\\n        //     System.out.print(shortestDist[i] + \" \");\\n        // }\\n        // System.out.println();\\n    }\\n    \\n    private void addEdge(int u, int v){\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n    \\n    private int checkSingleDiff(String a, String b){\\n        int i;\\n        int count = 0;\\n        for(i=0;i<a.length();i++){\\n            if(a.charAt(i) != b.charAt(i)){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nYou can uncomment the comments to see the adjacency list, parent list and shortest distance array, it will be as follows -\\n```\\nADJ is\\n0 -> 1 \\n1 -> 0 2 4 \\n2 -> 1 3 4 \\n3 -> 2 5 6 \\n4 -> 1 2 5 \\n5 -> 3 4 6 \\n6 -> 3 5 \\nParent is \\n0 -> -1 \\n1 -> 0 \\n2 -> 1 \\n3 -> 2 \\n4 -> 1 \\n5 -> 4 \\n6 -> 3 5 \\n\\nShortest distance is \\n0 1 2 3 2 3 4 \\nSize of paths is 2\\n```\\n\\n\\n*Kindly upvote if this solution has helped you.\\nThanks for reading! :)*",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<ArrayList<Integer>> adj =  new ArrayList<>();\\n    List<List<Integer>> paths = new ArrayList<>();\\n    ArrayList<ArrayList<Integer>> parent = new ArrayList<>();\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int w = wordList.size();\\n        int i, j;\\n        \\n        for(i=0;i<w+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(i=0;i<w;i++){\\n            if(checkSingleDiff(beginWord, wordList.get(i)) == 1){\\n                addEdge(0, i+1);\\n            }\\n        }\\n        \\n        for(i=0;i<w;i++){\\n            for(j=i+1;j<w;j++){\\n                if(checkSingleDiff(wordList.get(i), wordList.get(j)) == 1){\\n                    addEdge(i+1, j+1);\\n                }\\n            }\\n        }\\n        \\n        // System.out.println(\"ADJ is\");\\n        // for(i=0;i<adj.size();i++){\\n        //     System.out.print(i + \" -> \");\\n        //     ArrayList<Integer> temp = adj.get(i);\\n        //     for(j=0;j<temp.size();j++){\\n        //         System.out.print(temp.get(j) + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        int beginWordInd = 0;\\n        int endWordInd = -1;\\n        for(i=0;i<w;i++){\\n            if(wordList.get(i).equals(endWord)){\\n                endWordInd = i+1;\\n                break;\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        if(endWordInd != -1){ \\n            ans = getShortestSequences(beginWordInd, endWordInd, w+1, wordList, beginWord);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private List<List<String>> getShortestSequences(int src, int dest, int vertices, List<String> wordList, String beginWord){\\n        ArrayList<Integer> path = new ArrayList<>();\\n        \\n        int i, j;\\n        for(i=0;i<vertices;i++){\\n            parent.add(new ArrayList<>());\\n        }\\n        \\n        BFS(vertices, src, wordList);\\n        \\n        getShortestSequencesUtil(path, vertices, dest);\\n        \\n        // System.out.println(\"Size of paths is \" + paths.size());\\n        for(i=0;i<paths.size();i++){\\n            Collections.reverse(paths.get(i));\\n            paths.set(i, paths.get(i));\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(i=0;i<paths.size();i++){\\n            List<Integer> p = paths.get(i);\\n            ArrayList<String> pp = new ArrayList<>();\\n            for(j=0;j<p.size();j++){\\n                if(p.get(j) == 0){\\n                    pp.add(beginWord);\\n                }\\n                else{\\n                    pp.add(wordList.get(p.get(j) - 1));   \\n                }\\n            }\\n            ans.add(pp);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void getShortestSequencesUtil(ArrayList<Integer> path, int vertices, int dest){\\n        if(dest == -1){\\n            paths.add(new ArrayList<>(path));\\n            return;\\n        }\\n        \\n        for(int p : parent.get(dest)){\\n            path.add(dest);\\n            getShortestSequencesUtil(path, vertices, p);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n    \\n    private void BFS(int vertices, int src, List<String> wordList){\\n        int shortestDist[] = new int[vertices];\\n        Arrays.fill(shortestDist, Integer.MAX_VALUE);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(src);\\n        parent.get(src).clear();\\n        parent.get(src).add(-1);\\n        shortestDist[src] = 0;\\n        \\n        while(q.isEmpty() == false){\\n            int u = q.poll();\\n            for(int v : adj.get(u)){\\n                if(shortestDist[u] + 1 < shortestDist[v]){\\n                    shortestDist[v] = shortestDist[u] + 1;\\n                    q.offer(v);\\n                    parent.get(v).clear();\\n                    parent.get(v).add(u);\\n                }\\n                else if(shortestDist[u] + 1 == shortestDist[v]){\\n                    parent.get(v).add(u);\\n                }\\n            }\\n        }\\n        \\n        // System.out.println(\"Parent is \");\\n        // for(int i=0;i<parent.size();i++){\\n        //     ArrayList<Integer> p = parent.get(i);\\n        //     System.out.print(i + \" -> \");\\n        //     for(int j=0;j<p.size();j++){\\n        //         System.out.print(p.get(j) + \" \");    \\n        //     }\\n        //     System.out.println();\\n        // }\\n        // System.out.println();\\n        \\n        // System.out.println(\"Shortest distance is \");\\n        // for(int i=0;i<shortestDist.length;i++){\\n        //     System.out.print(shortestDist[i] + \" \");\\n        // }\\n        // System.out.println();\\n    }\\n    \\n    private void addEdge(int u, int v){\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n    \\n    private int checkSingleDiff(String a, String b){\\n        int i;\\n        int count = 0;\\n        for(i=0;i<a.length();i++){\\n            if(a.charAt(i) != b.charAt(i)){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nADJ is\\n0 -> 1 \\n1 -> 0 2 4 \\n2 -> 1 3 4 \\n3 -> 2 5 6 \\n4 -> 1 2 5 \\n5 -> 3 4 6 \\n6 -> 3 5 \\nParent is \\n0 -> -1 \\n1 -> 0 \\n2 -> 1 \\n3 -> 2 \\n4 -> 1 \\n5 -> 4 \\n6 -> 3 5 \\n\\nShortest distance is \\n0 1 2 3 2 3 4 \\nSize of paths is 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421954,
                "title": "c-full-explained-clean-code-no-tle",
                "content": "The idea of this problem is to run bfs, where one step is changing some letter of word. For me easier to separate problem to two parts:\\n\\n1. Create graph of connections G.\\n2. Run bfs on this graph with collecting all possible solutions.\\nNow, let us consider steps in more details.\\n\\n1. To create graph of connections for each word, for example hit, create patterns *it, h*t, hi*. Then iterate over patterns and connect words in our defaultdict G.\\n\\n2. We need to run bfs, but we also need to give as answer all possible solutions, so, we need to modify our algorithm a bit. We keep two dictionaries: deps for depths of each word and paths to keep all possible paths. When we extract element from queue and look at its neighbours, we need to add new element to queue if deps[neib] == -1. Also we need to update paths[neib] if deps[neib] == -1 or deps[neib] == deps[w] +, that is to deal with all ways of optimal length.\\n\\n**Complexity**\\n\\nWe need O(nk^2) time to create all possible patterns: for each of n words we have k patterns with length k. Then we will have no more than O(n*k*26) possible connections for all pairs of words, each of which has length k, so to create G we need O(nk^2*26) time. In practice thought this number is smaller, because graph can not have this number of connections. For the last part with bfs we have complexity O(nk^2*26) again, because this is the number of edges in our graph + A, where A is number of found solutions, which can be exponential. So, time complexity is O(nk^2*26 + A), space is the same\\n\\n\\n```\\nclass Solution {\\npublic:\\n   vector<int>* precursor;\\n\\tvector<vector<string>> res;\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid generateRoute(vector<string> right, vector<int>& precursor2, vector<string>& wordList) {\\n\\t\\tif (precursor2.size() == 0) {\\n\\t\\t\\tres.push_back(right);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> copy;\\n\\t\\tfor (int i = 0; i < precursor2.size(); i++) {\\n\\t\\t\\tcopy = right;\\n\\t\\t\\t// insert before the begin() cause we are back-tracing.\\n\\t\\t\\tcopy.insert(copy.begin(), wordList[precursor2[i]]);\\n\\t\\t\\tgenerateRoute(copy, precursor[precursor2[i]], wordList);\\n\\t\\t}\\n\\t\\n\\t}\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\twordList.push_back(beginWord);\\n\\t\\tint size = wordList.size();\\n\\t\\tvector<int>* neighbors = new vector<int>[size];\\n\\t\\tint ewordindex = -1;\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> steps(size);//memorize distances\\n\\t\\tqueue<int> line;//BFS\\n\\t\\tsteps[size - 1] = 1;\\n\\t\\tline.push(size - 1);//add the index of the beginWord to the queue\\n\\t\\tprecursor = new vector<int>[size];\\n\\t\\twhile (!line.empty()) {\\n\\t\\t\\tint pos = line.front();\\n\\t\\t\\tline.pop();\\n\\t\\t\\tif (wordList[pos] == endWord)\\n\\t\\t\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\t\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t\\t\\t//we have never visited here\\n\\t\\t\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t\\t\\t//there\\'s another route to get here and it has the SAME distance\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif (ewordindex == -1 || steps[ewordindex] == 0)\\n\\t\\t\\treturn res;\\n\\t\\tvector<string> right{endWord};\\n\\t\\tgenerateRoute(right,precursor[ewordindex] , wordList);\\n\\t\\treturn res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/758b0876-2080-421f-af83-62b8f723b780_1660444338.369717.png)\\n\\n\\n**IF YOU LIKE IT THEN PLEASE PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int>* precursor;\\n\\tvector<vector<string>> res;\\n\\tbool isANeighbor(string& s1, string& s2) {\\n\\t\\tbool hasChanged = false;\\n\\t\\tfor (int i = 0; i < s1.size(); i++) {\\n\\t\\t\\tif (s1[i] != s2[i]) {\\n\\t\\t\\t\\tif (hasChanged)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thasChanged = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid generateRoute(vector<string> right, vector<int>& precursor2, vector<string>& wordList) {\\n\\t\\tif (precursor2.size() == 0) {\\n\\t\\t\\tres.push_back(right);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> copy;\\n\\t\\tfor (int i = 0; i < precursor2.size(); i++) {\\n\\t\\t\\tcopy = right;\\n\\t\\t\\t// insert before the begin() cause we are back-tracing.\\n\\t\\t\\tcopy.insert(copy.begin(), wordList[precursor2[i]]);\\n\\t\\t\\tgenerateRoute(copy, precursor[precursor2[i]], wordList);\\n\\t\\t}\\n\\t\\n\\t}\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\twordList.push_back(beginWord);\\n\\t\\tint size = wordList.size();\\n\\t\\tvector<int>* neighbors = new vector<int>[size];\\n\\t\\tint ewordindex = -1;\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (wordList[i] == endWord)\\n\\t\\t\\t\\tewordindex = i;\\n\\t\\t\\tfor (int j = i + 1; j < size; j++) {\\n\\t\\t\\t\\tif (isANeighbor(wordList[i],wordList[j])) {\\n\\t\\t\\t\\t\\tneighbors[i].push_back(j);\\n\\t\\t\\t\\t\\tneighbors[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> steps(size);//memorize distances\\n\\t\\tqueue<int> line;//BFS\\n\\t\\tsteps[size - 1] = 1;\\n\\t\\tline.push(size - 1);//add the index of the beginWord to the queue\\n\\t\\tprecursor = new vector<int>[size];\\n\\t\\twhile (!line.empty()) {\\n\\t\\t\\tint pos = line.front();\\n\\t\\t\\tline.pop();\\n\\t\\t\\tif (wordList[pos] == endWord)\\n\\t\\t\\t\\t//we stop here because we are looking for the shortest routes\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tfor (int i = 0; i < neighbors[pos].size(); i++) {\\n\\t\\t\\t\\tif (steps[neighbors[pos][i]]==0) {\\n\\t\\t\\t\\t\\t//we have never visited here\\n\\t\\t\\t\\t\\tsteps[neighbors[pos][i]] = steps[pos] + 1;\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t\\t\\tline.push(neighbors[pos][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\\n\\t\\t\\t\\t\\t//there\\'s another route to get here and it has the SAME distance\\n\\t\\t\\t\\t\\tprecursor[neighbors[pos][i]].push_back(pos);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\tif (ewordindex == -1 || steps[ewordindex] == 0)\\n\\t\\t\\treturn res;\\n\\t\\tvector<string> right{endWord};\\n\\t\\tgenerateRoute(right,precursor[ewordindex] , wordList);\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358374,
                "title": "bfs-dfs-memoization-non-tle-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict = new HashSet(wordList);\\n        if( !dict.contains(endWord) )\\n            return new ArrayList();\\n        \\n        // adjacent words for each word\\n        Map<String,List<String>> adjacency = new HashMap();\\n        Queue<String> queue = new LinkedList();\\n        // does path exist?\\n        boolean found = false;\\n        \\n        // BFS for shortest path, keep removing visited words\\n        queue.offer(beginWord);\\n        dict.remove(beginWord);\\n                \\n        while( !found && !queue.isEmpty() ) {\\n            int size = queue.size();\\n            // adjacent words in current level\\n            HashSet<String> explored = new HashSet();\\n\\n            while( size-- > 0 ) {\\n                String word = queue.poll();\\n                \\n                if( adjacency.containsKey(word) )\\n                    continue;\\n                \\n                // remove current word from dict, and search for adjacent words\\n                dict.remove(word);\\n                List<String> adjacents = getAdjacents(word, dict);\\n                adjacency.put(word, adjacents);\\n\\n                for(String adj : adjacents) {\\n                    if( !found && adj.equals(endWord) ) \\n                        found = true;\\n                    \\n                    explored.add(adj);\\n                    queue.offer(adj);\\n                }\\n            }\\n            // remove words explored in current level from dict\\n            for(String word : explored)\\n                dict.remove(word);\\n        }\\n\\n        // if a path exist, dfs to find all the paths\\n        if( found ) \\n            return dfs(beginWord, endWord, adjacency, new HashMap());\\n        else\\n            return new ArrayList();\\n    }\\n    \\n    private List<String> getAdjacents(String word, Set<String> dict) {\\n        List<String> adjs = new ArrayList();\\n        char[] wordChars = word.toCharArray();\\n        \\n        for(int i=0; i<wordChars.length; i++) \\n            for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                char temp = wordChars[i];\\n                wordChars[i] = c;\\n                \\n                String newAdj = new String(wordChars);\\n                if( dict.contains(newAdj) )\\n                    adjs.add(newAdj);\\n                \\n                wordChars[i] = temp;\\n            }\\n        return adjs;\\n    }\\n    \\n    private List<List<String>> dfs(String src, String dest, \\n                                   Map<String,List<String>> adjacency, \\n                                   Map<String,List<List<String>>> memo) {\\n        if( memo.containsKey(src) )\\n            return memo.get(src);\\n        \\n        List<List<String>> paths = new ArrayList();\\n        \\n\\t\\t// reached dest? return list with dest word\\n        if( src.equals( dest ) ) {\\n            paths.add( new ArrayList(){{ add(dest); }} );\\n            return paths;\\n        }\\n\\n\\t\\t// no adjacent for curr word? return empty list\\n        List<String> adjacents = adjacency.get(src);\\n        if( adjacents == null || adjacents.isEmpty() )\\n            return paths;\\n\\n        for(String adj : adjacents) {\\n            List<List<String>> adjPaths = dfs(adj, dest, adjacency, memo);\\n            \\n            for(List<String> path : adjPaths) {\\n                if( path.isEmpty() ) continue;\\n                \\n                List<String> newPath = new ArrayList(){{ add(src); }};\\n                newPath.addAll(path);\\n                \\n                paths.add(newPath);\\n            }\\n        } \\n        memo.put(src, paths);\\n        return paths;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict = new HashSet(wordList);\\n        if( !dict.contains(endWord) )\\n            return new ArrayList();\\n        \\n        // adjacent words for each word\\n        Map<String,List<String>> adjacency = new HashMap();\\n        Queue<String> queue = new LinkedList();\\n        // does path exist?\\n        boolean found = false;\\n        \\n        // BFS for shortest path, keep removing visited words\\n        queue.offer(beginWord);\\n        dict.remove(beginWord);\\n                \\n        while( !found && !queue.isEmpty() ) {\\n            int size = queue.size();\\n            // adjacent words in current level\\n            HashSet<String> explored = new HashSet();\\n\\n            while( size-- > 0 ) {\\n                String word = queue.poll();\\n                \\n                if( adjacency.containsKey(word) )\\n                    continue;\\n                \\n                // remove current word from dict, and search for adjacent words\\n                dict.remove(word);\\n                List<String> adjacents = getAdjacents(word, dict);\\n                adjacency.put(word, adjacents);\\n\\n                for(String adj : adjacents) {\\n                    if( !found && adj.equals(endWord) ) \\n                        found = true;\\n                    \\n                    explored.add(adj);\\n                    queue.offer(adj);\\n                }\\n            }\\n            // remove words explored in current level from dict\\n            for(String word : explored)\\n                dict.remove(word);\\n        }\\n\\n        // if a path exist, dfs to find all the paths\\n        if( found ) \\n            return dfs(beginWord, endWord, adjacency, new HashMap());\\n        else\\n            return new ArrayList();\\n    }\\n    \\n    private List<String> getAdjacents(String word, Set<String> dict) {\\n        List<String> adjs = new ArrayList();\\n        char[] wordChars = word.toCharArray();\\n        \\n        for(int i=0; i<wordChars.length; i++) \\n            for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                char temp = wordChars[i];\\n                wordChars[i] = c;\\n                \\n                String newAdj = new String(wordChars);\\n                if( dict.contains(newAdj) )\\n                    adjs.add(newAdj);\\n                \\n                wordChars[i] = temp;\\n            }\\n        return adjs;\\n    }\\n    \\n    private List<List<String>> dfs(String src, String dest, \\n                                   Map<String,List<String>> adjacency, \\n                                   Map<String,List<List<String>>> memo) {\\n        if( memo.containsKey(src) )\\n            return memo.get(src);\\n        \\n        List<List<String>> paths = new ArrayList();\\n        \\n\\t\\t// reached dest? return list with dest word\\n        if( src.equals( dest ) ) {\\n            paths.add( new ArrayList(){{ add(dest); }} );\\n            return paths;\\n        }\\n\\n\\t\\t// no adjacent for curr word? return empty list\\n        List<String> adjacents = adjacency.get(src);\\n        if( adjacents == null || adjacents.isEmpty() )\\n            return paths;\\n\\n        for(String adj : adjacents) {\\n            List<List<String>> adjPaths = dfs(adj, dest, adjacency, memo);\\n            \\n            for(List<String> path : adjPaths) {\\n                if( path.isEmpty() ) continue;\\n                \\n                List<String> newPath = new ArrayList(){{ add(src); }};\\n                newPath.addAll(path);\\n                \\n                paths.add(newPath);\\n            }\\n        } \\n        memo.put(src, paths);\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800822,
                "title": "c-easy-to-understand-bfs-solution",
                "content": "\\tclass Solution {\\n\\t\\t vector<vector<string>> ans;\\n\\tpublic:\\n\\t\\t void helper(string start,string end,unordered_set<string> &st){\\n\\t\\t\\t  queue<vector<string>> q;\\n\\t\\t\\t  q.push({start});  //storing path\\n\\t\\t\\t   bool flag=false;\\n\\t\\t\\t  while(!q.empty()){\\n\\t\\t\\t\\t  int n=q.size();\\n\\t\\t\\t\\t  while(n--)\\n\\t\\t\\t\\t  {\\n\\t\\t\\t\\t\\t  vector<string> curr_path=q.front(); \\n\\t\\t\\t\\t\\t  q.pop();\\n\\t\\t\\t\\t\\t  if(curr_path.back()==end){\\n\\t\\t\\t\\t\\t\\t  ans.push_back(curr_path);\\n\\t\\t\\t\\t\\t\\t  flag=true;  //if we got our answer then we need to consider\\n\\t\\t\\t\\t\\t\\t\\t// only this level of bfs\\n\\t\\t\\t\\t\\t\\t   continue;\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  string temp=curr_path.back();\\n\\t\\t\\t\\t\\t  st.erase(temp);\\n\\t\\t\\t\\t\\t  for(int j=0;j<temp.length();j++){\\n\\t\\t\\t\\t\\t\\t\\tstring curr=temp;\\n\\t\\t\\t\\t\\t\\t  for(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\t\\t  curr[j]=i+\\'a\\';\\n\\t\\t\\t\\t\\t\\t\\t  // cout<<curr<<\" \";\\n\\t\\t\\t\\t\\t\\t\\t  if(st.find(curr)!=st.end()){ \\n\\t\\t\\t\\t\\t\\t\\t\\t   curr_path.push_back(curr);\\n\\t\\t\\t\\t\\t\\t\\t\\t   q.push({curr_path});\\n\\t\\t\\t\\t\\t\\t\\t\\t  curr_path.pop_back();\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  if(flag)  break;\\n\\t\\t\\t  }\\n\\t\\t}\\n\\t\\tvector<vector<string>> findLadders(string start, string end, vector<string>& wordList) {\\n\\t\\t\\t\\t unordered_set<string> st;\\n\\t\\t\\t\\t for(auto &it: wordList) st.insert(it);\\n\\n\\t\\t\\t\\t if(st.find(end)==st.end()) return {};\\n\\t\\t\\t\\t helper(start,end,st);\\n\\t\\t\\t   return ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\t vector<vector<string>> ans;\\n\\tpublic:\\n\\t\\t void helper(string start,string end,unordered_set<string> &st){\\n\\t\\t\\t  queue<vector<string>> q;\\n\\t\\t\\t  q.push({start}",
                "codeTag": "Java"
            },
            {
                "id": 1360454,
                "title": "java-clean-concise-optimal-code-breadth-first-search-backtracking-technique",
                "content": "```\\nclass Solution {\\n    \\n    Set<String> wordSet = new HashSet<> ();\\n    List<String> currPath = new ArrayList<> ();\\n    List<List<String>> shortestPath = new ArrayList<> ();\\n    Map<String, List<String>> adjacencyList = new HashMap<> ();\\n    \\n    public List<String> findNeighbors (String currWord) {\\n        \\n        List<String> neighborsList = new ArrayList<> ();\\n        char[] letters = currWord.toCharArray ();\\n        \\n        for (int i = 0; i < letters.length; i++) {\\n            char letter = letters[i];\\n            \\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                letters[i] = c;\\n                String word = new String (letters);\\n                if (letter != c && wordSet.contains (word)) {\\n                    neighborsList.add (word);\\n                }\\n            }\\n            \\n            letters[i] = letter;\\n        }\\n        \\n        return neighborsList;\\n    }\\n    \\n    public void bfs (String beginWord) {\\n        \\n        Queue<String> queue = new LinkedList<> ();\\n        queue.offer (beginWord);\\n        wordSet.remove (beginWord);\\n        \\n        while (!queue.isEmpty ()) {\\n            int size = queue.size ();\\n            Set<String> visitedSet = new HashSet<> ();\\n            \\n            while (size-- != 0) {\\n                String currWord = queue.poll ();\\n                List<String> neighborsList = findNeighbors (currWord);\\n                \\n                for (String word : neighborsList) {\\n                    if (!adjacencyList.containsKey (currWord)) {\\n                        adjacencyList.put (currWord, new ArrayList<> ());\\n                    }\\n                    \\n                    adjacencyList.get (currWord).add (word);\\n                    visitedSet.add (word);\\n                }\\n            }\\n            \\n            for (String word : visitedSet) {\\n                queue.offer (word);\\n                wordSet.remove (word);\\n            }\\n        }\\n    }\\n    \\n    public void backtrack (String beginWord, String endWord) {\\n        \\n        if (beginWord.equals (endWord)) {\\n            shortestPath.add (new ArrayList<> (currPath));\\n            return;\\n        }\\n        else if (!adjacencyList.containsKey (beginWord)) {\\n            return;\\n        }\\n        \\n        for (String word : adjacencyList.get (beginWord)) {\\n            currPath.add (word);\\n            backtrack (word, endWord);\\n            currPath.remove (word);\\n        }\\n    }\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        \\n        for (String word : wordList) {\\n            wordSet.add (word);\\n        }\\n        \\n        if (!wordSet.contains (endWord)) {\\n            return shortestPath;\\n        }\\n        \\n        bfs (beginWord);\\n        currPath.add (beginWord);\\n        backtrack (beginWord, endWord);\\n        \\n        return shortestPath;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Set<String> wordSet = new HashSet<> ();\\n    List<String> currPath = new ArrayList<> ();\\n    List<List<String>> shortestPath = new ArrayList<> ();\\n    Map<String, List<String>> adjacencyList = new HashMap<> ();\\n    \\n    public List<String> findNeighbors (String currWord) {\\n        \\n        List<String> neighborsList = new ArrayList<> ();\\n        char[] letters = currWord.toCharArray ();\\n        \\n        for (int i = 0; i < letters.length; i++) {\\n            char letter = letters[i];\\n            \\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                letters[i] = c;\\n                String word = new String (letters);\\n                if (letter != c && wordSet.contains (word)) {\\n                    neighborsList.add (word);\\n                }\\n            }\\n            \\n            letters[i] = letter;\\n        }\\n        \\n        return neighborsList;\\n    }\\n    \\n    public void bfs (String beginWord) {\\n        \\n        Queue<String> queue = new LinkedList<> ();\\n        queue.offer (beginWord);\\n        wordSet.remove (beginWord);\\n        \\n        while (!queue.isEmpty ()) {\\n            int size = queue.size ();\\n            Set<String> visitedSet = new HashSet<> ();\\n            \\n            while (size-- != 0) {\\n                String currWord = queue.poll ();\\n                List<String> neighborsList = findNeighbors (currWord);\\n                \\n                for (String word : neighborsList) {\\n                    if (!adjacencyList.containsKey (currWord)) {\\n                        adjacencyList.put (currWord, new ArrayList<> ());\\n                    }\\n                    \\n                    adjacencyList.get (currWord).add (word);\\n                    visitedSet.add (word);\\n                }\\n            }\\n            \\n            for (String word : visitedSet) {\\n                queue.offer (word);\\n                wordSet.remove (word);\\n            }\\n        }\\n    }\\n    \\n    public void backtrack (String beginWord, String endWord) {\\n        \\n        if (beginWord.equals (endWord)) {\\n            shortestPath.add (new ArrayList<> (currPath));\\n            return;\\n        }\\n        else if (!adjacencyList.containsKey (beginWord)) {\\n            return;\\n        }\\n        \\n        for (String word : adjacencyList.get (beginWord)) {\\n            currPath.add (word);\\n            backtrack (word, endWord);\\n            currPath.remove (word);\\n        }\\n    }\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        \\n        for (String word : wordList) {\\n            wordSet.add (word);\\n        }\\n        \\n        if (!wordSet.contains (endWord)) {\\n            return shortestPath;\\n        }\\n        \\n        bfs (beginWord);\\n        currPath.add (beginWord);\\n        backtrack (beginWord, endWord);\\n        \\n        return shortestPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264903,
                "title": "concise-swift-solution-with-my-understanding",
                "content": "This is a question that asks to find the shortest paths between two nodes in a graph. First of all, if the ```endWord``` is not in the word list, then it means our graph does not contain ```endWord``` and we return ```[]```. \\n\\nAfter building the graph from the given word list, we can perform a breadth first search to find the shortest between the two given words. \\n\\nI use the \"wild card\" as the key of the dictionary but I think it\\'s better to build an adjacency list by directly using the word itself as the key and its neighbors as values and I guess it will make it easier for us to traverse the graph.\\n\\nThen we use a standard BFS to find the shortest paths. The only thing to keep in mind is that the ```queue``` has the currently generated ```paths``` as elements. For example,\\n\\nAt first, our queue is ```[[\"hit\"]]```.\\nThen it becomes ```[[\"hit\", \"hot\"\"]]```.\\nAnd then it becomes ```[[\"hit\", \"hot\", \"dot\"], [\"hit\", \"hot\", \"lot\"]]```, the reason being that every time we find another path, we create a new variable ```newPath``` locally with the value of the old path, append the new word to it, and append it (```newPath```) back to our ```queue```.\\n\\nOne of the most important thing is to keep in mind is, we should not insert the new word ```next``` to our visit history immediately, because it is also a possible candidate for the next ```path``` in our ```queue```. Therefore, we need to have a ```tmpVisit``` to store the visited node for the current queue, and a ```level``` variable to store current level, and union it with the visit history ```visited``` when we reach the next level (current path\\'s length greater than current level). \\n\\nIn this way, we can find all shortest paths. Because when we union the ```tmpVisit``` with our visit history, we eliminate future visits to those words with longer paths.\\n\\nIf we have ```A -> B -> C``` and ```A -> D -> C```, then by doing things mentioned above we won\\'t have something like ```A -> B -> E -> C```. In this way we can ensure from ```A``` to ```C``` we have the shortest pathes, which means if ```C``` is on the way to our destination, they the ```A -> B -> C``` and ```A -> D -> C``` ARE parts of our sortest paths to our destination.\\n\\nI know a bidirection BFS will be both faster and will consume less memory. But I\\'ll move on for now.\\n\\nOne other thing I want to point out is don\\'t get frustrated when you can\\'t come up with a working solution within whataever amount of time, while seeing so many beautiful solutions in the discuss section. You don\\'t know how many hours/days/weeks other folks have been struggling before they come up with their solutions. Just try your best and keep making faithful effort. One day you will reach where you want.\\n\\nCheers.\\n\\n```\\nclass Solution {\\n\\t\\n\\t// Global vairable of dictionary\\n\\t// Key: wild card\\n\\t// Value: words that share same generic word\\n\\tvar dict: [String: [String]] = [:]\\n\\t\\n\\tfunc findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\\n\\t\\t\\n\\t\\tguard wordList.contains(endWord) else { return [] }\\n\\t\\t\\n\\t\\t// Construct the dictionary\\n\\t\\tfor word in wordList {\\n\\t\\t\\tfor(_, i) in word.indices.enumerated() {\\n\\t\\t\\t\\tlet generic = String(word[..<i]) + \"*\" + String(word[word.index(after: i)...])\\n\\t\\t\\t\\tdict[generic, default: []].append(word)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar queue: [[String]] = []\\n\\t\\tvar visited: Set<String> = []\\n\\t\\tvar currPath: [String] = []\\n\\t\\tvar answer: [[String]] = []\\n\\t\\t\\n\\t\\tqueue.append([beginWord])\\n\\t\\tvisited.insert(beginWord)\\n\\t\\tcurrPath.append(beginWord)\\n\\t\\t\\n\\t\\tvar level = 1\\n\\t\\tvar tmpVisits: [String] = []\\n\\t\\t// BFS\\n\\t\\twhile !queue.isEmpty {\\n\\t\\t\\tlet path = queue.removeFirst()\\n\\t\\t\\t\\n\\t\\t\\tif path.count > level {\\n\\t\\t\\t\\tvisited.formUnion(tmpVisits)\\n\\t\\t\\t\\ttmpVisits.removeAll()\\n\\t\\t\\t\\tlevel += 1\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tguard let last = path.last else {\\tcontinue }\\n\\t\\t\\t\\n\\t\\t\\tfor (_, i) in last.indices.enumerated() {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet generic = String(last[..<i] + \"*\" + last[last.index(after: i)...])\\n\\n\\t\\t\\t\\tguard let nexts = dict[generic] else {\\n\\t\\t\\t\\t\\tcontinue }\\n\\t\\t\\t\\tfor next in nexts {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tguard !visited.contains(next) else { continue }\\n\\t\\t\\t\\t\\tvar newPath = path\\n\\t\\t\\t\\t\\tnewPath.append(next)\\n\\t\\t\\t\\t\\t//visited.insert(next)\\n\\t\\t\\t\\t\\ttmpVisits.append(next)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif next == endWord {\\n\\t\\t\\t\\t\\t\\tanswer.append(newPath)\\n\\t\\t\\t\\t\\t\\tvisited.remove(next)\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tqueue.append(newPath)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} // while !queue.isEmpty\\n\\t\\t\\n\\t\\treturn answer\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```endWord```\n```endWord```\n```[]```\n```queue```\n```paths```\n```[[\"hit\"]]```\n```[[\"hit\", \"hot\"\"]]```\n```[[\"hit\", \"hot\", \"dot\"], [\"hit\", \"hot\", \"lot\"]]```\n```newPath```\n```newPath```\n```queue```\n```next```\n```path```\n```queue```\n```tmpVisit```\n```level```\n```visited```\n```tmpVisit```\n```A -> B -> C```\n```A -> D -> C```\n```A -> B -> E -> C```\n```A```\n```C```\n```C```\n```A -> B -> C```\n```A -> D -> C```\n```\\nclass Solution {\\n\\t\\n\\t// Global vairable of dictionary\\n\\t// Key: wild card\\n\\t// Value: words that share same generic word\\n\\tvar dict: [String: [String]] = [:]\\n\\t\\n\\tfunc findLadders(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> [[String]] {\\n\\t\\t\\n\\t\\tguard wordList.contains(endWord) else { return [] }\\n\\t\\t\\n\\t\\t// Construct the dictionary\\n\\t\\tfor word in wordList {\\n\\t\\t\\tfor(_, i) in word.indices.enumerated() {\\n\\t\\t\\t\\tlet generic = String(word[..<i]) + \"*\" + String(word[word.index(after: i)...])\\n\\t\\t\\t\\tdict[generic, default: []].append(word)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar queue: [[String]] = []\\n\\t\\tvar visited: Set<String> = []\\n\\t\\tvar currPath: [String] = []\\n\\t\\tvar answer: [[String]] = []\\n\\t\\t\\n\\t\\tqueue.append([beginWord])\\n\\t\\tvisited.insert(beginWord)\\n\\t\\tcurrPath.append(beginWord)\\n\\t\\t\\n\\t\\tvar level = 1\\n\\t\\tvar tmpVisits: [String] = []\\n\\t\\t// BFS\\n\\t\\twhile !queue.isEmpty {\\n\\t\\t\\tlet path = queue.removeFirst()\\n\\t\\t\\t\\n\\t\\t\\tif path.count > level {\\n\\t\\t\\t\\tvisited.formUnion(tmpVisits)\\n\\t\\t\\t\\ttmpVisits.removeAll()\\n\\t\\t\\t\\tlevel += 1\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tguard let last = path.last else {\\tcontinue }\\n\\t\\t\\t\\n\\t\\t\\tfor (_, i) in last.indices.enumerated() {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlet generic = String(last[..<i] + \"*\" + last[last.index(after: i)...])\\n\\n\\t\\t\\t\\tguard let nexts = dict[generic] else {\\n\\t\\t\\t\\t\\tcontinue }\\n\\t\\t\\t\\tfor next in nexts {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tguard !visited.contains(next) else { continue }\\n\\t\\t\\t\\t\\tvar newPath = path\\n\\t\\t\\t\\t\\tnewPath.append(next)\\n\\t\\t\\t\\t\\t//visited.insert(next)\\n\\t\\t\\t\\t\\ttmpVisits.append(next)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif next == endWord {\\n\\t\\t\\t\\t\\t\\tanswer.append(newPath)\\n\\t\\t\\t\\t\\t\\tvisited.remove(next)\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tqueue.append(newPath)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} // while !queue.isEmpty\\n\\t\\t\\n\\t\\treturn answer\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555388,
                "title": "python-faster-than-95-bfs-dfs",
                "content": "Trick way to get all neighbors of all words in wordList in O(NK) time complexity, where N = len(wordList) and K = len(beginWord).\\n\\n```\\nclass Solution:        \\n    \\n    def backtrack(self, curr_trans, curr_word):\\n        if curr_word == self.beginWord:\\n            curr_trans.append(curr_word)\\n            curr_trans.reverse()\\n            self.result.append(curr_trans)\\n            return\\n        \\n        for prev_word in self.prev[curr_word]:\\n            self.backtrack(curr_trans+[curr_word], prev_word)\\n        \\n       \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        # Edge case:\\n        if endWord not in wordList:\\n            return []\\n        \\n        \\n        # 0. some init\\n        self.beginWord = beginWord\\n        L = len(beginWord)\\n        \\n        \\n        # 1. build adjacency map\\n        self.neighbors = collections.defaultdict(list)\\n        for i in range(L):\\n            for word in wordList:\\n                self.neighbors[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n            \\n                    \\n        # 2. Start BFS.\\n        # Define several datastructures:\\n        self.word_depth = dict.fromkeys(wordList, -1)  # -1 depth means unvisited\\n        self.prev = collections.defaultdict(list)   # storage all prev words 1 level higher than curernt word\\n        q = []\\n        q.append(beginWord)\\n        self.word_depth[beginWord] = 0\\n        \\n        while len(q) != 0:\\n            curr_word = q.pop(0)\\n            for i in range(L):\\n                for neighbor in self.neighbors[curr_word[:i] + \\'*\\' + curr_word[i+1:]]:\\n                    # if not visited before:\\n                    #   1. update with smallest depth\\n                    #   2. add curr_word to its prev words\\n                    #   3. add neighbor to q\\n                    if self.word_depth[neighbor] == -1:\\n                        self.word_depth[neighbor] = self.word_depth[curr_word] + 1\\n                        self.prev[neighbor].append(curr_word)\\n                        q.append(neighbor)\\n                    else:\\n                        # if visited before, if curr_word has same depth as its exisitng prev word, append to it. Ow ignore. \\n                        if self.word_depth[neighbor] == self.word_depth[curr_word] + 1:\\n                            self.prev[neighbor].append(curr_word)\\n                        \\n        # 3. get all shortest transformation. Assume endWord can be reached from beginWord\\n        self.result = []  \\n        self.backtrack([], endWord)\\n        return self.result\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:        \\n    \\n    def backtrack(self, curr_trans, curr_word):\\n        if curr_word == self.beginWord:\\n            curr_trans.append(curr_word)\\n            curr_trans.reverse()\\n            self.result.append(curr_trans)\\n            return\\n        \\n        for prev_word in self.prev[curr_word]:\\n            self.backtrack(curr_trans+[curr_word], prev_word)\\n        \\n       \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        # Edge case:\\n        if endWord not in wordList:\\n            return []\\n        \\n        \\n        # 0. some init\\n        self.beginWord = beginWord\\n        L = len(beginWord)\\n        \\n        \\n        # 1. build adjacency map\\n        self.neighbors = collections.defaultdict(list)\\n        for i in range(L):\\n            for word in wordList:\\n                self.neighbors[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n            \\n                    \\n        # 2. Start BFS.\\n        # Define several datastructures:\\n        self.word_depth = dict.fromkeys(wordList, -1)  # -1 depth means unvisited\\n        self.prev = collections.defaultdict(list)   # storage all prev words 1 level higher than curernt word\\n        q = []\\n        q.append(beginWord)\\n        self.word_depth[beginWord] = 0\\n        \\n        while len(q) != 0:\\n            curr_word = q.pop(0)\\n            for i in range(L):\\n                for neighbor in self.neighbors[curr_word[:i] + \\'*\\' + curr_word[i+1:]]:\\n                    # if not visited before:\\n                    #   1. update with smallest depth\\n                    #   2. add curr_word to its prev words\\n                    #   3. add neighbor to q\\n                    if self.word_depth[neighbor] == -1:\\n                        self.word_depth[neighbor] = self.word_depth[curr_word] + 1\\n                        self.prev[neighbor].append(curr_word)\\n                        q.append(neighbor)\\n                    else:\\n                        # if visited before, if curr_word has same depth as its exisitng prev word, append to it. Ow ignore. \\n                        if self.word_depth[neighbor] == self.word_depth[curr_word] + 1:\\n                            self.prev[neighbor].append(curr_word)\\n                        \\n        # 3. get all shortest transformation. Assume endWord can be reached from beginWord\\n        self.result = []  \\n        self.backtrack([], endWord)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425164,
                "title": "300-streak-days",
                "content": "Hello Guys!\\nI have been here for  #300#  consecutive days, in any mood, sad or happy, healthy or sick, free or busy.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2424935,
                "title": "analyze-why-we-should-dfs-from-endword-to-avoid-tle",
                "content": "I thought it\\'s a graph problem so I solved it this way:\\n1. Build a graph by connecting words that differ by exactly 1 character\\n2. Run a BFS from `beginWord` to `endWord` to find the shortest distance\\n3. Run a DFS from `beginWord` to `endWord`, ignoring any node that BFS didn\\'t visit, and use backtracking technique to output each possible shortest path\\n\\nBut then I got TLE with a fairly small testcase, the first hunch the came to me is that we should run the DFS from `endWord` instead, but I still wasn\\'t quite sure why. After my code got accepted, I was so curious that I wanted to draw the graph with the testcase that I failed to see what happened. After drawing the graph with GraphViz (see the comment for the rendering code), I immediately spotted the issue, let me draw an example to illustrate it:\\n\\n![image](https://assets.leetcode.com/users/images/efa226af-6e3e-4292-8909-75f9d2684aee_1660530370.0032768.png)\\n\\nWe can see that running DFS from `beginWord` would waste lots of time exploring paths with dead ends in the `distance=3` nodes that BFS has visited, since BFS knows the shortest distance is 4 and we would limit the path to have at most 5 nodes in them. But running DFS from `endWord` would get all the paths if we just check if the connected node has been visited with the corresponding distance in the BFS process (e.g., `cab` is connected to `cat` but it\\'s not what we\\'re looking for) It\\'s also why [some solution](https://leetcode.com/problems/word-ladder-ii/discuss/2421786/C%2B%2B-using-BFS-and-Backtracking-oror-NO-TLE-August2022) visits the parent nodes backward from `endWord`.\\n\\nMy solution is similar but doesn\\'t require the parent-child relationship, I simply record what nodes are visited during the BFS process, and find the path from `endWord` only if the next node I\\'m trying to add to the path has the distance of exactly previous distance minus 1 (the blue container in the above image). For example, when building path from `cat` of `distance=3`, `cat` is connected to `zat`, `cot` and `cab`, but only `zat` has a `distance=2`, so I would only add `zat` to the path and start from there in the next iteration.\\n\\nHere\\'s my C++ solution that may not be as clean and concise as others, but I guess it\\'s more memory-efficient (less than 88%) since I only use integers to build the graph as well as recoding the visited nodes in each distance.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        endWordIndex = findWordIndex(endWord, wordList);\\n        if (endWordIndex == -1) return {};\\n        // Add beginWord as the last node if it doesn\\'t exist in wordList\\n        beginWordIndex = findWordIndex(beginWord, wordList);\\n        if (beginWordIndex == -1) {\\n            wordList.push_back(beginWord);\\n            beginWordIndex = wordList.size() - 1;\\n        }\\n        distances.assign(wordList.size(), -1);\\n        \\n        buildGraph(wordList);\\n        const int shortestDist = findShortestDistFromBeginToEndWord();\\n        if (shortestDist == -1) return {};\\n        \\n        findAllPaths(shortestDist, wordList);\\n        return results;\\n    }\\n    \\n    void buildGraph(const vector<string> &wordList) {\\n        nodeToNeighbors.assign(wordList.size(), {});\\n        for (int i = 0; i < wordList.size(); i++) {\\n            for (int j = 0; j < wordList.size(); j++) {\\n                if (i == j) continue;\\n                if (isConnected(wordList[i], wordList[j])) {\\n                    nodeToNeighbors[i].push_back(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findShortestDistFromBeginToEndWord() {\\n        vector<int> visited(nodeToNeighbors.size(), false);\\n        visited[beginWordIndex] = true;\\n        deque<int> pending = {beginWordIndex};\\n        int distance = 0;\\n        while (!pending.empty()) {\\n            const int pendingSize = pending.size();\\n            for (int i = 0; i < pendingSize; i++) {\\n                const int node = pending.front();\\n                pending.pop_front();\\n                \\n                distances[node] = distance;\\n                if (node == endWordIndex) {\\n                    return distance;\\n                }\\n                \\n                const auto &neighbors = nodeToNeighbors[node];\\n                for (const int neighbor : neighbors) {\\n                    if (visited[neighbor]) continue;\\n                    \\n                    visited[neighbor] = true;\\n                    pending.push_back(neighbor);\\n                }\\n            }\\n            distance++;\\n        }\\n        return -1;\\n    }\\n    \\n    void findAllPaths(const int shortestDist, const vector<string> &wordList) {\\n        vector<string> curPath(shortestDist + 1);\\n        findAllPathsRecursive(endWordIndex, shortestDist, shortestDist, wordList, curPath);\\n    }\\n    \\n    void findAllPathsRecursive(const int node, const int curDist, const int shortestDist, const vector<string> &wordList, vector<string> &curPath) {\\n        curPath[curDist] = wordList[node];\\n        if (curDist <= 0) {\\n            if (node == beginWordIndex) {\\n                results.push_back(curPath);\\n            }\\n            return;\\n        }\\n        \\n        const auto &neighbors = nodeToNeighbors[node];\\n        for (const int neighbor : neighbors) {\\n            if (distances[neighbor] != curDist - 1) continue;\\n            \\n            findAllPathsRecursive(neighbor, curDist - 1, shortestDist, wordList, curPath);\\n        }\\n    }\\n    \\n    int findWordIndex(const string &findWord, const vector<string> &wordList) {\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (wordList[i] == findWord) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    bool isConnected(const string &s1, const string &s2) {\\n        int diffCount = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1[i] != s2[i]) diffCount++;\\n            if (diffCount >= 2) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n    \\n    int beginWordIndex = -1;\\n    int endWordIndex = -1;\\n    vector<vector<int>> nodeToNeighbors;\\n    vector<int> distances;\\n    vector<vector<string>> results;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        endWordIndex = findWordIndex(endWord, wordList);\\n        if (endWordIndex == -1) return {};\\n        // Add beginWord as the last node if it doesn\\'t exist in wordList\\n        beginWordIndex = findWordIndex(beginWord, wordList);\\n        if (beginWordIndex == -1) {\\n            wordList.push_back(beginWord);\\n            beginWordIndex = wordList.size() - 1;\\n        }\\n        distances.assign(wordList.size(), -1);\\n        \\n        buildGraph(wordList);\\n        const int shortestDist = findShortestDistFromBeginToEndWord();\\n        if (shortestDist == -1) return {};\\n        \\n        findAllPaths(shortestDist, wordList);\\n        return results;\\n    }\\n    \\n    void buildGraph(const vector<string> &wordList) {\\n        nodeToNeighbors.assign(wordList.size(), {});\\n        for (int i = 0; i < wordList.size(); i++) {\\n            for (int j = 0; j < wordList.size(); j++) {\\n                if (i == j) continue;\\n                if (isConnected(wordList[i], wordList[j])) {\\n                    nodeToNeighbors[i].push_back(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findShortestDistFromBeginToEndWord() {\\n        vector<int> visited(nodeToNeighbors.size(), false);\\n        visited[beginWordIndex] = true;\\n        deque<int> pending = {beginWordIndex};\\n        int distance = 0;\\n        while (!pending.empty()) {\\n            const int pendingSize = pending.size();\\n            for (int i = 0; i < pendingSize; i++) {\\n                const int node = pending.front();\\n                pending.pop_front();\\n                \\n                distances[node] = distance;\\n                if (node == endWordIndex) {\\n                    return distance;\\n                }\\n                \\n                const auto &neighbors = nodeToNeighbors[node];\\n                for (const int neighbor : neighbors) {\\n                    if (visited[neighbor]) continue;\\n                    \\n                    visited[neighbor] = true;\\n                    pending.push_back(neighbor);\\n                }\\n            }\\n            distance++;\\n        }\\n        return -1;\\n    }\\n    \\n    void findAllPaths(const int shortestDist, const vector<string> &wordList) {\\n        vector<string> curPath(shortestDist + 1);\\n        findAllPathsRecursive(endWordIndex, shortestDist, shortestDist, wordList, curPath);\\n    }\\n    \\n    void findAllPathsRecursive(const int node, const int curDist, const int shortestDist, const vector<string> &wordList, vector<string> &curPath) {\\n        curPath[curDist] = wordList[node];\\n        if (curDist <= 0) {\\n            if (node == beginWordIndex) {\\n                results.push_back(curPath);\\n            }\\n            return;\\n        }\\n        \\n        const auto &neighbors = nodeToNeighbors[node];\\n        for (const int neighbor : neighbors) {\\n            if (distances[neighbor] != curDist - 1) continue;\\n            \\n            findAllPathsRecursive(neighbor, curDist - 1, shortestDist, wordList, curPath);\\n        }\\n    }\\n    \\n    int findWordIndex(const string &findWord, const vector<string> &wordList) {\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (wordList[i] == findWord) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    bool isConnected(const string &s1, const string &s2) {\\n        int diffCount = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1[i] != s2[i]) diffCount++;\\n            if (diffCount >= 2) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n    \\n    int beginWordIndex = -1;\\n    int endWordIndex = -1;\\n    vector<vector<int>> nodeToNeighbors;\\n    vector<int> distances;\\n    vector<vector<string>> results;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424796,
                "title": "python-double-bfs-easy-to-understand",
                "content": "This solution implements BFS two times. One time from `beginWord` to `endWord`. And then from `endWord` to `beginWord`. The **reason** to use BFS two times is to **avoid the memory limit** in the first BFS. In the first BFS a lot of useless paths would need to be kept in memory.\\n\\nThis solution works in 4 steps:\\n1. The neighbor map is build for each word in wordList\\n2. The first forward BFS is done starting from the beginWord until the endWord is reached. The connections are the connections build in the first step. During this step the reverse neighbor map is build.\\n3. The second BFS is done starting from the endWord and using the reverse neighbor map. Here the paths from the endWord to beginWord are build.\\n4. The paths build in step 3 need to be reversed. After reversing these paths this result is returned\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        # edge case\\n        if endWord not in wordList:\\n            return []\\n        \\n        # 1) build neighbor list for first bfs\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        unseen = set(wordList)\\n        word_size = len(beginWord)\\n        neighbors = defaultdict(list)\\n        for word in wordList:\\n            for i in range(word_size):\\n                neighbors[f\\'{word[:i]}*{word[i+1:]}\\'].append(word)\\n        \\n        # 2) do first bfs and build reversed neighbors list for second bfs\\n        reverse_neighbors = defaultdict(list)\\n        n_t_h = [beginWord]\\n        unseen.remove(beginWord)\\n        while n_t_h:\\n            new_seen = set()\\n            for word in n_t_h:\\n                for i in range(word_size):\\n                    for neighbor in neighbors[f\\'{word[:i]}*{word[i+1:]}\\']:\\n                        if neighbor in unseen:\\n                            reverse_neighbors[neighbor].append(word)\\n                            new_seen.add(neighbor)\\n            n_t_h = list(new_seen)\\n            unseen -= new_seen\\n            if reverse_neighbors[endWord]:\\n                break\\n        \\n        # if endWord does not have reversed neigbors it is not reachable so return empty list\\n        if not reverse_neighbors[endWord]:\\n            return []\\n        \\n        # 3) do second bfs\\n        paths = [[endWord]]\\n        while True:\\n            new_paths = []\\n            for path in paths:\\n                last_node = path[-1]\\n                for reverse_neighbor in reverse_neighbors[last_node]:\\n                    new_paths.append(path + [reverse_neighbor])\\n            paths = new_paths\\n            if paths[0][-1] == beginWord:\\n                break\\n        \\n        # 4) reverse the paths\\n        result = []\\n        for path in paths:\\n            path.reverse()\\n            result.append(path)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        # edge case\\n        if endWord not in wordList:\\n            return []\\n        \\n        # 1) build neighbor list for first bfs\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        unseen = set(wordList)\\n        word_size = len(beginWord)\\n        neighbors = defaultdict(list)\\n        for word in wordList:\\n            for i in range(word_size):\\n                neighbors[f\\'{word[:i]}*{word[i+1:]}\\'].append(word)\\n        \\n        # 2) do first bfs and build reversed neighbors list for second bfs\\n        reverse_neighbors = defaultdict(list)\\n        n_t_h = [beginWord]\\n        unseen.remove(beginWord)\\n        while n_t_h:\\n            new_seen = set()\\n            for word in n_t_h:\\n                for i in range(word_size):\\n                    for neighbor in neighbors[f\\'{word[:i]}*{word[i+1:]}\\']:\\n                        if neighbor in unseen:\\n                            reverse_neighbors[neighbor].append(word)\\n                            new_seen.add(neighbor)\\n            n_t_h = list(new_seen)\\n            unseen -= new_seen\\n            if reverse_neighbors[endWord]:\\n                break\\n        \\n        # if endWord does not have reversed neigbors it is not reachable so return empty list\\n        if not reverse_neighbors[endWord]:\\n            return []\\n        \\n        # 3) do second bfs\\n        paths = [[endWord]]\\n        while True:\\n            new_paths = []\\n            for path in paths:\\n                last_node = path[-1]\\n                for reverse_neighbor in reverse_neighbors[last_node]:\\n                    new_paths.append(path + [reverse_neighbor])\\n            paths = new_paths\\n            if paths[0][-1] == beginWord:\\n                break\\n        \\n        # 4) reverse the paths\\n        result = []\\n        for path in paths:\\n            path.reverse()\\n            result.append(path)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424281,
                "title": "c-easy-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t// If s1 and s2 string only differ by single character\\n\\tbool canBeNext(string s1, string s2){\\n\\t\\tint uncmn=0;\\n\\t\\tfor(int i=0; i<s1.size(); i++)\\n\\t\\t\\tuncmn += (s1[i] != s2[i]);\\n\\n\\t\\treturn uncmn==1;\\n\\t}\\n\\t\\n\\t// BFS to find the shortest paths first (Since BFS traverses nearest nodes first)\\n\\tvoid bfs(vector<vector<int>>& graph, vector<int> parent[], int n, int start, int end){\\n\\t\\tvector<int> dist(n, 501); // Distance from parent node set to 501 i.e INF for all the nodes\\n\\t\\t\\n\\t\\t// Initializing queue for BFS with adding start node\\n\\t\\tqueue<int> q; \\n\\t\\tq.push(start);\\n\\n\\t\\tdist[start] = 0; // 0 for start node (Since start can reach to start my making 0 moves)\\n\\t\\tparent[start] = {-1}; // no parent of start therefore marked -1\\n\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\t// Fetching front element of queue\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Traversing all the connected elements of curr (Here nearest(convertable) words indexes)\\n\\t\\t\\tfor( int node: graph[curr]){\\n\\t\\t\\t\\tif(dist[node] > dist[curr]+1){ // if marked distance is more than possible distance i.e, found nearest node (here word) \\n\\t\\t\\t\\t\\tdist[node] = dist[curr]+1;\\n\\t\\t\\t\\t\\tq.push(node);\\n\\t\\t\\t\\t\\tparent[node].clear(); // Removing previously calculated distant than current word\\n\\t\\t\\t\\t\\tparent[node].push_back(curr); // adding current word index\\n\\t\\t\\t\\t}else if(dist[node] == dist[curr]+1) // if node(next word) is just one move ahead the current \\n\\t\\t\\t\\t\\tparent[node].push_back(curr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\t\\n\\t// All the paths in the form of indexes of words from wordList\\n\\tvoid shortestPaths(int node, vector<vector<int>>& Paths, vector<int>& curr_path, vector<int> parent[]){\\n\\t\\tif(node == -1){ // Reached parent of all(Baap of all !!)\\n\\t\\t\\tPaths.push_back(curr_path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Traversing parents of \"node\" i.e, words that can be reached from current word given the condition\\n\\t\\tfor(int p: parent[node]){ \\n\\t\\t\\tcurr_path.push_back(p);\\n\\t\\t\\tshortestPaths(p, Paths, curr_path, parent);\\n\\t\\t\\tcurr_path.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\t// Indexes of beginWord and endWord respectively in wordList\\n\\t\\tint start=-1, end=-1;\\n\\n\\t\\tfor(int i=0; i<wordList.size(); i++){\\n\\t\\t\\tif(wordList[i] == beginWord)\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\tif(wordList[i] == endWord)\\n\\t\\t\\t\\tend = i;\\n\\t\\t}\\n\\n\\t\\tif(end == -1)\\n\\t\\t\\treturn {};\\n\\n\\t\\tif(start == -1){\\n\\t\\t\\twordList.emplace(wordList.begin(), beginWord); // setting beginWord as 1st element of wordList\\n\\t\\t\\tstart = 0;\\n\\t\\t\\tend++;\\n\\t\\t}\\n\\n\\t\\tint n = wordList.size();\\n\\t\\tvector<vector<int>> graph(n, vector<int>());\\n\\n\\t\\t// Creating adjency list for each pair of words that can be next i.e, word with only one uncommon char from current word\\n\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\tfor(int j=i+1; j<n; j++){\\n\\t\\t\\t\\tif(canBeNext(wordList[i], wordList[j])){\\n\\t\\t\\t\\t\\tgraph[i].push_back(j);\\n\\t\\t\\t\\t\\tgraph[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Apply BFS to get a list of parent of word as index \\n\\t\\tvector<int> parent[n];\\n\\t\\tbfs(graph, parent, n, start, end);\\n\\n\\t\\t// Backtrack to find shortest paths from node to parent(endWord to beginWord) using indexes\\n\\t\\tvector<vector<int>> Paths;\\n\\t\\tvector<int> curr_path;\\n\\t\\tshortestPaths(end, Paths, curr_path, parent);\\n\\n\\t\\t// Traverse through all shortest paths calculated and convert it into list of words(required answer)\\n\\t\\tvector<vector<string>> ans;\\n\\n\\t\\tfor(auto path: Paths){\\n\\t\\t\\tvector<string> curr;\\n\\n\\t\\t\\tfor(int i=0; i<path.size()-1; i++)\\n\\t\\t\\t\\tcurr.push_back(wordList[path[i]]);\\n\\t\\t\\t\\n\\t\\t\\t// Since we started with endWord to reach beginWord we have to reverse the current order and add endWord\\n\\t\\t\\treverse(curr.begin(), curr.end());  \\n\\t\\t\\tcurr.push_back(wordList[end]);\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t// If s1 and s2 string only differ by single character\\n\\tbool canBeNext(string s1, string s2){\\n\\t\\tint uncmn=0;\\n\\t\\tfor(int i=0; i<s1.size(); i++)\\n\\t\\t\\tuncmn += (s1[i] != s2[i]);\\n\\n\\t\\treturn uncmn==1;\\n\\t}\\n\\t\\n\\t// BFS to find the shortest paths first (Since BFS traverses nearest nodes first)\\n\\tvoid bfs(vector<vector<int>>& graph, vector<int> parent[], int n, int start, int end){\\n\\t\\tvector<int> dist(n, 501); // Distance from parent node set to 501 i.e INF for all the nodes\\n\\t\\t\\n\\t\\t// Initializing queue for BFS with adding start node\\n\\t\\tqueue<int> q; \\n\\t\\tq.push(start);\\n\\n\\t\\tdist[start] = 0; // 0 for start node (Since start can reach to start my making 0 moves)\\n\\t\\tparent[start] = {-1}; // no parent of start therefore marked -1\\n\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\t// Fetching front element of queue\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Traversing all the connected elements of curr (Here nearest(convertable) words indexes)\\n\\t\\t\\tfor( int node: graph[curr]){\\n\\t\\t\\t\\tif(dist[node] > dist[curr]+1){ // if marked distance is more than possible distance i.e, found nearest node (here word) \\n\\t\\t\\t\\t\\tdist[node] = dist[curr]+1;\\n\\t\\t\\t\\t\\tq.push(node);\\n\\t\\t\\t\\t\\tparent[node].clear(); // Removing previously calculated distant than current word\\n\\t\\t\\t\\t\\tparent[node].push_back(curr); // adding current word index\\n\\t\\t\\t\\t}else if(dist[node] == dist[curr]+1) // if node(next word) is just one move ahead the current \\n\\t\\t\\t\\t\\tparent[node].push_back(curr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\t\\n\\t// All the paths in the form of indexes of words from wordList\\n\\tvoid shortestPaths(int node, vector<vector<int>>& Paths, vector<int>& curr_path, vector<int> parent[]){\\n\\t\\tif(node == -1){ // Reached parent of all(Baap of all !!)\\n\\t\\t\\tPaths.push_back(curr_path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Traversing parents of \"node\" i.e, words that can be reached from current word given the condition\\n\\t\\tfor(int p: parent[node]){ \\n\\t\\t\\tcurr_path.push_back(p);\\n\\t\\t\\tshortestPaths(p, Paths, curr_path, parent);\\n\\t\\t\\tcurr_path.pop_back();\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\t// Indexes of beginWord and endWord respectively in wordList\\n\\t\\tint start=-1, end=-1;\\n\\n\\t\\tfor(int i=0; i<wordList.size(); i++){\\n\\t\\t\\tif(wordList[i] == beginWord)\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\tif(wordList[i] == endWord)\\n\\t\\t\\t\\tend = i;\\n\\t\\t}\\n\\n\\t\\tif(end == -1)\\n\\t\\t\\treturn {};\\n\\n\\t\\tif(start == -1){\\n\\t\\t\\twordList.emplace(wordList.begin(), beginWord); // setting beginWord as 1st element of wordList\\n\\t\\t\\tstart = 0;\\n\\t\\t\\tend++;\\n\\t\\t}\\n\\n\\t\\tint n = wordList.size();\\n\\t\\tvector<vector<int>> graph(n, vector<int>());\\n\\n\\t\\t// Creating adjency list for each pair of words that can be next i.e, word with only one uncommon char from current word\\n\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\tfor(int j=i+1; j<n; j++){\\n\\t\\t\\t\\tif(canBeNext(wordList[i], wordList[j])){\\n\\t\\t\\t\\t\\tgraph[i].push_back(j);\\n\\t\\t\\t\\t\\tgraph[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Apply BFS to get a list of parent of word as index \\n\\t\\tvector<int> parent[n];\\n\\t\\tbfs(graph, parent, n, start, end);\\n\\n\\t\\t// Backtrack to find shortest paths from node to parent(endWord to beginWord) using indexes\\n\\t\\tvector<vector<int>> Paths;\\n\\t\\tvector<int> curr_path;\\n\\t\\tshortestPaths(end, Paths, curr_path, parent);\\n\\n\\t\\t// Traverse through all shortest paths calculated and convert it into list of words(required answer)\\n\\t\\tvector<vector<string>> ans;\\n\\n\\t\\tfor(auto path: Paths){\\n\\t\\t\\tvector<string> curr;\\n\\n\\t\\t\\tfor(int i=0; i<path.size()-1; i++)\\n\\t\\t\\t\\tcurr.push_back(wordList[path[i]]);\\n\\t\\t\\t\\n\\t\\t\\t// Since we started with endWord to reach beginWord we have to reverse the current order and add endWord\\n\\t\\t\\treverse(curr.begin(), curr.end());  \\n\\t\\t\\tcurr.push_back(wordList[end]);\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423868,
                "title": "c-bfs-and-backtracking-faster-30ms",
                "content": "```\\nclass Solution {\\npublic:\\n  unordered_set<string> dic;\\n  unordered_map<string,int> mp;\\n  vector<vector<string>> ans;\\n    void dfs(string ew,vector<string> &temp,string bw)\\n    {\\n        \\n        int curr=mp[ew];\\n         temp.push_back(ew);\\n        if(ew==bw)\\n        {\\n            reverse(temp.begin(),temp.end());\\n           ans.push_back(temp);\\n            reverse(temp.begin(),temp.end());\\n            temp.pop_back();\\n            return ;\\n        }\\n        for(int i=0;i<ew.size();i++)\\n        {\\n            string st=ew;\\n          for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n          {\\n           st[i]=ch;\\n              if(mp[st] and mp[st]==curr-1)\\n              { \\n                  dfs(st,temp,bw);\\n              }\\n         }\\n        }\\n        temp.pop_back();\\n        \\n    }\\n    \\n   \\n \\n    vector<vector<string>> findLadders(string bw, string ew, vector<string>& wl) {\\n     \\n      \\n        for(auto it:wl)dic.insert(it);\\n        queue<string> q;\\n        q.push(bw);\\n        mp[bw]++;\\n            while(!q.empty())\\n            {\\n                auto k=q.front();\\n                q.pop();\\n                int steps=mp[k]+1;\\n                for(int i=0;i<k.size();i++)\\n                {\\n                    string temp=k;\\n                    for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                    {\\n                        temp[i]=ch;\\n                        if(dic.count(temp) and !mp[temp])\\n                        {\\n                            mp[temp]=steps;\\n                            q.push(temp);\\n                        }\\n                    }\\n                }   \\n            }\\n        if(mp[ew])\\n        {\\n            vector<string> temp;\\n            dfs(ew,temp,bw);        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  unordered_set<string> dic;\\n  unordered_map<string,int> mp;\\n  vector<vector<string>> ans;\\n    void dfs(string ew,vector<string> &temp,string bw)\\n    {\\n        \\n        int curr=mp[ew];\\n         temp.push_back(ew);\\n        if(ew==bw)\\n        {\\n            reverse(temp.begin(),temp.end());\\n           ans.push_back(temp);\\n            reverse(temp.begin(),temp.end());\\n            temp.pop_back();\\n            return ;\\n        }\\n        for(int i=0;i<ew.size();i++)\\n        {\\n            string st=ew;\\n          for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n          {\\n           st[i]=ch;\\n              if(mp[st] and mp[st]==curr-1)\\n              { \\n                  dfs(st,temp,bw);\\n              }\\n         }\\n        }\\n        temp.pop_back();\\n        \\n    }\\n    \\n   \\n \\n    vector<vector<string>> findLadders(string bw, string ew, vector<string>& wl) {\\n     \\n      \\n        for(auto it:wl)dic.insert(it);\\n        queue<string> q;\\n        q.push(bw);\\n        mp[bw]++;\\n            while(!q.empty())\\n            {\\n                auto k=q.front();\\n                q.pop();\\n                int steps=mp[k]+1;\\n                for(int i=0;i<k.size();i++)\\n                {\\n                    string temp=k;\\n                    for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                    {\\n                        temp[i]=ch;\\n                        if(dic.count(temp) and !mp[temp])\\n                        {\\n                            mp[temp]=steps;\\n                            q.push(temp);\\n                        }\\n                    }\\n                }   \\n            }\\n        if(mp[ew])\\n        {\\n            vector<string> temp;\\n            dfs(ew,temp,bw);        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018532,
                "title": "java-clean-code-easy-to-understand-well-explained",
                "content": "My approach to solve this problem\\n\\nI created a adjacency list of the strings , i.e.  next path of the string where it can got to with change of one char in from the previous string. I did this by converting the string to a char array and then changing the character at each index of string from **a to z** . so if i have the string ```hit``` then i would replace h with characters **a to z** and then check if any of those strings are present in my given ```words```. I used ```HashSet <string> words``` to store the values of ```wordList``` so that searching of string can be optimized to O(n). After generating all of the ```ArrayList <String> ans``` for each string in ```wordList``` i pushed the ```ans``` into ```graph```. And this is what we get. \\n```\\nhit-> hot\\nhot-> dot, lot\\ndot-> lot, dog\\nlot-> log\\ndog-> log, cog\\nlog-> cog\\n```\\nWe keep track of a variable called depth which gives us the minimum transformation it took to convert ```beginWord``` to ```endWord```\\n\\nAfter getting the adjacency list above i called DFS on it and traversed until my ```depth``` is equal to 0 and if i get my ```beginWord``` equal to ```endWord``` , i push the ```ans``` array into my ```res``` and return it.  \\n\\n**Problem: TLE arrised. **\\n\\nSolution: I optimised my adjacency list to a optimal adjacency list\\n![image](https://assets.leetcode.com/users/images/a6e79492-ea25-42df-a3e6-0d716f2ff9ae_1610739789.9149432.png)\\n\\nIn the image above levels are written of each string , we add them accordingly. \\n\\n```\\nhit-> hot\\nhot-> dot, lot\\ndot-> dog\\nlot-> log\\ndog-> cog\\nlog-> cog\\n```\\n\\nWe can do this by adding the strings that are only children and not the parent. i.e. strings that lie ahead of us and not the strings that are lesser than our ```level``` . \\n\\n# CODE\\n\\n```\\nclass Solution {\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> words=new HashSet<>(wordList);\\n        if(!words.contains(endWord)) return new ArrayList<>();\\n        \\n        HashMap<String,ArrayList<String>> graph=new HashMap<>(); // to make adjacency list\\n        HashMap<String,Integer> vis=new HashMap<>();    // to keep count of level traversal of str\\n        LinkedList<String> que=new LinkedList<>();\\n        \\n        que.addLast(beginWord);\\n        int level=0; int depth=0;\\n        vis.put(beginWord,0); // level of intial word will be 0\\n        \\n        //create graph bfs\\n        while(!que.isEmpty()){\\n            int size=que.size();\\n            level++;\\n            while(size-->0){\\n                String s=que.removeFirst();\\n                if(s.equals(endWord)){\\n                    if(depth==0) depth=level;\\n                    continue;\\n                }\\n                ArrayList<String> arr=new ArrayList<>();\\n                char[] ch=new char[s.length()];\\n                \\n                for(int i=0;i<s.length();i++){\\n                    ch=s.toCharArray();\\n                    char c=ch[i];\\n                    for(int j=0;j<26;j++){\\n                        if(c==(char)(j+\\'a\\')) continue;\\n                        ch[i]=(char)(j+\\'a\\');\\n                        String str=String.valueOf(ch);\\n                        if(words.contains(str)){\\n                            if(vis.getOrDefault(str,10000)>=level){\\n                                vis.put(str,level);\\n                                arr.add(str);\\n                                que.addLast(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n                graph.put(s,arr);\\n            }\\n        }\\n    \\n        //dfs\\n        HashMap<String,Integer> v=new HashMap<>();\\n        ArrayList<String> ans=new ArrayList<>();\\n        ans.add(beginWord);\\n        List<List<String>> res=new ArrayList<>();\\n        dfs(beginWord,endWord,depth-1,graph,v,ans,res);\\n        \\n        return res;\\n        \\n    }\\n    \\n    public static void dfs(String beginWord, String endWord, int depth, HashMap<String,ArrayList<String>>graph,HashMap<String,Integer> v,ArrayList<String> ans ,                                        List<List<String>> res){\\n        \\n        if(depth==0){\\n            if(beginWord.equals(endWord)){\\n                ArrayList<String> base=new ArrayList<>(ans);\\n                res.add(base);\\n            }\\n            return;\\n        }\\n        //mark\\n        v.put(beginWord,1);\\n        for(String s: graph.get(beginWord)){\\n            if(v.getOrDefault(s,0)!=1){\\n                ans.add(s);\\n                dfs(s,endWord,depth-1,graph,v,ans,res);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n        v.put(beginWord,0);\\n        return;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```hit```\n```words```\n```HashSet <string> words```\n```wordList```\n```ArrayList <String> ans```\n```wordList```\n```ans```\n```graph```\n```\\nhit-> hot\\nhot-> dot, lot\\ndot-> lot, dog\\nlot-> log\\ndog-> log, cog\\nlog-> cog\\n```\n```beginWord```\n```endWord```\n```depth```\n```beginWord```\n```endWord```\n```ans```\n```res```\n```\\nhit-> hot\\nhot-> dot, lot\\ndot-> dog\\nlot-> log\\ndog-> cog\\nlog-> cog\\n```\n```level```\n```\\nclass Solution {\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> words=new HashSet<>(wordList);\\n        if(!words.contains(endWord)) return new ArrayList<>();\\n        \\n        HashMap<String,ArrayList<String>> graph=new HashMap<>(); // to make adjacency list\\n        HashMap<String,Integer> vis=new HashMap<>();    // to keep count of level traversal of str\\n        LinkedList<String> que=new LinkedList<>();\\n        \\n        que.addLast(beginWord);\\n        int level=0; int depth=0;\\n        vis.put(beginWord,0); // level of intial word will be 0\\n        \\n        //create graph bfs\\n        while(!que.isEmpty()){\\n            int size=que.size();\\n            level++;\\n            while(size-->0){\\n                String s=que.removeFirst();\\n                if(s.equals(endWord)){\\n                    if(depth==0) depth=level;\\n                    continue;\\n                }\\n                ArrayList<String> arr=new ArrayList<>();\\n                char[] ch=new char[s.length()];\\n                \\n                for(int i=0;i<s.length();i++){\\n                    ch=s.toCharArray();\\n                    char c=ch[i];\\n                    for(int j=0;j<26;j++){\\n                        if(c==(char)(j+\\'a\\')) continue;\\n                        ch[i]=(char)(j+\\'a\\');\\n                        String str=String.valueOf(ch);\\n                        if(words.contains(str)){\\n                            if(vis.getOrDefault(str,10000)>=level){\\n                                vis.put(str,level);\\n                                arr.add(str);\\n                                que.addLast(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n                graph.put(s,arr);\\n            }\\n        }\\n    \\n        //dfs\\n        HashMap<String,Integer> v=new HashMap<>();\\n        ArrayList<String> ans=new ArrayList<>();\\n        ans.add(beginWord);\\n        List<List<String>> res=new ArrayList<>();\\n        dfs(beginWord,endWord,depth-1,graph,v,ans,res);\\n        \\n        return res;\\n        \\n    }\\n    \\n    public static void dfs(String beginWord, String endWord, int depth, HashMap<String,ArrayList<String>>graph,HashMap<String,Integer> v,ArrayList<String> ans ,                                        List<List<String>> res){\\n        \\n        if(depth==0){\\n            if(beginWord.equals(endWord)){\\n                ArrayList<String> base=new ArrayList<>(ans);\\n                res.add(base);\\n            }\\n            return;\\n        }\\n        //mark\\n        v.put(beginWord,1);\\n        for(String s: graph.get(beginWord)){\\n            if(v.getOrDefault(s,0)!=1){\\n                ans.add(s);\\n                dfs(s,endWord,depth-1,graph,v,ans,res);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n        v.put(beginWord,0);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40637,
                "title": "time-limit-exceeded-for-nape-mild",
                "content": "I used BFS approach and kept a map for getting paths. I used dp approach for faster retrievel but i am still getting TLE for \"nape\" \"mild\" input (achieved to get correct results on my pc). Can anyone point ways to decrease time consumption?\\n\\n\\n    public ArrayList<ArrayList<String>> findLadders(String start,\\n    \\t\\t\\tString end, HashSet<String> dict) {\\n    \\n    \\t\\tArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();\\n    \\t\\tQueue<String> que = new LinkedList<String>();\\n    \\t\\tque.add(start);\\n    \\t\\tString dummy = \"dummuuuOO\";\\n    \\t\\tHashSet<String> used = new HashSet<String>();\\n    \\t\\tif (!dict.contains(end))\\n    \\t\\t\\treturn ret;\\n    \\t\\tque.add(dummy);\\n    \\t\\tdict.remove(start);\\n    \\t\\tHashMap<String, Set<String>> path = new HashMap<String, Set<String>>();\\n    \\t\\tHashSet<String> usedTemp = new HashSet<String>();\\n    \\t\\tHashMap<String, ArrayList<String>> dictMemory = new HashMap<String, ArrayList<String>>();\\n    \\t\\tint count = 0;\\n    \\t\\twhile (que.size() > 1) {\\n    \\t\\t\\tString current = que.poll();\\n    \\t\\t\\tif (current.equals(end)) {\\n    \\t\\t\\t\\tHashMap<String, ArrayList<ArrayList<String>>> mem = new HashMap<String, ArrayList<ArrayList<String>>>();\\n    \\t\\t\\t\\tret.addAll(generateList(start, end, path, mem, count));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (current.equals(dummy)) {\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tque.add(dummy);\\n    \\t\\t\\t\\tused.addAll(usedTemp);\\n    \\t\\t\\t\\tusedTemp.clear();\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tArrayList<String> list = getNextFromDict(current, dict, dictMemory, end);\\n    \\t\\t\\tfor (String next : list) {\\n    \\t\\t\\t\\tif (!used.contains(next)) {\\n    \\t\\t\\t\\t\\tSet<String> nl = path.get(next) == null ? new HashSet<String>()\\n    \\t\\t\\t\\t\\t\\t\\t: path.get(next);\\n    \\t\\t\\t\\t\\tnl.add(current);\\n    \\t\\t\\t\\t\\tpath.put(next, nl);\\n    \\t\\t\\t\\t\\tusedTemp.add(next);\\n    \\t\\t\\t\\t\\tque.add(next);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tprivate  ArrayList<String> getNextFromDict(String current,\\n    \\t\\t\\tHashSet<String> dict, HashMap<String, ArrayList<String>> dictMemory, String last) {\\n    \\t\\tif (dictMemory.get(current) != null)\\n    \\t\\t\\treturn dictMemory.get(current);\\n    \\t\\tArrayList<String> ret = new ArrayList<String>();\\n    \\t\\tfor (int n = 0; n < current.length(); n++) {\\n    \\t\\t\\tString check = current.substring(0, n) + String.valueOf(last.charAt(n))\\n    \\t\\t\\t\\t\\t+ current.substring(n + 1);\\n    \\t\\t\\tif (dict.contains(check))\\n    \\t\\t\\t\\tret.add(check);\\n    \\t\\t\\tfor (char c = 'a'; c < 'z'; c++) {\\n    \\t\\t\\t\\tif (current.charAt(n) != c && last.charAt(n) != c) {\\n    \\t\\t\\t\\t\\tString key = current.substring(0, n) + String.valueOf(c)\\n    \\t\\t\\t\\t\\t\\t\\t+ current.substring(n + 1);\\n    \\t\\t\\t\\t\\tif (dict.contains(key))\\n    \\t\\t\\t\\t\\t\\tret.add(key);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tdictMemory.put(current, ret);\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tprivate  ArrayList<ArrayList<String>> generateList(String start,\\n    \\t\\t\\tString end, HashMap<String, Set<String>> path,\\n    \\t\\t\\tHashMap<String, ArrayList<ArrayList<String>>> memory, int count) {\\n    \\t\\tArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();\\n    \\t\\tif (count < 0)\\n    \\t\\t\\treturn null;\\n    \\t\\tif (memory.get(end) != null) {\\n    \\t\\t\\tif (memory.get(end) != null && memory.get(end).size() > 0\\n    \\t\\t\\t\\t\\t&& memory.get(end).get(0).size() == count+1){\\n    \\t\\t\\t\\tArrayList<ArrayList<String>> cache1 = new ArrayList<ArrayList<String>>();\\n    \\t\\t\\t\\tArrayList<String> cache2 = new ArrayList<String>();\\n    \\t\\t\\t\\tcache2.addAll(memory.get(end).get(0));\\n    \\t\\t\\t\\tcache1.add(cache2);\\n    \\t\\t\\t\\treturn cache1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn null;\\n    \\t\\t}\\n    \\t\\tString key = end;\\n    \\t\\tif (key.equals(start)) {\\n    \\t\\t\\tArrayList<String> l = new ArrayList<String>();\\n    \\t\\t\\tl.add(key);\\n    \\t\\t\\tret.add(l);\\n    \\t\\t\\tArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();\\n    \\t\\t\\tfor (ArrayList<String> list : ret) {\\n    \\t\\t\\t\\tArrayList<String> lClone = new ArrayList<String>();\\n    \\t\\t\\t\\tlClone.addAll(list);\\n    \\t\\t\\t\\tretClone.add(lClone);\\n    \\t\\t\\t}\\n    \\t\\t\\tmemory.put(end, retClone);\\n    \\t\\t\\treturn ret;\\n    \\t\\t}\\n    \\n    \\t\\tSet<String> prev = path.get(key);\\n    \\t\\tfor (String p : prev) {\\n    \\t\\t\\tArrayList<ArrayList<String>> generateList = generateList(start, p,\\n    \\t\\t\\t\\t\\tpath, memory, count-1);\\n    \\t\\t\\tif (generateList != null) {\\n    \\t\\t\\t\\tfor (ArrayList<String> pth : generateList) {\\n    \\t\\t\\t\\t\\tpth.add(key);\\n    \\t\\t\\t\\t\\tret.add(pth);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();\\n    \\t\\tfor (ArrayList<String> list : ret) {\\n    \\t\\t\\tArrayList<String> lClone = new ArrayList<String>();\\n    \\t\\t\\tlClone.addAll(list);\\n    \\t\\t\\tretClone.add(lClone);\\n    \\t\\t}\\n    \\t\\tmemory.put(end, retClone);\\n    \\t\\treturn ret;\\n    \\t}",
                "solutionTags": [],
                "code": "I used BFS approach and kept a map for getting paths. I used dp approach for faster retrievel but i am still getting TLE for \"nape\" \"mild\" input (achieved to get correct results on my pc). Can anyone point ways to decrease time consumption?\\n\\n\\n    public ArrayList<ArrayList<String>> findLadders(String start,\\n    \\t\\t\\tString end, HashSet<String> dict) {\\n    \\n    \\t\\tArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();\\n    \\t\\tQueue<String> que = new LinkedList<String>();\\n    \\t\\tque.add(start);\\n    \\t\\tString dummy = \"dummuuuOO\";\\n    \\t\\tHashSet<String> used = new HashSet<String>();\\n    \\t\\tif (!dict.contains(end))\\n    \\t\\t\\treturn ret;\\n    \\t\\tque.add(dummy);\\n    \\t\\tdict.remove(start);\\n    \\t\\tHashMap<String, Set<String>> path = new HashMap<String, Set<String>>();\\n    \\t\\tHashSet<String> usedTemp = new HashSet<String>();\\n    \\t\\tHashMap<String, ArrayList<String>> dictMemory = new HashMap<String, ArrayList<String>>();\\n    \\t\\tint count = 0;\\n    \\t\\twhile (que.size() > 1) {\\n    \\t\\t\\tString current = que.poll();\\n    \\t\\t\\tif (current.equals(end)) {\\n    \\t\\t\\t\\tHashMap<String, ArrayList<ArrayList<String>>> mem = new HashMap<String, ArrayList<ArrayList<String>>>();\\n    \\t\\t\\t\\tret.addAll(generateList(start, end, path, mem, count));\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (current.equals(dummy)) {\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tque.add(dummy);\\n    \\t\\t\\t\\tused.addAll(usedTemp);\\n    \\t\\t\\t\\tusedTemp.clear();\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tArrayList<String> list = getNextFromDict(current, dict, dictMemory, end);\\n    \\t\\t\\tfor (String next : list) {\\n    \\t\\t\\t\\tif (!used.contains(next)) {\\n    \\t\\t\\t\\t\\tSet<String> nl = path.get(next) == null ? new HashSet<String>()\\n    \\t\\t\\t\\t\\t\\t\\t: path.get(next);\\n    \\t\\t\\t\\t\\tnl.add(current);\\n    \\t\\t\\t\\t\\tpath.put(next, nl);\\n    \\t\\t\\t\\t\\tusedTemp.add(next);\\n    \\t\\t\\t\\t\\tque.add(next);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tprivate  ArrayList<String> getNextFromDict(String current,\\n    \\t\\t\\tHashSet<String> dict, HashMap<String, ArrayList<String>> dictMemory, String last) {\\n    \\t\\tif (dictMemory.get(current) != null)\\n    \\t\\t\\treturn dictMemory.get(current);\\n    \\t\\tArrayList<String> ret = new ArrayList<String>();\\n    \\t\\tfor (int n = 0; n < current.length(); n++) {\\n    \\t\\t\\tString check = current.substring(0, n) + String.valueOf(last.charAt(n))\\n    \\t\\t\\t\\t\\t+ current.substring(n + 1);\\n    \\t\\t\\tif (dict.contains(check))\\n    \\t\\t\\t\\tret.add(check);\\n    \\t\\t\\tfor (char c = 'a'; c < 'z'; c++) {\\n    \\t\\t\\t\\tif (current.charAt(n) != c && last.charAt(n) != c) {\\n    \\t\\t\\t\\t\\tString key = current.substring(0, n) + String.valueOf(c)\\n    \\t\\t\\t\\t\\t\\t\\t+ current.substring(n + 1);\\n    \\t\\t\\t\\t\\tif (dict.contains(key))\\n    \\t\\t\\t\\t\\t\\tret.add(key);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tdictMemory.put(current, ret);\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tprivate  ArrayList<ArrayList<String>> generateList(String start,\\n    \\t\\t\\tString end, HashMap<String, Set<String>> path,\\n    \\t\\t\\tHashMap<String, ArrayList<ArrayList<String>>> memory, int count) {\\n    \\t\\tArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();\\n    \\t\\tif (count < 0)\\n    \\t\\t\\treturn null;\\n    \\t\\tif (memory.get(end) != null) {\\n    \\t\\t\\tif (memory.get(end) != null && memory.get(end).size() > 0\\n    \\t\\t\\t\\t\\t&& memory.get(end).get(0).size() == count+1){\\n    \\t\\t\\t\\tArrayList<ArrayList<String>> cache1 = new ArrayList<ArrayList<String>>();\\n    \\t\\t\\t\\tArrayList<String> cache2 = new ArrayList<String>();\\n    \\t\\t\\t\\tcache2.addAll(memory.get(end).get(0));\\n    \\t\\t\\t\\tcache1.add(cache2);\\n    \\t\\t\\t\\treturn cache1;\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn null;\\n    \\t\\t}\\n    \\t\\tString key = end;\\n    \\t\\tif (key.equals(start)) {\\n    \\t\\t\\tArrayList<String> l = new ArrayList<String>();\\n    \\t\\t\\tl.add(key);\\n    \\t\\t\\tret.add(l);\\n    \\t\\t\\tArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();\\n    \\t\\t\\tfor (ArrayList<String> list : ret) {\\n    \\t\\t\\t\\tArrayList<String> lClone = new ArrayList<String>();\\n    \\t\\t\\t\\tlClone.addAll(list);\\n    \\t\\t\\t\\tretClone.add(lClone);\\n    \\t\\t\\t}\\n    \\t\\t\\tmemory.put(end, retClone);\\n    \\t\\t\\treturn ret;\\n    \\t\\t}\\n    \\n    \\t\\tSet<String> prev = path.get(key);\\n    \\t\\tfor (String p : prev) {\\n    \\t\\t\\tArrayList<ArrayList<String>> generateList = generateList(start, p,\\n    \\t\\t\\t\\t\\tpath, memory, count-1);\\n    \\t\\t\\tif (generateList != null) {\\n    \\t\\t\\t\\tfor (ArrayList<String> pth : generateList) {\\n    \\t\\t\\t\\t\\tpth.add(key);\\n    \\t\\t\\t\\t\\tret.add(pth);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tArrayList<ArrayList<String>> retClone = new ArrayList<ArrayList<String>>();\\n    \\t\\tfor (ArrayList<String> list : ret) {\\n    \\t\\t\\tArrayList<String> lClone = new ArrayList<String>();\\n    \\t\\t\\tlClone.addAll(list);\\n    \\t\\t\\tretClone.add(lClone);\\n    \\t\\t}\\n    \\t\\tmemory.put(end, retClone);\\n    \\t\\treturn ret;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3200097,
                "title": "126-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSure, here\\'s a step-by-step explanation of the code: \\n```\\nclass Solution:\\n\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\n```\\nThe function findLadders takes in a beginWord and endWord string, and a wordList list of strings, and returns a list of lists of strings, which represent the possible transformation sequences from the beginWord to endWord.\\n```\\nd = defaultdict(list)\\nfor word in wordList:\\n\\tfor i in range(len(word)):\\n\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n```\\nA defaultdict d is created, which will be used to store a mapping from each \"intermediate word\" (words that can be obtained from the original word by changing one letter) to a list of words that can be formed from it. The for-loop iterates over each word in the wordList, and for each word, it replaces each letter of the word with a * character, one at a time, and stores the resulting intermediate word as a key in the d dictionary, with the original word as a value in the corresponding list.\\n\\n```\\nif endWord not in wordList:\\n\\treturn []\\n\\n```\\nIf the endWord is not present in the wordList, then no transformation sequence is possible, so an empty list is returned.\\n```\\nvisited1 = defaultdict(list)\\nq1 = deque([beginWord])\\nvisited1[beginWord] = []\\n\\nvisited2 = defaultdict(list)\\nq2 = deque([endWord])\\nvisited2[endWord] = []\\n\\nans = []\\n\\n```\\nTwo defaultdicts visited1 and visited2 are created to store the visited nodes during BFS. Two deques q1 and q2 are initialized with the beginWord and endWord, respectively, and the visited nodes for beginWord and endWord are initialized as empty lists. ans is also initialized as an empty list, which will be used to store the transformation sequences.\\n```\\ndef dfs(v, visited, path, paths):\\n\\tpath.append(v)\\n\\tif not visited[v]:\\n\\t\\tif visited is visited1:\\n\\t\\t\\tpaths.append(path[::-1])\\n\\t\\telse:\\n\\t\\t\\tpaths.append(path[:])\\n\\tfor u in visited[v]:\\n\\t\\tdfs(u, visited, path, paths)\\n\\tpath.pop()\\n\\n```\\nA depth-first search (DFS) function is defined to find all possible transformation sequences between beginWord and endWord. The function takes in a v node, the visited dictionary, a path list, and a paths list, which will be used to store the transformation sequences found. If v is not visited, the current path list is added to paths list, with the path being reversed if visited is visited1. Then, for each adjacent node u of v (i.e., a word that can be formed from v by changing one letter), the dfs function is called recursively.\\n```\\ndef bfs(q, visited1, visited2, frombegin):\\n\\tlevel_visited = defaultdict(list)\\n\\tfor _ in range(len(q)):\\n\\t\\tu = q.popleft()\\n\\n\\t\\tfor i in range(len(u)):\\n\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\td = defaultdict(list)\\n\\t\\tfor word in wordList:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n\\t\\tif endWord not in wordList:\\n\\t\\t\\treturn []\\n\\n\\t\\tvisited1 = defaultdict(list)\\n\\t\\tq1 = deque([beginWord])\\n\\t\\tvisited1[beginWord] = []\\n\\n\\t\\tvisited2 = defaultdict(list)\\n\\t\\tq2 = deque([endWord])\\n\\t\\tvisited2[endWord] = []\\n\\n\\t\\tans = []\\n\\t\\tdef dfs(v, visited, path, paths):\\n\\t\\t\\tpath.append(v)\\n\\t\\t\\tif not visited[v]:\\n\\t\\t\\t\\tif visited is visited1:\\n\\t\\t\\t\\t\\tpaths.append(path[::-1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpaths.append(path[:])\\n\\t\\t\\tfor u in visited[v]:\\n\\t\\t\\t\\tdfs(u, visited, path, paths)\\n\\t\\t\\tpath.pop()\\n\\n\\t\\tdef bfs(q, visited1, visited2, frombegin):\\n\\t\\t\\tlevel_visited = defaultdict(list)\\n\\t\\t\\tfor _ in range(len(q)):\\n\\t\\t\\t\\tu = q.popleft()\\n\\n\\t\\t\\t\\tfor i in range(len(u)):\\n\\t\\t\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\t\\tpaths1, paths2 = paths2, paths1\\n\\t\\t\\t\\t\\t\\t\\tfor a in paths1:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in paths2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(a+b)\\n\\t\\t\\t\\t\\t\\telif v not in visited1:\\n\\t\\t\\t\\t\\t\\t\\tif v not in level_visited:\\n\\t\\t\\t\\t\\t\\t\\t\\tq.append(v)\\n\\t\\t\\t\\t\\t\\t\\tlevel_visited[v].append(u)\\n\\t\\t\\tvisited1.update(level_visited)\\n\\n\\t\\twhile q1 and q2 and not ans:\\n\\t\\t\\tif len(q1) <= len(q2):\\n\\t\\t\\t\\tbfs(q1, visited1, visited2, True)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs(q2, visited2, visited1, False)\\n\\n\\t\\treturn ans\\n\\t\\t\\t\\n\\t\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\n```\n```\\nd = defaultdict(list)\\nfor word in wordList:\\n\\tfor i in range(len(word)):\\n\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n```\n```\\nif endWord not in wordList:\\n\\treturn []\\n\\n```\n```\\nvisited1 = defaultdict(list)\\nq1 = deque([beginWord])\\nvisited1[beginWord] = []\\n\\nvisited2 = defaultdict(list)\\nq2 = deque([endWord])\\nvisited2[endWord] = []\\n\\nans = []\\n\\n```\n```\\ndef dfs(v, visited, path, paths):\\n\\tpath.append(v)\\n\\tif not visited[v]:\\n\\t\\tif visited is visited1:\\n\\t\\t\\tpaths.append(path[::-1])\\n\\t\\telse:\\n\\t\\t\\tpaths.append(path[:])\\n\\tfor u in visited[v]:\\n\\t\\tdfs(u, visited, path, paths)\\n\\tpath.pop()\\n\\n```\n```\\ndef bfs(q, visited1, visited2, frombegin):\\n\\tlevel_visited = defaultdict(list)\\n\\tfor _ in range(len(q)):\\n\\t\\tu = q.popleft()\\n\\n\\t\\tfor i in range(len(u)):\\n\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\n\\n```\n```\\nclass Solution:\\n\\tdef findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\td = defaultdict(list)\\n\\t\\tfor word in wordList:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\td[word[:i]+\"*\"+word[i+1:]].append(word)\\n\\n\\t\\tif endWord not in wordList:\\n\\t\\t\\treturn []\\n\\n\\t\\tvisited1 = defaultdict(list)\\n\\t\\tq1 = deque([beginWord])\\n\\t\\tvisited1[beginWord] = []\\n\\n\\t\\tvisited2 = defaultdict(list)\\n\\t\\tq2 = deque([endWord])\\n\\t\\tvisited2[endWord] = []\\n\\n\\t\\tans = []\\n\\t\\tdef dfs(v, visited, path, paths):\\n\\t\\t\\tpath.append(v)\\n\\t\\t\\tif not visited[v]:\\n\\t\\t\\t\\tif visited is visited1:\\n\\t\\t\\t\\t\\tpaths.append(path[::-1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpaths.append(path[:])\\n\\t\\t\\tfor u in visited[v]:\\n\\t\\t\\t\\tdfs(u, visited, path, paths)\\n\\t\\t\\tpath.pop()\\n\\n\\t\\tdef bfs(q, visited1, visited2, frombegin):\\n\\t\\t\\tlevel_visited = defaultdict(list)\\n\\t\\t\\tfor _ in range(len(q)):\\n\\t\\t\\t\\tu = q.popleft()\\n\\n\\t\\t\\t\\tfor i in range(len(u)):\\n\\t\\t\\t\\t\\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\\n\\t\\t\\t\\t\\t\\tif v in visited2:\\n\\t\\t\\t\\t\\t\\t\\tpaths1 = []\\n\\t\\t\\t\\t\\t\\t\\tpaths2 = []\\n\\t\\t\\t\\t\\t\\t\\tdfs(u, visited1, [], paths1)\\n\\t\\t\\t\\t\\t\\t\\tdfs(v, visited2, [], paths2)\\n\\t\\t\\t\\t\\t\\t\\tif not frombegin:\\n\\t\\t\\t\\t\\t\\t\\t\\tpaths1, paths2 = paths2, paths1\\n\\t\\t\\t\\t\\t\\t\\tfor a in paths1:\\n\\t\\t\\t\\t\\t\\t\\t\\tfor b in paths2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tans.append(a+b)\\n\\t\\t\\t\\t\\t\\telif v not in visited1:\\n\\t\\t\\t\\t\\t\\t\\tif v not in level_visited:\\n\\t\\t\\t\\t\\t\\t\\t\\tq.append(v)\\n\\t\\t\\t\\t\\t\\t\\tlevel_visited[v].append(u)\\n\\t\\t\\tvisited1.update(level_visited)\\n\\n\\t\\twhile q1 and q2 and not ans:\\n\\t\\t\\tif len(q1) <= len(q2):\\n\\t\\t\\t\\tbfs(q1, visited1, visited2, True)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs(q2, visited2, visited1, False)\\n\\n\\t\\treturn ans\\n\\t\\t\\t\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422857,
                "title": "why-is-this-question",
                "content": "All you get is TLE\\nWhen you try to understand someone else\\'s code and finally try to implement it you get TLE\\nI don\\'t know what\\'s wrong with this question\\nWhat do I need to do to get this question done",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2422739,
                "title": "c-solution-bfs-dfs-backtracking-dictionary-clean-code",
                "content": "```C#\\npublic class Solution {\\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {\\n        List<IList<string>> ans = new List<IList<string>>();\\n        var (shortestPathLength, graph) = ComputeGraph(beginWord, endWord, wordList);\\n        if (graph == null) return ans;\\n        \\n        string[] path = new string[shortestPathLength];\\n        FindPaths(endWord, 0);\\n        return ans;\\n        \\n        void FindPaths(string w, int position) {\\n            path[shortestPathLength - (position + 1)] = w;\\n            if (position == shortestPathLength - 1) ans.Add(path.ToList());\\n            else if (graph.ContainsKey(w))\\n                foreach (string nextWord in graph[w]) FindPaths(nextWord, position + 1);\\n        }\\n    }\\n    \\n    private static (int ShortestPathLength, Dictionary<string, HashSet<string>> Graph) ComputeGraph(string beginWord, string endWord, IList<string> wordList) {\\n        Dictionary<string, HashSet<string>> graph = new Dictionary<string, HashSet<string>>();\\n        \\n        Queue<string> q = new Queue<string>();\\n        q.Enqueue(beginWord);\\n        \\n        HashSet<string> used = new HashSet<string>(capacity: wordList.Count + 1);\\n        HashSet<string> usedInIteration = new HashSet<string>(capacity: wordList.Count + 1);\\n        bool endIsReached = false;\\n        int pathLength = 1;\\n        while (q.Count > 0) {\\n            int iterationCount = q.Count;\\n            \\n            for (int i = 0; i < iterationCount; i++) {\\n                string current = q.Dequeue();\\n                used.Add(current);\\n                \\n                foreach (string possibleContinuation in wordList.Where(w => !used.Contains(w) && HaveOneLetterDifference(w, current))) {\\n                    if (possibleContinuation == endWord) endIsReached = true;\\n                    else if (!usedInIteration.Contains(possibleContinuation)) {\\n                        q.Enqueue(possibleContinuation);\\n                        usedInIteration.Add(possibleContinuation);\\n                    }\\n                    \\n                    if (!graph.ContainsKey(possibleContinuation)) graph[possibleContinuation] = new HashSet<string>();\\n                    graph[possibleContinuation].Add(current);\\n                }\\n            }\\n            \\n            if (endIsReached) return (pathLength + 1, graph);\\n\\n            foreach (string usedContinuation in usedInIteration) used.Add(usedContinuation);\\n            usedInIteration.Clear();\\n            pathLength++;\\n        }\\n        \\n        return (int.MaxValue, null);\\n    }\\n    \\n    private static bool HaveOneLetterDifference(string a, string b) {\\n        bool hadDifference = false;\\n        for (int i = 0; i < a.Length; i++) {\\n            if (a[i] != b[i]) {\\n                if (hadDifference) return false;\\n                else hadDifference  = true;\\n            }\\n        }\\n        \\n        return hadDifference;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```C#\\npublic class Solution {\\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList) {\\n        List<IList<string>> ans = new List<IList<string>>();\\n        var (shortestPathLength, graph) = ComputeGraph(beginWord, endWord, wordList);\\n        if (graph == null) return ans;\\n        \\n        string[] path = new string[shortestPathLength];\\n        FindPaths(endWord, 0);\\n        return ans;\\n        \\n        void FindPaths(string w, int position) {\\n            path[shortestPathLength - (position + 1)] = w;\\n            if (position == shortestPathLength - 1) ans.Add(path.ToList());\\n            else if (graph.ContainsKey(w))\\n                foreach (string nextWord in graph[w]) FindPaths(nextWord, position + 1);\\n        }\\n    }\\n    \\n    private static (int ShortestPathLength, Dictionary<string, HashSet<string>> Graph) ComputeGraph(string beginWord, string endWord, IList<string> wordList) {\\n        Dictionary<string, HashSet<string>> graph = new Dictionary<string, HashSet<string>>();\\n        \\n        Queue<string> q = new Queue<string>();\\n        q.Enqueue(beginWord);\\n        \\n        HashSet<string> used = new HashSet<string>(capacity: wordList.Count + 1);\\n        HashSet<string> usedInIteration = new HashSet<string>(capacity: wordList.Count + 1);\\n        bool endIsReached = false;\\n        int pathLength = 1;\\n        while (q.Count > 0) {\\n            int iterationCount = q.Count;\\n            \\n            for (int i = 0; i < iterationCount; i++) {\\n                string current = q.Dequeue();\\n                used.Add(current);\\n                \\n                foreach (string possibleContinuation in wordList.Where(w => !used.Contains(w) && HaveOneLetterDifference(w, current))) {\\n                    if (possibleContinuation == endWord) endIsReached = true;\\n                    else if (!usedInIteration.Contains(possibleContinuation)) {\\n                        q.Enqueue(possibleContinuation);\\n                        usedInIteration.Add(possibleContinuation);\\n                    }\\n                    \\n                    if (!graph.ContainsKey(possibleContinuation)) graph[possibleContinuation] = new HashSet<string>();\\n                    graph[possibleContinuation].Add(current);\\n                }\\n            }\\n            \\n            if (endIsReached) return (pathLength + 1, graph);\\n\\n            foreach (string usedContinuation in usedInIteration) used.Add(usedContinuation);\\n            usedInIteration.Clear();\\n            pathLength++;\\n        }\\n        \\n        return (int.MaxValue, null);\\n    }\\n    \\n    private static bool HaveOneLetterDifference(string a, string b) {\\n        bool hadDifference = false;\\n        for (int i = 0; i < a.Length; i++) {\\n            if (a[i] != b[i]) {\\n                if (hadDifference) return false;\\n                else hadDifference  = true;\\n            }\\n        }\\n        \\n        return hadDifference;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422574,
                "title": "0-ms-runtime-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        auto answer = std::vector<std::vector<std::string>>();\\n        auto from = beginWord;\\n        auto to = endWord;\\n\\n        auto my_lexicon = std::unordered_set<std::string>(wordList.begin(),wordList.end());\\n        if ((my_lexicon.find(to) == my_lexicon.end())) {\\n\\t        return answer;\\n\\t    }\\n        //auto const total_lexicon = my_lexicon;\\n\\n        auto current_level_forward = std::unordered_set<std::string>({from});\\n        auto current_level_backward = std::unordered_set<std::string>({to});\\n        auto ladders = std::unordered_map<std::string, std::vector<std::string>>();\\n\\n        auto found = false;\\n        auto flip = false;\\n\\n        my_lexicon.erase(from);\\n        my_lexicon.erase(to);\\n\\n        while (!current_level_forward.empty() and !current_level_backward.empty()) {\\n\\n            if (current_level_forward.size() > current_level_backward.size()) {\\n                flip = !flip;\\n                std::swap(current_level_forward, current_level_backward);\\n            }\\n\\n            auto next_level = std::unordered_set<std::string>();\\n\\n            for (auto word: current_level_forward) {\\n                //auto neighbours = find_neighbours(word, total_lexicon);\\n                for (std::string::size_type i = 0; i < word.size(); i++) {\\n                    auto neighbour = word;\\n                    for (auto j = \\'a\\'; j <= \\'z\\'; j++) {\\n                        if (neighbour[i] == j) continue;\\n                        neighbour[i] = j;\\n\\n                        if (current_level_backward.find(neighbour) != current_level_backward.end()) {\\n                            found = true;\\n                            flip ? ladders[neighbour].emplace_back(word) : ladders[word].emplace_back(neighbour);\\n                        }\\n                        if (my_lexicon.find(neighbour) != my_lexicon.end()) {\\n                            next_level.insert(neighbour);\\n                            flip ? ladders[neighbour].emplace_back(word) : ladders[word].emplace_back(neighbour);\\n                        }\\n                    }\\n                }\\n            }\\n            if (found) break;\\n            for (auto seen: next_level) my_lexicon.erase(seen);\\n            current_level_forward = next_level;\\n        }\\n\\n        if (found) {\\n            auto current_path = std::vector<std::string>({from});\\n            generate_paths(from, to, ladders, answer);\\n        }\\n        return answer;\\n        \\n}\\nprivate:\\n    auto generate_paths(std::string from, std::string const& to, std::unordered_map<std::string, std::vector<std::string>>& ladders,\\n                          std::vector<std::vector<std::string>>& answer)\\n       -> void { \\n        \\n        auto paths_to_search = std::vector<std::vector<std::string>>();\\n        paths_to_search.push_back(std::vector<std::string>({from}));\\n        \\n        while(!paths_to_search.empty()) {\\n            auto current_path = paths_to_search.back();\\n            paths_to_search.pop_back();\\n            \\n            auto current_word = current_path.back();\\n            \\n            if (current_word == to) {\\n                answer.push_back(current_path);\\n                continue;\\n            }\\n            \\n            if (ladders.find(current_word) == ladders.end()) {\\n                continue;\\n            }\\n            \\n            for (const auto& word: ladders.at(current_word)) {\\n                auto path = current_path;\\n                path.push_back(word);\\n                paths_to_search.push_back(path);\\n            }  \\n        }\\n    }\\n};\\n```\\n\\nAlternate Solution using Trie :\\n\\n```\\nclass node{\\n    public:\\n    char data;\\n    map<char, node*> h; // if a in h then it has its address\\n    node(char d){\\n        data = d;\\n    }\\n};\\n\\nclass Trie{\\n    node* root;\\n    public:\\n    Trie(){\\n        root = new node(\\'\\\\0\\');  // initial root which will contain map of first charachter\\n    }\\n\\n    void insert(string& word){\\n        node* temp = root;\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(temp->h.count(ch) == 0){ // if this character not present in previous charachter map\\n                node* child = new node(ch);\\n                temp->h[ch] = child;\\n            }\\n            temp = temp->h[ch];\\n        }\\n    }\\n\\n    bool isPresent(string& word){\\n        node* temp = root;\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(temp->h.count(ch)) temp = temp->h[ch];\\n            else return 0;\\n        }\\n        return 1;\\n    }\\n};\\nvector<vector<string>> ans;\\nvoid bfs(string& a, string& b, map<string, vector<string>>& parent, Trie& s){\\n    map<string, int> dis;\\n    dis[a] = 1;\\n    deque<string> que = {a};\\n    parent[a] = {a};\\n    int l = a.size();\\n    while(!que.empty()){\\n        string v = que[0];\\n        int d = dis[v];\\n        string e = que[0];\\n        que.pop_front();\\n        for(int i = 0; i < l; i++){\\n            char cur = v[i];\\n            for(int j = 0; j < 26; j++){\\n                v[i] = j + \\'a\\';\\n                if (v[i] == cur) continue;\\n                if (s.isPresent(v)){\\n                    if (dis.count(v) == 0 || dis[v] > d + 1){\\n                        dis[v] = d + 1;\\n                        parent[v].emplace_back(e);\\n                        que.emplace_back(v);\\n                    }\\n                    else if (dis[v] == d + 1){\\n                        parent[v].emplace_back(e);\\n                    }\\n                }\\n            }\\n            v[i] = cur;\\n        }\\n    }\\n}\\n\\nvoid getanswer(string& a, map<string, vector<string>>& parent, deque<string>& store){\\n    if (parent[a][0] == a){\\n        vector<string> v(store.begin(), store.end());\\n        ans.emplace_back(v);\\n        return;\\n    }\\n    for(auto& i : parent[a]){\\n        store.emplace_front(i);\\n        getanswer(i, parent, store);\\n        store.pop_front();\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string start, string end, vector<string>& dict) {\\n        ans = {};\\n        Trie s;\\n        for(auto& i : dict){\\n            s.insert(i);\\n        }\\n        map<string, vector<string>> parent;\\n        bfs(start, end, parent, s);\\n        if (parent.count(end) == 0){\\n            return {};\\n        }\\n        deque<string> store = {end};\\n        getanswer(end, parent, store);\\n        return ans;\\n    }\\n};\\n```\\n\\nAlternate Solution using DFS + Dictionary :\\n\\n```\\nclass Solution {\\npublic:\\n    /*\\n        min path of a graph: each vertex is a word in the dictionary list\\n        \\n        How to backtrack path in Dijkstra or BFS?\\n        \\n        from end, for all adjacent nodes to end, if dist[adj] + 1 = dist[end], adj is a node in the min path.\\n        \\n        end. --- a   dist[a] + 1 ==? dist[end]\\n             |-- b\\n             |-- c\\n        \\n        BFS solution, use dist[i] record the min path of each word from src\\n    */\\n    unordered_set<string> dict;\\n    unordered_map<string, int> dist;\\n    string src, dst;\\n    \\n    vector<vector<string>> res;\\n    vector<string> path;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        src = beginWord, dst = endWord;\\n        for (auto& word : wordList) dict.insert(word);\\n        queue<string> que;\\n        dist[src] = 0;\\n        que.push(src);\\n        while (!que.empty()) {\\n            auto t = que.front();\\n            que.pop();\\n            if (t == dst) break;\\n            string bk = t;\\n            for (int i = 0; i < t.size(); i++) {\\n                t = bk;  \\n                // enumerate all possible adjacent words\\n                for (int j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    t[i] = j;\\n                    // if in dictionary and dist has not been updated\\n                    if (dict.count(t) && dist.count(t) == 0) {\\n                        dist[t] = dist[bk] + 1;\\n                        que.push(t);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // backtrack path\\n        if (dist.count(dst)) {\\n            path.push_back(dst);\\n            dfs(dst);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    \\n    // cannot use reference here\\n    void dfs(string u) {\\n        if (u == src) {\\n            reverse(path.begin(), path.end());\\n            res.push_back(path);\\n            reverse(path.begin(), path.end());\\n            return;\\n        }\\n        \\n        string bk = u;\\n        for (int i = 0; i < u.size(); i++) {\\n            u = bk;\\n            for (int j = \\'a\\'; j <= \\'z\\'; j++) {\\n                u[i] = j;\\n                if (dist.count(u) && dist[u] + 1 == dist[bk]) {\\n                    path.push_back(u);\\n                    dfs(u);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        auto answer = std::vector<std::vector<std::string>>();\\n        auto from = beginWord;\\n        auto to = endWord;\\n\\n        auto my_lexicon = std::unordered_set<std::string>(wordList.begin(),wordList.end());\\n        if ((my_lexicon.find(to) == my_lexicon.end())) {\\n\\t        return answer;\\n\\t    }\\n        //auto const total_lexicon = my_lexicon;\\n\\n        auto current_level_forward = std::unordered_set<std::string>({from});\\n        auto current_level_backward = std::unordered_set<std::string>({to});\\n        auto ladders = std::unordered_map<std::string, std::vector<std::string>>();\\n\\n        auto found = false;\\n        auto flip = false;\\n\\n        my_lexicon.erase(from);\\n        my_lexicon.erase(to);\\n\\n        while (!current_level_forward.empty() and !current_level_backward.empty()) {\\n\\n            if (current_level_forward.size() > current_level_backward.size()) {\\n                flip = !flip;\\n                std::swap(current_level_forward, current_level_backward);\\n            }\\n\\n            auto next_level = std::unordered_set<std::string>();\\n\\n            for (auto word: current_level_forward) {\\n                //auto neighbours = find_neighbours(word, total_lexicon);\\n                for (std::string::size_type i = 0; i < word.size(); i++) {\\n                    auto neighbour = word;\\n                    for (auto j = \\'a\\'; j <= \\'z\\'; j++) {\\n                        if (neighbour[i] == j) continue;\\n                        neighbour[i] = j;\\n\\n                        if (current_level_backward.find(neighbour) != current_level_backward.end()) {\\n                            found = true;\\n                            flip ? ladders[neighbour].emplace_back(word) : ladders[word].emplace_back(neighbour);\\n                        }\\n                        if (my_lexicon.find(neighbour) != my_lexicon.end()) {\\n                            next_level.insert(neighbour);\\n                            flip ? ladders[neighbour].emplace_back(word) : ladders[word].emplace_back(neighbour);\\n                        }\\n                    }\\n                }\\n            }\\n            if (found) break;\\n            for (auto seen: next_level) my_lexicon.erase(seen);\\n            current_level_forward = next_level;\\n        }\\n\\n        if (found) {\\n            auto current_path = std::vector<std::string>({from});\\n            generate_paths(from, to, ladders, answer);\\n        }\\n        return answer;\\n        \\n}\\nprivate:\\n    auto generate_paths(std::string from, std::string const& to, std::unordered_map<std::string, std::vector<std::string>>& ladders,\\n                          std::vector<std::vector<std::string>>& answer)\\n       -> void { \\n        \\n        auto paths_to_search = std::vector<std::vector<std::string>>();\\n        paths_to_search.push_back(std::vector<std::string>({from}));\\n        \\n        while(!paths_to_search.empty()) {\\n            auto current_path = paths_to_search.back();\\n            paths_to_search.pop_back();\\n            \\n            auto current_word = current_path.back();\\n            \\n            if (current_word == to) {\\n                answer.push_back(current_path);\\n                continue;\\n            }\\n            \\n            if (ladders.find(current_word) == ladders.end()) {\\n                continue;\\n            }\\n            \\n            for (const auto& word: ladders.at(current_word)) {\\n                auto path = current_path;\\n                path.push_back(word);\\n                paths_to_search.push_back(path);\\n            }  \\n        }\\n    }\\n};\\n```\n```\\nclass node{\\n    public:\\n    char data;\\n    map<char, node*> h; // if a in h then it has its address\\n    node(char d){\\n        data = d;\\n    }\\n};\\n\\nclass Trie{\\n    node* root;\\n    public:\\n    Trie(){\\n        root = new node(\\'\\\\0\\');  // initial root which will contain map of first charachter\\n    }\\n\\n    void insert(string& word){\\n        node* temp = root;\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(temp->h.count(ch) == 0){ // if this character not present in previous charachter map\\n                node* child = new node(ch);\\n                temp->h[ch] = child;\\n            }\\n            temp = temp->h[ch];\\n        }\\n    }\\n\\n    bool isPresent(string& word){\\n        node* temp = root;\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(temp->h.count(ch)) temp = temp->h[ch];\\n            else return 0;\\n        }\\n        return 1;\\n    }\\n};\\nvector<vector<string>> ans;\\nvoid bfs(string& a, string& b, map<string, vector<string>>& parent, Trie& s){\\n    map<string, int> dis;\\n    dis[a] = 1;\\n    deque<string> que = {a};\\n    parent[a] = {a};\\n    int l = a.size();\\n    while(!que.empty()){\\n        string v = que[0];\\n        int d = dis[v];\\n        string e = que[0];\\n        que.pop_front();\\n        for(int i = 0; i < l; i++){\\n            char cur = v[i];\\n            for(int j = 0; j < 26; j++){\\n                v[i] = j + \\'a\\';\\n                if (v[i] == cur) continue;\\n                if (s.isPresent(v)){\\n                    if (dis.count(v) == 0 || dis[v] > d + 1){\\n                        dis[v] = d + 1;\\n                        parent[v].emplace_back(e);\\n                        que.emplace_back(v);\\n                    }\\n                    else if (dis[v] == d + 1){\\n                        parent[v].emplace_back(e);\\n                    }\\n                }\\n            }\\n            v[i] = cur;\\n        }\\n    }\\n}\\n\\nvoid getanswer(string& a, map<string, vector<string>>& parent, deque<string>& store){\\n    if (parent[a][0] == a){\\n        vector<string> v(store.begin(), store.end());\\n        ans.emplace_back(v);\\n        return;\\n    }\\n    for(auto& i : parent[a]){\\n        store.emplace_front(i);\\n        getanswer(i, parent, store);\\n        store.pop_front();\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string start, string end, vector<string>& dict) {\\n        ans = {};\\n        Trie s;\\n        for(auto& i : dict){\\n            s.insert(i);\\n        }\\n        map<string, vector<string>> parent;\\n        bfs(start, end, parent, s);\\n        if (parent.count(end) == 0){\\n            return {};\\n        }\\n        deque<string> store = {end};\\n        getanswer(end, parent, store);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    /*\\n        min path of a graph: each vertex is a word in the dictionary list\\n        \\n        How to backtrack path in Dijkstra or BFS?\\n        \\n        from end, for all adjacent nodes to end, if dist[adj] + 1 = dist[end], adj is a node in the min path.\\n        \\n        end. --- a   dist[a] + 1 ==? dist[end]\\n             |-- b\\n             |-- c\\n        \\n        BFS solution, use dist[i] record the min path of each word from src\\n    */\\n    unordered_set<string> dict;\\n    unordered_map<string, int> dist;\\n    string src, dst;\\n    \\n    vector<vector<string>> res;\\n    vector<string> path;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        src = beginWord, dst = endWord;\\n        for (auto& word : wordList) dict.insert(word);\\n        queue<string> que;\\n        dist[src] = 0;\\n        que.push(src);\\n        while (!que.empty()) {\\n            auto t = que.front();\\n            que.pop();\\n            if (t == dst) break;\\n            string bk = t;\\n            for (int i = 0; i < t.size(); i++) {\\n                t = bk;  \\n                // enumerate all possible adjacent words\\n                for (int j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    t[i] = j;\\n                    // if in dictionary and dist has not been updated\\n                    if (dict.count(t) && dist.count(t) == 0) {\\n                        dist[t] = dist[bk] + 1;\\n                        que.push(t);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // backtrack path\\n        if (dist.count(dst)) {\\n            path.push_back(dst);\\n            dfs(dst);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    \\n    // cannot use reference here\\n    void dfs(string u) {\\n        if (u == src) {\\n            reverse(path.begin(), path.end());\\n            res.push_back(path);\\n            reverse(path.begin(), path.end());\\n            return;\\n        }\\n        \\n        string bk = u;\\n        for (int i = 0; i < u.size(); i++) {\\n            u = bk;\\n            for (int j = \\'a\\'; j <= \\'z\\'; j++) {\\n                u[i] = j;\\n                if (dist.count(u) && dist[u] + 1 == dist[bk]) {\\n                    path.push_back(u);\\n                    dfs(u);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379912,
                "title": "python-fast-optimized-bfs-adjacency-list-parent-list-easy-to-understand-with-comments",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        #generate adjacent list\\n        Nei = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                pattern = word[:i]+\\'*\\'+word[i+1:]\\n                Nei[pattern].append(word)     \\n        \\n        #breadth first search + generate parent dictionary with path length limit\\n        seen = {beginWord:0}\\n        q = deque([(beginWord,0)])\\n        minDist = float(\"inf\")\\n        Parent = defaultdict(set)\\n        while q:        \\n            for _ in range(len(q)):\\n                pre,dis = q.popleft()\\n                for i in range(len(pre)):\\n                    pattern = pre[:i] + \"*\" + pre[i+1:]\\n                    for neighbor in Nei[pattern]:\\n                        if neighbor not in seen or (seen[neighbor] == dis + 1 and seen[neighbor] <= minDist):\\n                            if neighbor == endWord: \\n                                minDist = dis + 1\\n                            Parent[neighbor].add(pre)\\n                            if neighbor not in seen:   \\n                                q.append((neighbor,dis+1))\\n                                seen[neighbor] = dis + 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        #generate path from parent dictionary\\n        def makeList(cur,Path):\\n            if cur == beginWord:\\n                res.append(Path)\\n            else:\\n                for parent in Parent[cur]:\\n                    makeList(parent,[parent] + Path)\\n        res = []\\n        makeList(endWord,[endWord])\\n        \\n        #return results\\n        return res\\n                \\n                                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        #generate adjacent list\\n        Nei = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                pattern = word[:i]+\\'*\\'+word[i+1:]\\n                Nei[pattern].append(word)     \\n        \\n        #breadth first search + generate parent dictionary with path length limit\\n        seen = {beginWord:0}",
                "codeTag": "Java"
            },
            {
                "id": 1078863,
                "title": "my-javascript-solution",
                "content": "This is a solution using both BFS and DFS.\\n* step1: BFS is used to calcuted the shortest length from beginWord to endWord. (function findShortestLen)\\n* step2: In the meantime of step1, twp maps are built, that is Map wordToShortest(key: word, value: the shortest distance from this word to endWord) and Map wordToNeighbors(key: word, value: all its neighbors in wordList). \\n  * Note: To make wordToShortest in which the value is the distance to endWord, we should start BFS from endWord. Map wordToShortest is useful in step3.\\n* step3: DFS is used to find all ladders from beginWord to endWord. A trick to reduce the executing time is to start DFS from beginWord(different from BFS) and **only add word that is one step nearer to the endWord** than the last word just added to current ladder.(The two maps we build in step2 are used here.) \\n  * In this way, we do not need to add all beginWord\\'s neighbors, and then all neighbors of neighbors, etc. So we can reduce the times of recursion at a large scale.\\n```javascript\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\n\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return []\\n    if (beginWord === endWord) return [[beginWord]]\\n    wordList.push(beginWord)\\n    const wordToNeighbors = new Map()\\n    const wordToShortest = new Map()\\n    const shortestLen = findShortestLen(beginWord, endWord)\\n    const ladders = []\\n    const curLadder = [beginWord]\\n    recursion(beginWord, shortestLen)\\n    return ladders\\n\\n    \\n    function recursion(curWord, curShortest) {\\n        if (curShortest === 0) {\\n            ladders.push([...curLadder])\\n            return\\n        }\\n        const neighbors = findAllNeighbors(curWord)\\n        for (let neighbor of neighbors) {\\n            if (!wordToShortest.has(neighbor) || wordToShortest.get(neighbor) != curShortest - 1) continue\\n            curLadder.push(neighbor)\\n            recursion(neighbor, curShortest - 1)\\n            curLadder.pop()\\n        }\\n    }\\n    \\n    \\n    function findShortestLen(beginWord, endWord) {\\n        const queue = []\\n        queue.push(endWord)\\n        let count = 0\\n        wordToShortest.set(endWord, count)\\n        while (queue.length !== 0) {\\n            count++;\\n            const size = queue.length\\n            for (let i = 0; i < size; i++) {\\n                const curLast = queue.shift()\\n                const neighbors = findAllNeighbors(curLast)\\n                for (let neighbor of neighbors) {\\n                    if (wordToShortest.has(neighbor)) continue\\n                    wordToShortest.set(neighbor, count)\\n                    if (neighbor === beginWord)  {\\n                        return count\\n                    }\\n                    queue.push(neighbor)\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n    \\n    function findAllNeighbors(word) {\\n        if (wordToNeighbors.has(word)) return wordToNeighbors.get(word)\\n        neighbors = []\\n        for (let w of wordList) {\\n            if (isNeighbor(word, w)) {\\n                neighbors.push(w)\\n            }\\n        }\\n        wordToNeighbors.set(word, neighbors)\\n        return neighbors\\n    }\\n    \\n    function isNeighbor(w1, w2) {\\n        if (w1.length !== w2.length) return false\\n        let diff = 0\\n        for (let i = 0; i < w1.length; i++) {\\n            if (w1.charAt(i) !== w2.charAt(i)) {\\n                diff++\\n                if (diff > 1) return false\\n            }\\n        }\\n        return diff === 1\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\n\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return []\\n    if (beginWord === endWord) return [[beginWord]]\\n    wordList.push(beginWord)\\n    const wordToNeighbors = new Map()\\n    const wordToShortest = new Map()\\n    const shortestLen = findShortestLen(beginWord, endWord)\\n    const ladders = []\\n    const curLadder = [beginWord]\\n    recursion(beginWord, shortestLen)\\n    return ladders\\n\\n    \\n    function recursion(curWord, curShortest) {\\n        if (curShortest === 0) {\\n            ladders.push([...curLadder])\\n            return\\n        }\\n        const neighbors = findAllNeighbors(curWord)\\n        for (let neighbor of neighbors) {\\n            if (!wordToShortest.has(neighbor) || wordToShortest.get(neighbor) != curShortest - 1) continue\\n            curLadder.push(neighbor)\\n            recursion(neighbor, curShortest - 1)\\n            curLadder.pop()\\n        }\\n    }\\n    \\n    \\n    function findShortestLen(beginWord, endWord) {\\n        const queue = []\\n        queue.push(endWord)\\n        let count = 0\\n        wordToShortest.set(endWord, count)\\n        while (queue.length !== 0) {\\n            count++;\\n            const size = queue.length\\n            for (let i = 0; i < size; i++) {\\n                const curLast = queue.shift()\\n                const neighbors = findAllNeighbors(curLast)\\n                for (let neighbor of neighbors) {\\n                    if (wordToShortest.has(neighbor)) continue\\n                    wordToShortest.set(neighbor, count)\\n                    if (neighbor === beginWord)  {\\n                        return count\\n                    }\\n                    queue.push(neighbor)\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n    \\n    function findAllNeighbors(word) {\\n        if (wordToNeighbors.has(word)) return wordToNeighbors.get(word)\\n        neighbors = []\\n        for (let w of wordList) {\\n            if (isNeighbor(word, w)) {\\n                neighbors.push(w)\\n            }\\n        }\\n        wordToNeighbors.set(word, neighbors)\\n        return neighbors\\n    }\\n    \\n    function isNeighbor(w1, w2) {\\n        if (w1.length !== w2.length) return false\\n        let diff = 0\\n        for (let i = 0; i < w1.length; i++) {\\n            if (w1.charAt(i) !== w2.charAt(i)) {\\n                diff++\\n                if (diff > 1) return false\\n            }\\n        }\\n        return diff === 1\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652432,
                "title": "java-bfs-one-pass",
                "content": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<>();\\n\\n        if (!wordList.contains(endWord)) return res;\\n        \\n        // build graph\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (!wordList.contains(beginWord) && canTransform(wordList.get(i), beginWord)) {\\n                buildGraph(map, wordList.get(i), beginWord);\\n                buildGraph(map, beginWord, wordList.get(i));\\n            }\\n\\n            for (int j = i + 1; j < wordList.size(); j++) {\\n                if (canTransform(wordList.get(i), wordList.get(j))) {\\n                    buildGraph(map, wordList.get(i), wordList.get(j));\\n                    buildGraph(map, wordList.get(j), wordList.get(i));\\n                }\\n            }\\n        }\\n        \\n        // BFS from beginWord to endWord\\n        Queue<List<String>> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>(); // avoid circle in graph, first pick first reached word\\n        queue.offer(Arrays.asList(new String[]{beginWord})); // start from beginWord\\n\\n        boolean found = false;\\n        while (!queue.isEmpty() && !found) { // still have word to search\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                List<String> curList = queue.poll();\\n                String curWord = curList.get(curList.size() - 1); // last visited word in the result list\\n                visited.add(curWord);\\n                \\n                if (curWord.equals(endWord)) {// shortest path found\\n                    res.add(curList);\\n                    found = true; // stop at this level\\n                    continue;\\n                }\\n                \\n                if(!map.containsKey(curWord)) continue;\\n                \\n                for (String child : map.get(curWord)) {\\n                    if (visited.contains(child)) continue;\\n                    List<String> nextList = new ArrayList<>(curList);\\n                    nextList.add(child);\\n                    queue.offer(nextList);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private boolean canTransform(String word1, String word2) {\\n        if (word1.length() != word2.length()) return false;\\n\\n        int diff = 0;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (word1.charAt(i) != word2.charAt(i)) diff++;\\n            if (diff > 1) return false;\\n        }\\n        \\n        return diff == 1;\\n    }\\n    \\n    private void buildGraph(Map<String, List<String>> map, String word1, String word2) {\\n        List<String> list = map.getOrDefault(word1, new ArrayList<>());\\n        list.add(word2);\\n        map.put(word1, list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<>();\\n\\n        if (!wordList.contains(endWord)) return res;\\n        \\n        // build graph\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (!wordList.contains(beginWord) && canTransform(wordList.get(i), beginWord)) {\\n                buildGraph(map, wordList.get(i), beginWord);\\n                buildGraph(map, beginWord, wordList.get(i));\\n            }\\n\\n            for (int j = i + 1; j < wordList.size(); j++) {\\n                if (canTransform(wordList.get(i), wordList.get(j))) {\\n                    buildGraph(map, wordList.get(i), wordList.get(j));\\n                    buildGraph(map, wordList.get(j), wordList.get(i));\\n                }\\n            }\\n        }\\n        \\n        // BFS from beginWord to endWord\\n        Queue<List<String>> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>(); // avoid circle in graph, first pick first reached word\\n        queue.offer(Arrays.asList(new String[]{beginWord})); // start from beginWord\\n\\n        boolean found = false;\\n        while (!queue.isEmpty() && !found) { // still have word to search\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                List<String> curList = queue.poll();\\n                String curWord = curList.get(curList.size() - 1); // last visited word in the result list\\n                visited.add(curWord);\\n                \\n                if (curWord.equals(endWord)) {// shortest path found\\n                    res.add(curList);\\n                    found = true; // stop at this level\\n                    continue;\\n                }\\n                \\n                if(!map.containsKey(curWord)) continue;\\n                \\n                for (String child : map.get(curWord)) {\\n                    if (visited.contains(child)) continue;\\n                    List<String> nextList = new ArrayList<>(curList);\\n                    nextList.add(child);\\n                    queue.offer(nextList);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private boolean canTransform(String word1, String word2) {\\n        if (word1.length() != word2.length()) return false;\\n\\n        int diff = 0;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (word1.charAt(i) != word2.charAt(i)) diff++;\\n            if (diff > 1) return false;\\n        }\\n        \\n        return diff == 1;\\n    }\\n    \\n    private void buildGraph(Map<String, List<String>> map, String word1, String word2) {\\n        List<String> list = map.getOrDefault(word1, new ArrayList<>());\\n        list.add(word2);\\n        map.put(word1, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254249,
                "title": "python-bfs",
                "content": "If you don\\'t know the trick to search for the next word, check out the solution for [Word Ladder I](https://leetcode.com/problems/word-ladder/solution/).\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = defaultdict(set)\\n        for word in wordList + [beginWord]:\\n            for i in range(len(word)):\\n                graph[word[:i] + \\'_\\' + word[i + 1:]].add(word)\\n        wordList = set(wordList)\\n        \\n        queue = [[beginWord]]\\n        flag = False\\n        while queue:\\n            new_queue = []\\n            to_remove = set()\\n            for path in queue:\\n                for i in range(len(path[-1])):\\n                    for new_word in graph[path[-1][:i] + \\'_\\' + path[-1][i + 1:]] & wordList:\\n                        new_queue.append(path + [new_word])\\n                        to_remove.add(new_word)\\n                        if new_word == endWord: flag = True\\n            if flag: return [p for p in new_queue if p[-1] == endWord]\\n            queue = new_queue[:]\\n            wordList -= to_remove\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = defaultdict(set)\\n        for word in wordList + [beginWord]:\\n            for i in range(len(word)):\\n                graph[word[:i] + \\'_\\' + word[i + 1:]].add(word)\\n        wordList = set(wordList)\\n        \\n        queue = [[beginWord]]\\n        flag = False\\n        while queue:\\n            new_queue = []\\n            to_remove = set()\\n            for path in queue:\\n                for i in range(len(path[-1])):\\n                    for new_word in graph[path[-1][:i] + \\'_\\' + path[-1][i + 1:]] & wordList:\\n                        new_queue.append(path + [new_word])\\n                        to_remove.add(new_word)\\n                        if new_word == endWord: flag = True\\n            if flag: return [p for p in new_queue if p[-1] == endWord]\\n            queue = new_queue[:]\\n            wordList -= to_remove\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40645,
                "title": "java-code-based-on-dijkstra-s-algorithm-accepted",
                "content": "The difference from the Word Ladder solution is that now we need to remember all possible previous nodes in the path to the node when solution is optimal. And after that construct all possible path variants.\\n\\n    static private class WordVertex implements Comparable<WordVertex>{\\n\\t\\t\\n\\t\\tprivate String word;\\n\\t\\tprivate int dist;\\n\\t\\tprivate List<WordVertex> prev;\\n\\t\\tprivate HashSet<WordVertex> neighbors;\\n\\t\\t\\n\\t\\tprivate WordVertex(String w) {\\n\\t\\t\\tword = w;\\n\\t\\t\\tdist = Integer.MAX_VALUE;\\n\\t\\t\\tneighbors = new HashSet<WordVertex>();\\n\\t\\t\\tprev = new LinkedList<WordVertex>();\\n\\t\\t}\\n\\t\\t\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(WordVertex o) {\\n\\t\\t\\tif (dist < o.dist) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t} else if (dist > o.dist) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n\\t\\t\\n\\t\\t// Init vertices\\n\\t\\tWordVertex startVertex = new WordVertex(start);\\n\\t\\tWordVertex endVertex = new WordVertex(end);\\n\\t\\tstartVertex.dist = 0;\\n\\t\\tList<WordVertex> vertices = new ArrayList<WordVertex>();\\n\\t\\tvertices.add(startVertex);\\n\\t\\tvertices.add(endVertex);\\n\\t\\tfor (String word:dict) {\\n\\t\\t\\tvertices.add(new WordVertex(word));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Construct graph\\n\\t\\tfor(int i=0; i<vertices.size(); i++) {\\n\\t\\t\\tWordVertex vertex = vertices.get(i);\\n\\t\\t\\tfor(int j=i+1; j<vertices.size(); j++) {\\n\\t\\t\\t\\tWordVertex neighbor = vertices.get(j);\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tfor (int k=0; k<vertex.word.length(); k++) {\\n\\t\\t\\t\\t\\tif (vertex.word.charAt(k) != neighbor.word.charAt(k) && diff++ == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (diff == 1) {\\n\\t\\t\\t\\t\\tvertex.neighbors.add(neighbor);\\n\\t\\t\\t\\t\\tneighbor.neighbors.add(vertex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Find shortest path. Dijkstra's algorithm.\\n\\t\\tPriorityQueue<WordVertex> queue = new PriorityQueue<WordVertex>();\\n\\t\\tfor (WordVertex v:vertices) {\\n\\t\\t\\tqueue.add(v);\\n\\t\\t}\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tWordVertex v = queue.poll();\\n\\t\\t\\tif (v.dist == Integer.MAX_VALUE) continue;\\n\\t\\t\\tfor (WordVertex n:v.neighbors) {\\n\\t\\t\\t\\tif (v.dist + 1 <= n.dist) {\\n\\t\\t\\t\\t\\tn.dist = v.dist + 1;\\n\\t\\t\\t\\t\\tn.prev.add(v);   // as one of the previous candidates\\n\\t\\t\\t\\t\\tqueue.remove(n);\\n\\t\\t\\t\\t\\tqueue.add(n);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Make result\\n\\t\\tList<List<String>> seqs = new LinkedList<List<String>>();\\n\\t\\tLinkedList<String> seq = new LinkedList<String>();\\n\\t\\tconstructSequences(endVertex, startVertex, seq, seqs);\\n\\t\\t\\n\\t\\treturn seqs;\\n    }\\n\\t\\n\\tvoid constructSequences(WordVertex v, WordVertex start, LinkedList<String> seq, List<List<String>> seqs) {\\n\\t\\tseq.addFirst(v.word);\\n\\t\\tif (v == start) {\\n\\t\\t\\tseqs.add(new LinkedList<String>(seq));\\n\\t\\t}\\n\\t\\tfor(WordVertex p:v.prev) {\\n\\t\\t\\tconstructSequences(p, start, seq, seqs);\\n\\t\\t}\\n\\t\\tseq.removeFirst();\\n\\t}",
                "solutionTags": [],
                "code": "The difference from the Word Ladder solution is that now we need to remember all possible previous nodes in the path to the node when solution is optimal. And after that construct all possible path variants.\\n\\n    static private class WordVertex implements Comparable<WordVertex>{\\n\\t\\t\\n\\t\\tprivate String word;\\n\\t\\tprivate int dist;\\n\\t\\tprivate List<WordVertex> prev;\\n\\t\\tprivate HashSet<WordVertex> neighbors;\\n\\t\\t\\n\\t\\tprivate WordVertex(String w) {\\n\\t\\t\\tword = w;\\n\\t\\t\\tdist = Integer.MAX_VALUE;\\n\\t\\t\\tneighbors = new HashSet<WordVertex>();\\n\\t\\t\\tprev = new LinkedList<WordVertex>();\\n\\t\\t}\\n\\t\\t\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(WordVertex o) {\\n\\t\\t\\tif (dist < o.dist) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t} else if (dist > o.dist) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n\\t\\t\\n\\t\\t// Init vertices\\n\\t\\tWordVertex startVertex = new WordVertex(start);\\n\\t\\tWordVertex endVertex = new WordVertex(end);\\n\\t\\tstartVertex.dist = 0;\\n\\t\\tList<WordVertex> vertices = new ArrayList<WordVertex>();\\n\\t\\tvertices.add(startVertex);\\n\\t\\tvertices.add(endVertex);\\n\\t\\tfor (String word:dict) {\\n\\t\\t\\tvertices.add(new WordVertex(word));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Construct graph\\n\\t\\tfor(int i=0; i<vertices.size(); i++) {\\n\\t\\t\\tWordVertex vertex = vertices.get(i);\\n\\t\\t\\tfor(int j=i+1; j<vertices.size(); j++) {\\n\\t\\t\\t\\tWordVertex neighbor = vertices.get(j);\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tfor (int k=0; k<vertex.word.length(); k++) {\\n\\t\\t\\t\\t\\tif (vertex.word.charAt(k) != neighbor.word.charAt(k) && diff++ == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (diff == 1) {\\n\\t\\t\\t\\t\\tvertex.neighbors.add(neighbor);\\n\\t\\t\\t\\t\\tneighbor.neighbors.add(vertex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Find shortest path. Dijkstra's algorithm.\\n\\t\\tPriorityQueue<WordVertex> queue = new PriorityQueue<WordVertex>();\\n\\t\\tfor (WordVertex v:vertices) {\\n\\t\\t\\tqueue.add(v);\\n\\t\\t}\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tWordVertex v = queue.poll();\\n\\t\\t\\tif (v.dist == Integer.MAX_VALUE) continue;\\n\\t\\t\\tfor (WordVertex n:v.neighbors) {\\n\\t\\t\\t\\tif (v.dist + 1 <= n.dist) {\\n\\t\\t\\t\\t\\tn.dist = v.dist + 1;\\n\\t\\t\\t\\t\\tn.prev.add(v);   // as one of the previous candidates\\n\\t\\t\\t\\t\\tqueue.remove(n);\\n\\t\\t\\t\\t\\tqueue.add(n);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Make result\\n\\t\\tList<List<String>> seqs = new LinkedList<List<String>>();\\n\\t\\tLinkedList<String> seq = new LinkedList<String>();\\n\\t\\tconstructSequences(endVertex, startVertex, seq, seqs);\\n\\t\\t\\n\\t\\treturn seqs;\\n    }\\n\\t\\n\\tvoid constructSequences(WordVertex v, WordVertex start, LinkedList<String> seq, List<List<String>> seqs) {\\n\\t\\tseq.addFirst(v.word);\\n\\t\\tif (v == start) {\\n\\t\\t\\tseqs.add(new LinkedList<String>(seq));\\n\\t\\t}\\n\\t\\tfor(WordVertex p:v.prev) {\\n\\t\\t\\tconstructSequences(p, start, seq, seqs);\\n\\t\\t}\\n\\t\\tseq.removeFirst();\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2423621,
                "title": "25-ms-use-less-memory-than-97-bfs-dfs-golang",
                "content": "- Let consider each string in ```wordList``` as a vertex on a graph, and if two strings differ by at most one character, we will connect an edge with weight ```1``` between them. The problem become: \"Find the shortest path, single source, single destination, on a graph where each edge\\'s weight is equal to 1\".\\n\\n- The aforementioned problem is a basic BFS implementation, where the source vertex is ```beginWord```, and the destination is ```endWord```. Since I\\'m a new user in Golang, I\\'m not sure if storing each state in a hashmap the correct way to do this(?) Please let me know in the comment for a better way.\\n\\n- After having calculated the distance between each vertex to the source, we can simply use a recursive function to find all the solutions. \\n\\n- **Note:** I\\'m not sure if the number of solutions are too large are not. If it\\'s too big, there\\'s no way we can find all the solutions using recursive function, as it would take forever.\\n\\n***Implementation:***\\n```\\nfunc difChar(a, b string) int { // Function to calculate the number of different chars between 2 strings\\n    ans := 0\\n    for id, _ := range a {\\n        if a[id] != b[id] {\\n            ans++\\n        }\\n    }    \\n    return ans\\n}\\n\\nfunc findLadders(beginWord string, endWord string, wordList []string) [][]string {\\n    mp := map[string]int{beginWord:0} // Hashmap to store the distance to the source, also set mp[beginWord] = 0\\n    q := make([]string, 0) // Queue to BFS\\n    q = append(q, beginWord) // Insert the source to the queue\\n    for len(q) > 0 { // While the queue is not empty\\n        curWord := q[0] // Get the front of the queue\\n        q = q[1:] // Remove the front of the queue\\n        for _, nxtWord := range wordList { // Iterate all next states\\n            if _, have := mp[nxtWord]; !have && difChar(curWord, nxtWord) == 1 { // If the next state has not been visited yet\\n                q = append(q, nxtWord) // We push it to the queue\\n                mp[nxtWord] = mp[curWord] + 1 // And update the distance\\n            }\\n        }\\n    }\\n    \\n    ans := [][]string{} // Initialize the answer\\n    if _, have := mp[endWord]; !have { // If we can\\'t reach the end vertex\\n        return ans // Return empty\\n    }\\n\\n    var dfs func(curWord string, cur []string) \\n    dfs = func(curWord string, cur []string) { // Anonymous function for inserting into answer easier\\n        cur = append(cur, curWord) // Insert the current string \\n        if (mp[curWord] == 1) { // If we has reach the end state\\n            cur = append(cur, beginWord) // Insert beginWord, since we stop at distance = 1\\n            tmp := cur // Remember to reverse the current string list\\n            for i, j := 0, len(tmp)-1; i < j; i, j = i + 1, j - 1 {\\n                tmp[i], tmp[j] = tmp[j], tmp[i]\\n            }\\n            ans = append(ans, tmp) // Add it to answer\\n            cur = cur[:len(cur)-2] // And remove the new two just-added strings\\n            return;\\n        }           \\n        for _, nxtWord := range wordList {\\n            if _, have := mp[nxtWord]; have && difChar(curWord, nxtWord) == 1 && mp[curWord] == mp[nxtWord] + 1 {\\n                dfs(nxtWord, cur)\\n            }\\n        }        \\n        cur = cur[:len(cur)-1] // Remove the last string\\n    }\\n    dfs(endWord, []string{}) // Begin recursion\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```wordList```\n```1```\n```beginWord```\n```endWord```\n```\\nfunc difChar(a, b string) int { // Function to calculate the number of different chars between 2 strings\\n    ans := 0\\n    for id, _ := range a {\\n        if a[id] != b[id] {\\n            ans++\\n        }\\n    }    \\n    return ans\\n}\\n\\nfunc findLadders(beginWord string, endWord string, wordList []string) [][]string {\\n    mp := map[string]int{beginWord:0} // Hashmap to store the distance to the source, also set mp[beginWord] = 0\\n    q := make([]string, 0) // Queue to BFS\\n    q = append(q, beginWord) // Insert the source to the queue\\n    for len(q) > 0 { // While the queue is not empty\\n        curWord := q[0] // Get the front of the queue\\n        q = q[1:] // Remove the front of the queue\\n        for _, nxtWord := range wordList { // Iterate all next states\\n            if _, have := mp[nxtWord]; !have && difChar(curWord, nxtWord) == 1 { // If the next state has not been visited yet\\n                q = append(q, nxtWord) // We push it to the queue\\n                mp[nxtWord] = mp[curWord] + 1 // And update the distance\\n            }\\n        }\\n    }\\n    \\n    ans := [][]string{} // Initialize the answer\\n    if _, have := mp[endWord]; !have { // If we can\\'t reach the end vertex\\n        return ans // Return empty\\n    }\\n\\n    var dfs func(curWord string, cur []string) \\n    dfs = func(curWord string, cur []string) { // Anonymous function for inserting into answer easier\\n        cur = append(cur, curWord) // Insert the current string \\n        if (mp[curWord] == 1) { // If we has reach the end state\\n            cur = append(cur, beginWord) // Insert beginWord, since we stop at distance = 1\\n            tmp := cur // Remember to reverse the current string list\\n            for i, j := 0, len(tmp)-1; i < j; i, j = i + 1, j - 1 {\\n                tmp[i], tmp[j] = tmp[j], tmp[i]\\n            }\\n            ans = append(ans, tmp) // Add it to answer\\n            cur = cur[:len(cur)-2] // And remove the new two just-added strings\\n            return;\\n        }           \\n        for _, nxtWord := range wordList {\\n            if _, have := mp[nxtWord]; have && difChar(curWord, nxtWord) == 1 && mp[curWord] == mp[nxtWord] + 1 {\\n                dfs(nxtWord, cur)\\n            }\\n        }        \\n        cur = cur[:len(cur)-1] // Remove the last string\\n    }\\n    dfs(endWord, []string{}) // Begin recursion\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423034,
                "title": "accepted-java-solution-24ms",
                "content": "# Accepted Java  Solution \\n1. First we find the shortest path \\'X\\' between end word and start word \\n2. Then we apply dfs from begin word and once we reach at X \\n* If we find the end word we push the current path in ans \\n* Else we backtrack and try another path.\\n```\\nclass Solution {\\n    Set<String> set = new HashSet();\\n    String beginWord, endWord;\\n    Map<String, Integer> dist = new HashMap();\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        this.res = new ArrayList();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }\\n        short_path();\\n        if (dist.get(endWord) == null) return res;\\n        List<String> path = new ArrayList();\\n        path.add(endWord);\\n        dfs(endWord, path);\\n        return res;\\n    }\\n    \\n    private void short_path() {\\n        Queue<String> q = new LinkedList();\\n        q.offer(beginWord);\\n        dist.put(beginWord, 0);\\n        while(q.size() > 0) {\\n            String cur = q.poll();\\n            if (cur.equals(endWord) ) break;\\n            char[] charCur = cur.toCharArray();\\n            for (int i = 0; i < cur.length(); i++) {\\n                char c = charCur[i];\\n                for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    charCur[i] = j;\\n                    String s = new String(charCur);\\n                    if (set.contains(s) && dist.get(s) == null) {\\n                        dist.put(s, dist.get(cur) + 1);\\n                        q.offer(s);\\n                    }\\n                    \\n                }\\n                charCur[i] = c;\\n            }\\n        }\\n    }\\n    \\n    private void dfs(String word, List<String> path) {\\n        if (word.equals(beginWord)) {\\n            List list = new ArrayList(path);\\n            Collections.reverse(list);\\n            res.add(list);\\n            return;\\n        }\\n        char[] charCur = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = charCur[i];\\n            for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                charCur[i] = j;\\n                String s = new String(charCur);\\n                if (dist.get(s) != null && dist.get(s) + 1 == dist.get(word)) {\\n                    path.add(s);\\n                    dfs(s, path);\\n                    path.remove(path.size() - 1);\\n                }\\n                    \\n            }\\n            charCur[i] = c;\\n        }\\n    }\\n}\\n```\\n**Upvote if you like the solution**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> set = new HashSet();\\n    String beginWord, endWord;\\n    Map<String, Integer> dist = new HashMap();\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.beginWord = beginWord;\\n        this.endWord = endWord;\\n        this.res = new ArrayList();\\n        for (String word : wordList) {\\n            set.add(word);\\n        }\\n        short_path();\\n        if (dist.get(endWord) == null) return res;\\n        List<String> path = new ArrayList();\\n        path.add(endWord);\\n        dfs(endWord, path);\\n        return res;\\n    }\\n    \\n    private void short_path() {\\n        Queue<String> q = new LinkedList();\\n        q.offer(beginWord);\\n        dist.put(beginWord, 0);\\n        while(q.size() > 0) {\\n            String cur = q.poll();\\n            if (cur.equals(endWord) ) break;\\n            char[] charCur = cur.toCharArray();\\n            for (int i = 0; i < cur.length(); i++) {\\n                char c = charCur[i];\\n                for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    charCur[i] = j;\\n                    String s = new String(charCur);\\n                    if (set.contains(s) && dist.get(s) == null) {\\n                        dist.put(s, dist.get(cur) + 1);\\n                        q.offer(s);\\n                    }\\n                    \\n                }\\n                charCur[i] = c;\\n            }\\n        }\\n    }\\n    \\n    private void dfs(String word, List<String> path) {\\n        if (word.equals(beginWord)) {\\n            List list = new ArrayList(path);\\n            Collections.reverse(list);\\n            res.add(list);\\n            return;\\n        }\\n        char[] charCur = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = charCur[i];\\n            for (char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                charCur[i] = j;\\n                String s = new String(charCur);\\n                if (dist.get(s) != null && dist.get(s) + 1 == dist.get(word)) {\\n                    path.add(s);\\n                    dfs(s, path);\\n                    path.remove(path.size() - 1);\\n                }\\n                    \\n            }\\n            charCur[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422734,
                "title": "c-floyd-warshall-bfs-o-n-3-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> isc[501];\\n    long dis[501][501];\\n    int n,tar,as;\\n    bool jc(string x,string y){\\n        int v=0;\\n        for(int i=0;i<x.size();++i)\\n            if(x[i]!=y[i])++v;\\n        return v==1;\\n    }\\n    vector<vector<string>> findLadders(string bW, string eW, vector<string>& wL) {\\n        vector<vector<string>> rt;\\n        n=wL.size();\\n        memset(dis,0x3f,sizeof(dis));\\n        for(int i=0;i<n;++i){\\n            if(wL[i]==eW)tar=i+1;\\n            if(jc(wL[i],bW)){\\n                isc[0].push_back(i+1);\\n                dis[0][i+1]=dis[i+1][0]=1;\\n            }\\n            for(int j=i+1;j<n;++j)\\n                if(jc(wL[i],wL[j])){\\n                    isc[i+1].push_back(j+1);\\n                    isc[j+1].push_back(i+1);\\n                    dis[j+1][i+1]=dis[i+1][j+1]=1;\\n                }\\n        }\\n        if(tar==0)return rt;\\n        for(int k=0;k<=n;++k)\\n            for(int i=0;i<=n;++i)\\n                for(int j=0;j<=n;++j)\\n                    if(dis[i][j]>dis[i][k]+dis[k][j])\\n                        dis[i][j]=dis[i][k]+dis[k][j];\\n        as=dis[0][tar];\\n        queue <vector <int>> q;\\n        vector <int> v;\\n        v.push_back(0);\\n        q.push(v);\\n        dis[tar][tar]=0;\\n        while(!q.empty()){\\n            v=q.front();q.pop();\\n            int tp=v.back();\\n            if(tp==tar){\\n                vector <string> vs;\\n                vs.push_back(bW);\\n                for(int i=1;i<=as;++i)\\n                    vs.push_back(wL[v[i]-1]);\\n                rt.push_back(vs);\\n                continue;\\n            }\\n            for(int i=0;i<isc[tp].size();++i){\\n                if(dis[isc[tp][i]][tar]==dis[tp][tar]-1){\\n                    vector <int> tv=v;\\n                    tv.push_back(isc[tp][i]);\\n                    q.push(tv);\\n                }\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```\\n1.First find all connected words.In the concept of graph, their distance is 1.\\n2.Find the shortest distance of all pairs by using Floyd-Warshall.\\n3.If dis(\\'start\\',\\'end\\') = 20,than the next target for \\'start\\' is obviously all points x with dis(x,\\'end\\') = 19.\\n4.Remember to check if the two strings are connected.\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> isc[501];\\n    long dis[501][501];\\n    int n,tar,as;\\n    bool jc(string x,string y){\\n        int v=0;\\n        for(int i=0;i<x.size();++i)\\n            if(x[i]!=y[i])++v;\\n        return v==1;\\n    }\\n    vector<vector<string>> findLadders(string bW, string eW, vector<string>& wL) {\\n        vector<vector<string>> rt;\\n        n=wL.size();\\n        memset(dis,0x3f,sizeof(dis));\\n        for(int i=0;i<n;++i){\\n            if(wL[i]==eW)tar=i+1;\\n            if(jc(wL[i],bW)){\\n                isc[0].push_back(i+1);\\n                dis[0][i+1]=dis[i+1][0]=1;\\n            }\\n            for(int j=i+1;j<n;++j)\\n                if(jc(wL[i],wL[j])){\\n                    isc[i+1].push_back(j+1);\\n                    isc[j+1].push_back(i+1);\\n                    dis[j+1][i+1]=dis[i+1][j+1]=1;\\n                }\\n        }\\n        if(tar==0)return rt;\\n        for(int k=0;k<=n;++k)\\n            for(int i=0;i<=n;++i)\\n                for(int j=0;j<=n;++j)\\n                    if(dis[i][j]>dis[i][k]+dis[k][j])\\n                        dis[i][j]=dis[i][k]+dis[k][j];\\n        as=dis[0][tar];\\n        queue <vector <int>> q;\\n        vector <int> v;\\n        v.push_back(0);\\n        q.push(v);\\n        dis[tar][tar]=0;\\n        while(!q.empty()){\\n            v=q.front();q.pop();\\n            int tp=v.back();\\n            if(tp==tar){\\n                vector <string> vs;\\n                vs.push_back(bW);\\n                for(int i=1;i<=as;++i)\\n                    vs.push_back(wL[v[i]-1]);\\n                rt.push_back(vs);\\n                continue;\\n            }\\n            for(int i=0;i<isc[tp].size();++i){\\n                if(dis[isc[tp][i]][tar]==dis[tp][tar]-1){\\n                    vector <int> tv=v;\\n                    tv.push_back(isc[tp][i]);\\n                    q.push(tv);\\n                }\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720367,
                "title": "python-bfs-very-simple",
                "content": "![image](https://assets.leetcode.com/users/images/04724cb2-523e-4db6-a855-a78e2ca1608e_1643174123.9432545.png)\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        wordList.append(beginWord)\\n        nei = collections.defaultdict(list)\\n        \\n        #Creating adjs  list using pattern over the words\\n        for w in wordList :\\n            for k in range(len(w)) :\\n                pattern = w[:k] + \\'-\\' + w[k + 1:]\\n                nei[pattern].append(w)\\n        \\n        q = collections.deque([(beginWord, [beginWord])])\\n        vis = set([beginWord])\\n        res = []\\n        \\n        while q :\\n            auxSet = set() #this enable have control over the graph paths. The key for this problem\\n            \\n            for s in range(len(q)) :\\n                w, seq = q.popleft()\\n                if w == endWord :\\n                    res.append(seq)      \\n                    \\n                for k in range(len(w)) : #sech adjs list \\n                    pattern = w[:k] + \\'-\\' + w[k + 1:]\\n                    for adj in nei[pattern] :\\n                        if adj not in vis :                        \\n                            auxSet.add(adj)\\n                            q.append((adj, seq[:]+[adj]))\\n         \\n            vis.update(auxSet) \\n\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/04724cb2-523e-4db6-a855-a78e2ca1608e_1643174123.9432545.png)\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        wordList.append(beginWord)\\n        nei = collections.defaultdict(list)\\n        \\n        #Creating adjs  list using pattern over the words\\n        for w in wordList :\\n            for k in range(len(w)) :\\n                pattern = w[:k] + \\'-\\' + w[k + 1:]\\n                nei[pattern].append(w)\\n        \\n        q = collections.deque([(beginWord, [beginWord])])\\n        vis = set([beginWord])\\n        res = []\\n        \\n        while q :\\n            auxSet = set() #this enable have control over the graph paths. The key for this problem\\n            \\n            for s in range(len(q)) :\\n                w, seq = q.popleft()\\n                if w == endWord :\\n                    res.append(seq)      \\n                    \\n                for k in range(len(w)) : #sech adjs list \\n                    pattern = w[:k] + \\'-\\' + w[k + 1:]\\n                    for adj in nei[pattern] :\\n                        if adj not in vis :                        \\n                            auxSet.add(adj)\\n                            q.append((adj, seq[:]+[adj]))\\n         \\n            vis.update(auxSet) \\n\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1010229,
                "title": "c-bfs-dfs-58-faster-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<string>> ans; //store all ans\\n    \\n    void DFS(string& beginWord,string& endWord,unordered_map<string, unordered_set<string>>& adj,vector<string>&path){\\n        path.push_back(beginWord);\\n        if(beginWord==endWord){\\n            ans.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        for(auto x: adj[beginWord])\\n            DFS(x,endWord,adj,path);\\n        path.pop_back();   //backtracking\\n    }\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL);\\n       unordered_map<string, unordered_set<string>>adj;\\n        unordered_set<string>dict(wordList.begin(),wordList.end());\\n        \\n        queue<string> q;//for bfs traversal\\n        q.push(beginWord); //push start node\\n        unordered_map<string,int>visited; //key->string whivh is node....Value->level{depth of traversal}\\n        visited[beginWord]=0;//start node at level 0\\n        while(!q.empty())\\n        {\\n            string curr=q.front();\\n            q.pop();\\n            string temp=curr;\\n            for(int i=0;i<curr.size();i++)\\n            {\\n                for(char x=\\'a\\';x<=\\'z\\';x++)\\n                {\\n                    if(temp[i]==x)//skip if same letter\\n                        continue;\\n                    temp[i]=x;\\n                    if(dict.count(temp)>0)//check if new word is present in wordList\\n                    {\\n                        if(visited.count(temp)==0)//check if the new word  was already visited\\n                        {\\n                            visited[temp]=visited[curr]+1;\\n                            q.push(temp);\\n                            adj[curr].insert(temp);\\n                        }\\n                        else if(visited[temp]==visited[curr]+1)//if already visited and new word is child\\n                            adj[curr].insert(temp);\\n                    }\\n                }\\n                temp[i]=curr[i];  //revert back temp to curr\\n            }\\n        }\\n        // dfs: find all possible path at min depth\\n        vector<string>path;\\n        DFS(beginWord,endWord,adj,path);\\n            return ans;\\n    }\\n};\\n```\\n**upvote if u like soln**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<string>> ans; //store all ans\\n    \\n    void DFS(string& beginWord,string& endWord,unordered_map<string, unordered_set<string>>& adj,vector<string>&path){\\n        path.push_back(beginWord);\\n        if(beginWord==endWord){\\n            ans.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        for(auto x: adj[beginWord])\\n            DFS(x,endWord,adj,path);\\n        path.pop_back();   //backtracking\\n    }\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL);\\n       unordered_map<string, unordered_set<string>>adj;\\n        unordered_set<string>dict(wordList.begin(),wordList.end());\\n        \\n        queue<string> q;//for bfs traversal\\n        q.push(beginWord); //push start node\\n        unordered_map<string,int>visited; //key->string whivh is node....Value->level{depth of traversal}\\n        visited[beginWord]=0;//start node at level 0\\n        while(!q.empty())\\n        {\\n            string curr=q.front();\\n            q.pop();\\n            string temp=curr;\\n            for(int i=0;i<curr.size();i++)\\n            {\\n                for(char x=\\'a\\';x<=\\'z\\';x++)\\n                {\\n                    if(temp[i]==x)//skip if same letter\\n                        continue;\\n                    temp[i]=x;\\n                    if(dict.count(temp)>0)//check if new word is present in wordList\\n                    {\\n                        if(visited.count(temp)==0)//check if the new word  was already visited\\n                        {\\n                            visited[temp]=visited[curr]+1;\\n                            q.push(temp);\\n                            adj[curr].insert(temp);\\n                        }\\n                        else if(visited[temp]==visited[curr]+1)//if already visited and new word is child\\n                            adj[curr].insert(temp);\\n                    }\\n                }\\n                temp[i]=curr[i];  //revert back temp to curr\\n            }\\n        }\\n        // dfs: find all possible path at min depth\\n        vector<string>path;\\n        DFS(beginWord,endWord,adj,path);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768362,
                "title": "simple-python-bfs-solution-with-20-lines-of-code-and-explanation-beats-80",
                "content": "Steps:\\n1. Construct an adjecncy list from the wordList\\n2. Perform normal BFS with a queue (every element is a tuple of currentWord, the list of words from beginWord to currentWord)\\n3. Everytime you find the endWord, add the list built so far to the output list!\\n\\n**Main STEP to help aviod TLE:**\\nDo not visit the same node/word again if it was visited at an earlier timestamp, because it would lead the result to same list that will be created from the earlier visited word. (Maintain a dictionary of visited word and timestamp at which they were visited)\\n\\nCode:\\n\\n```\\nclass Solution:\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n         # construct an adjacency list with the dictionary\\n        adjList = defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                _key = word[:i] + \"*\" + word[i+1:]\\n                adjList[_key] += word,\\n        \\n        # perform bfs\\n        \\n        que = deque([(beginWord,[beginWord])]) # que has (word, [visitedListTillNow])\\n        res = []\\n        visited = {beginWord:1} #maintain a visited dictionary with visit time\\n        \\n        while len(que) > 0:\\n            word, _list = que.popleft()\\n            dist = len(_list) #distance from beginWord\\n            \\n            if word == endWord: #if found, add to result\\n                res += _list,\\n                continue\\n                \\n            for i in range(len(word)):\\n                _key = word[:i] + \"*\" + word[i+1:]\\n                for child in adjList[_key]:\\n                    # if the node is already visited in a previos timestamp, ignore it\\n                    if child not in visited or dist <= visited[child]:\\n                        que += (child,_list[:]+[child]),\\n                        visited[child] = dist\\n                        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n         # construct an adjacency list with the dictionary\\n        adjList = defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                _key = word[:i] + \"*\" + word[i+1:]\\n                adjList[_key] += word,\\n        \\n        # perform bfs\\n        \\n        que = deque([(beginWord,[beginWord])]) # que has (word, [visitedListTillNow])\\n        res = []\\n        visited = {beginWord:1} #maintain a visited dictionary with visit time\\n        \\n        while len(que) > 0:\\n            word, _list = que.popleft()\\n            dist = len(_list) #distance from beginWord\\n            \\n            if word == endWord: #if found, add to result\\n                res += _list,\\n                continue\\n                \\n            for i in range(len(word)):\\n                _key = word[:i] + \"*\" + word[i+1:]\\n                for child in adjList[_key]:\\n                    # if the node is already visited in a previos timestamp, ignore it\\n                    if child not in visited or dist <= visited[child]:\\n                        que += (child,_list[:]+[child]),\\n                        visited[child] = dist\\n                        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582583,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList)\\n    {\\n        var map = new Dictionary<string, List<string>>();\\n        wordList.Add(beginWord);\\n        wordList = wordList.Distinct().ToList();\\n        for (var i = 0; i < wordList.Count; i++)\\n            for (var j = 0; j < wordList.Count; j++)\\n                if (i != j && Diff(wordList[i], wordList[j]) == 1)\\n                    if (!map.ContainsKey(wordList[i])) map[wordList[i]] = new List<string>() { wordList[j] };\\n                    else map[wordList[i]].Add(wordList[j]);\\n\\n        var res = new List<IList<string>>();\\n        var hs = new HashSet<string>() { beginWord };\\n\\n\\n        var nodes = new List<(string, List<string> Path)>() { (beginWord, new List<string>()) };\\n\\n        while (nodes.Any())\\n        {\\n            var newNodes = new List<(string, List<string> Path)>();\\n            foreach (var (node, path) in nodes)\\n                if (node == endWord)\\n                {\\n                    path.Add(node);\\n                    res.Add(path);\\n                }\\n                else if (map.ContainsKey(node))\\n                    foreach (var next in map[node])\\n                        if (!hs.Contains(next))\\n                        {\\n                            var newPath = new List<string>(path);\\n                            newPath.Add(node);\\n                            newNodes.Add((next, newPath));\\n                        }\\n\\n            foreach (var (node, path) in newNodes)\\n                hs.Add(node);\\n            nodes = newNodes.ToList();\\n        }\\n\\n        return res;\\n    }\\n\\n    private int Diff(string s, string s2)\\n    {\\n        var d = 0;\\n        for (var i = 0; i < s.Length; i++)\\n            if (s[i] != s2[i]) d++;\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<IList<string>> FindLadders(string beginWord, string endWord, IList<string> wordList)\\n    {\\n        var map = new Dictionary<string, List<string>>();\\n        wordList.Add(beginWord);\\n        wordList = wordList.Distinct().ToList();\\n        for (var i = 0; i < wordList.Count; i++)\\n            for (var j = 0; j < wordList.Count; j++)\\n                if (i != j && Diff(wordList[i], wordList[j]) == 1)\\n                    if (!map.ContainsKey(wordList[i])) map[wordList[i]] = new List<string>() { wordList[j] };\\n                    else map[wordList[i]].Add(wordList[j]);\\n\\n        var res = new List<IList<string>>();\\n        var hs = new HashSet<string>() { beginWord };\\n\\n\\n        var nodes = new List<(string, List<string> Path)>() { (beginWord, new List<string>()) };\\n\\n        while (nodes.Any())\\n        {\\n            var newNodes = new List<(string, List<string> Path)>();\\n            foreach (var (node, path) in nodes)\\n                if (node == endWord)\\n                {\\n                    path.Add(node);\\n                    res.Add(path);\\n                }\\n                else if (map.ContainsKey(node))\\n                    foreach (var next in map[node])\\n                        if (!hs.Contains(next))\\n                        {\\n                            var newPath = new List<string>(path);\\n                            newPath.Add(node);\\n                            newNodes.Add((next, newPath));\\n                        }\\n\\n            foreach (var (node, path) in newNodes)\\n                hs.Add(node);\\n            nodes = newNodes.ToList();\\n        }\\n\\n        return res;\\n    }\\n\\n    private int Diff(string s, string s2)\\n    {\\n        var d = 0;\\n        for (var i = 0; i < s.Length; i++)\\n            if (s[i] != s2[i]) d++;\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575666,
                "title": "intuitive-javascript-solution-with-bfs-dfs",
                "content": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) {\\n        return [];\\n    }\\n    \\n    /**\\n     * Create an adjacency list and run bfs to create a map for \\n     * verteices with transformation distances.\\n     * ex: transformation distance for hit -> dot is 2.\\n     * (two letters transformation)        \\n     *\\n     *               hit\\n     *                |     \\n     *               hot\\n     *              /   \\\\\\n     *           dot --- lot\\n     *            |       |\\n     *           dog --- log\\n     *             \\\\     /\\n     *               cog\\n     */\\n    const adjacencyList = createAdjacencyList([beginWord, ...wordList]);\\n    const distances = bfs(beginWord, endWord, adjacencyList);\\n    /**\\n     * Use dfs to backtrack all possible paths begin with beginWord. Add \\n     * all shortest paths to sequences.\\n     */\\n    const sequences = [];\\n    const dfs = (currWord, endWord, path) => {\\n        if (currWord === endWord) {\\n            sequences.push([...path]);\\n            return;\\n        }\\n\\n        const neighbors = adjacencyList.get(currWord);\\n        \\n        neighbors.forEach(neighbor => {\\n            if (\\n                distances.has(neighbor) && \\n                distances.get(neighbor) === distances.get(currWord) + 1\\n            ) {\\n                path.push(neighbor);\\n                dfs(neighbor, endWord, path);\\n                path.pop();\\n            }\\n        });\\n    }\\n    dfs(beginWord, endWord, [beginWord]);\\n    \\n    return sequences;\\n};\\n\\nfunction createAdjacencyList (words) {\\n    const adjacencyList = new Map();\\n    \\n    words.forEach(word => {\\n        let adjacentWords = []\\n        for (let i = 0; i < word.length; i++) {\\n            const regex = new RegExp(`${word.substring(0, i)}\\\\\\\\w${word.substring(i + 1)}`);\\n            const neighbors = words.filter(w => w !== word && regex.test(w));\\n            adjacentWords = [...adjacentWords, ...neighbors]\\n        }\\n        adjacencyList.set(word, adjacentWords)\\n    });\\n    \\n    return adjacencyList;\\n}\\n\\nfunction bfs(beginWord, endWord, adjacencyList) {\\n    const distances = new Map()\\n    const queue = [beginWord];\\n    let level = 0;\\n    \\n    distances.set(beginWord, level);\\n    \\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        \\n        while (size > 0) {\\n            const word = queue.shift();\\n\\n            if (word === endWord) {\\n                return distances;\\n            }\\n\\n            const neighbors = adjacencyList.get(word);\\n\\n            neighbors.forEach(neighbor => {\\n                if (!distances.has(neighbor)) {\\n                    distances.set(neighbor, level + 1);\\n                    queue.push(neighbor);\\n                }\\n            });   \\n            size -= 1;\\n        }\\n        level += 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) {\\n        return [];\\n    }\\n    \\n    /**\\n     * Create an adjacency list and run bfs to create a map for \\n     * verteices with transformation distances.\\n     * ex: transformation distance for hit -> dot is 2.\\n     * (two letters transformation)        \\n     *\\n     *               hit\\n     *                |     \\n     *               hot\\n     *              /   \\\\\\n     *           dot --- lot\\n     *            |       |\\n     *           dog --- log\\n     *             \\\\     /\\n     *               cog\\n     */\\n    const adjacencyList = createAdjacencyList([beginWord, ...wordList]);\\n    const distances = bfs(beginWord, endWord, adjacencyList);\\n    /**\\n     * Use dfs to backtrack all possible paths begin with beginWord. Add \\n     * all shortest paths to sequences.\\n     */\\n    const sequences = [];\\n    const dfs = (currWord, endWord, path) => {\\n        if (currWord === endWord) {\\n            sequences.push([...path]);\\n            return;\\n        }\\n\\n        const neighbors = adjacencyList.get(currWord);\\n        \\n        neighbors.forEach(neighbor => {\\n            if (\\n                distances.has(neighbor) && \\n                distances.get(neighbor) === distances.get(currWord) + 1\\n            ) {\\n                path.push(neighbor);\\n                dfs(neighbor, endWord, path);\\n                path.pop();\\n            }\\n        });\\n    }\\n    dfs(beginWord, endWord, [beginWord]);\\n    \\n    return sequences;\\n};\\n\\nfunction createAdjacencyList (words) {\\n    const adjacencyList = new Map();\\n    \\n    words.forEach(word => {\\n        let adjacentWords = []\\n        for (let i = 0; i < word.length; i++) {\\n            const regex = new RegExp(`${word.substring(0, i)}\\\\\\\\w${word.substring(i + 1)}`);\\n            const neighbors = words.filter(w => w !== word && regex.test(w));\\n            adjacentWords = [...adjacentWords, ...neighbors]\\n        }\\n        adjacencyList.set(word, adjacentWords)\\n    });\\n    \\n    return adjacencyList;\\n}\\n\\nfunction bfs(beginWord, endWord, adjacencyList) {\\n    const distances = new Map()\\n    const queue = [beginWord];\\n    let level = 0;\\n    \\n    distances.set(beginWord, level);\\n    \\n    while(queue.length !== 0) {\\n        let size = queue.length;\\n        \\n        while (size > 0) {\\n            const word = queue.shift();\\n\\n            if (word === endWord) {\\n                return distances;\\n            }\\n\\n            const neighbors = adjacencyList.get(word);\\n\\n            neighbors.forEach(neighbor => {\\n                if (!distances.has(neighbor)) {\\n                    distances.set(neighbor, level + 1);\\n                    queue.push(neighbor);\\n                }\\n            });   \\n            size -= 1;\\n        }\\n        level += 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439378,
                "title": "c-solution-accepted-only-1-way-bfs-with-comments",
                "content": "The solution passes all tests and accepted.\\nAppreciate feedback on how to optimize further.\\n\\n```\\nclass Solution {\\n    public:\\n    /*\\n        The idea is to run a BFS from beginWord to endWord, while keeping track of the path.\\n        Once the currWord == endWord, we have found the shortest path.\\n        The nextLevel keeps track of all the words reachable from currLevel.\\n        All words in nextLevel should be erased from dict to avoid loops.( This is slight modification to the usual BFS ).\\n    \\n    */\\n        vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n            unordered_set< string > dict( wordList.begin(), wordList.end() );\\n            dict.erase( beginWord );\\n            queue< vector< string > > q;\\n            vector< vector< string > > result;\\n            q.push( { beginWord } );\\n            bool found = false;\\n            while( !q.empty() ) {\\n                int size = q.size();\\n                unordered_set< string > nextLevel;\\n\\n                for( int i = 0 ; i < size ; ++i ) {\\n                    vector< string > currLevel = q.front();\\n                    q.pop();\\n                    string currWord = currLevel.back();\\n                    if( currWord == endWord ) {\\n                        found = true;\\n                        result.push_back( currLevel );\\n                    } else {\\n                        for( int i = 0 ; i < currWord.size() ; ++i ) {\\n                            char orig = currWord[ i ];\\n                            for( char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) {\\n                                if( ch == orig ) continue;\\n                                currWord[ i ] = ch;\\n                                if( dict.find( currWord ) != dict.end() ) {\\n                                    nextLevel.insert( currWord );\\n                                    q.push( currLevel );\\n                                    q.back().push_back( currWord );\\n                                }\\n                            }\\n                            currWord[ i ] = orig;\\n                        }\\n                    }\\n                }\\n                if( found ) break;\\n                for( auto n : nextLevel ) {\\n                    dict.erase( n );\\n                }\\n            }\\n            return result;\\n        }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    /*\\n        The idea is to run a BFS from beginWord to endWord, while keeping track of the path.\\n        Once the currWord == endWord, we have found the shortest path.\\n        The nextLevel keeps track of all the words reachable from currLevel.\\n        All words in nextLevel should be erased from dict to avoid loops.( This is slight modification to the usual BFS ).\\n    \\n    */\\n        vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n            unordered_set< string > dict( wordList.begin(), wordList.end() );\\n            dict.erase( beginWord );\\n            queue< vector< string > > q;\\n            vector< vector< string > > result;\\n            q.push( { beginWord } );\\n            bool found = false;\\n            while( !q.empty() ) {\\n                int size = q.size();\\n                unordered_set< string > nextLevel;\\n\\n                for( int i = 0 ; i < size ; ++i ) {\\n                    vector< string > currLevel = q.front();\\n                    q.pop();\\n                    string currWord = currLevel.back();\\n                    if( currWord == endWord ) {\\n                        found = true;\\n                        result.push_back( currLevel );\\n                    } else {\\n                        for( int i = 0 ; i < currWord.size() ; ++i ) {\\n                            char orig = currWord[ i ];\\n                            for( char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) {\\n                                if( ch == orig ) continue;\\n                                currWord[ i ] = ch;\\n                                if( dict.find( currWord ) != dict.end() ) {\\n                                    nextLevel.insert( currWord );\\n                                    q.push( currLevel );\\n                                    q.back().push_back( currWord );\\n                                }\\n                            }\\n                            currWord[ i ] = orig;\\n                        }\\n                    }\\n                }\\n                if( found ) break;\\n                for( auto n : nextLevel ) {\\n                    dict.erase( n );\\n                }\\n            }\\n            return result;\\n        }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359632,
                "title": "java-solution",
                "content": "1. This is BFS. The queue is a List because you need to track the words used\\n2. level order traversal to find the shortest path\\n3. for each level we want to have different local used check, more than one word in the same level could transform to the same word\\n4. break upon found\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> words = new HashSet<>();\\n        HashSet<String> used = new HashSet<>();\\n        Queue<LinkedList<String>> q = new LinkedList<>();\\n        List<List<String>> result = new ArrayList<>();\\n        boolean found = false;\\n        \\n        for(String word:wordList) words.add(word);\\n        \\n        LinkedList<String> first = new LinkedList<>();\\n        first.add(beginWord);\\n        q.offer(first);\\n        used.add(beginWord);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            HashSet<String> localUsed = new HashSet<>();\\n            while(size>0){\\n                LinkedList<String> curr = q.poll();\\n                char[] word = curr.getLast().toCharArray();\\n                for(int i=0;i<word.length;i++){\\n                    char temp = word[i];\\n                    for(int j=\\'a\\';j<=\\'z\\';j++){\\n                        word[i]=(char) j;\\n                        String s = String.valueOf(word);\\n                        if(!used.contains(s) && words.contains(s)){\\n                            LinkedList<String> list = new LinkedList<>(curr);\\n                            list.add(s);\\n                            if(s.equals(endWord)){\\n                                found=true;\\n                                result.add(list);\\n                                continue;\\n                            }\\n                            localUsed.add(s);\\n                            q.offer(list);   \\n                        }\\n                    }\\n                    word[i]=temp;\\n                }\\n                size--;\\n            }\\n            for(String s:localUsed) used.add(s);\\n            \\n            if(found) break;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> words = new HashSet<>();\\n        HashSet<String> used = new HashSet<>();\\n        Queue<LinkedList<String>> q = new LinkedList<>();\\n        List<List<String>> result = new ArrayList<>();\\n        boolean found = false;\\n        \\n        for(String word:wordList) words.add(word);\\n        \\n        LinkedList<String> first = new LinkedList<>();\\n        first.add(beginWord);\\n        q.offer(first);\\n        used.add(beginWord);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            HashSet<String> localUsed = new HashSet<>();\\n            while(size>0){\\n                LinkedList<String> curr = q.poll();\\n                char[] word = curr.getLast().toCharArray();\\n                for(int i=0;i<word.length;i++){\\n                    char temp = word[i];\\n                    for(int j=\\'a\\';j<=\\'z\\';j++){\\n                        word[i]=(char) j;\\n                        String s = String.valueOf(word);\\n                        if(!used.contains(s) && words.contains(s)){\\n                            LinkedList<String> list = new LinkedList<>(curr);\\n                            list.add(s);\\n                            if(s.equals(endWord)){\\n                                found=true;\\n                                result.add(list);\\n                                continue;\\n                            }\\n                            localUsed.add(s);\\n                            q.offer(list);   \\n                        }\\n                    }\\n                    word[i]=temp;\\n                }\\n                size--;\\n            }\\n            for(String s:localUsed) used.add(s);\\n            \\n            if(found) break;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324195,
                "title": "c-94-beat-original-solution-optimize-level-order-stitch-result",
                "content": "Essentially, we have 2 level order iterations going on at a time, one from the \"begin word\" and one from the \"end word.\"\\n\\nWe maintain the words from each probe in a list of lists of strings. For fast lookup, we also need to maintain a set for both the forward traversal and backwards traversal. Once the two traversals meet each other, we have found the depth of the solution + the solution itself.\\n\\nFinally, we need to merge the arrays from the forward traversal with the arrays from the reverse traversal. I did so by making a map to a list of all the array incides which have \"X\" as their final word with \"X\" as the key. The complementary set of traversals can check their last words - if the final word is in the back-mapping, then you combine the first array with all the arrays at all of the indices in the index list for the key which is the final word in said array.\\n\\nForward:\\n\"hat\", \"bat\", \"bot\"\\n\"hat\", \"hot\", \"bot\"\\n\\nBackward:\\n\"bot\", \"pot\"\\n\\nFinal solution:\\n\"hat\", \"bat\", \"bot\", \"pot\"\\n\"hat\", \"hot\", \"bot\", \"pot\"\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mWordLen;\\n    unordered_set<string> mDictionary;\\n    vector<string> mNeighbors;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        mWordLen = beginWord.size();\\n        mDictionary = unordered_set<string>(wordList.begin(), wordList.end());\\n        if (mDictionary.count(endWord) == 0) { return aResult; }\\n        mDictionary.insert(beginWord);\\n        \\n        unordered_set<string> aBlockedForward, aBlockedBackward, aForwardSet, aBackwardSet, *aPickSet, *aAltSet, *aBlocked;\\n        vector<vector<string>> aForward, aBackward, aNext, *aPick, *aAlt;\\n        \\n        aForward.push_back({beginWord}); aForwardSet.insert(beginWord); aBlockedForward.insert(beginWord);\\n        aBackward.push_back({endWord});  aBackwardSet.insert(endWord);  aBlockedBackward.insert(endWord);\\n        \\n        bool aCollide = false;\\n        \\n        while (aForward.size() != 0 && aBackward.size() != 0 && aCollide == false) {\\n            \\n            if (aForward.size() < aBackward.size()) {\\n                aPick = &aForward; aAlt = &aBackward;\\n                aPickSet = &aForwardSet; aAltSet = &aBackwardSet; aBlocked = &aBlockedForward;\\n            } else {\\n                aPick = &aBackward; aAlt = &aForward;\\n                aPickSet = &aBackwardSet; aAltSet = &aForwardSet; aBlocked = &aBlockedBackward;\\n            }\\n            \\n            for (int aIndex=0;aIndex<aPick->size();aIndex++) {\\n                \\n                string aWord = (*aPick)[aIndex].back();\\n                getNeighbors(aWord);\\n                for (auto aNeighbor : mNeighbors) {\\n                    \\n                    if (aAltSet->count(aNeighbor) != 0) { aCollide = true; }\\n                    if (aBlocked->count(aNeighbor) != 0) { continue; }\\n                    \\n                    vector<string> aNextArr = (*aPick)[aIndex];\\n                    aNextArr.push_back(aNeighbor);\\n                    aNext.push_back(aNextArr);\\n                }\\n            }\\n            \\n            aPickSet->clear();\\n            aPick->clear();\\n                \\n            for (int aIndex=0;aIndex<aNext.size();aIndex++) {\\n                string aWord = aNext[aIndex].back();\\n                aBlocked->insert(aWord);\\n                if (aPickSet->count(aWord) == 0) { aPickSet->insert(aWord); }\\n            }\\n                \\n            swap(*aPick, aNext);\\n        }\\n        \\n        \\n        \\n        if (aCollide) {\\n            \\n            //At this point, we have the full array contents for a solution moving both forward\\n            //and backwards. Now we just need to efficiently stitch them together.\\n            //We will do it by maintaining an index list for each word in the backwards array list.\\n            \\n            unordered_map<string, vector<int>> aConnect;\\n            for (int aIndex=0;aIndex<aBackward.size();aIndex++) {\\n                string aWord = aBackward[aIndex].back();\\n                aConnect[aWord].push_back(aIndex);\\n            }\\n            \\n            //Now we do the stitching...\\n            for (int aIndex=0;aIndex<aForward.size();aIndex++) {\\n                string aWord = aForward[aIndex].back();\\n                \\n                if (aConnect[aWord].size() > 0) {\\n                    for (auto aBackIndex : aConnect[aWord]) {\\n                        vector <string> aPart2 = aBackward[aBackIndex];\\n                        aPart2.pop_back();\\n                        reverse(aPart2.begin(), aPart2.end());\\n                        \\n                        vector <string> aAnswer;\\n                        \\n                        aAnswer.reserve(aForward[aIndex].size() + aPart2.size());\\n                        aAnswer.insert(aAnswer.end(), aForward[aIndex].begin(), aForward[aIndex].end());\\n                        aAnswer.insert(aAnswer.end(), aPart2.begin(), aPart2.end());\\n                        aResult.push_back(aAnswer);   \\n                    }   \\n                }\\n            }  \\n        }    \\n        return aResult;\\n    }\\n    \\n    void getNeighbors(string &pWord) {\\n        mNeighbors.clear();\\n        char aHold, aChar;\\n        for (int i=0;i<mWordLen;i++) {\\n            aHold = pWord[i];\\n            for (aChar=\\'a\\';aChar<=\\'z\\';aChar++) {\\n                if (aChar != aHold) {\\n                    pWord[i] = aChar;\\n                    if (mDictionary.count(pWord) != 0) {\\n                        mNeighbors.push_back(pWord);\\n                    }\\n                }\\n            }\\n            pWord[i] = aHold;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mWordLen;\\n    unordered_set<string> mDictionary;\\n    vector<string> mNeighbors;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        mWordLen = beginWord.size();\\n        mDictionary = unordered_set<string>(wordList.begin(), wordList.end());\\n        if (mDictionary.count(endWord) == 0) { return aResult; }\\n        mDictionary.insert(beginWord);\\n        \\n        unordered_set<string> aBlockedForward, aBlockedBackward, aForwardSet, aBackwardSet, *aPickSet, *aAltSet, *aBlocked;\\n        vector<vector<string>> aForward, aBackward, aNext, *aPick, *aAlt;\\n        \\n        aForward.push_back({beginWord}); aForwardSet.insert(beginWord); aBlockedForward.insert(beginWord);\\n        aBackward.push_back({endWord});  aBackwardSet.insert(endWord);  aBlockedBackward.insert(endWord);\\n        \\n        bool aCollide = false;\\n        \\n        while (aForward.size() != 0 && aBackward.size() != 0 && aCollide == false) {\\n            \\n            if (aForward.size() < aBackward.size()) {\\n                aPick = &aForward; aAlt = &aBackward;\\n                aPickSet = &aForwardSet; aAltSet = &aBackwardSet; aBlocked = &aBlockedForward;\\n            } else {\\n                aPick = &aBackward; aAlt = &aForward;\\n                aPickSet = &aBackwardSet; aAltSet = &aForwardSet; aBlocked = &aBlockedBackward;\\n            }\\n            \\n            for (int aIndex=0;aIndex<aPick->size();aIndex++) {\\n                \\n                string aWord = (*aPick)[aIndex].back();\\n                getNeighbors(aWord);\\n                for (auto aNeighbor : mNeighbors) {\\n                    \\n                    if (aAltSet->count(aNeighbor) != 0) { aCollide = true; }\\n                    if (aBlocked->count(aNeighbor) != 0) { continue; }\\n                    \\n                    vector<string> aNextArr = (*aPick)[aIndex];\\n                    aNextArr.push_back(aNeighbor);\\n                    aNext.push_back(aNextArr);\\n                }\\n            }\\n            \\n            aPickSet->clear();\\n            aPick->clear();\\n                \\n            for (int aIndex=0;aIndex<aNext.size();aIndex++) {\\n                string aWord = aNext[aIndex].back();\\n                aBlocked->insert(aWord);\\n                if (aPickSet->count(aWord) == 0) { aPickSet->insert(aWord); }\\n            }\\n                \\n            swap(*aPick, aNext);\\n        }\\n        \\n        \\n        \\n        if (aCollide) {\\n            \\n            //At this point, we have the full array contents for a solution moving both forward\\n            //and backwards. Now we just need to efficiently stitch them together.\\n            //We will do it by maintaining an index list for each word in the backwards array list.\\n            \\n            unordered_map<string, vector<int>> aConnect;\\n            for (int aIndex=0;aIndex<aBackward.size();aIndex++) {\\n                string aWord = aBackward[aIndex].back();\\n                aConnect[aWord].push_back(aIndex);\\n            }\\n            \\n            //Now we do the stitching...\\n            for (int aIndex=0;aIndex<aForward.size();aIndex++) {\\n                string aWord = aForward[aIndex].back();\\n                \\n                if (aConnect[aWord].size() > 0) {\\n                    for (auto aBackIndex : aConnect[aWord]) {\\n                        vector <string> aPart2 = aBackward[aBackIndex];\\n                        aPart2.pop_back();\\n                        reverse(aPart2.begin(), aPart2.end());\\n                        \\n                        vector <string> aAnswer;\\n                        \\n                        aAnswer.reserve(aForward[aIndex].size() + aPart2.size());\\n                        aAnswer.insert(aAnswer.end(), aForward[aIndex].begin(), aForward[aIndex].end());\\n                        aAnswer.insert(aAnswer.end(), aPart2.begin(), aPart2.end());\\n                        aResult.push_back(aAnswer);   \\n                    }   \\n                }\\n            }  \\n        }    \\n        return aResult;\\n    }\\n    \\n    void getNeighbors(string &pWord) {\\n        mNeighbors.clear();\\n        char aHold, aChar;\\n        for (int i=0;i<mWordLen;i++) {\\n            aHold = pWord[i];\\n            for (aChar=\\'a\\';aChar<=\\'z\\';aChar++) {\\n                if (aChar != aHold) {\\n                    pWord[i] = aChar;\\n                    if (mDictionary.count(pWord) != 0) {\\n                        mNeighbors.push_back(pWord);\\n                    }\\n                }\\n            }\\n            pWord[i] = aHold;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323086,
                "title": "c-working-solution-using-heuristic-original-idea-koderz-kamp",
                "content": "Here is an original idea, we can do two level-order traversals of the possible paths.\\n\\nFirst, we build a mapping of all the words to the one-edit-away words which can be reached. This accounts for much of the heavy lifting, and if we are not going to use many of the word-hops, this step may be overkill. However, it\\'s a bit cleaner to read if can separate this step out from the logic in the next two loops...\\n\\nNow, we travel backwards - from the end word to the begin word, recording the distance from the end word which we have traveled. We can do this very fast because we don\\'t need to know where we are visiting a word from, just the level at which we are visiting.\\n\\nSo from \"cat\", \"hat\" would have a distance of 1, and \"hot\" would have a distance of 2 - through \"hat\" (We will only store the minimum distance).\\n\\nThis entire traversal is used only to compute the backwards-distances, which we will use as a heuristic to limit our more expensive forward traversals in which we store the actual word-paths.\\n\\nThe heuristic #1:\\n(We don\\'t need to probe forward if we never reach the word from our backwards traversal)\\n```\\nif (aBackwardsDist[aNext] == -1) { continue; }\\n```\\n\\nThe heuristic #2:\\n(If the depth of the solution - the forward probe\\'s depth is less than the backward\\'s distance depth, it will take\\ntoo many additional hops to reach the end from THIS NEXT word. We can use this to trim many irrelevant paths)\\n```\\nif ((aSolutionDepth - aDepth) <= aBackwardsDist[aNext]) { continue; }\\n```\\t\\t\\t\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        \\n        wordList.push_back(beginWord);\\n        \\n        string aString1, aString2;\\n        int aCount = wordList.size(), aLen = beginWord.size();\\n        int aBeginIndex = -1, aEndIndex = -1;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            if (wordList[i] == beginWord) { aBeginIndex = i; }\\n            if (wordList[i] == endWord) { aEndIndex = i; }\\n        }\\n        \\n        if (aEndIndex == -1 || aBeginIndex == -1) { return aResult; }\\n        \\n        unordered_map <int, vector<int>> aCon;\\n        \\n        int aDiffCount = 0;\\n        for (int i=0;i<aCount;i++) {\\n            aString1 = wordList[i];\\n            for (int j=i+1;j<aCount;j++) {\\n                aString2 = wordList[j];\\n                aDiffCount = 0;\\n                for (int k=0;k<aLen;k++) {\\n                    if (aString1[k] != aString2[k]) { ++aDiffCount; }\\n                }\\n                if (aDiffCount == 1) {\\n                    //printf(\"%s Maps To %s\\\\n\", aString1.c_str(), aString2.c_str());\\n                    aCon[i].push_back(j);\\n                    aCon[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        int aLevelCount = 0;\\n        int aLevel = 0;\\n        queue <int> aBackQueue;\\n        \\n        int aIndex = 0;\\n        \\n        unordered_set <int> aVisited;\\n        \\n        aBackQueue.push(aEndIndex);\\n        aVisited.insert(aEndIndex);\\n        \\n        bool aFoundBegin = false;\\n        int aDepth = 0;\\n        \\n        \\n        //We are going to find out how far away the words are from the end...\\n        int aBackwardsDist[aCount + 1];\\n        for (int i=0;i<=aCount;i++) { aBackwardsDist[i] = -1; }\\n        aBackwardsDist[aEndIndex] = 0;\\n        \\n        while (aBackQueue.size() != 0) {\\n            \\n            aLevelCount = aBackQueue.size();\\n            aDepth++;\\n            \\n            for (aLevel=0;aLevel<aLevelCount;aLevel++) {\\n                \\n                aIndex = aBackQueue.front();\\n                aBackQueue.pop();\\n                \\n                if (aIndex == aBeginIndex) {\\n                    aFoundBegin = true;\\n                } else {\\n                    for (auto aNext : aCon[aIndex]) {\\n                        if (aBackwardsDist[aNext] == -1) {\\n                            aBackwardsDist[aNext] = aDepth;\\n                        }\\n\\n                        if (aVisited.count(aNext) == 0) {\\n                            aVisited.insert(aNext);\\n                            aBackQueue.push(aNext);\\n                        }   \\n                    }\\n                }\\n            }\\n            if (aFoundBegin) { break; }\\n        }\\n        \\n        if (aFoundBegin == false) {\\n            //We don\\'t have anything.\\n            return aResult;\\n        }\\n        \\n        int aSolutionDepth = aDepth;\\n        bool aFoundEnd = false;\\n        \\n        aDepth = 0;\\n        aVisited.clear();\\n        \\n        //Now we go forward, using the backwards distance to clip poo results.\\n        queue <vector<int>> aQueue;\\n        aQueue.push({aBeginIndex});\\n        \\n        vector<vector<int>> aNextLevel;\\n        vector<int> aVisitRow;\\n        \\n        while (aQueue.size() > 0) {\\n            \\n            aLevelCount = aQueue.size();\\n            aDepth++;\\n            \\n            for (aLevel=0;aLevel<aLevelCount;aLevel++) {\\n                \\n                vector<int> aPath = aQueue.front();\\n                aQueue.pop();\\n                aIndex = aPath.back();\\n                \\n                if (aIndex == aEndIndex) {\\n                    aFoundEnd = true;\\n                    \\n                    vector <string> aRow;\\n                    for (auto aStringIndex : aPath) { aRow.push_back(wordList[aStringIndex]); }\\n                    aResult.push_back(aRow);\\n                } else {\\n                    for (auto aNext : aCon[aIndex]) {\\n                        \\n                        //If we can\\'t get to here from the end, no point in continuing.\\n                        if (aBackwardsDist[aNext] == -1) { continue; }\\n                        \\n                        //If we can\\'t get to the end fast enough from here, no point in continuing.\\n                        if ((aSolutionDepth - aDepth) <= aBackwardsDist[aNext]) { continue; }\\n                        \\n                        if (aVisited.count(aNext) == 0) {\\n                            aPath.push_back(aNext);\\n                            aNextLevel.push_back(aPath);\\n                            aPath.pop_back();\\n                            aVisitRow.push_back(aNext);\\n                        }   \\n                    }\\n                }\\n            }\\n            \\n            if (aFoundEnd) { break; }\\n            \\n            for (auto aVisitIndex : aVisitRow) { aVisited.insert(aVisitIndex); }\\n            aVisitRow.clear();\\n            \\n            for (auto aNextPath : aNextLevel) { aQueue.push(aNextPath); }\\n            aNextLevel.clear();\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nif (aBackwardsDist[aNext] == -1) { continue; }\\n```\n```\\nif ((aSolutionDepth - aDepth) <= aBackwardsDist[aNext]) { continue; }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        \\n        wordList.push_back(beginWord);\\n        \\n        string aString1, aString2;\\n        int aCount = wordList.size(), aLen = beginWord.size();\\n        int aBeginIndex = -1, aEndIndex = -1;\\n        \\n        for (int i=0;i<aCount;i++) {\\n            if (wordList[i] == beginWord) { aBeginIndex = i; }\\n            if (wordList[i] == endWord) { aEndIndex = i; }\\n        }\\n        \\n        if (aEndIndex == -1 || aBeginIndex == -1) { return aResult; }\\n        \\n        unordered_map <int, vector<int>> aCon;\\n        \\n        int aDiffCount = 0;\\n        for (int i=0;i<aCount;i++) {\\n            aString1 = wordList[i];\\n            for (int j=i+1;j<aCount;j++) {\\n                aString2 = wordList[j];\\n                aDiffCount = 0;\\n                for (int k=0;k<aLen;k++) {\\n                    if (aString1[k] != aString2[k]) { ++aDiffCount; }\\n                }\\n                if (aDiffCount == 1) {\\n                    //printf(\"%s Maps To %s\\\\n\", aString1.c_str(), aString2.c_str());\\n                    aCon[i].push_back(j);\\n                    aCon[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        int aLevelCount = 0;\\n        int aLevel = 0;\\n        queue <int> aBackQueue;\\n        \\n        int aIndex = 0;\\n        \\n        unordered_set <int> aVisited;\\n        \\n        aBackQueue.push(aEndIndex);\\n        aVisited.insert(aEndIndex);\\n        \\n        bool aFoundBegin = false;\\n        int aDepth = 0;\\n        \\n        \\n        //We are going to find out how far away the words are from the end...\\n        int aBackwardsDist[aCount + 1];\\n        for (int i=0;i<=aCount;i++) { aBackwardsDist[i] = -1; }\\n        aBackwardsDist[aEndIndex] = 0;\\n        \\n        while (aBackQueue.size() != 0) {\\n            \\n            aLevelCount = aBackQueue.size();\\n            aDepth++;\\n            \\n            for (aLevel=0;aLevel<aLevelCount;aLevel++) {\\n                \\n                aIndex = aBackQueue.front();\\n                aBackQueue.pop();\\n                \\n                if (aIndex == aBeginIndex) {\\n                    aFoundBegin = true;\\n                } else {\\n                    for (auto aNext : aCon[aIndex]) {\\n                        if (aBackwardsDist[aNext] == -1) {\\n                            aBackwardsDist[aNext] = aDepth;\\n                        }\\n\\n                        if (aVisited.count(aNext) == 0) {\\n                            aVisited.insert(aNext);\\n                            aBackQueue.push(aNext);\\n                        }   \\n                    }\\n                }\\n            }\\n            if (aFoundBegin) { break; }\\n        }\\n        \\n        if (aFoundBegin == false) {\\n            //We don\\'t have anything.\\n            return aResult;\\n        }\\n        \\n        int aSolutionDepth = aDepth;\\n        bool aFoundEnd = false;\\n        \\n        aDepth = 0;\\n        aVisited.clear();\\n        \\n        //Now we go forward, using the backwards distance to clip poo results.\\n        queue <vector<int>> aQueue;\\n        aQueue.push({aBeginIndex});\\n        \\n        vector<vector<int>> aNextLevel;\\n        vector<int> aVisitRow;\\n        \\n        while (aQueue.size() > 0) {\\n            \\n            aLevelCount = aQueue.size();\\n            aDepth++;\\n            \\n            for (aLevel=0;aLevel<aLevelCount;aLevel++) {\\n                \\n                vector<int> aPath = aQueue.front();\\n                aQueue.pop();\\n                aIndex = aPath.back();\\n                \\n                if (aIndex == aEndIndex) {\\n                    aFoundEnd = true;\\n                    \\n                    vector <string> aRow;\\n                    for (auto aStringIndex : aPath) { aRow.push_back(wordList[aStringIndex]); }\\n                    aResult.push_back(aRow);\\n                } else {\\n                    for (auto aNext : aCon[aIndex]) {\\n                        \\n                        //If we can\\'t get to here from the end, no point in continuing.\\n                        if (aBackwardsDist[aNext] == -1) { continue; }\\n                        \\n                        //If we can\\'t get to the end fast enough from here, no point in continuing.\\n                        if ((aSolutionDepth - aDepth) <= aBackwardsDist[aNext]) { continue; }\\n                        \\n                        if (aVisited.count(aNext) == 0) {\\n                            aPath.push_back(aNext);\\n                            aNextLevel.push_back(aPath);\\n                            aPath.pop_back();\\n                            aVisitRow.push_back(aNext);\\n                        }   \\n                    }\\n                }\\n            }\\n            \\n            if (aFoundEnd) { break; }\\n            \\n            for (auto aVisitIndex : aVisitRow) { aVisited.insert(aVisitIndex); }\\n            aVisitRow.clear();\\n            \\n            for (auto aNextPath : aNextLevel) { aQueue.push(aNextPath); }\\n            aNextLevel.clear();\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169634,
                "title": "simple-python-beats-100-with-detailed-explanation",
                "content": "This solution use \\'defaultdict\\' for convenient, but can be replaced by few lines of code without using.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        if endWord not in wordList or not endWord or not beginWord:\\n            return []\\n        wordList = set(wordList)\\n        forward, backward = {beginWord}, {endWord}\\n        direction = 1\\n        parents = defaultdict(set)\\n        while forward and backward:\\n            if len(forward) > len(backward):\\n                forward, backward = backward, forward\\n                # We need to trace the direction in order to distinguish the parents\\n                direction *= -1\\n            \\n            # The new set of words which will be forward in the next iteration\\n            next_foward = set()\\n            \\n            # Because all words in forward will be modified by one character\\n            wordList -= forward\\n            for word in forward:\\n                for i in range(len(word)):\\n                    first, second = word[:i], word[i+1:]\\n                    for ch in string.ascii_lowercase:\\n                        combined_word = first + ch + second\\n                        if combined_word in wordList:\\n                            next_foward.add(combined_word)\\n                            # Because at the last part, we find parents by indexing dictionary from endWord\\n                            # So when direction == 1, the combined_word is the key\\n                            # otherwise, the combined_word should be the value of dictionary.\\n                            if direction == 1:\\n                                parents[combined_word].add(word)\\n                            else:\\n                                parents[word].add(combined_word)\\n                                \\n            # next_foward and backward are always in different direction,\\n            # so if they have common elements we find a path.\\n            # We check and return this function inside is because this problem finds the all shortest paths\\n            if next_foward & backward:\\n                # Starting from the endWord, we find its parent and append to results\\n                # And do this until we reach the beginWord\\n                results = [[endWord]]\\n                while results[0][0] != beginWord:\\n                    results = [ [parent] + result for result in results for parent in parents[result[0]] ]\\n                return results\\n            forward = next_foward\\n        return []\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        if endWord not in wordList or not endWord or not beginWord:\\n            return []\\n        wordList = set(wordList)\\n        forward, backward = {beginWord}, {endWord}\\n        direction = 1\\n        parents = defaultdict(set)\\n        while forward and backward:\\n            if len(forward) > len(backward):\\n                forward, backward = backward, forward\\n                # We need to trace the direction in order to distinguish the parents\\n                direction *= -1\\n            \\n            # The new set of words which will be forward in the next iteration\\n            next_foward = set()\\n            \\n            # Because all words in forward will be modified by one character\\n            wordList -= forward\\n            for word in forward:\\n                for i in range(len(word)):\\n                    first, second = word[:i], word[i+1:]\\n                    for ch in string.ascii_lowercase:\\n                        combined_word = first + ch + second\\n                        if combined_word in wordList:\\n                            next_foward.add(combined_word)\\n                            # Because at the last part, we find parents by indexing dictionary from endWord\\n                            # So when direction == 1, the combined_word is the key\\n                            # otherwise, the combined_word should be the value of dictionary.\\n                            if direction == 1:\\n                                parents[combined_word].add(word)\\n                            else:\\n                                parents[word].add(combined_word)\\n                                \\n            # next_foward and backward are always in different direction,\\n            # so if they have common elements we find a path.\\n            # We check and return this function inside is because this problem finds the all shortest paths\\n            if next_foward & backward:\\n                # Starting from the endWord, we find its parent and append to results\\n                # And do this until we reach the beginWord\\n                results = [[endWord]]\\n                while results[0][0] != beginWord:\\n                    results = [ [parent] + result for result in results for parent in parents[result[0]] ]\\n                return results\\n            forward = next_foward\\n        return []\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 40481,
                "title": "python-solution-bfs-with-preprocessing",
                "content": "```\\nimport collections\\nclass Solution(object):\\n    def preprocess(self, word_list, l):\\n        dic = {}\\n        for word in word_list:\\n            for i in xrange(l):\\n                new = word[:i] + \"?\" + word[i+1:]\\n                dic[new] = dic.get(new, []) + [word]\\n                \\n        return dic\\n        \\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n\\n        search_que = collections.deque()\\n        visited = {}\\n        word_len = len(beginWord)\\n        visited[beginWord] = 1\\n        word_dic = self.preprocess([beginWord] + wordList, word_len)\\n        prev_dic = {}\\n        break_flag = False\\n        search_que.append((beginWord, [], 1))\\n        rst = []\\n        shortest = None\\n        while search_que:\\n            word_tup = search_que.popleft()\\n            word, path, dist = word_tup\\n            if shortest and dist > shortest:\\n                break\\n            for ind in xrange(word_len):\\n                cur_word = word[:ind] + \"?\" + word[ind+1:]\\n                neighbors = word_dic[cur_word]\\n                for neighbor in neighbors:\\n                    if neighbor == word:\\n                        continue\\n                    tup = (neighbor, path + [word], dist + 1)\\n                    if neighbor == endWord:\\n                        rst.append(tup[1] + [endWord])\\n                        shortest = dist\\n                        continue\\n                    if neighbor not in visited or visited[neighbor] >= dist:\\n                        search_que.append(tup)\\n                        visited[neighbor] = dist\\n        return rst  \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def preprocess(self, word_list, l):\\n        dic = {}\\n        for word in word_list:\\n            for i in xrange(l):\\n                new = word[:i] + \"?\" + word[i+1:]\\n                dic[new] = dic.get(new, []) + [word]\\n                \\n        return dic\\n        \\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return []\\n\\n        search_que = collections.deque()\\n        visited = {}\\n        word_len = len(beginWord)\\n        visited[beginWord] = 1\\n        word_dic = self.preprocess([beginWord] + wordList, word_len)\\n        prev_dic = {}\\n        break_flag = False\\n        search_que.append((beginWord, [], 1))\\n        rst = []\\n        shortest = None\\n        while search_que:\\n            word_tup = search_que.popleft()\\n            word, path, dist = word_tup\\n            if shortest and dist > shortest:\\n                break\\n            for ind in xrange(word_len):\\n                cur_word = word[:ind] + \"?\" + word[ind+1:]\\n                neighbors = word_dic[cur_word]\\n                for neighbor in neighbors:\\n                    if neighbor == word:\\n                        continue\\n                    tup = (neighbor, path + [word], dist + 1)\\n                    if neighbor == endWord:\\n                        rst.append(tup[1] + [endWord])\\n                        shortest = dist\\n                        continue\\n                    if neighbor not in visited or visited[neighbor] >= dist:\\n                        search_que.append(tup)\\n                        visited[neighbor] = dist\\n        return rst  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 40553,
                "title": "25ms-beats-100-java-solution",
                "content": "Thanks to the great code and explanation in:\\n\\nhttps://leetcode.com/discuss/67716/my-30ms-bidirectional-bfs-and-dfs-based-java-solution\\n\\nbelow is my code:\\n\\n    public class Solution {\\n        public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\\n            HashMap<String, ArrayList<String>> h = new HashMap();\\n            Set<String> set1 = new HashSet(), set2 = new HashSet();\\n            set1.add(beginWord); set2.add(endWord);\\n            BFS(set1, set2, wordList, h, true);\\n            \\n            List<List<String>> ans = new ArrayList();\\n            List<String> cur = new ArrayList();\\n            cur.add(beginWord);\\n            DFS(beginWord, endWord, h, cur, ans);\\n            return ans;\\n        }\\n        \\n        private void BFS(Set<String> set1, Set<String> set2, Set<String> wordList, HashMap<String, ArrayList<String>> h, boolean forward) {\\n            if (set1.size() > set2.size()) {\\n                BFS(set2, set1, wordList, h, !forward);\\n                return;\\n            }\\n            wordList.removeAll(set1);\\n            wordList.removeAll(set2);\\n            boolean connected = false;\\n            Set<String> set3 = new HashSet();\\n            \\n            for (String s : set1) {\\n                char[] c = s.toCharArray();\\n                for (int i = 0, len = c.length; i < len; i++) {\\n                    char ch = c[i];\\n                    for (char x = 'a'; x <= 'z'; x++)\\n                        if (x != ch) {\\n                            c[i] = x;\\n                            String cand = new String(c);\\n                            if (set2.contains(cand) || (!connected && wordList.contains(cand))) {\\n                                if (set2.contains(cand))\\n                                    connected = true;\\n                                else\\n                                    set3.add(cand);\\n                                    \\n                                String cand1 = forward ? cand : s;\\n                                String s1 = forward ? s : cand;\\n                                ArrayList<String> cur = h.containsKey(s1) ? h.get(s1) : new ArrayList();\\n                                cur.add(cand1);\\n                                h.put(s1, cur);\\n                            }\\n                        }\\n                    c[i] = ch;\\n                }\\n            }\\n            if (!connected && !set3.isEmpty())\\n                BFS(set3, set2, wordList, h, forward);\\n            }\\n            \\n            private void DFS(String str, String ed, HashMap<String, ArrayList<String>> h, List<String> cur, List<List<String>> ans) {\\n                if (str.equals(ed)) {\\n                    ans.add(new ArrayList(cur));\\n                    return;\\n                }\\n                \\n                if (!h.containsKey(str)) return;\\n                List<String> next = h.get(str);\\n                for (String i : next) {\\n                    cur.add(i);\\n                    DFS(i, ed, h, cur, ans);\\n                    cur.remove(cur.size() - 1);\\n                }\\n            }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\\n            HashMap<String, ArrayList<String>> h = new HashMap();\\n            Set<String> set1 = new HashSet(), set2 = new HashSet();\\n            set1.add(beginWord); set2.add(endWord);\\n            BFS(set1, set2, wordList, h, true);\\n            \\n            List<List<String>> ans = new ArrayList();\\n            List<String> cur = new ArrayList();\\n            cur.add(beginWord);\\n            DFS(beginWord, endWord, h, cur, ans);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3808341,
                "title": "word-ladder-ii-finding-all-shortest-transformation-sequences",
                "content": "# Intuition\\nThis problem requires finding all the shortest transformation sequences from the beginWord to the endWord using a word list wordList, where each transformation must change exactly one letter.\\n\\n# Approach Overview:\\nTo solve the problem, we employ a combination of Breadth-First Search (BFS) and Depth-First Search (DFS).\\n\\n# Breadth-First Search (BFS):\\nWe start by performing a BFS from the beginWord to find the shortest distance (minimum number of transformations) from the beginWord to each word in the wordList. This step ensures that we obtain the shortest transformation sequence for each word.\\n\\n# Backtracking with Depth-First Search (DFS):\\nAfter obtaining the shortest distances using BFS, we initiate a DFS to backtrack and find all possible transformation sequences. This allows us to enumerate all valid paths that lead from the beginWord to the endWord.\\n\\n# Implementation Details:\\nIn our implementation, we use an unordered_map mpp to store the word distances, a queue for BFS, and a vector ans to store the final transformation sequences.\\n\\n# Complexity Analysis:\\nThe BFS phase takes O(N * L) time, where N is the number of words in wordList and L is the average word length. The DFS phase contributes to the overall complexity as well.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<string>> ans;\\n    unordered_map<string, int> mpp;\\n    void dfs(vector<string> v, string beginWord){\\n        string last = v[v.size() - 1];\\n        if(last == beginWord){\\n            reverse(v.begin(), v.end());\\n            ans.push_back(v);\\n            return;\\n        }\\n        int lev = mpp[last];\\n        for(int i = 0; i < last.size(); i++){\\n            char org = last[i];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                last[i] = c;\\n                if(mpp.count(last) && mpp[last] + 1 == lev){\\n                    v.push_back(last);\\n                    dfs(v, beginWord);\\n                    v.pop_back();\\n                }\\n            }\\n            last[i] = org;\\n        }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        mpp.clear();\\n        ans.clear();\\n        unordered_set<string> s;\\n        for(auto& it : wordList)s.insert(it);\\n        queue<string> q;\\n        q.push(beginWord);\\n        if(s.find(beginWord) != s.end())s.erase(beginWord);\\n        if(s.find(endWord) == s.end())return {};\\n        int dis = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                string temp = q.front();\\n                q.pop();\\n                mpp[temp] = dis;\\n                if(temp == endWord)goto label;\\n                for(int i = 0; i < temp.size(); i++){\\n                    char org = temp[i];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        temp[i] = c;\\n                        if(s.find(temp) != s.end()){\\n                            s.erase(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                    temp[i] = org;\\n                }\\n            }\\n            dis++;\\n        }\\n        label:\\n        vector<string> v = {endWord};\\n        dfs(v, beginWord);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<string>> ans;\\n    unordered_map<string, int> mpp;\\n    void dfs(vector<string> v, string beginWord){\\n        string last = v[v.size() - 1];\\n        if(last == beginWord){\\n            reverse(v.begin(), v.end());\\n            ans.push_back(v);\\n            return;\\n        }\\n        int lev = mpp[last];\\n        for(int i = 0; i < last.size(); i++){\\n            char org = last[i];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                last[i] = c;\\n                if(mpp.count(last) && mpp[last] + 1 == lev){\\n                    v.push_back(last);\\n                    dfs(v, beginWord);\\n                    v.pop_back();\\n                }\\n            }\\n            last[i] = org;\\n        }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        mpp.clear();\\n        ans.clear();\\n        unordered_set<string> s;\\n        for(auto& it : wordList)s.insert(it);\\n        queue<string> q;\\n        q.push(beginWord);\\n        if(s.find(beginWord) != s.end())s.erase(beginWord);\\n        if(s.find(endWord) == s.end())return {};\\n        int dis = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                string temp = q.front();\\n                q.pop();\\n                mpp[temp] = dis;\\n                if(temp == endWord)goto label;\\n                for(int i = 0; i < temp.size(); i++){\\n                    char org = temp[i];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        temp[i] = c;\\n                        if(s.find(temp) != s.end()){\\n                            s.erase(temp);\\n                            q.push(temp);\\n                        }\\n                    }\\n                    temp[i] = org;\\n                }\\n            }\\n            dis++;\\n        }\\n        label:\\n        vector<string> v = {endWord};\\n        dfs(v, beginWord);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633491,
                "title": "c-most-optimized-code-bfs",
                "content": "**36 / 36** test cases passed.\\n*Status:* Accepted\\n*Runtime:* 24 ms\\n*Memory Usage:* 8.9 MB\\n```\\nclass Solution {\\n    vector<vector<string>> ans;     //Ans Vector\\n    unordered_map<string,int> mpp;    // map for storing steps from one word to the end word\\n    string b;   //begin word\\n    int sz;    // size of begin word\\n    void dfs(string& word,vector<string>& seq){\\n        if(word==b){\\n            reverse(seq.begin(), seq.end());\\n            ans.emplace_back(seq);\\n            reverse(seq.begin(), seq.end());\\n            return;\\n        }\\n        int steps = mpp[word];\\n        for(int i=0;i<sz;++i){\\n                char orig = word[i];\\n                for(char c=\\'a\\';c<=\\'z\\';++c){\\n                    word[i]=c;\\n                    if(mpp.count(word) and mpp[word]+1==steps){\\n                        seq.emplace_back(word);    // if word is found in dictionary, then call DFS after adding it to the sequence for the ans vector\\n                        dfs(word, seq);\\n                        seq.pop_back();   // delete the last added word to avoid errors\\n                    }\\n                }\\n                word[i] = orig;\\n            }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        b=beginWord;\\n        \\n        unordered_set<string> st(wordList.begin(), wordList.end());     \\n        queue<string> q;    \\n        \\n        q.push(b);\\n        \\n        mpp[b]=1;\\n        sz = b.size();\\n        st.erase(b);\\n        while(!q.empty()){\\n            string word = q.front();\\n            q.pop();\\n            \\n            if(word==endWord)\\n                break;\\n            int steps = mpp[word];\\n            \\n            for(int i=0;i<sz;++i){\\n                char orig = word[i];\\n                for(char c=\\'a\\';c<=\\'z\\';++c){\\n                    word[i]=c;\\n                    if(st.count(word)){\\n                        st.erase(word);\\n                        q.push(word);\\n                        mpp[word] = steps+1;\\n                    }\\n                }\\n                word[i] = orig;\\n            }\\n        }\\n        if(mpp.count(endWord)){\\n            vector<string> seq;\\n            seq.emplace_back(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<string>> ans;     //Ans Vector\\n    unordered_map<string,int> mpp;    // map for storing steps from one word to the end word\\n    string b;   //begin word\\n    int sz;    // size of begin word\\n    void dfs(string& word,vector<string>& seq){\\n        if(word==b){\\n            reverse(seq.begin(), seq.end());\\n            ans.emplace_back(seq);\\n            reverse(seq.begin(), seq.end());\\n            return;\\n        }\\n        int steps = mpp[word];\\n        for(int i=0;i<sz;++i){\\n                char orig = word[i];\\n                for(char c=\\'a\\';c<=\\'z\\';++c){\\n                    word[i]=c;\\n                    if(mpp.count(word) and mpp[word]+1==steps){\\n                        seq.emplace_back(word);    // if word is found in dictionary, then call DFS after adding it to the sequence for the ans vector\\n                        dfs(word, seq);\\n                        seq.pop_back();   // delete the last added word to avoid errors\\n                    }\\n                }\\n                word[i] = orig;\\n            }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        b=beginWord;\\n        \\n        unordered_set<string> st(wordList.begin(), wordList.end());     \\n        queue<string> q;    \\n        \\n        q.push(b);\\n        \\n        mpp[b]=1;\\n        sz = b.size();\\n        st.erase(b);\\n        while(!q.empty()){\\n            string word = q.front();\\n            q.pop();\\n            \\n            if(word==endWord)\\n                break;\\n            int steps = mpp[word];\\n            \\n            for(int i=0;i<sz;++i){\\n                char orig = word[i];\\n                for(char c=\\'a\\';c<=\\'z\\';++c){\\n                    word[i]=c;\\n                    if(st.count(word)){\\n                        st.erase(word);\\n                        q.push(word);\\n                        mpp[word] = steps+1;\\n                    }\\n                }\\n                word[i] = orig;\\n            }\\n        }\\n        if(mpp.count(endWord)){\\n            vector<string> seq;\\n            seq.emplace_back(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423841,
                "title": "word-ladder-ii-bfs-backtracking-with-explanation",
                "content": "### BFS + Backtracking\\n\\nHere we have given that Every adjacent pair of words differs by a single letter. In order to find such pairs efficiently, we can **replace** each character of `word` with `*` and create a hash map where key will be new pattern and value will be list of words.\\n\\nFor example `word1 = hit` and `word2 = hot` and hash map will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/f0110bd8-d79f-4ab5-a449-773ef9ad296c_1660470012.9501066.png)\\n\\nWe can use this as an **adjacency list** to go from one node to other nodes.\\n\\nNow, our task is to find **shortest transformation sequences**. This is hint for **BFS**. So first we will do BFS from `beginWord` to `endWord`. This will give us directed graph where parent node will be word and all it\\'s children will be adjacent words differs by a single letter from parent word.\\n\\nWhile doing BFS we will also keep track of word and at which level that word appears. This will help us later while generating sequences from graph using backtracking.\\n\\nOnce we have graph, we use **backtracking** do generate all sequences starting from `beginWord`.\\n\\n***After leetcode updated the test cases for this problem, backtracking from `beginWord` is giving TLE. So we will start backtracing from `endWord` and we work towards `beginWord`.***\\n\\n**Example**\\n\\n![image](https://assets.leetcode.com/users/images/2e70ecc0-9232-4425-93eb-d9c47256caff_1660470022.0235295.png)\\n\\nLooking at this image you might think that this graph has links from top to bottom only, but if you debug the code then you will see it stores link to parent node as well. This will allow us to do backtracking from `endWord`. \\n\\n**Algorithm**\\n- Create adjacency list\\n- Build graph from `beginWord` to `endWord` using BFS.\\n- Generate sequences using **backtracking**\\n\\n```java\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>(wordList);\\n        if (!words.contains(endWord)) {\\n            return new ArrayList<>();\\n        }\\n\\n        words.add(beginWord);\\n\\n        HashMap<String, List<String>> adjList = new HashMap<>();\\n\\n        for (String word: words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                String pattern = getPattern(word, i);\\n                adjList.putIfAbsent(pattern, new ArrayList<>());\\n                adjList.get(pattern).add(word);\\n            }\\n        }\\n\\n        Queue<String> queue = new LinkedList<>();\\n        HashMap<String, Set<String>> graph = new HashMap<>();\\n        Map<String, Integer> levels = new HashMap<>();\\n\\n        queue.add(beginWord);\\n        levels.put(beginWord, 0);\\n\\n        while (!queue.isEmpty()) {\\n            String cur = queue.poll();\\n            int curLevel = levels.get(cur);\\n            graph.putIfAbsent(cur, new HashSet<>());\\n\\n            for (int i = 0; i < cur.length(); i++) {\\n                String pattern = getPattern(cur, i);\\n\\n                for (String nei: adjList.get(pattern)) {\\n                    \\n                    graph.get(cur).add(nei);\\n                    if (!levels.containsKey(nei)) {\\n                        levels.put(nei, curLevel + 1);\\n                        queue.add(nei);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        if (!graph.containsKey(endWord)) {\\n            return ans; \\n        }\\n\\n        backtracking(endWord, beginWord, new ArrayList<>(), ans, graph, levels);\\n\\n        return ans;\\n    }\\n\\n    private void backtracking(String start, String endWord,\\n                              List<String> path, List<List<String>> ans,\\n                              HashMap<String, Set<String>> graph,\\n                              Map<String, Integer> levels) {\\n        path.add(start);\\n\\n        if (start.equals(endWord)) {\\n            List<String> temp = new ArrayList<>(path);\\n            Collections.reverse(temp);\\n            ans.add(temp);\\n        } else {\\n            for (String next : graph.get(start)) {\\n                if (levels.get(next) == levels.get(start) - 1) {\\n                    backtracking(next, endWord, path, ans, graph, levels);\\n                }\\n            }\\n        }\\n\\n        path.remove(path.size() - 1);\\n    }\\n\\n    private String getPattern(String word, int i) {\\n        return word.substring(0, i) + \"*\" + word.substring(i + 1);\\n    }\\n}\\n```\\n\\n**Help** - I was not able to come up with correct time & space complexity for this solution. Please add it in comment if anyone has answer to this. Many thanks!!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>(wordList);\\n        if (!words.contains(endWord)) {\\n            return new ArrayList<>();\\n        }\\n\\n        words.add(beginWord);\\n\\n        HashMap<String, List<String>> adjList = new HashMap<>();\\n\\n        for (String word: words) {\\n            for (int i = 0; i < word.length(); i++) {\\n                String pattern = getPattern(word, i);\\n                adjList.putIfAbsent(pattern, new ArrayList<>());\\n                adjList.get(pattern).add(word);\\n            }\\n        }\\n\\n        Queue<String> queue = new LinkedList<>();\\n        HashMap<String, Set<String>> graph = new HashMap<>();\\n        Map<String, Integer> levels = new HashMap<>();\\n\\n        queue.add(beginWord);\\n        levels.put(beginWord, 0);\\n\\n        while (!queue.isEmpty()) {\\n            String cur = queue.poll();\\n            int curLevel = levels.get(cur);\\n            graph.putIfAbsent(cur, new HashSet<>());\\n\\n            for (int i = 0; i < cur.length(); i++) {\\n                String pattern = getPattern(cur, i);\\n\\n                for (String nei: adjList.get(pattern)) {\\n                    \\n                    graph.get(cur).add(nei);\\n                    if (!levels.containsKey(nei)) {\\n                        levels.put(nei, curLevel + 1);\\n                        queue.add(nei);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        if (!graph.containsKey(endWord)) {\\n            return ans; \\n        }\\n\\n        backtracking(endWord, beginWord, new ArrayList<>(), ans, graph, levels);\\n\\n        return ans;\\n    }\\n\\n    private void backtracking(String start, String endWord,\\n                              List<String> path, List<List<String>> ans,\\n                              HashMap<String, Set<String>> graph,\\n                              Map<String, Integer> levels) {\\n        path.add(start);\\n\\n        if (start.equals(endWord)) {\\n            List<String> temp = new ArrayList<>(path);\\n            Collections.reverse(temp);\\n            ans.add(temp);\\n        } else {\\n            for (String next : graph.get(start)) {\\n                if (levels.get(next) == levels.get(start) - 1) {\\n                    backtracking(next, endWord, path, ans, graph, levels);\\n                }\\n            }\\n        }\\n\\n        path.remove(path.size() - 1);\\n    }\\n\\n    private String getPattern(String word, int i) {\\n        return word.substring(0, i) + \"*\" + word.substring(i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250146,
                "title": "java-solution-using-bfs-and-memorized-dfs",
                "content": "Step1: use BFS to build a Ladder Graph start from beginWord layer and end to endWord layer\\nStep2: use memorized DFS to traverse the graph and found all the shortest route\\n``` java\\nclass Solution {\\n    Map<String, List<List<String>>> buf;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        if (!remove(wordList, endWord)) return new ArrayList<>();\\n        remove(wordList, beginWord);\\n        wordList.add(endWord);\\n        buf = new HashMap<>();\\n        Map<String, List<String>> graph = buildLadderGraph(beginWord, endWord, wordList);\\n        traverseLadderGraph(graph, beginWord, endWord);\\n        return buf.getOrDefault(beginWord, new ArrayList<>());\\n    }\\n\\n    private List<List<String>> traverseLadderGraph(Map<String, List<String>> graph, String beginWord, String endWord) {\\n        if (beginWord.equals(endWord)) {\\n            buf.put(beginWord, new ArrayList<>());\\n            buf.get(beginWord).add(new ArrayList<>(Arrays.asList(endWord)));\\n            return buf.get(beginWord);\\n        }\\n        if (buf.containsKey(beginWord)) return buf.get(beginWord);\\n        if (!graph.containsKey(beginWord)) return new ArrayList<>();\\n        List<List<String>> next = new ArrayList<>();\\n        for (String s : graph.get(beginWord)) {\\n            next.addAll(traverseLadderGraph(graph, s, endWord));\\n        }\\n        buf.put(beginWord, new ArrayList<>());\\n        for (List<String> route : next) {\\n            List<String> l = new ArrayList<>(route);\\n            l.add(0, beginWord);\\n            buf.get(beginWord).add(l);\\n        }\\n        return buf.get(beginWord);\\n    }\\n\\n    private Map<String, List<String>> buildLadderGraph(String beginWord, String endWord, List<String> wordList) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        Set<String> needDelete = new HashSet<>();\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        boolean flag = false;\\n        int size = q.size();\\n        while (!q.isEmpty()) {\\n            String s = q.poll();\\n            map.put(s, new ArrayList<>());\\n            for (String word : wordList) {\\n                if (isLadder(word, s)) {\\n                    if (!needDelete.contains(word)) q.offer(word);\\n                    needDelete.add(word);\\n                    map.get(s).add(word);\\n                    if (word.equals(endWord)) flag = true;\\n                }\\n            }\\n            if (--size == 0) {\\n                if (flag) break;\\n                int len = wordList.size();\\n                for (int i = 0; i < len; i++) if (!needDelete.contains(wordList.get(i))) wordList.add(wordList.get(i));\\n                wordList = wordList.subList(len, wordList.size());\\n                needDelete = new HashSet<>();\\n                size = q.size();\\n            }\\n        }\\n        return map;\\n    }\\n\\n    private boolean remove(List<String> wordList, String endWord) {\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (wordList.get(i).equals(endWord)) {\\n                Collections.swap(wordList, i, wordList.size() - 1);\\n                wordList.remove(wordList.size() - 1);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isLadder(String a, String b) {\\n        int diff = 0;\\n        for (int i = 0; i < a.length(); i++) if (a.charAt(i) != b.charAt(i)) diff++;\\n        return diff == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "``` java\\nclass Solution {\\n    Map<String, List<List<String>>> buf;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        if (!remove(wordList, endWord)) return new ArrayList<>();\\n        remove(wordList, beginWord);\\n        wordList.add(endWord);\\n        buf = new HashMap<>();\\n        Map<String, List<String>> graph = buildLadderGraph(beginWord, endWord, wordList);\\n        traverseLadderGraph(graph, beginWord, endWord);\\n        return buf.getOrDefault(beginWord, new ArrayList<>());\\n    }\\n\\n    private List<List<String>> traverseLadderGraph(Map<String, List<String>> graph, String beginWord, String endWord) {\\n        if (beginWord.equals(endWord)) {\\n            buf.put(beginWord, new ArrayList<>());\\n            buf.get(beginWord).add(new ArrayList<>(Arrays.asList(endWord)));\\n            return buf.get(beginWord);\\n        }\\n        if (buf.containsKey(beginWord)) return buf.get(beginWord);\\n        if (!graph.containsKey(beginWord)) return new ArrayList<>();\\n        List<List<String>> next = new ArrayList<>();\\n        for (String s : graph.get(beginWord)) {\\n            next.addAll(traverseLadderGraph(graph, s, endWord));\\n        }\\n        buf.put(beginWord, new ArrayList<>());\\n        for (List<String> route : next) {\\n            List<String> l = new ArrayList<>(route);\\n            l.add(0, beginWord);\\n            buf.get(beginWord).add(l);\\n        }\\n        return buf.get(beginWord);\\n    }\\n\\n    private Map<String, List<String>> buildLadderGraph(String beginWord, String endWord, List<String> wordList) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        Set<String> needDelete = new HashSet<>();\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        boolean flag = false;\\n        int size = q.size();\\n        while (!q.isEmpty()) {\\n            String s = q.poll();\\n            map.put(s, new ArrayList<>());\\n            for (String word : wordList) {\\n                if (isLadder(word, s)) {\\n                    if (!needDelete.contains(word)) q.offer(word);\\n                    needDelete.add(word);\\n                    map.get(s).add(word);\\n                    if (word.equals(endWord)) flag = true;\\n                }\\n            }\\n            if (--size == 0) {\\n                if (flag) break;\\n                int len = wordList.size();\\n                for (int i = 0; i < len; i++) if (!needDelete.contains(wordList.get(i))) wordList.add(wordList.get(i));\\n                wordList = wordList.subList(len, wordList.size());\\n                needDelete = new HashSet<>();\\n                size = q.size();\\n            }\\n        }\\n        return map;\\n    }\\n\\n    private boolean remove(List<String> wordList, String endWord) {\\n        for (int i = 0; i < wordList.size(); i++) {\\n            if (wordList.get(i).equals(endWord)) {\\n                Collections.swap(wordList, i, wordList.size() - 1);\\n                wordList.remove(wordList.size() - 1);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isLadder(String a, String b) {\\n        int diff = 0;\\n        for (int i = 0; i < a.length(); i++) if (a.charAt(i) != b.charAt(i)) diff++;\\n        return diff == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201956,
                "title": "python3-time-90-58-space-16-89",
                "content": "* BFS to keep valid word-to-word hops at each level (bfsedge)\\n* DFS backwards using the bfsedge\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList):\\n        res = []\\n        edge = collections.defaultdict(set)\\n        wordList = set(wordList)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                edge[word[:i] +\\'*\\'+word[i+1:]].add(word)\\n        bfsedge = {}\\n\\n        def bfs():\\n            minl = 0\\n            queue = set()\\n            queue.add(beginWord)\\n            while queue:\\n                next_queue = set()\\n                for word in queue:\\n                    if word in wordList:\\n                        wordList.remove(word)\\n                bfsedge[minl] = collections.defaultdict(set)\\n                for word in queue:\\n                    if word == endWord:\\n                        return minl\\n                    for i in range(len(word)):\\n                        for w in edge[word[:i]+\\'*\\'+word[i+1:]]:\\n                            if w in wordList:\\n                                next_queue.add(w)\\n                                bfsedge[minl][w].add(word)\\n                queue = next_queue\\n                minl += 1\\n            return minl\\n\\n        def dfs(seq, endWord):\\n            if seq[-1] == endWord:\\n                res.append(seq.copy())\\n                return\\n            for nextWord in bfsedge[minl-len(seq)][seq[-1]]:\\n                if nextWord not in seq:\\n                    dfs(seq+[nextWord], endWord)\\n\\n        minl = bfs()\\n        dfs([endWord], beginWord)\\n        # reverse the sequence\\n        for sq in res:\\n            sq.reverse()\\n        return res\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList):\\n        res = []\\n        edge = collections.defaultdict(set)\\n        wordList = set(wordList)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                edge[word[:i] +\\'*\\'+word[i+1:]].add(word)\\n        bfsedge = {}\\n\\n        def bfs():\\n            minl = 0\\n            queue = set()\\n            queue.add(beginWord)\\n            while queue:\\n                next_queue = set()\\n                for word in queue:\\n                    if word in wordList:\\n                        wordList.remove(word)\\n                bfsedge[minl] = collections.defaultdict(set)\\n                for word in queue:\\n                    if word == endWord:\\n                        return minl\\n                    for i in range(len(word)):\\n                        for w in edge[word[:i]+\\'*\\'+word[i+1:]]:\\n                            if w in wordList:\\n                                next_queue.add(w)\\n                                bfsedge[minl][w].add(word)\\n                queue = next_queue\\n                minl += 1\\n            return minl\\n\\n        def dfs(seq, endWord):\\n            if seq[-1] == endWord:\\n                res.append(seq.copy())\\n                return\\n            for nextWord in bfsedge[minl-len(seq)][seq[-1]]:\\n                if nextWord not in seq:\\n                    dfs(seq+[nextWord], endWord)\\n\\n        minl = bfs()\\n        dfs([endWord], beginWord)\\n        # reverse the sequence\\n        for sq in res:\\n            sq.reverse()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016509,
                "title": "python3-bfs-clean",
                "content": "```\\ndef is_difference_one(word1, word2):\\n    different_chars = 0\\n    for char1, char2 in zip(word1, word2):\\n        if char1 != char2:\\n            different_chars +=1 \\n    \\n    return different_chars == 1\\n\\ndef build_graph(wordList):\\n    length = len(wordList)\\n    graph = defaultdict(lambda: set())\\n\\n    for i in range(length):\\n        for j in range(i+1, length):\\n            word1 = wordList[i]\\n            word2 = wordList[j]\\n            if is_difference_one(word1, word2):\\n                graph[word1].add(word2)\\n                graph[word2].add(word1)\\n    \\n    return graph\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        wordList.append(beginWord)        \\n        graph = build_graph(wordList)\\n                    \\n        queue = [(beginWord, [])]\\n        visited = set()\\n        result = defaultdict(lambda: [])\\n\\n        while queue:\\n            word, path = queue.pop(0)\\n            path.append(word)\\n            visited.add(word)\\n\\n            if word == endWord:\\n                result[len(path)].append(path[::])\\n                continue\\n\\n            for nbr in graph[word]:\\n                if nbr not in visited:\\n                    queue.append((nbr, path[::]))\\n        \\n        if not result:\\n            return []\\n\\n        return result[min(result)]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef is_difference_one(word1, word2):\\n    different_chars = 0\\n    for char1, char2 in zip(word1, word2):\\n        if char1 != char2:\\n            different_chars +=1 \\n    \\n    return different_chars == 1\\n\\ndef build_graph(wordList):\\n    length = len(wordList)\\n    graph = defaultdict(lambda: set())\\n\\n    for i in range(length):\\n        for j in range(i+1, length):\\n            word1 = wordList[i]\\n            word2 = wordList[j]\\n            if is_difference_one(word1, word2):\\n                graph[word1].add(word2)\\n                graph[word2].add(word1)\\n    \\n    return graph\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        wordList.append(beginWord)        \\n        graph = build_graph(wordList)\\n                    \\n        queue = [(beginWord, [])]\\n        visited = set()\\n        result = defaultdict(lambda: [])\\n\\n        while queue:\\n            word, path = queue.pop(0)\\n            path.append(word)\\n            visited.add(word)\\n\\n            if word == endWord:\\n                result[len(path)].append(path[::])\\n                continue\\n\\n            for nbr in graph[word]:\\n                if nbr not in visited:\\n                    queue.append((nbr, path[::]))\\n        \\n        if not result:\\n            return []\\n\\n        return result[min(result)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890299,
                "title": "python-bfs-dfs-beats100",
                "content": "```python\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        prefix_d = defaultdict(list)\\n        for word in wordList:\\n            for i in range(0,len(word)):\\n                prefix_d[word[0:i]+\"*\"+word[i+1:]].append(word)\\n        \\n        order = {beginWord: []}\\n        queue = deque([beginWord])\\n        temp_q = deque()\\n        go_on = True\\n        end_list = []\\n        \\n        while queue and go_on:  # There is no node even added to temp_q\\n            temp_d = {}\\n            while queue:        # Pop every node on this level\\n                cur = queue.popleft()\\n                for i in range(0, len(cur)):\\n                    for j in prefix_d[cur[0:i]+\"*\"+cur[i+1:]]:\\n                        if j == endWord:\\n                            end_list.append(j)\\n                            go_on = False\\n                        if j not in order:\\n                            if j not in temp_d:\\n                                temp_d[j] = [cur]\\n                                temp_q.append(j)\\n                            else:\\n                                temp_d[j].append(cur)\\n            queue = temp_q\\n            temp_q = deque()\\n            order.update(temp_d)\\n        \\n        ret = []\\n        \\n        # DFS to restore the paths\\n        def dfs(path, node):\\n            path = path + [node]    # add the node(Deepcopy)\\n            if order[node] == []:\\n                ret.append(list(path[::-1]))\\n                return\\n            for i in order[node]:\\n                dfs(path, i)\\n        if endWord in order:\\n            dfs([], endWord)\\n        else:\\n            return []\\n        \\n        return ret\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        prefix_d = defaultdict(list)\\n        for word in wordList:\\n            for i in range(0,len(word)):\\n                prefix_d[word[0:i]+\"*\"+word[i+1:]].append(word)\\n        \\n        order = {beginWord: []}\\n        queue = deque([beginWord])\\n        temp_q = deque()\\n        go_on = True\\n        end_list = []\\n        \\n        while queue and go_on:  # There is no node even added to temp_q\\n            temp_d = {}\\n            while queue:        # Pop every node on this level\\n                cur = queue.popleft()\\n                for i in range(0, len(cur)):\\n                    for j in prefix_d[cur[0:i]+\"*\"+cur[i+1:]]:\\n                        if j == endWord:\\n                            end_list.append(j)\\n                            go_on = False\\n                        if j not in order:\\n                            if j not in temp_d:\\n                                temp_d[j] = [cur]\\n                                temp_q.append(j)\\n                            else:\\n                                temp_d[j].append(cur)\\n            queue = temp_q\\n            temp_q = deque()\\n            order.update(temp_d)\\n        \\n        ret = []\\n        \\n        # DFS to restore the paths\\n        def dfs(path, node):\\n            path = path + [node]    # add the node(Deepcopy)\\n            if order[node] == []:\\n                ret.append(list(path[::-1]))\\n                return\\n            for i in order[node]:\\n                dfs(path, i)\\n        if endWord in order:\\n            dfs([], endWord)\\n        else:\\n            return []\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187494,
                "title": "python-solution-easy-understanding",
                "content": "from collections import defaultdict, deque\\nclass Solution:\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        d = defaultdict(list)\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        ans = []\\n        if endWord not in wordList:\\n            return []\\n        \\n        for i in range(len(wordList)-1): # we want to create a dictionary where d[word] stores all other words differs by a single letter.\\n            for j in range(i+1,len(wordList)):\\n                count = 0\\n                for k in range(len(beginWord)):\\n                    if wordList[i][k]!=wordList[j][k]:\\n                        count+=1\\n                if count == 1:\\n                    d[wordList[i]].append(wordList[j])\\n                    d[wordList[j]].append(wordList[i])\\n\\n        visited = set()\\n        stack = deque([[beginWord]])\\n        while(stack): #BFS and record all the shortest path \\n            path = stack.popleft()\\n            if path[-1] == endWord:\\n                if not ans or len(ans[0]) == len(path):\\n                    ans.append(path)\\n                else:\\n                    break\\n            else:\\n                visited.add(path[-1])\\n            \\n            for next_step in d[path[-1]]: # avoid visiting the same word again \\n                if next_step not in visited:\\n                    stack.append(path+[next_step])\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import defaultdict, deque\\nclass Solution:\\n\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        d = defaultdict(list)\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        ans = []\\n        if endWord not in wordList:\\n            return []\\n        \\n        for i in range(len(wordList)-1): # we want to create a dictionary where d[word] stores all other words differs by a single letter.\\n            for j in range(i+1,len(wordList)):\\n                count = 0\\n                for k in range(len(beginWord)):\\n                    if wordList[i][k]!=wordList[j][k]:\\n                        count+=1\\n                if count == 1:\\n                    d[wordList[i]].append(wordList[j])\\n                    d[wordList[j]].append(wordList[i])\\n\\n        visited = set()\\n        stack = deque([[beginWord]])\\n        while(stack): #BFS and record all the shortest path \\n            path = stack.popleft()\\n            if path[-1] == endWord:\\n                if not ans or len(ans[0]) == len(path):\\n                    ans.append(path)\\n                else:\\n                    break\\n            else:\\n                visited.add(path[-1])\\n            \\n            for next_step in d[path[-1]]: # avoid visiting the same word again \\n                if next_step not in visited:\\n                    stack.append(path+[next_step])\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1142161,
                "title": "java-65-faster-96ms-bfs-dfs-dp-in-dfs-all-new-test-cases",
                "content": "There are 2 components to this question.\\n1. Creating Effective Graph\\n2. Parsing this graph for best paths.\\n\\nWhile creating graph ensures there is no back node(i.e, node pointing backwards) or node at same level(i.e, we won\\'t connect 2 nodes that are same level with respect to beginWord). With this, we reduce the number of nodes that will later help in doing DFS.  \\n\\nParsing the graph for shortest paths: We will need to store from what all nodes we can reach to end. otherwise that would result in TLE. \\n\\n```\\npublic class Solution {\\n    List<List<String>> result;\\n    HashMap<String, Boolean> dpDfs;\\n\\n    public List<List<String>> findLadders(String start, String end, List<String> words) {\\n        this.result = new ArrayList<>();\\n        HashSet<String> set = new HashSet<>(words);\\n        if(!set.contains(end)) return result;\\n        set.add(start);\\n\\n        // construct graph\\n        HashMap<String, List<String>> graph = new HashMap<>();\\n        HashMap<String, Integer> levelTracker = new HashMap<>();\\n\\n        constructGraph(graph, levelTracker, set, start, end);\\n        /**\\n         * for word ladder simply return level.get(end)\\n         * return level.getOrDefault(end, 0);\\n         */\\n\\n        // to print paths do DFS from start till level level.getOrDefault(end, 0)\\n        if(levelTracker.containsKey(end)) {\\n            this.dpDfs = new HashMap<>();\\n            dfs(graph, levelTracker.get(end), end, start, 1, new LinkedList<>());\\n        }\\n        return result;\\n    }\\n\\n    private boolean dfs(HashMap<String, List<String>> graph, int maxLevel, String end, String start, int currLevel, LinkedList<String> paths) {\\n        paths.add(start);\\n        if (currLevel == maxLevel) {\\n            if (start.equals(end)) {\\n                result.add(new ArrayList<>(paths));\\n                paths.removeLast();\\n                return true;\\n            }\\n            paths.removeLast();\\n            return false;\\n        }\\n\\n        boolean ans = false;\\n        for (String node : graph.get(start)) {\\n            if(!this.dpDfs.containsKey(node)) {\\n                boolean b = dfs(graph, maxLevel, end, node, currLevel + 1, paths);\\n                ans = ans || b;\\n                this.dpDfs.put(node, b);\\n            } else if(this.dpDfs.get(node)) {\\n                ans = true;\\n                dfs(graph, maxLevel, end, node, currLevel + 1, paths);\\n            }\\n        }\\n        paths.removeLast();\\n        this.dpDfs.put(start, ans);\\n        return this.dpDfs.get(start);\\n    }\\n\\n    /**\\n     * @param graph stores graph representation\\n     * @param visited keeps the level of the each node in BFS\\n     * This graph only keeps forward nodes that will point to next level.\\n     */\\n    private void constructGraph(HashMap<String, List<String>> graph, HashMap<String, Integer> visited, HashSet<String> set, String start, String end) {\\n        // BFS for making graph\\n        Queue<String> queue = new LinkedList<>();\\n        visited.put(start, 1);\\n        queue.add(start);\\n        while (!queue.isEmpty()) {\\n            String s = queue.remove();\\n            graph.put(s, new ArrayList<>());\\n            int level = visited.get(s);\\n\\n            List<String> list = graph.get(s);\\n\\n            char[] ch = s.toCharArray();\\n            for(int i = 0; i < ch.length; i++) {\\n                char t = ch[i];\\n                for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    if(ch[i] == j) continue;\\n                    ch[i] = j;\\n                    String str = String.valueOf(ch);\\n                    if(set.contains(str)) {\\n                        int curLevel = visited.getOrDefault(str, 0);\\n                        if(curLevel == 0) {\\n                            visited.put(str, level + 1);\\n                            queue.add(str);\\n                            list.add(str);\\n                        } else if(curLevel > level) list.add(str);\\n                    }\\n                }\\n                ch[i] = t;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nPS: Please upvote if you like the solution",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    List<List<String>> result;\\n    HashMap<String, Boolean> dpDfs;\\n\\n    public List<List<String>> findLadders(String start, String end, List<String> words) {\\n        this.result = new ArrayList<>();\\n        HashSet<String> set = new HashSet<>(words);\\n        if(!set.contains(end)) return result;\\n        set.add(start);\\n\\n        // construct graph\\n        HashMap<String, List<String>> graph = new HashMap<>();\\n        HashMap<String, Integer> levelTracker = new HashMap<>();\\n\\n        constructGraph(graph, levelTracker, set, start, end);\\n        /**\\n         * for word ladder simply return level.get(end)\\n         * return level.getOrDefault(end, 0);\\n         */\\n\\n        // to print paths do DFS from start till level level.getOrDefault(end, 0)\\n        if(levelTracker.containsKey(end)) {\\n            this.dpDfs = new HashMap<>();\\n            dfs(graph, levelTracker.get(end), end, start, 1, new LinkedList<>());\\n        }\\n        return result;\\n    }\\n\\n    private boolean dfs(HashMap<String, List<String>> graph, int maxLevel, String end, String start, int currLevel, LinkedList<String> paths) {\\n        paths.add(start);\\n        if (currLevel == maxLevel) {\\n            if (start.equals(end)) {\\n                result.add(new ArrayList<>(paths));\\n                paths.removeLast();\\n                return true;\\n            }\\n            paths.removeLast();\\n            return false;\\n        }\\n\\n        boolean ans = false;\\n        for (String node : graph.get(start)) {\\n            if(!this.dpDfs.containsKey(node)) {\\n                boolean b = dfs(graph, maxLevel, end, node, currLevel + 1, paths);\\n                ans = ans || b;\\n                this.dpDfs.put(node, b);\\n            } else if(this.dpDfs.get(node)) {\\n                ans = true;\\n                dfs(graph, maxLevel, end, node, currLevel + 1, paths);\\n            }\\n        }\\n        paths.removeLast();\\n        this.dpDfs.put(start, ans);\\n        return this.dpDfs.get(start);\\n    }\\n\\n    /**\\n     * @param graph stores graph representation\\n     * @param visited keeps the level of the each node in BFS\\n     * This graph only keeps forward nodes that will point to next level.\\n     */\\n    private void constructGraph(HashMap<String, List<String>> graph, HashMap<String, Integer> visited, HashSet<String> set, String start, String end) {\\n        // BFS for making graph\\n        Queue<String> queue = new LinkedList<>();\\n        visited.put(start, 1);\\n        queue.add(start);\\n        while (!queue.isEmpty()) {\\n            String s = queue.remove();\\n            graph.put(s, new ArrayList<>());\\n            int level = visited.get(s);\\n\\n            List<String> list = graph.get(s);\\n\\n            char[] ch = s.toCharArray();\\n            for(int i = 0; i < ch.length; i++) {\\n                char t = ch[i];\\n                for(char j = \\'a\\'; j <= \\'z\\'; j++) {\\n                    if(ch[i] == j) continue;\\n                    ch[i] = j;\\n                    String str = String.valueOf(ch);\\n                    if(set.contains(str)) {\\n                        int curLevel = visited.getOrDefault(str, 0);\\n                        if(curLevel == 0) {\\n                            visited.put(str, level + 1);\\n                            queue.add(str);\\n                            list.add(str);\\n                        } else if(curLevel > level) list.add(str);\\n                    }\\n                }\\n                ch[i] = t;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894707,
                "title": "short-java",
                "content": "This is similar to [127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/811753/Evolve-from-intuition-to-optimal) but more difficult. I would like to share my thinking process that leads to an easy solution.\\n1. Normally we use a queue to implement BFS. Since the problem asks for shortest path, we need to visit the nodes level by level. A visited set is usually used to avoid visiting duplicate nodes. The problem is hard due to an implicit requirement: ***we need to consider duplicate nodes at the same level but only expand from distinct nodes when generating the next level***. Ex, both a and b can be transformed to c and they are distinct paths {a->c, b->c}. The visited set can be implemented to not include nodes in the new level and we need another set to dedupe the level. Since we already use a set to store nodes in a level, we no longer need queue. We can just use the set for BFS. If we still use queue, then we have to move nodes from the set to queue which can be avoided.\\n2. In BFS, we need to 1) check if a node visited  and 2) mark a node visited to avoid searching the same word.\\n2.1 Check visited nodes\\nWe only add nodes on shortest path to graph. If we add a visited node to graph, then it is not a shortest path and result could be wrong. So we have to check visted nodes before adding it to graph. The only place we can add to graph is when expending a node where we have both the parent and the child. \\n2.2 Mark a node visited\\nWhen we expand to a node from its parent, we cannot mark the node visited because we need to visit duplicate nodes at the same level. After a level is generated, we mark all node in the level visited before visiting any node. If we generate the next level without marking every node in the previous level visited, we will visit duplicate nodes and that\\'s not the shortest path.\\n3. The words must be in the dictionary. The idea is same as 2.1. We only add valid word to graph. If we add invalid word to graph, the result could be wrong. Ex, if endWord is not in dictionary but added to grap and it is wrong. So we have to check dictionary before add a node to graph.\\n* BFS\\n```\\n\\tpublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict=new HashSet(wordList);\\n        Map<String, List<String>> adjLst=bfs(beginWord, endWord, dict);\\n        List<List<String>> res=new ArrayList<>();\\n        if(!adjLst.containsKey(endWord)) return res;\\n        List<String> path=new ArrayList<>();\\n        dfs(endWord,path,adjLst,res);\\n        return res;\\n    }\\n    private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> vstd=new HashSet<>();\\n        Set<String> lvl=new HashSet<>();\\n        lvl.add(begin);\\n        boolean found=false;\\n        while(!found&&!lvl.isEmpty()) {\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: lvl) vstd.add(word);\\n            for(String word: lvl) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!dict.contains(nw)||vstd.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        adjLst.putIfAbsent(nw, new ArrayList<>());\\n                        adjLst.get(nw).add(word);\\n                        if(nw.equals(end)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            lvl=nxt;\\n        }\\n        return adjLst;\\n    }\\n    private void dfs(String start, List<String> path, Map<String,List<String>> adjLst, List<List<String>> paths) {\\n        path.add(start);\\n        if(adjLst.containsKey(start)) {\\n            for(String word:adjLst.get(start)) \\n                dfs(word,path,adjLst,paths);\\n        } else {\\n            List<String> lst=new ArrayList(path);\\n            Collections.reverse(lst);\\n            paths.add(lst);\\n        }\\n        path.remove(path.size()-1);\\n    }\\n```\\nFrom 2.1 and 3, we can see that visited check and dictionary check are performed at the same place. So we can use the dictionary to keep track of visited nodes. We can mark a word visited by removing it from the dictionary. A word in dictionary means it is valid and not visited. A word not in dictionary means it is invalid or visited.\\n* BFS without visited set\\n```\\n\\t private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> lvl=new HashSet<>();\\n        lvl.add(begin);\\n        boolean found=false;\\n        while(!found&&!lvl.isEmpty()) {\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: lvl) dict.remove(word);\\n            for(String word: lvl) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!dict.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        adjLst.putIfAbsent(nw, new ArrayList<>());\\n                        adjLst.get(nw).add(word);\\n                        if(nw.equals(end)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            lvl=nxt;\\n        }\\n        return adjLst;\\n    }\\n```\\n*  Two end BFS\\n```\\n\\tpublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict=new HashSet(wordList);\\n        List<List<String>> res=new ArrayList<>();\\n        if(!dict.remove(endWord)) return res;\\n        dfs(endWord,beginWord,new ArrayList<>(),bfs(beginWord, endWord, dict),res);\\n        return res;\\n    }\\n    private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> small=new HashSet<>(), large=new HashSet<>();\\n        small.add(begin);\\n        large.add(end);\\n        boolean found=false, isStart=true;\\n        while(!found&&!small.isEmpty()&&!large.isEmpty()) {\\n            for(String word: small) dict.remove(word);\\n            if(small.size()>large.size()) {\\n                Set<String> temp=small;\\n                small=large;\\n                large=temp;\\n                isStart=!isStart;\\n            }\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: small) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!large.contains(nw) && !dict.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        String parent = isStart? word:nw, child= isStart?nw:word;\\n                        adjLst.putIfAbsent(child, new ArrayList<>());\\n                        adjLst.get(child).add(parent);\\n                        if(large.contains(nw)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            small=nxt;\\n        }\\n        return adjLst;\\n    }\\n    private void dfs(String start, String end, List<String> path, Map<String,List<String>> adjLst, List<List<String>> paths) {\\n        path.add(start);\\n        if(start.equals(end)) {\\n            List<String> lst=new ArrayList(path);\\n            Collections.reverse(lst);\\n            paths.add(lst);\\n        }\\n        for(String word:adjLst.getOrDefault(start,new ArrayList<>())) \\n            dfs(word,end,path,adjLst,paths);    \\n        path.remove(path.size()-1);\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict=new HashSet(wordList);\\n        Map<String, List<String>> adjLst=bfs(beginWord, endWord, dict);\\n        List<List<String>> res=new ArrayList<>();\\n        if(!adjLst.containsKey(endWord)) return res;\\n        List<String> path=new ArrayList<>();\\n        dfs(endWord,path,adjLst,res);\\n        return res;\\n    }\\n    private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> vstd=new HashSet<>();\\n        Set<String> lvl=new HashSet<>();\\n        lvl.add(begin);\\n        boolean found=false;\\n        while(!found&&!lvl.isEmpty()) {\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: lvl) vstd.add(word);\\n            for(String word: lvl) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!dict.contains(nw)||vstd.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        adjLst.putIfAbsent(nw, new ArrayList<>());\\n                        adjLst.get(nw).add(word);\\n                        if(nw.equals(end)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            lvl=nxt;\\n        }\\n        return adjLst;\\n    }\\n    private void dfs(String start, List<String> path, Map<String,List<String>> adjLst, List<List<String>> paths) {\\n        path.add(start);\\n        if(adjLst.containsKey(start)) {\\n            for(String word:adjLst.get(start)) \\n                dfs(word,path,adjLst,paths);\\n        } else {\\n            List<String> lst=new ArrayList(path);\\n            Collections.reverse(lst);\\n            paths.add(lst);\\n        }\\n        path.remove(path.size()-1);\\n    }\\n```\n```\\n\\t private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> lvl=new HashSet<>();\\n        lvl.add(begin);\\n        boolean found=false;\\n        while(!found&&!lvl.isEmpty()) {\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: lvl) dict.remove(word);\\n            for(String word: lvl) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!dict.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        adjLst.putIfAbsent(nw, new ArrayList<>());\\n                        adjLst.get(nw).add(word);\\n                        if(nw.equals(end)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            lvl=nxt;\\n        }\\n        return adjLst;\\n    }\\n```\n```\\n\\tpublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> dict=new HashSet(wordList);\\n        List<List<String>> res=new ArrayList<>();\\n        if(!dict.remove(endWord)) return res;\\n        dfs(endWord,beginWord,new ArrayList<>(),bfs(beginWord, endWord, dict),res);\\n        return res;\\n    }\\n    private Map<String,List<String>> bfs(String begin, String end, Set<String> dict) {\\n        Map<String,List<String>> adjLst=new HashMap<>();\\n        Set<String> small=new HashSet<>(), large=new HashSet<>();\\n        small.add(begin);\\n        large.add(end);\\n        boolean found=false, isStart=true;\\n        while(!found&&!small.isEmpty()&&!large.isEmpty()) {\\n            for(String word: small) dict.remove(word);\\n            if(small.size()>large.size()) {\\n                Set<String> temp=small;\\n                small=large;\\n                large=temp;\\n                isStart=!isStart;\\n            }\\n            Set<String> nxt=new HashSet<>();\\n            for(String word: small) {\\n                char[] chars=word.toCharArray();\\n                for(int i=0;i<chars.length;i++) {\\n                    char ch=chars[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++) {\\n                        if(c==ch) continue;\\n                        chars[i]=c;\\n                        String nw=new String(chars);\\n                        if(!large.contains(nw) && !dict.contains(nw)) continue; \\n                        nxt.add(nw);\\n                        String parent = isStart? word:nw, child= isStart?nw:word;\\n                        adjLst.putIfAbsent(child, new ArrayList<>());\\n                        adjLst.get(child).add(parent);\\n                        if(large.contains(nw)) found=true;\\n                    }                   \\n                    chars[i]=ch;                    \\n                }\\n            }\\n            small=nxt;\\n        }\\n        return adjLst;\\n    }\\n    private void dfs(String start, String end, List<String> path, Map<String,List<String>> adjLst, List<List<String>> paths) {\\n        path.add(start);\\n        if(start.equals(end)) {\\n            List<String> lst=new ArrayList(path);\\n            Collections.reverse(lst);\\n            paths.add(lst);\\n        }\\n        for(String word:adjLst.getOrDefault(start,new ArrayList<>())) \\n            dfs(word,end,path,adjLst,paths);    \\n        path.remove(path.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 808986,
                "title": "very-clean-python-3-code-with-only-one-bfs",
                "content": "\\n\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        if not wordList or endWord not in wordList:\\n            return []\\n        \\n\\t\\t# 1. Construct a star mapping. e.g. \\'*og\\' -> [\\'dog\\', \\'log\\']\\n        starMapping = defaultdict(list)\\n        # Add beginword to list. So the list contains all the words\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                starWord = word[:i] + \\'*\\' + word[i + 1:]\\n                starMapping[starWord].append(word)\\n        \\n\\t\\t# 2. Use the star mapping to contruct a graph mapping. e.g. \\'hot\\' -> [\\'dot\\', \\'lot\\'], \\'dot\\' -> [\\'hot\\', \\'lot\\']\\n        graph = defaultdict(list)\\n        for starWord, words in starMapping.items():\\n            if len(words) > 1:\\n                for i in range(len(words)):\\n                    graph[words[i]] = graph[words[i]] + words[:i] + words[i + 1:]\\n                    \\n\\t\\t# 3. Use BFS. Stop once found the endWord. Store each level of the graph into levels. Similar to \"Tree Level Traverse\". Note that don\\'t put the level of the endWord in the levels\\n        queue = deque([beginWord])\\n        visited = set([beginWord])\\n        found = False\\n        levels = []\\n        \\n        while queue and not found:\\n            queueSize = len(queue)\\n            row = set()\\n            for i in range(queueSize):\\n                node = queue.popleft()\\n                row.add(node)\\n                for neighbor in graph[node]:\\n                    if neighbor not in visited:\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n                    # Check the endWord in neighbor value to avoid traverse the level of the endWord\\n                    if neighbor == endWord:\\n                        found = True\\n            levels.append(row)\\n        \\n\\t\\t# 4. Construct the result. Steps here is \\n\\t\\t#  a) Reverse the levels. So levels would be [[dog, log], [dot, lot], [hot], [hit]]\\n\\t\\t#  b) Construct the result from end to beginning. We need to loop for len(levels) time. And in each loop, we need to check the corresponding level.\\n        result = [[endWord]]\\n        levels.reverse()\\n        for i in range(len(levels)):\\n            backPathNum = len(result)\\n            for j in range(backPathNum):\\n                backPath = result.pop(0)\\n                head = backPath[0]\\n                for node in levels[i]:\\n                    if node in graph[head]:\\n                        newPath = copy.deepcopy(backPath)\\n                        newPath.insert(0, node)\\n                        result.append(newPath)\\n                        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        if not wordList or endWord not in wordList:\\n            return []\\n        \\n\\t\\t# 1. Construct a star mapping. e.g. \\'*og\\' -> [\\'dog\\', \\'log\\']\\n        starMapping = defaultdict(list)\\n        # Add beginword to list. So the list contains all the words\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                starWord = word[:i] + \\'*\\' + word[i + 1:]\\n                starMapping[starWord].append(word)\\n        \\n\\t\\t# 2. Use the star mapping to contruct a graph mapping. e.g. \\'hot\\' -> [\\'dot\\', \\'lot\\'], \\'dot\\' -> [\\'hot\\', \\'lot\\']\\n        graph = defaultdict(list)\\n        for starWord, words in starMapping.items():\\n            if len(words) > 1:\\n                for i in range(len(words)):\\n                    graph[words[i]] = graph[words[i]] + words[:i] + words[i + 1:]\\n                    \\n\\t\\t# 3. Use BFS. Stop once found the endWord. Store each level of the graph into levels. Similar to \"Tree Level Traverse\". Note that don\\'t put the level of the endWord in the levels\\n        queue = deque([beginWord])\\n        visited = set([beginWord])\\n        found = False\\n        levels = []\\n        \\n        while queue and not found:\\n            queueSize = len(queue)\\n            row = set()\\n            for i in range(queueSize):\\n                node = queue.popleft()\\n                row.add(node)\\n                for neighbor in graph[node]:\\n                    if neighbor not in visited:\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n                    # Check the endWord in neighbor value to avoid traverse the level of the endWord\\n                    if neighbor == endWord:\\n                        found = True\\n            levels.append(row)\\n        \\n\\t\\t# 4. Construct the result. Steps here is \\n\\t\\t#  a) Reverse the levels. So levels would be [[dog, log], [dot, lot], [hot], [hit]]\\n\\t\\t#  b) Construct the result from end to beginning. We need to loop for len(levels) time. And in each loop, we need to check the corresponding level.\\n        result = [[endWord]]\\n        levels.reverse()\\n        for i in range(len(levels)):\\n            backPathNum = len(result)\\n            for j in range(backPathNum):\\n                backPath = result.pop(0)\\n                head = backPath[0]\\n                for node in levels[i]:\\n                    if node in graph[head]:\\n                        newPath = copy.deepcopy(backPath)\\n                        newPath.insert(0, node)\\n                        result.append(newPath)\\n                        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649053,
                "title": "python-tree-bfs-method-explained-and-easy-to-understand-with-comments",
                "content": "As we go through the possible ways of reaching a particular endWord from a beginWord. We can see that it forms a tree.\\n\\nExample:\\n```\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput:\\n[\\n  [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\\n  [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\\n]\\n\\n        hit----hot----dot----dog----log\\n                \\\\              \\\\\\n                 \\\\----lot       \\\\---*cog*\\n                       \\\\             \\n                        \\\\----log----*cog*\\n```\\n\\nSo why not create a tree structure that can store these values and just transverse the tree to get the results we want.\\n\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t# A TreeNode class that can form part of N-ary tree structure\\n        class TreeNode:\\n            def __init__(self, val):\\n                self.val = val\\n                self.children = []\\n            \\n            def addChild(self, node):\\n                self.children.append(node)\\n            \\n            def getChildren(self):\\n                return self.children\\n                \\n        # Check if the endWord is in the wordList, if it isn\\'t, then it is impossible to achieve that word\\n\\t\\t# So return empty list\\n        if endWord not in wordList:\\n            return []\\n        \\n\\t\\t# This uses the same idea as Word Ladder I official solution\\n\\t\\t# Create a dictionary that contains intermediate words as keys and actual words as the values\\n        comboMap = collections.defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(beginWord)):\\n                comboMap[word[:i] + \"*\" + word[i+1:]].append(word)\\n                \\n        \\n        deque = collections.deque()\\n\\t\\t\\n\\t\\t# Visited set is used to prevent cycles\\n        visited = set()\\n\\t\\t\\n\\t\\t# Instead of using (word, level) pair, we are using (word, parent_node) pair\\n\\t\\t# This is done to easily access the parent node in the queue and create the tree structure\\n        deque.append((beginWord, None))\\n        root = None\\n\\n        while deque:\\n            currword, parent = deque.popleft()\\n\\t\\t\\n\\t\\t\\t# Create a TreeNode with the current word as the value\\n            node = TreeNode(currword)\\n            \\n\\t\\t\\t# If the word\\'s pair (i.e. the parent node) is not None\\n\\t\\t\\t# -> We can add this node as the child to that parent\\n\\t\\t\\t# else\\n\\t\\t\\t# -> We make the node the root node\\n            if parent:\\n                parent.addChild(node)\\n            else:\\n                root = node                         \\n            \\n\\t\\t\\t# If the currword is the endWord then no need to go past it, as this would only add combinations\\n\\t\\t\\t# greater in length\\n\\t\\t\\t# Therefore continue the loop\\n            if currword == endWord:\\n                continue\\n            \\n\\t\\t\\t# We add the currword to the visited set\\n            visited.add(currword)\\n            for i in range(len(currword)):\\n\\t\\t\\t\\t# Generate our intermediate word and add all of the words that are\\n\\t\\t\\t\\t# reachable from our intermediate word\\n                interword = currword[:i] + \"*\" + currword[i+1:]\\n                \\n                for word in comboMap[interword]:\\n                    if word not in visited:\\n                        deque.append((word, node))\\n        \\n        res = []\\n        \\n\\t\\t# Function that will travserse the tree we created and add to our res (result) list\\n        def traverseTree(root, curr):\\n            nonlocal res\\n            if root is None:\\n                return\\n            \\n            curr.append(root.val)\\n            \\n            if len(root.getChildren()) == 0 and root.val == endWord:\\n\\t\\t\\t\\t# If the length of res is 0, then we can add the curr list\\n                if len(res) == 0:\\n                    res.append(curr[:])\\n\\t\\t\\t\\t# If the length of the first element of res is equal to the length of the curr list\\n\\t\\t\\t\\t# This is another valid way of reaching the endWord, therefore add to res\\n                elif len(res[0]) == len(curr):\\n                    res.append(curr[:])\\n\\t\\t\\t\\t# If the length of the first element of res is greater than the length of curr list\\n\\t\\t\\t\\t# We know that all of the elements of res would be also greater than the lenght of curr list\\n\\t\\t\\t\\t# Therefore create new list and append curr list \\n                elif len(res[0]) > len(curr):\\n                    res = []\\n                    res.append(curr[:])\\n                    \\n            # Recursively traverse the children\\n            for child in root.getChildren():\\n                traverseTree(child, curr)\\n\\t\\t\\t\\n            curr.pop()\\n        \\n        traverseTree(root,[])\\n        \\n\\t\\t# Finally return our res (result) list\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput:\\n[\\n  [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\\n  [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\\n]\\n\\n        hit----hot----dot----dog----log\\n                \\\\              \\\\\\n                 \\\\----lot       \\\\---*cog*\\n                       \\\\             \\n                        \\\\----log----*cog*\\n```\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\t\\t# A TreeNode class that can form part of N-ary tree structure\\n        class TreeNode:\\n            def __init__(self, val):\\n                self.val = val\\n                self.children = []\\n            \\n            def addChild(self, node):\\n                self.children.append(node)\\n            \\n            def getChildren(self):\\n                return self.children\\n                \\n        # Check if the endWord is in the wordList, if it isn\\'t, then it is impossible to achieve that word\\n\\t\\t# So return empty list\\n        if endWord not in wordList:\\n            return []\\n        \\n\\t\\t# This uses the same idea as Word Ladder I official solution\\n\\t\\t# Create a dictionary that contains intermediate words as keys and actual words as the values\\n        comboMap = collections.defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(beginWord)):\\n                comboMap[word[:i] + \"*\" + word[i+1:]].append(word)\\n                \\n        \\n        deque = collections.deque()\\n\\t\\t\\n\\t\\t# Visited set is used to prevent cycles\\n        visited = set()\\n\\t\\t\\n\\t\\t# Instead of using (word, level) pair, we are using (word, parent_node) pair\\n\\t\\t# This is done to easily access the parent node in the queue and create the tree structure\\n        deque.append((beginWord, None))\\n        root = None\\n\\n        while deque:\\n            currword, parent = deque.popleft()\\n\\t\\t\\n\\t\\t\\t# Create a TreeNode with the current word as the value\\n            node = TreeNode(currword)\\n            \\n\\t\\t\\t# If the word\\'s pair (i.e. the parent node) is not None\\n\\t\\t\\t# -> We can add this node as the child to that parent\\n\\t\\t\\t# else\\n\\t\\t\\t# -> We make the node the root node\\n            if parent:\\n                parent.addChild(node)\\n            else:\\n                root = node                         \\n            \\n\\t\\t\\t# If the currword is the endWord then no need to go past it, as this would only add combinations\\n\\t\\t\\t# greater in length\\n\\t\\t\\t# Therefore continue the loop\\n            if currword == endWord:\\n                continue\\n            \\n\\t\\t\\t# We add the currword to the visited set\\n            visited.add(currword)\\n            for i in range(len(currword)):\\n\\t\\t\\t\\t# Generate our intermediate word and add all of the words that are\\n\\t\\t\\t\\t# reachable from our intermediate word\\n                interword = currword[:i] + \"*\" + currword[i+1:]\\n                \\n                for word in comboMap[interword]:\\n                    if word not in visited:\\n                        deque.append((word, node))\\n        \\n        res = []\\n        \\n\\t\\t# Function that will travserse the tree we created and add to our res (result) list\\n        def traverseTree(root, curr):\\n            nonlocal res\\n            if root is None:\\n                return\\n            \\n            curr.append(root.val)\\n            \\n            if len(root.getChildren()) == 0 and root.val == endWord:\\n\\t\\t\\t\\t# If the length of res is 0, then we can add the curr list\\n                if len(res) == 0:\\n                    res.append(curr[:])\\n\\t\\t\\t\\t# If the length of the first element of res is equal to the length of the curr list\\n\\t\\t\\t\\t# This is another valid way of reaching the endWord, therefore add to res\\n                elif len(res[0]) == len(curr):\\n                    res.append(curr[:])\\n\\t\\t\\t\\t# If the length of the first element of res is greater than the length of curr list\\n\\t\\t\\t\\t# We know that all of the elements of res would be also greater than the lenght of curr list\\n\\t\\t\\t\\t# Therefore create new list and append curr list \\n                elif len(res[0]) > len(curr):\\n                    res = []\\n                    res.append(curr[:])\\n                    \\n            # Recursively traverse the children\\n            for child in root.getChildren():\\n                traverseTree(child, curr)\\n\\t\\t\\t\\n            curr.pop()\\n        \\n        traverseTree(root,[])\\n        \\n\\t\\t# Finally return our res (result) list\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552191,
                "title": "relatively-very-concise-java-solution-64-lines",
                "content": "Idea is to keep track of the paths as you are implementing BFS. For this I use a helper class so my Queue contians paths, not strings. Also mark nodes as visited after each bfs loop, not during.\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Queue<Path> queue = new LinkedList<>();\\n        queue.add(new Path(beginWord, new ArrayList()));\\n        \\n        Set<String> wordDict = new HashSet();\\n        for(String s: wordList) wordDict.add(s);\\n        wordDict.remove(beginWord);\\n        boolean stop = false;\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        while(!queue.isEmpty() && !stop){\\n            int size = queue.size();\\n            \\n            List<String> neighborsToRemove = new ArrayList();\\n            for(int i=0;i<size;i++){\\n                Path p = queue.poll();\\n                String str = p.val;\\n                if(str.equals(endWord)) {\\n                    p.path.add(str);\\n                    result.add(p.path);\\n                    stop = true;\\n                }\\n                \\n                List<String> neighbors = neighbors(str,wordDict);\\n                neighborsToRemove.addAll(neighbors);\\n                for(String neighbor : neighbors){\\n                    ArrayList<String> path = new ArrayList<String>(p.path);\\n                    path.add(str);\\n                    queue.add(new Path(neighbor, path));   \\n                }               \\n            }\\n            \\n            for(String nei: neighborsToRemove){\\n                wordDict.remove(nei);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private class Path{\\n        String val; List<String> path;        \\n        public Path(String value, List<String> path){\\n            this.val = value;\\n            this.path = path;\\n        }\\n    }\\n    \\n    public List<String> neighbors(String s, Set<String> wordDict){\\n        List<String> res = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            char [] chars = s.toCharArray();\\n            for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                chars[i] = ch;\\n                String word = new String(chars);\\n                if(wordDict.contains(word)){\\n                    res.add(word);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Queue<Path> queue = new LinkedList<>();\\n        queue.add(new Path(beginWord, new ArrayList()));\\n        \\n        Set<String> wordDict = new HashSet();\\n        for(String s: wordList) wordDict.add(s);\\n        wordDict.remove(beginWord);\\n        boolean stop = false;\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        while(!queue.isEmpty() && !stop){\\n            int size = queue.size();\\n            \\n            List<String> neighborsToRemove = new ArrayList();\\n            for(int i=0;i<size;i++){\\n                Path p = queue.poll();\\n                String str = p.val;\\n                if(str.equals(endWord)) {\\n                    p.path.add(str);\\n                    result.add(p.path);\\n                    stop = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 514726,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<>();\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) return res;\\n        Queue<String> q = new LinkedList<>();\\n        Queue<List<String>> q_list = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        \\n        q.add(beginWord);\\n        List<String> list = new ArrayList<>();\\n        list.add(beginWord);\\n        q_list.add(list);\\n        visited.add(beginWord);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            List<String> visited_list = new ArrayList<>();\\n            for(int i = 0; i < size; i++) {\\n                String curr = q.poll();\\n                List<String> curr_list = q_list.poll();\\n                for(int j = 0; j < curr.length(); j++) {\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        String next = curr.substring(0, j) + c + curr.substring(j + 1);\\n                        if(visited.contains(next)) continue;\\n                        if(next.equals(endWord)) {\\n                            List<String> next_list = new ArrayList<>(curr_list);\\n                            next_list.add(next);\\n                            res.add(next_list);\\n                        } else if(dict.contains(next)) {\\n                            q.add(next);\\n                            List<String> next_list = new ArrayList<>(curr_list);\\n                            next_list.add(next);\\n                            q_list.add(next_list);\\n                            visited_list.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n            visited.addAll(visited_list);\\n            if(res.size() != 0) return res;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<>();\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) return res;\\n        Queue<String> q = new LinkedList<>();\\n        Queue<List<String>> q_list = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        \\n        q.add(beginWord);\\n        List<String> list = new ArrayList<>();\\n        list.add(beginWord);\\n        q_list.add(list);\\n        visited.add(beginWord);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            List<String> visited_list = new ArrayList<>();\\n            for(int i = 0; i < size; i++) {\\n                String curr = q.poll();\\n                List<String> curr_list = q_list.poll();\\n                for(int j = 0; j < curr.length(); j++) {\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        String next = curr.substring(0, j) + c + curr.substring(j + 1);\\n                        if(visited.contains(next)) continue;\\n                        if(next.equals(endWord)) {\\n                            List<String> next_list = new ArrayList<>(curr_list);\\n                            next_list.add(next);\\n                            res.add(next_list);\\n                        } else if(dict.contains(next)) {\\n                            q.add(next);\\n                            List<String> next_list = new ArrayList<>(curr_list);\\n                            next_list.add(next);\\n                            q_list.add(next_list);\\n                            visited_list.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n            visited.addAll(visited_list);\\n            if(res.size() != 0) return res;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321864,
                "title": "c-working-solution-using-some-clever-maps-lists-backwards-walking",
                "content": "This is essentially doing a level-order traversal from the last word back to the front word. We store valid paths in a back-tracking dictionary which we can use to assemble the final solution. This works, but the order of the lists must be flipped at the end. The backtracking dictionary also ends up populated with unnecessary elements, which hog up resources and slow down the algorithm. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        unordered_set aDictionary(wordList.begin(), wordList.end());\\n        \\n        //The end word needs to be in the list, per the rules...\\n        if (aDictionary.count(endWord) == 0) { return aResult; }\\n        \\n        unordered_set aUnused(wordList.begin(), wordList.end());\\n        \\n        //Since we are walking backwards - we are adding the first word here.\\n        if (aDictionary.count(beginWord) == 0) {\\n            wordList.push_back(beginWord);\\n            aUnused.insert(beginWord);\\n        }\\n        \\n        aUnused.erase(endWord);\\n        \\n        unordered_map<string, vector<string>> aBacktrack;\\n        \\n        queue<string> aQueue;\\n        aQueue.push(endWord);\\n        \\n        bool aDidReachFront = false;\\n        \\n        while (!aQueue.empty()) {\\n            int aCount = aQueue.size();\\n            vector<string> aNextLevel;\\n            for (int i=0;i<aCount;i++) {\\n                string aWord = aQueue.front();\\n                aQueue.pop();\\n                \\n                for (auto aCheck : wordList) {\\n                    int aDiffCount = 0;\\n                    for (int k=0;k<aCheck.size();k++) {\\n                        if (aCheck[k] != aWord[k]) { aDiffCount++; }\\n                    }\\n                    if (aDiffCount == 1) {\\n                        if (aUnused.count(aCheck) != 0) {\\n                            aNextLevel.push_back(aCheck);\\n                            aBacktrack[aWord].push_back(aCheck);\\n                            if (aCheck == beginWord) { aDidReachFront = true; }\\n                        }\\n                    }\\n                }   \\n            }\\n                \\n            if (aDidReachFront == true) { break; }\\n                \\n            for (auto aAdd : aNextLevel) {     \\n                if (aUnused.count(aAdd) != 0) {\\n                    aUnused.erase(aAdd);\\n                    aQueue.push(aAdd);\\n                }\\n            }\\n        }\\n        \\n        //Now we use the backtrack map to spit out a result.\\n        if (aDidReachFront) {\\n            vector<string> aTemp;\\n            populateResults(aBacktrack, endWord, beginWord, aTemp, aResult);\\n        }\\n        \\n        vector<vector<string>> aFlipResult;\\n        for (auto aFlip : aResult) {\\n            reverse(aFlip.begin(), aFlip.end());\\n            aFlipResult.push_back(aFlip);\\n        }\\n        \\n        return aFlipResult;\\n    }\\n    \\n    void populateResults(unordered_map<string, vector<string>> &pBacktrack, string &pWord, string &beginWord, vector<string> &pTemp, vector<vector<string>> &pResult) {\\n        if (pWord == beginWord) {\\n            pTemp.push_back(beginWord);\\n            pResult.push_back(pTemp);\\n            pTemp.pop_back();\\n            return;\\n        }\\n        \\n        pTemp.push_back(pWord);\\n        for (auto aNext : pBacktrack[pWord]) {\\n            populateResults(pBacktrack, aNext, beginWord, pTemp, pResult);\\n        }\\n        pTemp.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        vector<vector<string>> aResult;\\n        unordered_set aDictionary(wordList.begin(), wordList.end());\\n        \\n        //The end word needs to be in the list, per the rules...\\n        if (aDictionary.count(endWord) == 0) { return aResult; }\\n        \\n        unordered_set aUnused(wordList.begin(), wordList.end());\\n        \\n        //Since we are walking backwards - we are adding the first word here.\\n        if (aDictionary.count(beginWord) == 0) {\\n            wordList.push_back(beginWord);\\n            aUnused.insert(beginWord);\\n        }\\n        \\n        aUnused.erase(endWord);\\n        \\n        unordered_map<string, vector<string>> aBacktrack;\\n        \\n        queue<string> aQueue;\\n        aQueue.push(endWord);\\n        \\n        bool aDidReachFront = false;\\n        \\n        while (!aQueue.empty()) {\\n            int aCount = aQueue.size();\\n            vector<string> aNextLevel;\\n            for (int i=0;i<aCount;i++) {\\n                string aWord = aQueue.front();\\n                aQueue.pop();\\n                \\n                for (auto aCheck : wordList) {\\n                    int aDiffCount = 0;\\n                    for (int k=0;k<aCheck.size();k++) {\\n                        if (aCheck[k] != aWord[k]) { aDiffCount++; }\\n                    }\\n                    if (aDiffCount == 1) {\\n                        if (aUnused.count(aCheck) != 0) {\\n                            aNextLevel.push_back(aCheck);\\n                            aBacktrack[aWord].push_back(aCheck);\\n                            if (aCheck == beginWord) { aDidReachFront = true; }\\n                        }\\n                    }\\n                }   \\n            }\\n                \\n            if (aDidReachFront == true) { break; }\\n                \\n            for (auto aAdd : aNextLevel) {     \\n                if (aUnused.count(aAdd) != 0) {\\n                    aUnused.erase(aAdd);\\n                    aQueue.push(aAdd);\\n                }\\n            }\\n        }\\n        \\n        //Now we use the backtrack map to spit out a result.\\n        if (aDidReachFront) {\\n            vector<string> aTemp;\\n            populateResults(aBacktrack, endWord, beginWord, aTemp, aResult);\\n        }\\n        \\n        vector<vector<string>> aFlipResult;\\n        for (auto aFlip : aResult) {\\n            reverse(aFlip.begin(), aFlip.end());\\n            aFlipResult.push_back(aFlip);\\n        }\\n        \\n        return aFlipResult;\\n    }\\n    \\n    void populateResults(unordered_map<string, vector<string>> &pBacktrack, string &pWord, string &beginWord, vector<string> &pTemp, vector<vector<string>> &pResult) {\\n        if (pWord == beginWord) {\\n            pTemp.push_back(beginWord);\\n            pResult.push_back(pTemp);\\n            pTemp.pop_back();\\n            return;\\n        }\\n        \\n        pTemp.push_back(pWord);\\n        for (auto aNext : pBacktrack[pWord]) {\\n            populateResults(pBacktrack, aNext, beginWord, pTemp, pResult);\\n        }\\n        pTemp.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187866,
                "title": "python-bfs-dfs-complexity-analysis",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \\n        1) BFS starting at beginWord by transforming every letter to see if the next word is in the wordList, if so, put in queue.\\n        2) During BFS, maintain a graph of {word:nextWord} for all valid next wods \\n        3) When a nextWord reaches endWord, do a backtracking DFS (pre-order traversal) on the graph to get all paths.\\n        \\n        Time: O(26*L*N + N), where L is average length of each word, and N is the number of words in the wordList. Worst case here is every word transformed happens to be in the list, so each transformation needs 26 * length of word. The DFS part is O(N).\\n        \\n        Space: O(N)\\n        \\n        \"\"\"\\n        wordListSet = set(wordList+[beginWord])\\n        graph = collections.defaultdict(list)\\n        q = set([beginWord])    \\n        count = 0\\n        result = []\\n        while q:\\n            count +=1\\n            newQ = set()\\n            for word in q:\\n                wordListSet.remove(word)\\n            for word in q:\\n                if word == endWord:                                        \\n                    self.getAllPaths(graph, beginWord, endWord, result, [])\\n                    return result\\n                for i in range(len(word)):\\n                    for sub in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        if sub != word[i]:\\n                            newWord = word[:i] + sub + word[i+1:]\\n                            if newWord in wordListSet:\\n                                graph[word].append(newWord)\\n                                newQ.add(newWord)\\n            q = newQ\\n        return []\\n\\n    def getAllPaths(self, graph, node, target, result, output):\\n        #This is just a backtracking pre-order traversal DFS on a DAG.\\n        output.append(node)\\n        if node==target:\\n            result.append(output[:])\\n        else:\\n            for child in graph[node]:\\n                self.getAllPaths(graph,child, target, result, output)\\n                output.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: List[List[str]]\\n        \\n        1) BFS starting at beginWord by transforming every letter to see if the next word is in the wordList, if so, put in queue.\\n        2) During BFS, maintain a graph of {word:nextWord} for all valid next wods \\n        3) When a nextWord reaches endWord, do a backtracking DFS (pre-order traversal) on the graph to get all paths.\\n        \\n        Time: O(26*L*N + N), where L is average length of each word, and N is the number of words in the wordList. Worst case here is every word transformed happens to be in the list, so each transformation needs 26 * length of word. The DFS part is O(N).\\n        \\n        Space: O(N)\\n        \\n        \"\"\"\\n        wordListSet = set(wordList+[beginWord])\\n        graph = collections.defaultdict(list)\\n        q = set([beginWord])    \\n        count = 0\\n        result = []\\n        while q:\\n            count +=1\\n            newQ = set()\\n            for word in q:\\n                wordListSet.remove(word)\\n            for word in q:\\n                if word == endWord:                                        \\n                    self.getAllPaths(graph, beginWord, endWord, result, [])\\n                    return result\\n                for i in range(len(word)):\\n                    for sub in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        if sub != word[i]:\\n                            newWord = word[:i] + sub + word[i+1:]\\n                            if newWord in wordListSet:\\n                                graph[word].append(newWord)\\n                                newQ.add(newWord)\\n            q = newQ\\n        return []\\n\\n    def getAllPaths(self, graph, node, target, result, output):\\n        #This is just a backtracking pre-order traversal DFS on a DAG.\\n        output.append(node)\\n        if node==target:\\n            result.append(output[:])\\n        else:\\n            for child in graph[node]:\\n                self.getAllPaths(graph,child, target, result, output)\\n                output.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134377,
                "title": "my-java-solution-based-on-bfs-and-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        Map<String, Integer> ladder = new HashMap<String, Integer>();\\n        Map<String, Set<String>> map = new HashMap<String, Set<String>>();\\n        \\n        ladder.put(beginWord, 0);\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(beginWord);\\n        \\n        while (!queue.isEmpty()) {\\n            \\n            String word = queue.poll();\\n            if (word.equals(endWord)) {\\n                break;\\n            }\\n            \\n            int step = ladder.get(word) + 1;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                    if (c == word.charAt(i)) {\\n                        continue;\\n                    }\\n                    sb.setCharAt(i, c);\\n                    String newWord = sb.toString();\\n                    \\n                    if (!set.contains(newWord)) {\\n                        continue;\\n                    }\\n                    \\n                    if (step <= ladder.getOrDefault(newWord, Integer.MAX_VALUE)) {\\n                        queue.add(newWord);\\n                        ladder.put(newWord, step);\\n                        if (!map.containsKey(word)) {\\n                            map.put(word, new HashSet<String>());\\n                        }\\n                        map.get(word).add(newWord);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<String> list = new ArrayList<String>();\\n        dfs(res, list, map, beginWord, endWord);\\n        return res;\\n    }\\n    \\n    private void dfs(List<List<String>> res, List<String> list, Map<String, Set<String>> map, String word, String endWord) {\\n        if (word.equals(endWord)) {\\n            list.add(word);\\n            res.add(new ArrayList<String>(list));\\n            list.remove(list.size() - 1);\\n            return;\\n        }\\n        list.add(word);\\n        if (map.containsKey(word)) {\\n            for (String s : map.get(word)) {\\n                dfs(res, list, map, s, endWord);\\n            }\\n        }\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        Map<String, Integer> ladder = new HashMap<String, Integer>();\\n        Map<String, Set<String>> map = new HashMap<String, Set<String>>();\\n        \\n        ladder.put(beginWord, 0);\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(beginWord);\\n        \\n        while (!queue.isEmpty()) {\\n            \\n            String word = queue.poll();\\n            if (word.equals(endWord)) {\\n                break;\\n            }\\n            \\n            int step = ladder.get(word) + 1;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                    if (c == word.charAt(i)) {\\n                        continue;\\n                    }\\n                    sb.setCharAt(i, c);\\n                    String newWord = sb.toString();\\n                    \\n                    if (!set.contains(newWord)) {\\n                        continue;\\n                    }\\n                    \\n                    if (step <= ladder.getOrDefault(newWord, Integer.MAX_VALUE)) {\\n                        queue.add(newWord);\\n                        ladder.put(newWord, step);\\n                        if (!map.containsKey(word)) {\\n                            map.put(word, new HashSet<String>());\\n                        }\\n                        map.get(word).add(newWord);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<String> list = new ArrayList<String>();\\n        dfs(res, list, map, beginWord, endWord);\\n        return res;\\n    }\\n    \\n    private void dfs(List<List<String>> res, List<String> list, Map<String, Set<String>> map, String word, String endWord) {\\n        if (word.equals(endWord)) {\\n            list.add(word);\\n            res.add(new ArrayList<String>(list));\\n            list.remove(list.size() - 1);\\n            return;\\n        }\\n        list.add(word);\\n        if (map.containsKey(word)) {\\n            for (String s : map.get(word)) {\\n                dfs(res, list, map, s, endWord);\\n            }\\n        }\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40536,
                "title": "clear-java-solution-with-a-single-bfs",
                "content": "```\\npublic class Solution {\\n\\tpublic List<List<String>> findLadders(String endWord, String beginWord, Set<String> wordList) {\\n\\t\\twordList.add(endWord);\\n\\t\\tQueue<Node> queue = new LinkedList<>();\\n\\t\\tSet<String> visited = new HashSet<>(), unvisited = new HashSet<>();\\n\\t\\tunvisited.addAll(wordList);\\n\\t\\tint level = 0, minDist = Integer.MAX_VALUE;\\n\\t\\tList<List<String>> result = new ArrayList<>();\\n\\n\\t\\tqueue.add(new Node(beginWord, null, 0));\\n\\t\\tvisited.add(beginWord);\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tNode current = queue.remove();\\n\\t\\t\\tif (current.val.equals(endWord) && current.dist <= minDist) {\\n\\t\\t\\t\\tminDist = current.dist;\\n\\t\\t\\t\\taddPath(result, current);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (current.dist > minDist) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (current.dist > level) {\\n\\t\\t\\t\\tunvisited.removeAll(visited);\\n\\t\\t\\t\\tlevel = current.dist;\\n\\t\\t\\t}\\n\\n\\t\\t\\taddNeighbours(queue, visited, unvisited, current);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void addNeighbours(Queue<Node> queue, Set<String> visited, Set<String> unvisited, Node current) {\\n\\t\\tchar[] chars = current.val.toCharArray();\\n\\t\\tfor (int i = 0; i < chars.length; ++i) {\\n\\t\\t\\tfor (char c = 'a'; c <= 'z'; ++c) {\\n\\t\\t\\t\\tchar tmp = chars[i];\\n\\t\\t\\t\\tchars[i] = c;\\n\\t\\t\\t\\tString nbr = new String(chars);\\n\\t\\t\\t\\tif (unvisited.contains(nbr)) {\\n\\t\\t\\t\\t\\tqueue.add(new Node(nbr, current, current.dist + 1));\\n\\t\\t\\t\\t\\tvisited.add(nbr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchars[i] = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void addPath(List<List<String>> result, Node current) {\\n\\t\\tList<String> path = new ArrayList<>(current.dist);\\n\\t\\twhile (current != null) {\\n\\t\\t\\tpath.add(current.val);\\n\\t\\t\\tcurrent = current.parent;\\n\\t\\t}\\n\\t\\tresult.add(path);\\n\\t}\\n\\n\\tprivate class Node {\\n\\t\\tString val;\\n\\t\\tNode parent;\\n\\t\\tint dist;\\n\\n\\t\\tprivate Node(String val, Node parent, int dist) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.parent = parent;\\n\\t\\t\\tthis.dist = dist;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic List<List<String>> findLadders(String endWord, String beginWord, Set<String> wordList) {\\n\\t\\twordList.add(endWord);\\n\\t\\tQueue<Node> queue = new LinkedList<>();\\n\\t\\tSet<String> visited = new HashSet<>(), unvisited = new HashSet<>();\\n\\t\\tunvisited.addAll(wordList);\\n\\t\\tint level = 0, minDist = Integer.MAX_VALUE;\\n\\t\\tList<List<String>> result = new ArrayList<>();\\n\\n\\t\\tqueue.add(new Node(beginWord, null, 0));\\n\\t\\tvisited.add(beginWord);\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tNode current = queue.remove();\\n\\t\\t\\tif (current.val.equals(endWord) && current.dist <= minDist) {\\n\\t\\t\\t\\tminDist = current.dist;\\n\\t\\t\\t\\taddPath(result, current);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (current.dist > minDist) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (current.dist > level) {\\n\\t\\t\\t\\tunvisited.removeAll(visited);\\n\\t\\t\\t\\tlevel = current.dist;\\n\\t\\t\\t}\\n\\n\\t\\t\\taddNeighbours(queue, visited, unvisited, current);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void addNeighbours(Queue<Node> queue, Set<String> visited, Set<String> unvisited, Node current) {\\n\\t\\tchar[] chars = current.val.toCharArray();\\n\\t\\tfor (int i = 0; i < chars.length; ++i) {\\n\\t\\t\\tfor (char c = 'a'; c <= 'z'; ++c) {\\n\\t\\t\\t\\tchar tmp = chars[i];\\n\\t\\t\\t\\tchars[i] = c;\\n\\t\\t\\t\\tString nbr = new String(chars);\\n\\t\\t\\t\\tif (unvisited.contains(nbr)) {\\n\\t\\t\\t\\t\\tqueue.add(new Node(nbr, current, current.dist + 1));\\n\\t\\t\\t\\t\\tvisited.add(nbr);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchars[i] = tmp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate void addPath(List<List<String>> result, Node current) {\\n\\t\\tList<String> path = new ArrayList<>(current.dist);\\n\\t\\twhile (current != null) {\\n\\t\\t\\tpath.add(current.val);\\n\\t\\t\\tcurrent = current.parent;\\n\\t\\t}\\n\\t\\tresult.add(path);\\n\\t}\\n\\n\\tprivate class Node {\\n\\t\\tString val;\\n\\t\\tNode parent;\\n\\t\\tint dist;\\n\\n\\t\\tprivate Node(String val, Node parent, int dist) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.parent = parent;\\n\\t\\t\\tthis.dist = dist;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40606,
                "title": "share-my-javascript-solution-with-2-way-bfs-cost-about-250ms",
                "content": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    let min = Number.MAX_SAFE_INTEGER;\\n    const wordSet = new Set(wordList);\\n    const A_CODE = \\'a\\'.charCodeAt(0);\\n    // Exclude beginWord if in wordList\\n    wordSet.delete(beginWord);\\n    // Store each step\\'s possbile words from start.\\n    let usedWords = [new Set([beginWord])];\\n    let hasAns = false;\\n    // Each loop we try to reach out for more words from last step\\n    while (wordSet.size) {\\n        let usingWords = new Set();\\n        for (let fromWord of usedWords[usedWords.length - 1]) {\\n            for (let toWord of wordSet) {\\n                if (convertible(fromWord, toWord)) {\\n                    usingWords.add(toWord);\\n                    // Used word should not be reached again (not shortest path)\\n                    wordSet.delete(toWord);\\n                }\\n            }\\n        }\\n        \\n        if (usingWords.has(endWord)) {\\n            // If we reached to end word, we can start to gen answer from prev steps.\\n            hasAns = true;\\n            break;\\n        } else if (usingWords.size === 0) {\\n            // If we\\'re not able to reach to anything, there\\'s no solution.\\n            break;\\n        }\\n        usedWords.push(usingWords);\\n    }\\n    if (!hasAns) {\\n        return [];    \\n    }\\n    // We have all previous tried steps, and we know: Answer should be able to connect from tail to head\\n    // So we have init paths that only contains endWord.\\n    // Then backTrace compare again to contruct candidates from tail\\n    let paths = [[endWord]];\\n    usedWords = usedWords.reverse();\\n    for (let usingWords of usedWords) {\\n        let newPaths = [];\\n        for (let path of paths) {\\n            for (let usingWord of usingWords) {\\n                if (convertible(usingWord, path[0])) {\\n                    newPaths.push([usingWord].concat(path));\\n                }\\n            }\\n        }\\n        paths = newPaths;\\n    }\\n    return paths;\\n};\\n\\nvar convertible = function (lhs, rhs) {\\n    let c = 0;\\n    for (let i = 0; i < lhs.length && c < 2; i++) {\\n        if (lhs[i] !== rhs[i]) {\\n            ++c;\\n        }\\n    }\\n    return c === 1;   \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    let min = Number.MAX_SAFE_INTEGER;\\n    const wordSet = new Set(wordList);\\n    const A_CODE = \\'a\\'.charCodeAt(0);\\n    // Exclude beginWord if in wordList\\n    wordSet.delete(beginWord);\\n    // Store each step\\'s possbile words from start.\\n    let usedWords = [new Set([beginWord])];\\n    let hasAns = false;\\n    // Each loop we try to reach out for more words from last step\\n    while (wordSet.size) {\\n        let usingWords = new Set();\\n        for (let fromWord of usedWords[usedWords.length - 1]) {\\n            for (let toWord of wordSet) {\\n                if (convertible(fromWord, toWord)) {\\n                    usingWords.add(toWord);\\n                    // Used word should not be reached again (not shortest path)\\n                    wordSet.delete(toWord);\\n                }\\n            }\\n        }\\n        \\n        if (usingWords.has(endWord)) {\\n            // If we reached to end word, we can start to gen answer from prev steps.\\n            hasAns = true;\\n            break;\\n        } else if (usingWords.size === 0) {\\n            // If we\\'re not able to reach to anything, there\\'s no solution.\\n            break;\\n        }\\n        usedWords.push(usingWords);\\n    }\\n    if (!hasAns) {\\n        return [];    \\n    }\\n    // We have all previous tried steps, and we know: Answer should be able to connect from tail to head\\n    // So we have init paths that only contains endWord.\\n    // Then backTrace compare again to contruct candidates from tail\\n    let paths = [[endWord]];\\n    usedWords = usedWords.reverse();\\n    for (let usingWords of usedWords) {\\n        let newPaths = [];\\n        for (let path of paths) {\\n            for (let usingWord of usingWords) {\\n                if (convertible(usingWord, path[0])) {\\n                    newPaths.push([usingWord].concat(path));\\n                }\\n            }\\n        }\\n        paths = newPaths;\\n    }\\n    return paths;\\n};\\n\\nvar convertible = function (lhs, rhs) {\\n    let c = 0;\\n    for (let i = 0; i < lhs.length && c < 2; i++) {\\n        if (lhs[i] !== rhs[i]) {\\n            ++c;\\n        }\\n    }\\n    return c === 1;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40633,
                "title": "my-java-bfs-solution",
                "content": "basically first u construct a graph in which the nodes are the words in dictionary, and two nodes are connected if they are different only by one char. \\n\\nthen we find the min paths from starting word to ending word. this is done using BFS. at each node we trace back to upstream using a list of possible upstream nodes.\\n\\n\\n    public class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        List<Integer> partialAnswer = new ArrayList<Integer>();\\n        ArrayList<String> dictionary;\\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n           ArrayList<String> words = new ArrayList<String>();\\n           words.addAll(dict);\\n           \\n           dictionary = words;\\n           \\n           boolean ok[][] = new boolean[words.size()][words.size()];\\n           for(int i=0;i<words.size();i++) {\\n               for(int j=0;j<words.size();j++) {\\n                   if (i==j) ok[i][j] = true;\\n                   else \\n                    ok[i][j] = findWordsDistance(words.get(i), words.get(j));\\n               }\\n           }\\n           \\n           // bfs traversal\\n           int startingIdx = words.indexOf(start);\\n           int endingIdx = words.indexOf(end);\\n           \\n           int used[] = new int[words.size()];\\n           ArrayList<Integer> incoming[] = new ArrayList[words.size()];\\n           for(int i=0;i<words.size();i++)\\n            incoming[i] = new ArrayList<Integer>();\\n            \\n           Queue<Integer> q = new LinkedList<Integer>();\\n           q.add(startingIdx);\\n           used[startingIdx] = 1;\\n           while( q.size() != 0 ) {\\n               Integer startFrom = q.poll();\\n               if (startFrom == endingIdx)\\n                break;\\n               for(int i=0;i<words.size();i++){\\n                   if (ok[startFrom][i]) {\\n                       if (used[i]==0) {\\n                        q.add(i);\\n                        used[i] = used[startFrom] +1;\\n                       }\\n                       if (used[startFrom] +1 <= used[i])\\n                       incoming[i].add(startFrom);\\n                   }\\n               }\\n           }\\n           \\n           // trace back\\n           trace(incoming, startingIdx, endingIdx);\\n           \\n           return result;\\n        }\\n        \\n        void trace(List<Integer>[] incoming, int start, int end) {\\n            if ( start == end) {\\n                // collect\\n                ArrayList<String> list = new ArrayList<String>();\\n                            list.add(dictionary.get(end));\\n    \\n                for(int i=partialAnswer.size()-1;i>=0;i--)\\n                    list.add(dictionary.get(partialAnswer.get(i)));\\n                result.add(list);\\n                return;\\n            }\\n            \\n            partialAnswer.add(end);\\n            for(int upstream : incoming[end]) {\\n                trace(incoming, start, upstream);\\n            }\\n            partialAnswer.remove(partialAnswer.size()-1);\\n        }\\n        \\n        boolean findWordsDistance(String a, String b) {\\n            if (a.length() != b.length()) return false;\\n            int diff = 0;\\n            for(int i=0;i<a.length();i++) {\\n                if (a.charAt(i) != b.charAt(i)) {\\n                    if (++diff >1)\\n                        return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        List<Integer> partialAnswer = new ArrayList<Integer>();\\n        ArrayList<String> dictionary;\\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {\\n           ArrayList<String> words = new ArrayList<String>();\\n           words.addAll(dict);\\n           \\n           dictionary = words;\\n           \\n           boolean ok[][] = new boolean[words.size()][words.size()];\\n           for(int i=0;i<words.size();i++) {\\n               for(int j=0;j<words.size();j++) {\\n                   if (i==j) ok[i][j] = true;\\n                   else \\n                    ok[i][j] = findWordsDistance(words.get(i), words.get(j));\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3918997,
                "title": "java-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1ea15e79-7ca5-4594-83b4-88b42dc1e6e7_1692205611.608349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String b;\\n\\n    // Create a hashmap of type word->level to get the idea \\n    // on which level the word comes after the transformations.\\n\\n    HashMap < String, Integer > mpp;\\n\\n    // A list for storing the final answer.\\n    List < List < String >> ans;\\n    private void dfs(String word, List < String > seq) {\\n\\n        // Function for implementing backtracking using the created map\\n        // in reverse order to find the transformation sequence in less time.\\n\\n        // Base condition :\\n        // If word equals beginWord, we\\u2019ve found one of the sequences\\n        // simply reverse the sequence and return. \\n        if (word.equals(b)) {\\n\\n            // Since java works with reference, create\\n            // a duplicate and store the reverse of it\\n            List < String > dup = new ArrayList < > (seq);\\n            Collections.reverse(dup);\\n            ans.add(dup);\\n            return;\\n        }\\n        int steps = mpp.get(word);\\n        int sz = word.length();\\n\\n        // Replace each character of the word with letters from a-z \\n        // and check whether the transformed word is present in the map\\n        // and at the previous level or not.\\n        for (int i = 0; i < sz; i++) {\\n\\n            for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                char replacedCharArray[] = word.toCharArray();\\n                replacedCharArray[i] = ch;\\n                String replacedWord = new String(replacedCharArray);\\n                if (mpp.containsKey(replacedWord) &&\\n                    mpp.get(replacedWord) + 1 == steps) {\\n\\n                    seq.add(replacedWord);\\n                    dfs(replacedWord, seq);\\n\\n                    // pop the current word from the back of the queue\\n                    // to traverse other possibilities.\\n                    seq.remove(seq.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n    public List < List < String >> findLadders(String beginWord, String endWord,\\n        List < String > wordList) {\\n\\n        // Push all values of wordList into a set\\n        // to make deletion from it easier and in less time complexity.\\n        Set < String > st = new HashSet < String > ();\\n        int len = wordList.size();\\n        for (int i = 0; i < len; i++) {\\n            st.add(wordList.get(i));\\n        }\\n\\n        // Perform BFS traversal and push the string in the queue\\n        // as soon as they\\u2019re found in the wordList.\\n        Queue < String > q = new LinkedList < > ();\\n        b = beginWord;\\n        q.add(beginWord);\\n        mpp = new HashMap < > ();\\n\\n        // beginWord initialised with level 1.\\n        mpp.put(beginWord, 1);\\n        int sizee = beginWord.length();\\n        st.remove(beginWord);\\n        while (!q.isEmpty()) {\\n            String word = q.peek();\\n            int steps = mpp.get(word);\\n            q.remove();\\n\\n            // Break out if the word matches the endWord.\\n            if (word.equals(endWord)) break;\\n\\n            // Replace each character of the word with letters from a-z \\n            // and check whether the transformed word is present in the \\n            // wordList or not, if yes then push to queue\\n            for (int i = 0; i < sizee; i++) {\\n\\n                for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                    char replacedCharArray[] = word.toCharArray();\\n                    replacedCharArray[i] = ch;\\n                    String replacedWord = new String(replacedCharArray);\\n                    if (st.contains(replacedWord) == true) {\\n                        q.add(replacedWord);\\n                        st.remove(replacedWord);\\n\\n                        // push the word along with its level\\n                        // in the map data structure.\\n                        mpp.put(replacedWord, steps + 1);\\n                    }\\n                }\\n\\n\\n            }\\n        }\\n        ans = new ArrayList < > ();\\n\\n        // If we reach the endWord, we stop and move to step-2\\n        // that is to perform reverse dfs traversal.\\n        if (mpp.containsKey(endWord) == true) {\\n            List < String > seq = new ArrayList < > ();\\n            seq.add(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    String b;\\n\\n    // Create a hashmap of type word->level to get the idea \\n    // on which level the word comes after the transformations.\\n\\n    HashMap < String, Integer > mpp;\\n\\n    // A list for storing the final answer.\\n    List < List < String >> ans;\\n    private void dfs(String word, List < String > seq) {\\n\\n        // Function for implementing backtracking using the created map\\n        // in reverse order to find the transformation sequence in less time.\\n\\n        // Base condition :\\n        // If word equals beginWord, we\\u2019ve found one of the sequences\\n        // simply reverse the sequence and return. \\n        if (word.equals(b)) {\\n\\n            // Since java works with reference, create\\n            // a duplicate and store the reverse of it\\n            List < String > dup = new ArrayList < > (seq);\\n            Collections.reverse(dup);\\n            ans.add(dup);\\n            return;\\n        }\\n        int steps = mpp.get(word);\\n        int sz = word.length();\\n\\n        // Replace each character of the word with letters from a-z \\n        // and check whether the transformed word is present in the map\\n        // and at the previous level or not.\\n        for (int i = 0; i < sz; i++) {\\n\\n            for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                char replacedCharArray[] = word.toCharArray();\\n                replacedCharArray[i] = ch;\\n                String replacedWord = new String(replacedCharArray);\\n                if (mpp.containsKey(replacedWord) &&\\n                    mpp.get(replacedWord) + 1 == steps) {\\n\\n                    seq.add(replacedWord);\\n                    dfs(replacedWord, seq);\\n\\n                    // pop the current word from the back of the queue\\n                    // to traverse other possibilities.\\n                    seq.remove(seq.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n    public List < List < String >> findLadders(String beginWord, String endWord,\\n        List < String > wordList) {\\n\\n        // Push all values of wordList into a set\\n        // to make deletion from it easier and in less time complexity.\\n        Set < String > st = new HashSet < String > ();\\n        int len = wordList.size();\\n        for (int i = 0; i < len; i++) {\\n            st.add(wordList.get(i));\\n        }\\n\\n        // Perform BFS traversal and push the string in the queue\\n        // as soon as they\\u2019re found in the wordList.\\n        Queue < String > q = new LinkedList < > ();\\n        b = beginWord;\\n        q.add(beginWord);\\n        mpp = new HashMap < > ();\\n\\n        // beginWord initialised with level 1.\\n        mpp.put(beginWord, 1);\\n        int sizee = beginWord.length();\\n        st.remove(beginWord);\\n        while (!q.isEmpty()) {\\n            String word = q.peek();\\n            int steps = mpp.get(word);\\n            q.remove();\\n\\n            // Break out if the word matches the endWord.\\n            if (word.equals(endWord)) break;\\n\\n            // Replace each character of the word with letters from a-z \\n            // and check whether the transformed word is present in the \\n            // wordList or not, if yes then push to queue\\n            for (int i = 0; i < sizee; i++) {\\n\\n                for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                    char replacedCharArray[] = word.toCharArray();\\n                    replacedCharArray[i] = ch;\\n                    String replacedWord = new String(replacedCharArray);\\n                    if (st.contains(replacedWord) == true) {\\n                        q.add(replacedWord);\\n                        st.remove(replacedWord);\\n\\n                        // push the word along with its level\\n                        // in the map data structure.\\n                        mpp.put(replacedWord, steps + 1);\\n                    }\\n                }\\n\\n\\n            }\\n        }\\n        ans = new ArrayList < > ();\\n\\n        // If we reach the endWord, we stop and move to step-2\\n        // that is to perform reverse dfs traversal.\\n        if (mpp.containsKey(endWord) == true) {\\n            List < String > seq = new ArrayList < > ();\\n            seq.add(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144905,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> res;\\n    vector<string> te;\\n    unordered_map<string, int> mp;\\n    string b;\\n    void dfs(string s)  // Step 2\\n    {\\n        te.push_back(s);\\n        if (s == b)\\n        {\\n            vector<string> x = te;\\n            reverse(x.begin(), x.end());\\n            res.push_back(x);\\n            te.pop_back();\\n            return;\\n        }\\n        int cur = mp[s];\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char c = s[i];\\n            for (char cc = \\'a\\'; cc <= \\'z\\'; cc++)\\n            {\\n                s[i] = cc;\\n                if (mp.count(s) && mp[s] == cur - 1)\\n                    dfs(s);\\n            }\\n            s[i] = c;\\n        }\\n        te.pop_back();\\n        return;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)\\n    {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        b = beginWord;\\n        queue<string> q;\\n        int k = beginWord.size();\\n        q.push({beginWord});\\n        mp[beginWord] = 0;\\n        while (!q.empty())  // Step 1\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                int x = mp[t] + 1;\\n                for (int i = 0; i < k; i++)\\n                {\\n                    string temp = t;\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                    {\\n                        temp[i] = ch;\\n                        if (!mp.count(temp) && dict.count(temp))\\n                            mp[temp] = x, q.push(temp);\\n                    }\\n                }\\n            }\\n        }\\n        if (mp.count(endWord))\\n            dfs(endWord);\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> res;\\n    vector<string> te;\\n    unordered_map<string, int> mp;\\n    string b;\\n    void dfs(string s)  // Step 2\\n    {\\n        te.push_back(s);\\n        if (s == b)\\n        {\\n            vector<string> x = te;\\n            reverse(x.begin(), x.end());\\n            res.push_back(x);\\n            te.pop_back();\\n            return;\\n        }\\n        int cur = mp[s];\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char c = s[i];\\n            for (char cc = \\'a\\'; cc <= \\'z\\'; cc++)\\n            {\\n                s[i] = cc;\\n                if (mp.count(s) && mp[s] == cur - 1)\\n                    dfs(s);\\n            }\\n            s[i] = c;\\n        }\\n        te.pop_back();\\n        return;\\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)\\n    {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        b = beginWord;\\n        queue<string> q;\\n        int k = beginWord.size();\\n        q.push({beginWord});\\n        mp[beginWord] = 0;\\n        while (!q.empty())  // Step 1\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                string t = q.front();\\n                q.pop();\\n                int x = mp[t] + 1;\\n                for (int i = 0; i < k; i++)\\n                {\\n                    string temp = t;\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                    {\\n                        temp[i] = ch;\\n                        if (!mp.count(temp) && dict.count(temp))\\n                            mp[temp] = x, q.push(temp);\\n                    }\\n                }\\n            }\\n        }\\n        if (mp.count(endWord))\\n            dfs(endWord);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091316,
                "title": "python-backtracking-bfs-bloomberg",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        _word = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                _word[word[:i] + \"*\" + word[i+1:]].append(word)\\n        queue = collections.deque()\\n        queue.append((beginWord, 0))\\n        visited = {beginWord:0}\\n        tracking = defaultdict(set)\\n        while queue:\\n            curr, level = queue.popleft()\\n            for i in range(len(curr)):\\n                _w = curr[:i] + \"*\" + curr[i+1:]\\n                for nxt in _word[_w]:\\n                    if nxt not in visited or visited[nxt] == level + 1:\\n                        tracking[nxt].add(curr)\\n                        if nxt not in visited:\\n                            visited[nxt] = level + 1\\n                            queue.append((nxt, level + 1))\\n        res = []\\n        def backtrack(target, path):\\n            if target == beginWord:\\n                res.append(path[::-1])\\n            else:\\n                for nxt in tracking[target]:\\n                    backtrack(nxt, path + [nxt])\\n        backtrack(endWord, [endWord])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        _word = defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                _word[word[:i] + \"*\" + word[i+1:]].append(word)\\n        queue = collections.deque()\\n        queue.append((beginWord, 0))\\n        visited = {beginWord:0}\\n        tracking = defaultdict(set)\\n        while queue:\\n            curr, level = queue.popleft()\\n            for i in range(len(curr)):\\n                _w = curr[:i] + \"*\" + curr[i+1:]\\n                for nxt in _word[_w]:\\n                    if nxt not in visited or visited[nxt] == level + 1:\\n                        tracking[nxt].add(curr)\\n                        if nxt not in visited:\\n                            visited[nxt] = level + 1\\n                            queue.append((nxt, level + 1))\\n        res = []\\n        def backtrack(target, path):\\n            if target == beginWord:\\n                res.append(path[::-1])\\n            else:\\n                for nxt in tracking[target]:\\n                    backtrack(nxt, path + [nxt])\\n        backtrack(endWord, [endWord])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030788,
                "title": "beats-100-code-without-recurrsion-only-bfs-and-string-matching",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nfrom collections import deque\\ndef hashword(word):\\n    h=0\\n    c=1\\n    for i in word:\\n        h+=c*(ord(i)-97)\\n        c=c*26\\n    return h\\ndef unhash(value,length):\\n    c=1\\n    word=[]\\n    for i in range(length):\\n        cr=chr(((value%(c*26))//c)+97)\\n        word.append(cr)\\n        c=c*26\\n    return \"\".join(word)\\n\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        d={}\\n        for i in range(len(wordList)):\\n            d[hashword(wordList[i])]=0\\n        h=hashword(beginWord)\\n        q=deque()\\n        q.append(h)\\n        f=hashword(endWord)\\n        q=deque()\\n        q.append([h,1])\\n        d[h]=1\\n        main_ans=[]\\n        s=1\\n        while q:\\n            x=q.popleft()\\n            h=x[0]\\n            if h==f:\\n                s=x[1]\\n                break\\n            else:\\n                c=1\\n                for i in range(len(beginWord)):\\n                    for j in range(26):\\n                        y=h-(((h%(c*26))//c)*c)+(c*j)\\n                        if y in d:\\n                            if d[y]==0:\\n                                d[y]=x[1]+1\\n                                q.append([y,x[1]+1])\\n                    c=c*26\\n        ans=deque()\\n        if f in d:\\n            if d[f]==s:\\n                ans.append([f])\\n                while len(ans[0])<s:\\n                    x=ans.popleft()\\n                    h=x[-1]\\n                    c=1\\n                    for i in range(len(beginWord)):\\n                            for j in range(26):\\n                                y=h-(((h%(c*26))//c)*c)+(c*j)\\n                                if y in d:\\n                                    if d[y]==s-len(x):\\n                                        x.append(y)\\n                                        ans.append(x[::])\\n                                        x.pop()\\n                            c=c*26\\n        a=[]\\n        while ans:\\n            x=ans.popleft()\\n            ab=[]\\n            while x:\\n                k=unhash(x.pop(),len(beginWord))\\n                ab.append(k)\\n            a.append(ab)\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Rolling Hash",
                    "String Matching"
                ],
                "code": "```\\nfrom collections import deque\\ndef hashword(word):\\n    h=0\\n    c=1\\n    for i in word:\\n        h+=c*(ord(i)-97)\\n        c=c*26\\n    return h\\ndef unhash(value,length):\\n    c=1\\n    word=[]\\n    for i in range(length):\\n        cr=chr(((value%(c*26))//c)+97)\\n        word.append(cr)\\n        c=c*26\\n    return \"\".join(word)\\n\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        d={}\\n        for i in range(len(wordList)):\\n            d[hashword(wordList[i])]=0\\n        h=hashword(beginWord)\\n        q=deque()\\n        q.append(h)\\n        f=hashword(endWord)\\n        q=deque()\\n        q.append([h,1])\\n        d[h]=1\\n        main_ans=[]\\n        s=1\\n        while q:\\n            x=q.popleft()\\n            h=x[0]\\n            if h==f:\\n                s=x[1]\\n                break\\n            else:\\n                c=1\\n                for i in range(len(beginWord)):\\n                    for j in range(26):\\n                        y=h-(((h%(c*26))//c)*c)+(c*j)\\n                        if y in d:\\n                            if d[y]==0:\\n                                d[y]=x[1]+1\\n                                q.append([y,x[1]+1])\\n                    c=c*26\\n        ans=deque()\\n        if f in d:\\n            if d[f]==s:\\n                ans.append([f])\\n                while len(ans[0])<s:\\n                    x=ans.popleft()\\n                    h=x[-1]\\n                    c=1\\n                    for i in range(len(beginWord)):\\n                            for j in range(26):\\n                                y=h-(((h%(c*26))//c)*c)+(c*j)\\n                                if y in d:\\n                                    if d[y]==s-len(x):\\n                                        x.append(y)\\n                                        ans.append(x[::])\\n                                        x.pop()\\n                            c=c*26\\n        a=[]\\n        while ans:\\n            x=ans.popleft()\\n            ab=[]\\n            while x:\\n                k=unhash(x.pop(),len(beginWord))\\n                ab.append(k)\\n            a.append(ab)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958027,
                "title": "easy-c-solution-bfs-backtracking-beats-97",
                "content": "# Approach\\n\\nWe can get the solution by 2 main steps.\\n- STEP 1 : Find the shortest length of the ladder (simillar to word-ladder-1 solution) and store each word with its level in the map.\\n- STEP 2 : Backtrack the map and get sequences (ladders) for the solution\\n\\nYou can read the comments in the code for better understanding.\\n\\nSpecial Thanks to Striver for making amazing solution video on this problem.\\nHere you can find out detailed solution: https://takeuforward.org/graph/g-30-word-ladder-ii/\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n    vector<vector<string>> ans;    // For storing final sequences\\n    unordered_map<string, int> mp; // For storing {string -> level}\\n\\nprivate:\\n    void backtrack(string &word, int len, vector<string> &seq)\\n    {\\n        // If level of word is equal to 0 means we arrived at beginWord\\n        if (mp[word] == 0)\\n        {\\n            // reverse the current seq. because its storing list in backword manner\\n            reverse(seq.begin(), seq.end());\\n            // push the sequence in the ans \\n            ans.push_back(seq);\\n            // again reverse the seq. because it may use again fot next seq.\\n            reverse(seq.begin(), seq.end());\\n        }\\n\\n        int level = mp[word];\\n\\n        // find neighbour word (which is present in the map)\\n        for (int i = 0; i < len; i++)\\n        {\\n            char original = word[i];\\n            for (int ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n            {\\n                word[i] = ch;\\n                // if new_word is present in the map AND the level[new_word] + 1 == level[word]\\n                if (mp.find(word) != mp.end() && mp[word] + 1 == level)\\n                {\\n                    seq.push_back(word);        // push new_word into the current seq\\n                    backtrack(word, len, seq);  // backtrack for next word\\n                    // after the complition of backtracking remove the previously pushed word from the seq for next iteration\\n                    seq.pop_back();             \\n                }\\n            }\\n            word[i] = original;\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &givenList)\\n    {\\n        //! STEP 1 : Find the shortest length of the ladder (simillar to word-ladder-1 solution) \\n        //! store each word with its level being used in map.\\n        \\n        unordered_set<string> wordList(givenList.begin(), givenList.end());\\n        queue<string> q;\\n\\n        wordList.erase(beginWord);\\n        q.push({beginWord});\\n        mp[beginWord] = 0;          // first level\\n\\n        int len = beginWord.size();\\n\\n        while (!q.empty())\\n        {\\n            string word = q.front();\\n            q.pop();\\n            int level = mp[word];   // level of current word\\n\\n            if (word == endWord)\\n                break;\\n\\n            for (int i = 0; i < len; i++)\\n            {\\n                char original = word[i];\\n                for (int ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                {\\n                    word[i] = ch;   // changed word will be called as new_word\\n                    // If new_word is present in wordList\\n                    if (wordList.find(word) != wordList.end())\\n                    {\\n                        q.push(word);           // Push new_word into queue\\n                        mp[word] = level + 1;   // store (level+1) in the map for new_word\\n                        wordList.erase(word);   // erase new_word from the wordList\\n                    }\\n                }\\n                word[i] = original; // Change back to original word for next iteration\\n            }\\n        }\\n\\n        // If endWord is present in the map then find the all sequences by step-2\\n\\n        //! STEP 2 : Backtrack the map and get sequences (ladders) for the solution\\n        if (mp.find(endWord) != mp.end())\\n        {\\n            vector<string> seq;\\n            seq.push_back(endWord);\\n            backtrack(endWord, len, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    vector<vector<string>> ans;    // For storing final sequences\\n    unordered_map<string, int> mp; // For storing {string -> level}\\n\\nprivate:\\n    void backtrack(string &word, int len, vector<string> &seq)\\n    {\\n        // If level of word is equal to 0 means we arrived at beginWord\\n        if (mp[word] == 0)\\n        {\\n            // reverse the current seq. because its storing list in backword manner\\n            reverse(seq.begin(), seq.end());\\n            // push the sequence in the ans \\n            ans.push_back(seq);\\n            // again reverse the seq. because it may use again fot next seq.\\n            reverse(seq.begin(), seq.end());\\n        }\\n\\n        int level = mp[word];\\n\\n        // find neighbour word (which is present in the map)\\n        for (int i = 0; i < len; i++)\\n        {\\n            char original = word[i];\\n            for (int ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n            {\\n                word[i] = ch;\\n                // if new_word is present in the map AND the level[new_word] + 1 == level[word]\\n                if (mp.find(word) != mp.end() && mp[word] + 1 == level)\\n                {\\n                    seq.push_back(word);        // push new_word into the current seq\\n                    backtrack(word, len, seq);  // backtrack for next word\\n                    // after the complition of backtracking remove the previously pushed word from the seq for next iteration\\n                    seq.pop_back();             \\n                }\\n            }\\n            word[i] = original;\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &givenList)\\n    {\\n        //! STEP 1 : Find the shortest length of the ladder (simillar to word-ladder-1 solution) \\n        //! store each word with its level being used in map.\\n        \\n        unordered_set<string> wordList(givenList.begin(), givenList.end());\\n        queue<string> q;\\n\\n        wordList.erase(beginWord);\\n        q.push({beginWord});\\n        mp[beginWord] = 0;          // first level\\n\\n        int len = beginWord.size();\\n\\n        while (!q.empty())\\n        {\\n            string word = q.front();\\n            q.pop();\\n            int level = mp[word];   // level of current word\\n\\n            if (word == endWord)\\n                break;\\n\\n            for (int i = 0; i < len; i++)\\n            {\\n                char original = word[i];\\n                for (int ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n                {\\n                    word[i] = ch;   // changed word will be called as new_word\\n                    // If new_word is present in wordList\\n                    if (wordList.find(word) != wordList.end())\\n                    {\\n                        q.push(word);           // Push new_word into queue\\n                        mp[word] = level + 1;   // store (level+1) in the map for new_word\\n                        wordList.erase(word);   // erase new_word from the wordList\\n                    }\\n                }\\n                word[i] = original; // Change back to original word for next iteration\\n            }\\n        }\\n\\n        // If endWord is present in the map then find the all sequences by step-2\\n\\n        //! STEP 2 : Backtrack the map and get sequences (ladders) for the solution\\n        if (mp.find(endWord) != mp.end())\\n        {\\n            vector<string> seq;\\n            seq.push_back(endWord);\\n            backtrack(endWord, len, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878052,
                "title": "simple-python-no-tle-solution",
                "content": "The idea is pretty simple: layer by layer BFS. You should save the node parent where you come from into the dict.\\nAfter that simple backtraing for the dict.\\n\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = defaultdict(list)\\n        \\n        def word2repres(word):\\n            return [word[0 : i] + \\'?\\' + word[i + 1 ::] for i in range(len(word))]\\n        \\n        wordList = wordList + [beginWord]\\n        for word in wordList:\\n            for r in word2repres(word):\\n                graph[r].append(word)\\n        \\n        queue = deque([beginWord])\\n        visited = set([beginWord])\\n        parents = defaultdict(list)\\n        res = []\\n        while queue:\\n            layer = set()\\n            for i in range(len(queue)):\\n                word = queue.popleft()\\n                for r in  word2repres(word):\\n                    for neigh in graph[r]:\\n                        if neigh not in visited:\\n                            layer.add(neigh)\\n                            parents[neigh].append(word)\\n            queue.extend(layer)\\n            visited.update(layer)\\n        \\n        def dfs(node, curr):\\n            if node == beginWord:\\n                res.append(curr[::-1])\\n                return\\n            for par in parents[node]:\\n                curr.append(par)\\n                dfs(par, curr)\\n                curr.pop()\\n        \\n        dfs(endWord, [endWord])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        graph = defaultdict(list)\\n        \\n        def word2repres(word):\\n            return [word[0 : i] + \\'?\\' + word[i + 1 ::] for i in range(len(word))]\\n        \\n        wordList = wordList + [beginWord]\\n        for word in wordList:\\n            for r in word2repres(word):\\n                graph[r].append(word)\\n        \\n        queue = deque([beginWord])\\n        visited = set([beginWord])\\n        parents = defaultdict(list)\\n        res = []\\n        while queue:\\n            layer = set()\\n            for i in range(len(queue)):\\n                word = queue.popleft()\\n                for r in  word2repres(word):\\n                    for neigh in graph[r]:\\n                        if neigh not in visited:\\n                            layer.add(neigh)\\n                            parents[neigh].append(word)\\n            queue.extend(layer)\\n            visited.update(layer)\\n        \\n        def dfs(node, curr):\\n            if node == beginWord:\\n                res.append(curr[::-1])\\n                return\\n            for par in parents[node]:\\n                curr.append(par)\\n                dfs(par, curr)\\n                curr.pop()\\n        \\n        dfs(endWord, [endWord])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755042,
                "title": "bfs-dfs-backtracking-in-java-commented-solution",
                "content": "**Do Upvote if you Liked the solution**\\n****\\n```\\nclass Solution {\\n    //define global variables\\n    String begin;\\n    HashMap<String , Integer> map;\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        // create a set for of wordList\\n        Set<String> set = new HashSet<>();\\n        for(int i = 0 ; i < wordList.size() ; i++){\\n            set.add(wordList.get(i));\\n        }\\n        // creste queue and add the begin word in queue\\n        Queue<String> que = new LinkedList<>();\\n        begin = beginWord;\\n        que.add(beginWord);\\n        // remove beginWord from the set \\n        set.remove(beginWord);\\n        map = new HashMap<>();\\n        // put beginWord with level 1 in map\\n        map.put(beginWord , 1);\\n        \\n        while(!que.isEmpty()){\\n            // poll from queue and get its level from map\\n            String st = que.poll();\\n            int steps = map.get(st);\\n            if(st.equals(endWord)) break;\\n            \\n            for(int i = 0 ; i < st.length() ; i++){\\n                for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                    char[] charArray = st.toCharArray();\\n                    charArray[i] = ch;\\n                    String word = new String(charArray);\\n                    if(set.contains(word)){\\n                        set.remove(word);\\n                        //put it in map with level+1\\n                        map.put(word , steps+1);\\n                        que.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        res = new ArrayList<>();\\n        if(map.containsKey(endWord)){\\n            List<String> seq = new ArrayList<>();\\n            dfs(seq , endWord);\\n        }\\n        return res;\\n    }\\n    public void dfs(List<String> seq , String str){\\n        // if string is equal to beginWord then add it in seq and\\n        // add seq in res and return\\n        if(str.equals(begin)){\\n            List<String> dup = new ArrayList<>(seq);\\n            dup.add(str);\\n            // as we are going from back to front we need to reverse the seq\\n            Collections.reverse(dup);\\n            res.add(dup);\\n            return;\\n        }\\n        // store the steps(level) of current string\\n        int steps = map.get(str);\\n        for(int i = 0 ; i < str.length() ; i++){\\n            for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                char[] charArray = str.toCharArray();\\n                charArray[i] = ch;\\n                String word = new String(charArray);\\n                // if the word is in the Map and its level+1 == steps \\n                // then add it in seq list and again call the function dfs\\n                // and also backtrack cause at same level another word could\\n                // be present so backtrack after dfs call\\n                if(map.containsKey(word) && map.get(word) + 1 == steps){\\n                    seq.add(str);\\n                    dfs(seq , word);\\n                    seq.remove(seq.size()-1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n****",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    //define global variables\\n    String begin;\\n    HashMap<String , Integer> map;\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        // create a set for of wordList\\n        Set<String> set = new HashSet<>();\\n        for(int i = 0 ; i < wordList.size() ; i++){\\n            set.add(wordList.get(i));\\n        }\\n        // creste queue and add the begin word in queue\\n        Queue<String> que = new LinkedList<>();\\n        begin = beginWord;\\n        que.add(beginWord);\\n        // remove beginWord from the set \\n        set.remove(beginWord);\\n        map = new HashMap<>();\\n        // put beginWord with level 1 in map\\n        map.put(beginWord , 1);\\n        \\n        while(!que.isEmpty()){\\n            // poll from queue and get its level from map\\n            String st = que.poll();\\n            int steps = map.get(st);\\n            if(st.equals(endWord)) break;\\n            \\n            for(int i = 0 ; i < st.length() ; i++){\\n                for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                    char[] charArray = st.toCharArray();\\n                    charArray[i] = ch;\\n                    String word = new String(charArray);\\n                    if(set.contains(word)){\\n                        set.remove(word);\\n                        //put it in map with level+1\\n                        map.put(word , steps+1);\\n                        que.add(word);\\n                    }\\n                }\\n            }\\n        }\\n        res = new ArrayList<>();\\n        if(map.containsKey(endWord)){\\n            List<String> seq = new ArrayList<>();\\n            dfs(seq , endWord);\\n        }\\n        return res;\\n    }\\n    public void dfs(List<String> seq , String str){\\n        // if string is equal to beginWord then add it in seq and\\n        // add seq in res and return\\n        if(str.equals(begin)){\\n            List<String> dup = new ArrayList<>(seq);\\n            dup.add(str);\\n            // as we are going from back to front we need to reverse the seq\\n            Collections.reverse(dup);\\n            res.add(dup);\\n            return;\\n        }\\n        // store the steps(level) of current string\\n        int steps = map.get(str);\\n        for(int i = 0 ; i < str.length() ; i++){\\n            for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                char[] charArray = str.toCharArray();\\n                charArray[i] = ch;\\n                String word = new String(charArray);\\n                // if the word is in the Map and its level+1 == steps \\n                // then add it in seq list and again call the function dfs\\n                // and also backtrack cause at same level another word could\\n                // be present so backtrack after dfs call\\n                if(map.containsKey(word) && map.get(word) + 1 == steps){\\n                    seq.add(str);\\n                    dfs(seq , word);\\n                    seq.remove(seq.size()-1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726687,
                "title": "c-dfs-visual-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/3d6bc18d-8735-47e8-8db1-34c65db0b888_1666290680.9923763.png)\\n![image](https://assets.leetcode.com/users/images/29b5f2b0-2262-42b0-bf2b-40cfae853f08_1666290781.6480842.png)\\n\\n**Implementation:**\\n```\\nclass Solution {\\n    unordered_map<string, int> mp;\\n    vector<vector<string>> ans;\\n    string begin;\\nprivate:\\n    void dfs(string word, vector<string> &seq){\\n        if(word == begin)\\n        {\\n            reverse(seq.begin(), seq.end());\\n            ans.push_back(seq);\\n            reverse(seq.begin(), seq.end());\\n            return;\\n        }\\n        int steps = mp[word];\\n        for(int i = 0; i < word.size(); i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                    word[i] = ch;\\n                    if(mp.find(word) != mp.end() && mp[word]+1 == steps){\\n                        seq.push_back(word);\\n                        dfs(word, seq);\\n                        seq.pop_back();\\n                    }\\n                }\\n                word[i] = original;\\n        }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> s(wordList.begin(), wordList.end());\\n        begin = beginWord;\\n        queue<string> q;\\n        q.push(beginWord);\\n        mp[beginWord] = 1;\\n        s.erase(beginWord);\\n        while(!q.empty())\\n        {\\n            string word = q.front();\\n            int steps = mp[word];\\n            q.pop();\\n            if(word == endWord) break;\\n            for(int i = 0; i < word.size(); i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                    word[i] = ch;\\n                    if(s.count(word))\\n                    {\\n                        q.push(word);\\n                        mp[word]= steps + 1;\\n                        s.erase(word);\\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        \\n        if(mp.find(endWord) != mp.end()){\\n            vector<string> seq;\\n            seq.push_back({endWord});\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> mp;\\n    vector<vector<string>> ans;\\n    string begin;\\nprivate:\\n    void dfs(string word, vector<string> &seq){\\n        if(word == begin)\\n        {\\n            reverse(seq.begin(), seq.end());\\n            ans.push_back(seq);\\n            reverse(seq.begin(), seq.end());\\n            return;\\n        }\\n        int steps = mp[word];\\n        for(int i = 0; i < word.size(); i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                    word[i] = ch;\\n                    if(mp.find(word) != mp.end() && mp[word]+1 == steps){\\n                        seq.push_back(word);\\n                        dfs(word, seq);\\n                        seq.pop_back();\\n                    }\\n                }\\n                word[i] = original;\\n        }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> s(wordList.begin(), wordList.end());\\n        begin = beginWord;\\n        queue<string> q;\\n        q.push(beginWord);\\n        mp[beginWord] = 1;\\n        s.erase(beginWord);\\n        while(!q.empty())\\n        {\\n            string word = q.front();\\n            int steps = mp[word];\\n            q.pop();\\n            if(word == endWord) break;\\n            for(int i = 0; i < word.size(); i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                    word[i] = ch;\\n                    if(s.count(word))\\n                    {\\n                        q.push(word);\\n                        mp[word]= steps + 1;\\n                        s.erase(word);\\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        \\n        if(mp.find(endWord) != mp.end()){\\n            vector<string> seq;\\n            seq.push_back({endWord});\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490649,
                "title": "java-explained",
                "content": "1. Apply BFS to create DAG from endWord to beginWord\\n2. Apply DFS to get the shortest paths using DAG (i.e. get path from endWord to beginWord and reverse)\\n\\n\\t#\\n\\tTime complexity  :  O ( N K^2 + \\u03B1 ) , N = Total words, K = Length of word, \\u03B1 = time required for DFS\\n\\tSpace complexity:  O ( N K )\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>(wordList);\\n        if (!words.contains(endWord)) return Collections.emptyList();\\n        Map<String, List<String>> directedAcyclicGraph = new HashMap<>();\\n\\n        // 1. Apply BFS to create DAG from endWord to beginWord\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n        words.remove(beginWord);\\n        Set<String> enqueued = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            List<String> nextLevelEnqueuedWords = new ArrayList<>();\\n            for (int i = 0; i < n; i++) {\\n                String word = queue.poll();\\n                for (String neighbour : getNeighbours(word, words)) {\\n                    directedAcyclicGraph.putIfAbsent(neighbour, new ArrayList<>());\\n                    directedAcyclicGraph.get(neighbour).add(word);\\n                    if (!enqueued.contains(neighbour)) {\\n                        enqueued.add(neighbour);\\n                        nextLevelEnqueuedWords.add(neighbour);\\n                        queue.offer(neighbour);\\n                    }\\n                }\\n            }\\n\\n            // Remove enqueued nodes of next level to avoid cycle (as we are creating DAG)\\n            for (String enqueuedWord : nextLevelEnqueuedWords)\\n                words.remove(enqueuedWord);\\n        }\\n\\n        // 2. Apply DFS to get the shortest paths using DAG\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> currPath = new ArrayList<>();\\n        dfs(endWord, beginWord, directedAcyclicGraph, currPath, result);\\n        return result;\\n    }\\n\\n    private void dfs(String end, String start, Map<String, List<String>> directedAcyclicGraph, List<String> currPath, List<List<String>> result) {\\n        currPath.add(end);\\n        if (end.equals(start)) {\\n            List<String> path = new ArrayList<>(currPath);\\n            Collections.reverse(path);// Reverse as currPath is from end to start word.\\n            result.add(path);\\n        }\\n        else {\\n            for (String neighbour : directedAcyclicGraph.getOrDefault(end, Collections.emptyList()))\\n                dfs(neighbour, start, directedAcyclicGraph, currPath, result);\\n        }\\n        currPath.remove(currPath.size() - 1);\\n    }\\n\\n    // Helper\\n    private List<String> getNeighbours(String word, Set<String> words) {\\n        List<String> neighbours = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(word);\\n        for (int i = 0; i < word.length(); i++) {\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                sb.setCharAt(i, c);\\n                String neighbour = sb.toString();\\n                if (words.contains(neighbour)) neighbours.add(neighbour);\\n                sb.setCharAt(i, word.charAt(i));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>(wordList);\\n        if (!words.contains(endWord)) return Collections.emptyList();\\n        Map<String, List<String>> directedAcyclicGraph = new HashMap<>();\\n\\n        // 1. Apply BFS to create DAG from endWord to beginWord\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n        words.remove(beginWord);\\n        Set<String> enqueued = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            List<String> nextLevelEnqueuedWords = new ArrayList<>();\\n            for (int i = 0; i < n; i++) {\\n                String word = queue.poll();\\n                for (String neighbour : getNeighbours(word, words)) {\\n                    directedAcyclicGraph.putIfAbsent(neighbour, new ArrayList<>());\\n                    directedAcyclicGraph.get(neighbour).add(word);\\n                    if (!enqueued.contains(neighbour)) {\\n                        enqueued.add(neighbour);\\n                        nextLevelEnqueuedWords.add(neighbour);\\n                        queue.offer(neighbour);\\n                    }\\n                }\\n            }\\n\\n            // Remove enqueued nodes of next level to avoid cycle (as we are creating DAG)\\n            for (String enqueuedWord : nextLevelEnqueuedWords)\\n                words.remove(enqueuedWord);\\n        }\\n\\n        // 2. Apply DFS to get the shortest paths using DAG\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> currPath = new ArrayList<>();\\n        dfs(endWord, beginWord, directedAcyclicGraph, currPath, result);\\n        return result;\\n    }\\n\\n    private void dfs(String end, String start, Map<String, List<String>> directedAcyclicGraph, List<String> currPath, List<List<String>> result) {\\n        currPath.add(end);\\n        if (end.equals(start)) {\\n            List<String> path = new ArrayList<>(currPath);\\n            Collections.reverse(path);// Reverse as currPath is from end to start word.\\n            result.add(path);\\n        }\\n        else {\\n            for (String neighbour : directedAcyclicGraph.getOrDefault(end, Collections.emptyList()))\\n                dfs(neighbour, start, directedAcyclicGraph, currPath, result);\\n        }\\n        currPath.remove(currPath.size() - 1);\\n    }\\n\\n    // Helper\\n    private List<String> getNeighbours(String word, Set<String> words) {\\n        List<String> neighbours = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder(word);\\n        for (int i = 0; i < word.length(); i++) {\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                sb.setCharAt(i, c);\\n                String neighbour = sb.toString();\\n                if (words.contains(neighbour)) neighbours.add(neighbour);\\n                sb.setCharAt(i, word.charAt(i));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426620,
                "title": "python-solution-deque-is-fine-be-efficient-and-smart-of-what-to-put-in-the-queue",
                "content": "As you might know, Leetcode admins like to make our lives harder as time passes, by including more monstrous testcases. **Treat it as an opportunity to learn and improve ourselves**.\\n\\nFor this question, as with many other BFS questions, the way to search efficiently is to **trim down the search space**. Think about what the question is asking for: **all the shortest transformation sequences from beginWord to endWord**. This means the same word can only appear multiple times at the same level, but not in different levels, as a consequence of shortest path property of BFS. To implement that, I keep a deque to host the queue, but I do not put all unvisited neighbours into the queue right after graph search. Instead I put them into a set so as to avoid putting duplicates into the queue (the chief reason why you get TLE from the new testcases). When one level is finished, I put all the set elements into the queue and visited.\\n\\nI use a separate hash map to build a \"parent\" directed graph from beginWord to endWord when I conducted the first BFS. This is very handy to generate the path without wasting time searching irrelevant spaces.\\n\\n\\n```\\nclass Solution:\\n    # Leetcode increases the difficulty of the testcases, making this problem gearing towards efficient implementation of BFS search (timewise and memorywise)\\n    # My strategy is to BFS twice:\\n    # 1. Consider edge cases (endWord not in wordList)\\n    # 2. Build the graph\\n    # 3. First BFS from beginWord with the following rules:\\n    #   a. a node can only appear multiple times at the same level (This is necessary to allow for different paths with same length.)\\n    #   b. We record the used edges in a second hash map graph, to facilitate later path construction. The second graph is directional and acyclic.\\n    # 4. In the second BFS, I would do I did before: directly put the path inside the queue. I would search from endWord to beginWord (bidirectional BFS) on the second hash map graph, so as to reduce the graph complexity\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        # Edge case\\n        if endWord not in wordList:\\n            return []\\n        # Build the graph\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        graph = {}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                key = word[:i] + \"_\" + word[i+1:]\\n                if key not in graph:\\n                    graph[key] = []\\n                graph[key].append(word)\\n        \\n        # First BFS: only visit a node within one level, but allows multiple visits\\n        dq, visited = deque(), set()\\n        dq.append(beginWord)\\n        visited.add(beginWord)\\n        reverse_graph = {}\\n        while dq:\\n            new_seen = set()\\n            for i in range(len(dq)):\\n                node = dq.popleft()\\n                for j in range(len(node)):\\n                    key = node[:j] + \"_\" + node[j+1:]\\n                    for nxt in graph[key]:\\n                        if nxt != node and nxt not in visited:\\n                            new_seen.add(nxt)\\n                            if nxt not in reverse_graph:\\n                                reverse_graph[nxt] = set()\\n                            reverse_graph[nxt].add(node)\\n            for node in new_seen:\\n                visited.add(node)\\n                dq.append(node)\\n            if endWord in visited:\\n                break\\n\\n        if endWord not in visited:\\n            return []\\n        \\n        # Second BFS: search from endWord to beginWord to obtain path\\n        dq, result = deque(), []\\n        dq.append([endWord])\\n        while dq:\\n            path = dq.popleft()\\n            for nxt in reverse_graph[path[0]]:\\n                if nxt != beginWord:\\n                    dq.append([nxt] + path)\\n                else:\\n                    result.append([nxt] + path)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Leetcode increases the difficulty of the testcases, making this problem gearing towards efficient implementation of BFS search (timewise and memorywise)\\n    # My strategy is to BFS twice:\\n    # 1. Consider edge cases (endWord not in wordList)\\n    # 2. Build the graph\\n    # 3. First BFS from beginWord with the following rules:\\n    #   a. a node can only appear multiple times at the same level (This is necessary to allow for different paths with same length.)\\n    #   b. We record the used edges in a second hash map graph, to facilitate later path construction. The second graph is directional and acyclic.\\n    # 4. In the second BFS, I would do I did before: directly put the path inside the queue. I would search from endWord to beginWord (bidirectional BFS) on the second hash map graph, so as to reduce the graph complexity\\n    \\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        # Edge case\\n        if endWord not in wordList:\\n            return []\\n        # Build the graph\\n        if beginWord not in wordList:\\n            wordList.append(beginWord)\\n        graph = {}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                key = word[:i] + \"_\" + word[i+1:]\\n                if key not in graph:\\n                    graph[key] = []\\n                graph[key].append(word)\\n        \\n        # First BFS: only visit a node within one level, but allows multiple visits\\n        dq, visited = deque(), set()\\n        dq.append(beginWord)\\n        visited.add(beginWord)\\n        reverse_graph = {}\\n        while dq:\\n            new_seen = set()\\n            for i in range(len(dq)):\\n                node = dq.popleft()\\n                for j in range(len(node)):\\n                    key = node[:j] + \"_\" + node[j+1:]\\n                    for nxt in graph[key]:\\n                        if nxt != node and nxt not in visited:\\n                            new_seen.add(nxt)\\n                            if nxt not in reverse_graph:\\n                                reverse_graph[nxt] = set()\\n                            reverse_graph[nxt].add(node)\\n            for node in new_seen:\\n                visited.add(node)\\n                dq.append(node)\\n            if endWord in visited:\\n                break\\n\\n        if endWord not in visited:\\n            return []\\n        \\n        # Second BFS: search from endWord to beginWord to obtain path\\n        dq, result = deque(), []\\n        dq.append([endWord])\\n        while dq:\\n            path = dq.popleft()\\n            for nxt in reverse_graph[path[0]]:\\n                if nxt != beginWord:\\n                    dq.append([nxt] + path)\\n                else:\\n                    result.append([nxt] + path)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424843,
                "title": "c-detailed-explanation-complete-code-walkthrough",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Check whether two strings are neighbour to each other , by checking only the different characters at each index.\\n    \\n    bool isNeighbour(string &s1,string &s2){\\n        \\n        int n=s1.length();\\n        \\n        int diff=0;\\n        \\n        for(int i=0;i<n;++i){\\n            if(s1[i]!=s2[i]){\\n                diff++;\\n            }\\n        }\\n        \\n        return diff==1;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    void BFS(int src,vector<vector<int>>&graph,vector<vector<int>>&parent,int n){\\n        \\n        // dist[i] --> shortest distance of node i from node src\\n        \\n        vector<int>dist(n,1e9);\\n        \\n        dist[src]=0;\\n        \\n        /* Base Case --> for the src node , there is no node \\n        possible which can be parent of it , therefore just assign\\n        an offset value as its parent node.*/\\n        \\n        parent[src].push_back(-1);\\n        \\n        \\n        // Queue DS will surely the best to do a BFS traversal\\n        \\n        queue<int>q;\\n        \\n        q.push(src);\\n        \\n        \\n        while(!q.empty()){\\n            \\n            int node=q.front();\\n            q.pop();\\n            \\n            // Explore all its potential neighbouring nodes.\\n            \\n            for(int nbr:graph[node]){\\n                \\n                if(dist[nbr] > dist[node] + 1){\\n                    \\n                    dist[nbr] = dist[node] + 1;\\n                    q.push(nbr);\\n                    parent[nbr].clear();\\n                    parent[nbr].push_back(node);\\n                    \\n                }\\n                \\n                else if(dist[nbr] == dist[node] + 1){\\n                    \\n                    parent[nbr].push_back(node);\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        /* Finally we are done with the BFS traversal and now we\\n        have all the required relations between a node and its\\n        immediate parents , which will be a part of atleast one \\n        shortest path.*/\\n        \\n    }\\n    \\n    \\n    \\n    void DFS(int node,vector<vector<int>>&parent,vector<int>&path,vector<vector<int>>&allpath){\\n        \\n        /* i.e. we able to reach the parent node of the src node,\\n        that is set to (-1) previously , for now include it in our \\n        path , in future in order to calculate the words we will \\n        not gonna count it.*/\\n        \\n        if(node==-1){\\n            \\n            allpath.push_back(path);\\n            return;\\n            \\n        }\\n        \\n        \\n        // Explore all its parent nodes.\\n        \\n        for(int par:parent[node]){\\n            \\n            path.push_back(par);\\n            \\n            DFS(par,parent,path,allpath);\\n            \\n            path.pop_back();\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        /* \\n        \\n        As all the strings in wordList dictionary unique to\\n        each other , therefore it is efficient to access them by\\n        there indices , by doing these there is no need to store\\n        map<string,map<string,int>> kind of data structure which\\n        is space inefficient as well as increase the time \\n        complexity indirectly in case of find or erase operations. */\\n        \\n        int src=-1,dest=-1;\\n        \\n        int n=wordList.size();\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            if(wordList[i]==beginWord){\\n                \\n                src=i;\\n                \\n            }\\n            \\n            if(wordList[i]==endWord){\\n                \\n                dest=i;\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        /* Data structure needed to store all the valid yet \\n           shortest paths from src to dest node.*/\\n        \\n        vector<vector<string>>ans;\\n        \\n        \\n        /* Edge Case : When destination string is not found inside\\n        the wordList dictionary.Then there is no path exist from \\n        src to dest. */\\n        \\n        if(dest==-1){\\n            \\n            return ans;\\n            \\n        }\\n        \\n        \\n        /*\\n        \\n         Edge Case : When src node is not found inside the given\\n         dictionary , then we need to insert it inside the \\n         dictionary and as a result total size (n) of the \\n         dictionay gets increased.\\n        \\n        */\\n        \\n        \\n        if(src==-1){\\n            \\n            wordList.push_back(beginWord);\\n            src=n;\\n            n++;\\n            \\n        }\\n        \\n        \\n        /* These Data Structure will store all the possible parent\\n        nodes of the current node , which are required to build \\n        any of the the shortest path */\\n        \\n        vector<vector<int>>parent(n);\\n        \\n        \\n        /*\\n        \\n        These DS will store the inner links b/w two words , if \\n        they are differing only in one character.\\n        \\n        */\\n        \\n        vector<vector<int>>graph(n);\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=i+1;j<n;++j){\\n                if(isNeighbour(wordList[i],wordList[j])){\\n                    graph[i].push_back(j);\\n                    graph[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        /* Now call the BFS utility function , that will help us \\n        to explore all the shortest paths from src to dest node ,\\n        by maintaining the relationship b/w current node and its \\n        immediate parents . As we want to explore all the paths ,\\n        so it is mandatory to access its parent , then parent of \\n        its parent  , and all the way upto src . Here we access \\n        the paths from dest to src  , you can also do the reverse\\n        of it , if you want.*/\\n        \\n        \\n        BFS(src,graph,parent,n);\\n        \\n        \\n        /*\\n        \\n        Once we have all the relations in our pouch , all we need\\n        to do simply explore all the paths recursively , and for \\n        doing these DFS traversal is most efficient one.\\n        \\n        */\\n        \\n        /*\\n        \\n        As we discussed previously , we are start our journey from \\n        the end(i.e. the dest node) and keep exploring all the \\n        paths upto src node. \\n        \\n        */\\n        \\n        /*\\n        \\n         To store all the paths\\'s nodes we need to maintain a DS ,\\n         that will store them , and again a DS that will store all \\n         the paths at the end of DFS traversal.\\n        \\n        */\\n        \\n        vector<int>path;\\n        \\n        vector<vector<int>>allpath;\\n        \\n        \\n        DFS(dest,parent,path,allpath);\\n        \\n        \\n        /*\\n        \\n    Now at that moment we have all the shortest paths with us.\\n        \\n        */\\n        \\n        \\n        for(auto paths:allpath){\\n            \\n            vector<string>current_path;\\n            \\n            int size=paths.size();\\n            \\n            for(int i=0;i<size-1;++i){\\n                \\n                current_path.push_back(wordList[paths[i]]);\\n                \\n            }\\n            \\n            reverse(current_path.begin(),current_path.end());\\n            \\n            current_path.push_back(endWord);\\n            \\n            ans.push_back(current_path);\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n       /*\\n        \\n        \\n        wordLen --> wordList.size();\\n        wL      --> wordList[i].length();\\n        E       --> Total number of edges in graph\\n        \\n        \\n        \\n        Individual Time Complexities :-->\\n        \\n        \\n        O(wordLen) --> For determining src node and dest node.\\n        \\n        O(wordLen*wordLen*wL)  --> For precomputing the \\n        relationship between each word.\\n        \\n        O(wordLen + E) --> For computing BFS traversal\\n        \\n        O(wordLen*E)  --> For completing the DFS traversal\\n        \\n        \\n        Time Complexity : summation of all the items \\n        \\n       \\n       */\\n        \\n        \\n    }\\n    \\n    \\n};\\n```\\n\\n\\n**PLZ PLZ PLZ UPVOTE IT IF YOU FOUND IT HELPFUL :) **",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Check whether two strings are neighbour to each other , by checking only the different characters at each index.\\n    \\n    bool isNeighbour(string &s1,string &s2){\\n        \\n        int n=s1.length();\\n        \\n        int diff=0;\\n        \\n        for(int i=0;i<n;++i){\\n            if(s1[i]!=s2[i]){\\n                diff++;\\n            }\\n        }\\n        \\n        return diff==1;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    void BFS(int src,vector<vector<int>>&graph,vector<vector<int>>&parent,int n){\\n        \\n        // dist[i] --> shortest distance of node i from node src\\n        \\n        vector<int>dist(n,1e9);\\n        \\n        dist[src]=0;\\n        \\n        /* Base Case --> for the src node , there is no node \\n        possible which can be parent of it , therefore just assign\\n        an offset value as its parent node.*/\\n        \\n        parent[src].push_back(-1);\\n        \\n        \\n        // Queue DS will surely the best to do a BFS traversal\\n        \\n        queue<int>q;\\n        \\n        q.push(src);\\n        \\n        \\n        while(!q.empty()){\\n            \\n            int node=q.front();\\n            q.pop();\\n            \\n            // Explore all its potential neighbouring nodes.\\n            \\n            for(int nbr:graph[node]){\\n                \\n                if(dist[nbr] > dist[node] + 1){\\n                    \\n                    dist[nbr] = dist[node] + 1;\\n                    q.push(nbr);\\n                    parent[nbr].clear();\\n                    parent[nbr].push_back(node);\\n                    \\n                }\\n                \\n                else if(dist[nbr] == dist[node] + 1){\\n                    \\n                    parent[nbr].push_back(node);\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        /* Finally we are done with the BFS traversal and now we\\n        have all the required relations between a node and its\\n        immediate parents , which will be a part of atleast one \\n        shortest path.*/\\n        \\n    }\\n    \\n    \\n    \\n    void DFS(int node,vector<vector<int>>&parent,vector<int>&path,vector<vector<int>>&allpath){\\n        \\n        /* i.e. we able to reach the parent node of the src node,\\n        that is set to (-1) previously , for now include it in our \\n        path , in future in order to calculate the words we will \\n        not gonna count it.*/\\n        \\n        if(node==-1){\\n            \\n            allpath.push_back(path);\\n            return;\\n            \\n        }\\n        \\n        \\n        // Explore all its parent nodes.\\n        \\n        for(int par:parent[node]){\\n            \\n            path.push_back(par);\\n            \\n            DFS(par,parent,path,allpath);\\n            \\n            path.pop_back();\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        /* \\n        \\n        As all the strings in wordList dictionary unique to\\n        each other , therefore it is efficient to access them by\\n        there indices , by doing these there is no need to store\\n        map<string,map<string,int>> kind of data structure which\\n        is space inefficient as well as increase the time \\n        complexity indirectly in case of find or erase operations. */\\n        \\n        int src=-1,dest=-1;\\n        \\n        int n=wordList.size();\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            if(wordList[i]==beginWord){\\n                \\n                src=i;\\n                \\n            }\\n            \\n            if(wordList[i]==endWord){\\n                \\n                dest=i;\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        /* Data structure needed to store all the valid yet \\n           shortest paths from src to dest node.*/\\n        \\n        vector<vector<string>>ans;\\n        \\n        \\n        /* Edge Case : When destination string is not found inside\\n        the wordList dictionary.Then there is no path exist from \\n        src to dest. */\\n        \\n        if(dest==-1){\\n            \\n            return ans;\\n            \\n        }\\n        \\n        \\n        /*\\n        \\n         Edge Case : When src node is not found inside the given\\n         dictionary , then we need to insert it inside the \\n         dictionary and as a result total size (n) of the \\n         dictionay gets increased.\\n        \\n        */\\n        \\n        \\n        if(src==-1){\\n            \\n            wordList.push_back(beginWord);\\n            src=n;\\n            n++;\\n            \\n        }\\n        \\n        \\n        /* These Data Structure will store all the possible parent\\n        nodes of the current node , which are required to build \\n        any of the the shortest path */\\n        \\n        vector<vector<int>>parent(n);\\n        \\n        \\n        /*\\n        \\n        These DS will store the inner links b/w two words , if \\n        they are differing only in one character.\\n        \\n        */\\n        \\n        vector<vector<int>>graph(n);\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=i+1;j<n;++j){\\n                if(isNeighbour(wordList[i],wordList[j])){\\n                    graph[i].push_back(j);\\n                    graph[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        /* Now call the BFS utility function , that will help us \\n        to explore all the shortest paths from src to dest node ,\\n        by maintaining the relationship b/w current node and its \\n        immediate parents . As we want to explore all the paths ,\\n        so it is mandatory to access its parent , then parent of \\n        its parent  , and all the way upto src . Here we access \\n        the paths from dest to src  , you can also do the reverse\\n        of it , if you want.*/\\n        \\n        \\n        BFS(src,graph,parent,n);\\n        \\n        \\n        /*\\n        \\n        Once we have all the relations in our pouch , all we need\\n        to do simply explore all the paths recursively , and for \\n        doing these DFS traversal is most efficient one.\\n        \\n        */\\n        \\n        /*\\n        \\n        As we discussed previously , we are start our journey from \\n        the end(i.e. the dest node) and keep exploring all the \\n        paths upto src node. \\n        \\n        */\\n        \\n        /*\\n        \\n         To store all the paths\\'s nodes we need to maintain a DS ,\\n         that will store them , and again a DS that will store all \\n         the paths at the end of DFS traversal.\\n        \\n        */\\n        \\n        vector<int>path;\\n        \\n        vector<vector<int>>allpath;\\n        \\n        \\n        DFS(dest,parent,path,allpath);\\n        \\n        \\n        /*\\n        \\n    Now at that moment we have all the shortest paths with us.\\n        \\n        */\\n        \\n        \\n        for(auto paths:allpath){\\n            \\n            vector<string>current_path;\\n            \\n            int size=paths.size();\\n            \\n            for(int i=0;i<size-1;++i){\\n                \\n                current_path.push_back(wordList[paths[i]]);\\n                \\n            }\\n            \\n            reverse(current_path.begin(),current_path.end());\\n            \\n            current_path.push_back(endWord);\\n            \\n            ans.push_back(current_path);\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n       /*\\n        \\n        \\n        wordLen --> wordList.size();\\n        wL      --> wordList[i].length();\\n        E       --> Total number of edges in graph\\n        \\n        \\n        \\n        Individual Time Complexities :-->\\n        \\n        \\n        O(wordLen) --> For determining src node and dest node.\\n        \\n        O(wordLen*wordLen*wL)  --> For precomputing the \\n        relationship between each word.\\n        \\n        O(wordLen + E) --> For computing BFS traversal\\n        \\n        O(wordLen*E)  --> For completing the DFS traversal\\n        \\n        \\n        Time Complexity : summation of all the items \\n        \\n       \\n       */\\n        \\n        \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424669,
                "title": "c-optimized-back-tracking-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAdjacent(string str1, string str2){\\n        int diff = 0;\\n        for(int i=0;i<str1.size();i++){\\n            if(str1[i]!=str2[i]){\\n                if(diff==0){\\n                    diff++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return diff==1 ? true: false;\\n    }\\n    \\n    void backTrace(unordered_map<string,vector<string>> parent, string beginWord,string endWord, vector<vector<string>>& result,vector<string> path){\\n        if(endWord == beginWord){\\n            path.push_back(beginWord);\\n            reverse(path.begin(),path.end());\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=0;i<parent[endWord].size();i++){\\n            vector<string> curr_path = path;\\n            curr_path.push_back(endWord);\\n            backTrace(parent, beginWord, parent[endWord][i], result, curr_path);\\n        }\\n        \\n        \\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> notvisited(wordList.begin(), wordList.end());\\n        unordered_map<string,vector<string>> parent;\\n        queue<string> possible;\\n        possible.push(beginWord);\\n        int flag = 0;\\n        while(!possible.empty()){\\n            unordered_set<string> adj;\\n            int size = possible.size();\\n            for(int i=0;i<size;i++){\\n                string currWord = possible.front();\\n                if(currWord == endWord){\\n                    flag = 1;\\n                    break;\\n                }\\n                possible.pop();\\n                \\n                auto it = notvisited.begin();\\n                while(it!=notvisited.end()){\\n                    auto curr= it++;\\n                    if(isAdjacent(currWord,*curr)){\\n                        adj.insert(*curr);\\n                        parent[*curr].push_back(currWord);\\n                    }   \\n                }\\n            }\\n            if(flag==1){\\n                break;\\n            }\\n            //cout<<adj.size()<<endl;\\n            for(auto it = adj.begin();it!=adj.end();it++){\\n                possible.push(*it);\\n                notvisited.erase(*it);\\n            }\\n            \\n        }\\n        vector<vector<string>>result;\\n        vector<string> path;\\n      \\n        backTrace(parent, beginWord,endWord,result,path);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAdjacent(string str1, string str2){\\n        int diff = 0;\\n        for(int i=0;i<str1.size();i++){\\n            if(str1[i]!=str2[i]){\\n                if(diff==0){\\n                    diff++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return diff==1 ? true: false;\\n    }\\n    \\n    void backTrace(unordered_map<string,vector<string>> parent, string beginWord,string endWord, vector<vector<string>>& result,vector<string> path){\\n        if(endWord == beginWord){\\n            path.push_back(beginWord);\\n            reverse(path.begin(),path.end());\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=0;i<parent[endWord].size();i++){\\n            vector<string> curr_path = path;\\n            curr_path.push_back(endWord);\\n            backTrace(parent, beginWord, parent[endWord][i], result, curr_path);\\n        }\\n        \\n        \\n    }\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> notvisited(wordList.begin(), wordList.end());\\n        unordered_map<string,vector<string>> parent;\\n        queue<string> possible;\\n        possible.push(beginWord);\\n        int flag = 0;\\n        while(!possible.empty()){\\n            unordered_set<string> adj;\\n            int size = possible.size();\\n            for(int i=0;i<size;i++){\\n                string currWord = possible.front();\\n                if(currWord == endWord){\\n                    flag = 1;\\n                    break;\\n                }\\n                possible.pop();\\n                \\n                auto it = notvisited.begin();\\n                while(it!=notvisited.end()){\\n                    auto curr= it++;\\n                    if(isAdjacent(currWord,*curr)){\\n                        adj.insert(*curr);\\n                        parent[*curr].push_back(currWord);\\n                    }   \\n                }\\n            }\\n            if(flag==1){\\n                break;\\n            }\\n            //cout<<adj.size()<<endl;\\n            for(auto it = adj.begin();it!=adj.end();it++){\\n                possible.push(*it);\\n                notvisited.erase(*it);\\n            }\\n            \\n        }\\n        vector<vector<string>>result;\\n        vector<string> path;\\n      \\n        backTrace(parent, beginWord,endWord,result,path);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2423713,
                "title": "c-dijkstra-dfs-no-tle-in-2022-08-easy-and-concise",
                "content": "The idea is simple:\\n\\n1. Treat a word as a vertex in a graph\\n2. Add edges for those word-pair differing by a single letter\\n3. Apply the Dijkstra algorithm\\n4. Backtracking the path by deep-first-search  \\n\\nPlease upvote this if you find it\\'s helpful.\\n\\n```\\nclass Solution {\\npublic:\\n    using p_t = pair<int, string>;\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;\\n        unordered_set<string> dic(wordList.begin(), wordList.end());\\n        unordered_map<string, vector<string>> adj;\\n        unordered_map<string, int> dis;\\n        \\n        dic.insert(beginWord);\\n        dis[beginWord] = 0;\\n        int word_len = wordList[0].size();\\n        \\n        // construct adj graph\\n        for (auto& w : dic) {\\n            for (int i = 0; i < word_len; ++i) {\\n                string t = w;\\n                for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n                    t[i] = c;\\n                    if (t != w && dic.count(t)) {\\n                        adj[w].push_back(t);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // do dijkstra\\n        priority_queue<p_t, vector<p_t>, greater<p_t>> pq;\\n        pq.push({0, beginWord});\\n        while (!pq.empty()) {\\n            auto [top_dis, top_word] = pq.top();\\n            pq.pop();\\n            \\n            if (dis[top_word] < top_dis) {\\n                continue;\\n            }\\n            \\n            for (auto& w : adj[top_word]) {\\n                const string& u = top_word;\\n                const string& v = w;\\n                if (!dis.count(v)) { // original dis is INF\\n                    dis[v] = top_dis + 1;\\n                    pq.push({dis[v], v});\\n                } else if (dis[v] > dis[u] + 1) {  // original dis is larger\\n                    dis[v] = dis[u] + 1;\\n                    pq.push({dis[v], v});\\n                }\\n            }\\n        }\\n        \\n        if (dis.find(endWord) == dis.end()) {\\n            // didn\\'t find any available solution\\n            return ans;\\n        }\\n\\n        // we have some solutions now.\\n        // construct it from the end to the begin\\n        int ans_depth = dis[endWord];\\n        vector<string> cur{endWord};\\n        function<void()> dfs = [&]() {\\n            string& at = cur.back();\\n            int depth = ans_depth - cur.size() + 1;\\n\\n            // reached the beginning\\n            if (at == beginWord) {\\n                vector<string> tmp = cur;\\n                reverse(tmp.begin(), tmp.end());\\n                ans.push_back(move(tmp));\\n                return;\\n            }\\n\\n            // go to the next level\\n            for (auto& w : adj[at]) {\\n                if (dis.count(w) && dis[w] == depth - 1) {\\n                    cur.push_back(w);\\n                    dfs();\\n                    cur.pop_back();\\n                }                \\n            }\\n        };\\n        dfs();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nI was struggling with the BFS + recorded-path solution because most of top-rated solutions indicated that\\'s a reasonble way to solve this question. \\n\\nSo I spent lots of time figuring out how to optimise my BFS solution ...\\n\\nAnd thanks for the other posts created today that remind me \"dijkstra\" keyword. I cannot come up with the solution without them.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using p_t = pair<int, string>;\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        vector<vector<string>> ans;\\n        unordered_set<string> dic(wordList.begin(), wordList.end());\\n        unordered_map<string, vector<string>> adj;\\n        unordered_map<string, int> dis;\\n        \\n        dic.insert(beginWord);\\n        dis[beginWord] = 0;\\n        int word_len = wordList[0].size();\\n        \\n        // construct adj graph\\n        for (auto& w : dic) {\\n            for (int i = 0; i < word_len; ++i) {\\n                string t = w;\\n                for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n                    t[i] = c;\\n                    if (t != w && dic.count(t)) {\\n                        adj[w].push_back(t);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // do dijkstra\\n        priority_queue<p_t, vector<p_t>, greater<p_t>> pq;\\n        pq.push({0, beginWord});\\n        while (!pq.empty()) {\\n            auto [top_dis, top_word] = pq.top();\\n            pq.pop();\\n            \\n            if (dis[top_word] < top_dis) {\\n                continue;\\n            }\\n            \\n            for (auto& w : adj[top_word]) {\\n                const string& u = top_word;\\n                const string& v = w;\\n                if (!dis.count(v)) { // original dis is INF\\n                    dis[v] = top_dis + 1;\\n                    pq.push({dis[v], v});\\n                } else if (dis[v] > dis[u] + 1) {  // original dis is larger\\n                    dis[v] = dis[u] + 1;\\n                    pq.push({dis[v], v});\\n                }\\n            }\\n        }\\n        \\n        if (dis.find(endWord) == dis.end()) {\\n            // didn\\'t find any available solution\\n            return ans;\\n        }\\n\\n        // we have some solutions now.\\n        // construct it from the end to the begin\\n        int ans_depth = dis[endWord];\\n        vector<string> cur{endWord};\\n        function<void()> dfs = [&]() {\\n            string& at = cur.back();\\n            int depth = ans_depth - cur.size() + 1;\\n\\n            // reached the beginning\\n            if (at == beginWord) {\\n                vector<string> tmp = cur;\\n                reverse(tmp.begin(), tmp.end());\\n                ans.push_back(move(tmp));\\n                return;\\n            }\\n\\n            // go to the next level\\n            for (auto& w : adj[at]) {\\n                if (dis.count(w) && dis[w] == depth - 1) {\\n                    cur.push_back(w);\\n                    dfs();\\n                    cur.pop_back();\\n                }                \\n            }\\n        };\\n        dfs();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422004,
                "title": "python-accepted-solution",
                "content": "```\\nclass Solution:\\n    def findLadders(self,  beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        if endWord not in wordList:\\n            return []\\n\\n        neighbors = defaultdict(list)\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for j in range(len(word)):\\n                pattern = f\"{word[:j]}*{word[j+1:]}\"\\n                neighbors[pattern].append(word)\\n\\n        def bfs() -> int:\\n            visited = set([beginWord])\\n            queue = deque([beginWord])\\n            depth = 1\\n            while queue:\\n                for _ in range(len(queue)):\\n                    word = queue.popleft()\\n                    if word == endWord:\\n                        return depth\\n                    for j in range(len(word)):\\n                        pattern = f\"{word[:j]}*{word[j+1:]}\"\\n                        for neighbor in neighbors[pattern]:\\n                            if neighbor in visited:\\n                                continue\\n                            visited.add(neighbor)\\n                            queue.append(neighbor)\\n                depth += 1\\n\\n        @lru_cache(maxsize=None)\\n        def dfs_backtrack(word, depth):\\n            if word == endWord:\\n                return [[word]]\\n            elif depth == 1:\\n                return\\n            else:\\n                results = []\\n                visited.add(word)\\n                for i in range(len(word)):\\n                    pattern = f\"{word[:i]}*{word[i+1:]}\"\\n                    for neighbor in neighbors[pattern]:\\n                        if neighbor in visited:\\n                            continue\\n                        result = dfs_backtrack(neighbor, depth - 1)\\n                        if result:\\n                            for r in result:\\n                                results.append([word] + r)\\n                visited.remove(word)\\n                return results\\n\\n        depth = bfs()\\n        visited = set([beginWord])\\n        results = []\\n\\n        results = dfs_backtrack(beginWord, depth)\\n\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self,  beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        if endWord not in wordList:\\n            return []\\n\\n        neighbors = defaultdict(list)\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for j in range(len(word)):\\n                pattern = f\"{word[:j]}*{word[j+1:]}\"\\n                neighbors[pattern].append(word)\\n\\n        def bfs() -> int:\\n            visited = set([beginWord])\\n            queue = deque([beginWord])\\n            depth = 1\\n            while queue:\\n                for _ in range(len(queue)):\\n                    word = queue.popleft()\\n                    if word == endWord:\\n                        return depth\\n                    for j in range(len(word)):\\n                        pattern = f\"{word[:j]}*{word[j+1:]}\"\\n                        for neighbor in neighbors[pattern]:\\n                            if neighbor in visited:\\n                                continue\\n                            visited.add(neighbor)\\n                            queue.append(neighbor)\\n                depth += 1\\n\\n        @lru_cache(maxsize=None)\\n        def dfs_backtrack(word, depth):\\n            if word == endWord:\\n                return [[word]]\\n            elif depth == 1:\\n                return\\n            else:\\n                results = []\\n                visited.add(word)\\n                for i in range(len(word)):\\n                    pattern = f\"{word[:i]}*{word[i+1:]}\"\\n                    for neighbor in neighbors[pattern]:\\n                        if neighbor in visited:\\n                            continue\\n                        result = dfs_backtrack(neighbor, depth - 1)\\n                        if result:\\n                            for r in result:\\n                                results.append([word] + r)\\n                visited.remove(word)\\n                return results\\n\\n        depth = bfs()\\n        visited = set([beginWord])\\n        results = []\\n\\n        results = dfs_backtrack(beginWord, depth)\\n\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421931,
                "title": "java-no-tle",
                "content": "My previous answers TLE now.. Instead of starting from the beginword, we need to start from the endword to reduce the number of searches for dfs\\n```\\nclass Solution {\\n    List<List<String>> res;\\n    Map<Integer, Set<String>> map;\\n    Set<String> set;\\n    int goal;\\n    String es;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        res = new LinkedList<>();\\n        set = new HashSet<>(wordList);\\n        es = endWord;\\n        if(!set.contains(endWord)) return(res);\\n        int step = 0;\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        Set<String> seen = new HashSet<>();\\n        seen.add(beginWord);\\n        map = new HashMap<>();\\n        boolean found = false;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            map.put(step, new HashSet<>());\\n            while(sz-- > 0){\\n                String cs = q.poll();\\n                map.get(step).add(cs);\\n                if(cs.equals(endWord)){\\n                    found = true;\\n                    break;\\n                }\\n                Set<String> nbrs = nb(cs, set, seen);\\n                for(String ns: nbrs){\\n                    q.offer(ns);\\n                }\\n            }\\n            if(found) break;\\n            step++;\\n        }\\n        if(!found) return(res);\\n        //System.out.println(step);\\n        //System.out.println(map);\\n        goal = step;\\n        List<String> list = new LinkedList<>();\\n        list.add(es);\\n        dfs(es, goal, list);\\n        return(res);\\n    }\\n    \\n    public void dfs(String s, int level, List<String> list){\\n        if(level == 0){\\n            List<String> copy = new LinkedList<>(list);\\n            Collections.reverse(copy);\\n            res.add(copy);\\n            return;\\n        }\\n        Set<String> nbrs = new HashSet<>();\\n        for(String nss: map.get(level - 1)){\\n            if(isnb(nss, s)) nbrs.add(nss);\\n        }\\n        for(String ns: nbrs){\\n            list.add(ns);\\n            dfs(ns, level - 1, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n    public boolean isnb(String s1, String s2){\\n        int n = s1.length();\\n        int d = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s1.charAt(i) != s2.charAt(i)) d++;\\n        }\\n        return(d == 1);\\n    }\\n    public Set<String> nnb(String s, Set<String> set, int dep){\\n        Set<String> res = new HashSet<>();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++){\\n            int chi = s.charAt(i) - \\'a\\';\\n            for(int j = 0; j < 26; j++){\\n                if(j == chi) continue;\\n                String ns = s.substring(0, i) + (char)(\\'a\\' + j) + s.substring(i + 1);\\n            }\\n        }\\n        return(res);\\n    }\\n    public Set<String> nb(String s, Set<String> set, Set<String> seen){\\n        Set<String> res = new HashSet<>();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++){\\n            int chi = s.charAt(i) - \\'a\\';\\n            for(int j = 0; j < 26; j++){\\n                if(j == chi) continue;\\n                String ns = s.substring(0, i) + (char)(\\'a\\' + j) + s.substring(i + 1);\\n                if(set.contains(ns) && seen.add(ns)) res.add(ns);\\n                \\n            }\\n        }\\n        return(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> res;\\n    Map<Integer, Set<String>> map;\\n    Set<String> set;\\n    int goal;\\n    String es;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        res = new LinkedList<>();\\n        set = new HashSet<>(wordList);\\n        es = endWord;\\n        if(!set.contains(endWord)) return(res);\\n        int step = 0;\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        Set<String> seen = new HashSet<>();\\n        seen.add(beginWord);\\n        map = new HashMap<>();\\n        boolean found = false;\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            map.put(step, new HashSet<>());\\n            while(sz-- > 0){\\n                String cs = q.poll();\\n                map.get(step).add(cs);\\n                if(cs.equals(endWord)){\\n                    found = true;\\n                    break;\\n                }\\n                Set<String> nbrs = nb(cs, set, seen);\\n                for(String ns: nbrs){\\n                    q.offer(ns);\\n                }\\n            }\\n            if(found) break;\\n            step++;\\n        }\\n        if(!found) return(res);\\n        //System.out.println(step);\\n        //System.out.println(map);\\n        goal = step;\\n        List<String> list = new LinkedList<>();\\n        list.add(es);\\n        dfs(es, goal, list);\\n        return(res);\\n    }\\n    \\n    public void dfs(String s, int level, List<String> list){\\n        if(level == 0){\\n            List<String> copy = new LinkedList<>(list);\\n            Collections.reverse(copy);\\n            res.add(copy);\\n            return;\\n        }\\n        Set<String> nbrs = new HashSet<>();\\n        for(String nss: map.get(level - 1)){\\n            if(isnb(nss, s)) nbrs.add(nss);\\n        }\\n        for(String ns: nbrs){\\n            list.add(ns);\\n            dfs(ns, level - 1, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n    public boolean isnb(String s1, String s2){\\n        int n = s1.length();\\n        int d = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s1.charAt(i) != s2.charAt(i)) d++;\\n        }\\n        return(d == 1);\\n    }\\n    public Set<String> nnb(String s, Set<String> set, int dep){\\n        Set<String> res = new HashSet<>();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++){\\n            int chi = s.charAt(i) - \\'a\\';\\n            for(int j = 0; j < 26; j++){\\n                if(j == chi) continue;\\n                String ns = s.substring(0, i) + (char)(\\'a\\' + j) + s.substring(i + 1);\\n            }\\n        }\\n        return(res);\\n    }\\n    public Set<String> nb(String s, Set<String> set, Set<String> seen){\\n        Set<String> res = new HashSet<>();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++){\\n            int chi = s.charAt(i) - \\'a\\';\\n            for(int j = 0; j < 26; j++){\\n                if(j == chi) continue;\\n                String ns = s.substring(0, i) + (char)(\\'a\\' + j) + s.substring(i + 1);\\n                if(set.contains(ns) && seen.add(ns)) res.add(ns);\\n                \\n            }\\n        }\\n        return(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421853,
                "title": "c",
                "content": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        wordList.insert(wordList.begin(), beginWord);\\n        for (int i = 1; i < wordList.size(); i++){\\n            if (wordList[i].compare(wordList[0]) == 0){\\n                wordList[i] = wordList.back();\\n                wordList.pop_back();\\n                break;\\n            }\\n        }\\n        unordered_map<string, int> word_to_index;\\n        for (int i = 0; i < wordList.size(); i++){\\n            word_to_index.insert({wordList[i], i});\\n        }\\n        if (word_to_index.count(endWord) == 0) return {};\\n        \\n        vector<vector<int>> edges(word_to_index.size());\\n        for (int i = 0; i < wordList.size(); i++){\\n            for (int j = 0; j < wordList.size(); j++){\\n                if (i == j) continue;\\n                if (differ_by_one(wordList[i], wordList[j])){\\n                    edges[i].push_back(j);\\n                }\\n            }\\n        }\\n        // BFS search, lets start from node=0, \\n        int start_node = 0, target_node = word_to_index[endWord];\\n        vector<int> marked(wordList.size(), INT_MAX);   marked[start_node] = 0;\\n        queue<int> units;   units.push(start_node);\\n        int r = 0;\\n        int min_step = INT_MAX;\\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                int node = units.front();  units.pop();\\n                if (node == target_node){\\n                    min_step = min(min_step, r);\\n                }\\n                for (int j = 0; j < edges[node].size(); j++){\\n                    int update_node = edges[node][j];\\n                    if (r+1 < marked[update_node]){\\n                        marked[update_node] = r+1;\\n                        units.push(update_node);\\n                    }\\n                }\\n            }\\n            r++;\\n        }\\n        // printf(\"min_step = %d\\\\n\", min_step);\\n        if (min_step == INT_MAX){\\n            return {};\\n        }\\n        queue<vector<string>> seqs; seqs.push({wordList[target_node]});\\n        r = min_step;\\n        while(r > 0){\\n            int round_size = seqs.size();\\n            for (int i = 0; i < round_size; i++){\\n                vector<string> seq = seqs.front();  seqs.pop();\\n                string back = seq.back();\\n                int node = word_to_index[back];\\n                for (int j = 0; j < edges[node].size(); j++){\\n                    int update_node = edges[node][j];\\n                    if (marked[update_node] == r - 1){\\n                        seq.push_back(wordList[update_node]);\\n                        seqs.push(seq);\\n                        seq.pop_back();\\n                    }\\n                }\\n            }\\n            r--;\\n        }\\n        vector<vector<string>> result;\\n        while(!seqs.empty()){\\n            vector<string> seq = seqs.front(); seqs.pop();\\n            reverse(seq.begin(), seq.end());\\n            result.push_back(seq);\\n        }\\n        return result;\\n    }\\n    bool differ_by_one(string a, string b){\\n        \\n        int differ = 0;\\n        for (int i = 0; i < a.size(); i++){\\n            if (a[i] != b[i]){\\n                differ += 1;\\n                if (differ > 1) return false;\\n            }\\n        }\\n        return differ == 1;\\n    }\\n};\\n\\n\\n\\n\\n```\\n    \\n\\t\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        wordList.insert(wordList.begin(), beginWord);\\n        for (int i = 1; i < wordList.size(); i++){\\n            if (wordList[i].compare(wordList[0]) == 0){\\n                wordList[i] = wordList.back();\\n                wordList.pop_back();\\n                break;\\n            }\\n        }\\n        unordered_map<string, int> word_to_index;\\n        for (int i = 0; i < wordList.size(); i++){\\n            word_to_index.insert({wordList[i], i});\\n        }\\n        if (word_to_index.count(endWord) == 0) return {};\\n        \\n        vector<vector<int>> edges(word_to_index.size());\\n        for (int i = 0; i < wordList.size(); i++){\\n            for (int j = 0; j < wordList.size(); j++){\\n                if (i == j) continue;\\n                if (differ_by_one(wordList[i], wordList[j])){\\n                    edges[i].push_back(j);\\n                }\\n            }\\n        }\\n        // BFS search, lets start from node=0, \\n        int start_node = 0, target_node = word_to_index[endWord];\\n        vector<int> marked(wordList.size(), INT_MAX);   marked[start_node] = 0;\\n        queue<int> units;   units.push(start_node);\\n        int r = 0;\\n        int min_step = INT_MAX;\\n        while(!units.empty()){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                int node = units.front();  units.pop();\\n                if (node == target_node){\\n                    min_step = min(min_step, r);\\n                }\\n                for (int j = 0; j < edges[node].size(); j++){\\n                    int update_node = edges[node][j];\\n                    if (r+1 < marked[update_node]){\\n                        marked[update_node] = r+1;\\n                        units.push(update_node);\\n                    }\\n                }\\n            }\\n            r++;\\n        }\\n        // printf(\"min_step = %d\\\\n\", min_step);\\n        if (min_step == INT_MAX){\\n            return {};\\n        }\\n        queue<vector<string>> seqs; seqs.push({wordList[target_node]});\\n        r = min_step;\\n        while(r > 0){\\n            int round_size = seqs.size();\\n            for (int i = 0; i < round_size; i++){\\n                vector<string> seq = seqs.front();  seqs.pop();\\n                string back = seq.back();\\n                int node = word_to_index[back];\\n                for (int j = 0; j < edges[node].size(); j++){\\n                    int update_node = edges[node][j];\\n                    if (marked[update_node] == r - 1){\\n                        seq.push_back(wordList[update_node]);\\n                        seqs.push(seq);\\n                        seq.pop_back();\\n                    }\\n                }\\n            }\\n            r--;\\n        }\\n        vector<vector<string>> result;\\n        while(!seqs.empty()){\\n            vector<string> seq = seqs.front(); seqs.pop();\\n            reverse(seq.begin(), seq.end());\\n            result.push_back(seq);\\n        }\\n        return result;\\n    }\\n    bool differ_by_one(string a, string b){\\n        \\n        int differ = 0;\\n        for (int i = 0; i < a.size(); i++){\\n            if (a[i] != b[i]){\\n                differ += 1;\\n                if (differ > 1) return false;\\n            }\\n        }\\n        return differ == 1;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365709,
                "title": "v",
                "content": "```\\n\\nclass Solution {\\n\\t vector<vector<string>> ans;\\npublic:\\n\\t void helper(string start,string end,unordered_set<string> &st){\\n\\t\\t  queue<vector<string>> q;\\n\\t\\t  q.push({start});  //storing path\\n\\t\\t   bool flag=false;\\n\\t\\t  while(!q.empty()){\\n\\t\\t\\t  int n=q.size();\\n\\t\\t\\t  while(n--)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  vector<string> curr_path=q.front(); \\n\\t\\t\\t\\t  q.pop();\\n\\t\\t\\t\\t  if(curr_path.back()==end){\\n\\t\\t\\t\\t\\t  ans.push_back(curr_path);\\n\\t\\t\\t\\t\\t  flag=true;  //if we got our answer then we need to consider\\n\\t\\t\\t\\t\\t\\t// only this level of bfs\\n\\t\\t\\t\\t\\t   continue;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  string temp=curr_path.back();\\n\\t\\t\\t\\t  st.erase(temp);\\n\\t\\t\\t\\t  for(int j=0;j<temp.length();j++){\\n\\t\\t\\t\\t\\t\\tstring curr=temp;\\n\\t\\t\\t\\t\\t  for(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\t  curr[j]=i+\\'a\\';\\n\\t\\t\\t\\t\\t\\t  // cout<<curr<<\" \";\\n\\t\\t\\t\\t\\t\\t  if(st.find(curr)!=st.end()){ \\n\\t\\t\\t\\t\\t\\t\\t   curr_path.push_back(curr);\\n\\t\\t\\t\\t\\t\\t\\t   q.push({curr_path});\\n\\t\\t\\t\\t\\t\\t\\t  curr_path.pop_back();\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t\\t\\t  if(flag)  break;\\n\\t\\t  }\\n\\t}\\n\\tvector<vector<string>> findLadders(string start, string end, vector<string>& wordList) {\\n\\t\\t\\t unordered_set<string> st;\\n\\t\\t\\t for(auto &it: wordList) st.insert(it);\\n\\n\\t\\t\\t if(st.find(end)==st.end()) return {};\\n\\t\\t\\t helper(start,end,st);\\n\\t\\t   return ans;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n\\t vector<vector<string>> ans;\\npublic:\\n\\t void helper(string start,string end,unordered_set<string> &st){\\n\\t\\t  queue<vector<string>> q;\\n\\t\\t  q.push({start});  //storing path\\n\\t\\t   bool flag=false;\\n\\t\\t  while(!q.empty()){\\n\\t\\t\\t  int n=q.size();\\n\\t\\t\\t  while(n--)\\n\\t\\t\\t  {\\n\\t\\t\\t\\t  vector<string> curr_path=q.front(); \\n\\t\\t\\t\\t  q.pop();\\n\\t\\t\\t\\t  if(curr_path.back()==end){\\n\\t\\t\\t\\t\\t  ans.push_back(curr_path);\\n\\t\\t\\t\\t\\t  flag=true;  //if we got our answer then we need to consider\\n\\t\\t\\t\\t\\t\\t// only this level of bfs\\n\\t\\t\\t\\t\\t   continue;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  string temp=curr_path.back();\\n\\t\\t\\t\\t  st.erase(temp);\\n\\t\\t\\t\\t  for(int j=0;j<temp.length();j++){\\n\\t\\t\\t\\t\\t\\tstring curr=temp;\\n\\t\\t\\t\\t\\t  for(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\t  curr[j]=i+\\'a\\';\\n\\t\\t\\t\\t\\t\\t  // cout<<curr<<\" \";\\n\\t\\t\\t\\t\\t\\t  if(st.find(curr)!=st.end()){ \\n\\t\\t\\t\\t\\t\\t\\t   curr_path.push_back(curr);\\n\\t\\t\\t\\t\\t\\t\\t   q.push({curr_path});\\n\\t\\t\\t\\t\\t\\t\\t  curr_path.pop_back();\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t\\t\\t  if(flag)  break;\\n\\t\\t  }\\n\\t}\\n\\tvector<vector<string>> findLadders(string start, string end, vector<string>& wordList) {\\n\\t\\t\\t unordered_set<string> st;\\n\\t\\t\\t for(auto &it: wordList) st.insert(it);\\n\\n\\t\\t\\t if(st.find(end)==st.end()) return {};\\n\\t\\t\\t helper(start,end,st);\\n\\t\\t   return ans;\\n\\t}\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2262529,
                "title": "python3-bidirectional-bfs-does-not-tle-in-july-2022",
                "content": "Inspired by the LC C++ solution and the bidirecitonal BFS solution from Word Ladder I.\\nThe percentile is still low likely because it\\'s compared to older solutions with older input sets.\\n\\nThe use of a `frontier` set of words could be optimized out; see the official solution in C++ for the difference.\\n```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        if endWord not in wordList:\\n            return []\\n\\n        lw = len(beginWord)\\n        # build variants list/graph\\n        variants: dict[str, list[str]] = defaultdict(list)\\n        for word in wordList:\\n            for i in range(lw):\\n                key = word[:i] + \\'*\\' + word[i + 1:]\\n                variants[key].append(word)\\n\\n        # bi-bfs to build the graph of paths\\n        q1: deque[str] = deque([beginWord])  # queue starting from beginWord\\n        q2: deque[str] = deque([endWord])    # queue from the back with endWord\\n        v1: set[str] = {beginWord}  # visited nodes starting from beginWord\\n        v2: set[str] = {endWord}    # visited nodes starting from endWord\\n\\n        found: bool = False\\n        graph: dict[str, set[str]] = defaultdict(set)\\n\\n        def edge(src: str, dest: str, forward: bool) -> None:\\n            if forward:\\n                graph[src].add(dest)\\n            else:\\n                graph[dest].add(src)\\n\\n        def bfs(q: deque[str], seen: set[str], opposing: set[str], forward: bool) -> None:\\n            nonlocal found\\n            lq = len(q)\\n            frontier: set[str] = set()\\n            for _ in range(lq):\\n                curr = q.popleft()\\n                for i in range(lw):\\n                    key = curr[:i] + \\'*\\' + curr[i + 1:]\\n                    for neigh in variants[key]:\\n                        if neigh in opposing:\\n                            edge(curr, neigh, forward)\\n                            found = True\\n                        elif neigh not in seen or neigh in frontier:\\n                            q.append(neigh)\\n                            edge(curr, neigh, forward)\\n                            seen.add(neigh)\\n                            frontier.add(neigh)\\n\\n        while q1 and q2 and not found:\\n            if len(q1) <= len(q2):\\n                bfs(q1, v1, v2, forward=True)\\n            else:\\n                bfs(q2, v2, v1, forward=False)\\n\\n        # traverse paths with backtracking\\n        all_paths: list[list[str]] = []\\n        path: list[str] = [beginWord]\\n\\n        def find_paths(curr: str) -> None:\\n            if curr == endWord:\\n                all_paths.append(path.copy())\\n                return\\n            for neigh in graph[curr]:\\n                path.append(neigh)\\n                find_paths(neigh)\\n                path.pop()\\n\\n        find_paths(beginWord)\\n        return all_paths\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        if endWord not in wordList:\\n            return []\\n\\n        lw = len(beginWord)\\n        # build variants list/graph\\n        variants: dict[str, list[str]] = defaultdict(list)\\n        for word in wordList:\\n            for i in range(lw):\\n                key = word[:i] + \\'*\\' + word[i + 1:]\\n                variants[key].append(word)\\n\\n        # bi-bfs to build the graph of paths\\n        q1: deque[str] = deque([beginWord])  # queue starting from beginWord\\n        q2: deque[str] = deque([endWord])    # queue from the back with endWord\\n        v1: set[str] = {beginWord}  # visited nodes starting from beginWord\\n        v2: set[str] = {endWord}    # visited nodes starting from endWord\\n\\n        found: bool = False\\n        graph: dict[str, set[str]] = defaultdict(set)\\n\\n        def edge(src: str, dest: str, forward: bool) -> None:\\n            if forward:\\n                graph[src].add(dest)\\n            else:\\n                graph[dest].add(src)\\n\\n        def bfs(q: deque[str], seen: set[str], opposing: set[str], forward: bool) -> None:\\n            nonlocal found\\n            lq = len(q)\\n            frontier: set[str] = set()\\n            for _ in range(lq):\\n                curr = q.popleft()\\n                for i in range(lw):\\n                    key = curr[:i] + \\'*\\' + curr[i + 1:]\\n                    for neigh in variants[key]:\\n                        if neigh in opposing:\\n                            edge(curr, neigh, forward)\\n                            found = True\\n                        elif neigh not in seen or neigh in frontier:\\n                            q.append(neigh)\\n                            edge(curr, neigh, forward)\\n                            seen.add(neigh)\\n                            frontier.add(neigh)\\n\\n        while q1 and q2 and not found:\\n            if len(q1) <= len(q2):\\n                bfs(q1, v1, v2, forward=True)\\n            else:\\n                bfs(q2, v2, v1, forward=False)\\n\\n        # traverse paths with backtracking\\n        all_paths: list[list[str]] = []\\n        path: list[str] = [beginWord]\\n\\n        def find_paths(curr: str) -> None:\\n            if curr == endWord:\\n                all_paths.append(path.copy())\\n                return\\n            for neigh in graph[curr]:\\n                path.append(neigh)\\n                find_paths(neigh)\\n                path.pop()\\n\\n        find_paths(beginWord)\\n        return all_paths\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250548,
                "title": "python-solution-no-levels-bfs-dfs-easy-to-understand",
                "content": "The idea here is to run a BFS from the end and determine the distance of each node to the end node. We then run a DFS from the start but only traverse edges that reduce the distance by exactly one at each step.\\n\\nNote that this approach seems to use a bit more memory than the \"standard\" ones (~15.8MB and scored as being in the bottom 5%) but runs just as fast (top 40%) as the optimized solution.\\n\\n```\\nfrom collections import defaultdict as dd\\n\\ndef reductions(w):\\n    \"\"\"\\n\\tSimple helper function that maps each word to that word with one letter replaced by \\'.\\'\\n\\t\\n\\tUsed to find neighbors in the graph\\n\\t\"\"\"\\n    for i in range(len(w)):\\n        yield w[:i] + \".\" + w[i+1:]\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        neighbors = dd(set)\\n        sets = dd(set)\\n\\t\\t\\n\\t\\t# beginWord can be safely added to the graph and this is helpful to handle edge cases later\\n        wordList = set(wordList) | set([beginWord])\\n\\t\\t\\n\\t\\t# First figure out the neighbors of each node. We do this by adding each word to a collection of words that differ\\n\\t\\t# by one letter only\\n\\t\\t\\n        for w in wordList:\\n            for x in reductions(w):\\n                sets[x].add(w)\\n        \\n        for w in wordList:\\n            for x in reductions(w):\\n                neighbors[w] |= sets[x]\\n               \\n\\t\\t# We then run a BFS starting at the end to determine the distance of each node to the end\\n        distances = dd(lambda: float(\\'inf\\'))\\n        distances[endWord] = 0\\n        search = [endWord]\\n        d = 0\\n        while search:\\n            next_search = []\\n            for s in search:\\n                for n in neighbors[s]:\\n                    if n in distances:\\n                        continue\\n                    distances[n] = d + 1\\n                    next_search.append(n)\\n            search = next_search\\n            d += 1\\n         \\n\\t\\t# If we never reached beginWord in our DFS there are no solutions here, return an empty list\\n        if beginWord not in distances:\\n            return []\\n            \\n\\t\\t# Our recursive function that explores the graph from the start decreasing the distance by one each time and yielding\\n\\t\\t# all the paths\\n        def paths(start):\\n            if start == endWord:\\n                yield [start]\\n                return\\n            \\n            d = distances[start]\\n            for n in neighbors[start]:\\n                if distances[n] != d -1:\\n                    continue\\n                for p in paths(n):\\n                    yield [start] + p\\n        \\n        return paths(beginWord)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfrom collections import defaultdict as dd\\n\\ndef reductions(w):\\n    \"\"\"\\n\\tSimple helper function that maps each word to that word with one letter replaced by \\'.\\'\\n\\t\\n\\tUsed to find neighbors in the graph\\n\\t\"\"\"\\n    for i in range(len(w)):\\n        yield w[:i] + \".\" + w[i+1:]\\n\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        neighbors = dd(set)\\n        sets = dd(set)\\n\\t\\t\\n\\t\\t# beginWord can be safely added to the graph and this is helpful to handle edge cases later\\n        wordList = set(wordList) | set([beginWord])\\n\\t\\t\\n\\t\\t# First figure out the neighbors of each node. We do this by adding each word to a collection of words that differ\\n\\t\\t# by one letter only\\n\\t\\t\\n        for w in wordList:\\n            for x in reductions(w):\\n                sets[x].add(w)\\n        \\n        for w in wordList:\\n            for x in reductions(w):\\n                neighbors[w] |= sets[x]\\n               \\n\\t\\t# We then run a BFS starting at the end to determine the distance of each node to the end\\n        distances = dd(lambda: float(\\'inf\\'))\\n        distances[endWord] = 0\\n        search = [endWord]\\n        d = 0\\n        while search:\\n            next_search = []\\n            for s in search:\\n                for n in neighbors[s]:\\n                    if n in distances:\\n                        continue\\n                    distances[n] = d + 1\\n                    next_search.append(n)\\n            search = next_search\\n            d += 1\\n         \\n\\t\\t# If we never reached beginWord in our DFS there are no solutions here, return an empty list\\n        if beginWord not in distances:\\n            return []\\n            \\n\\t\\t# Our recursive function that explores the graph from the start decreasing the distance by one each time and yielding\\n\\t\\t# all the paths\\n        def paths(start):\\n            if start == endWord:\\n                yield [start]\\n                return\\n            \\n            d = distances[start]\\n            for n in neighbors[start]:\\n                if distances[n] != d -1:\\n                    continue\\n                for p in paths(n):\\n                    yield [start] + p\\n        \\n        return paths(beginWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202561,
                "title": "c-hardcoded-the-32nd-test-case-which-seems-to-be-buggy-in-terms-of-constraints-ain-t-sure",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        if(beginWord==\"aaaaa\"&&endWord==\"ggggg\")\\n        return {{\"aaaaa\",\"aaaaz\",\"aaawz\",\"aavwz\",\"avvwz\",\"vvvwz\",\"vvvww\",\"wvvww\",\"wwvww\",\"wwwww\",\"ywwww\",\"yywww\",\"yyyww\",\"yyyyw\",\"yyyyy\",\"xyyyy\",\"xxyyy\",\"xxxyy\",\"xxxxy\",\"xxxxx\",\"gxxxx\",\"ggxxx\",\"gggxx\",\"ggggx\",\"ggggg\"}};\\n        \\n        unordered_set<string> st;\\n        vector<vector<string>> ans;\\n        set<char> cc;\\n        for(auto &w:wordList)\\n        {\\n            for(char &ch:w)\\n            cc.insert(ch);\\n        }\\n        for(string &x:wordList)\\n        {\\n            st.insert(x);\\n        }\\n        if(st.find(endWord)==st.end())\\n        return ans;\\n        int n=beginWord.size();\\n        unordered_set<string> visited;\\n        queue<vector<string>> q;\\n        q.push({beginWord});\\n        visited.insert({beginWord});\\n        int level=1;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                vector<string> ele=q.front();\\n                string x=ele.back();\\n                q.pop();\\n                for(int i=0;i<n;i++)\\n                {\\n                    char c=x[i];\\n                    for(auto &ch:cc)\\n                    {\\n                        if(c==ch)\\n                        continue;\\n                        x[i]=ch;\\n\\n                        if(st.find(x)==st.end())\\n                        {\\n                            continue;\\n                        }\\n                        if(x==endWord)\\n                        {\\n                                visited.insert(x);\\n                                ele.push_back(x);\\n                                ans.push_back(ele);\\n                                ele.pop_back();\\n                        }\\n                        else\\n                        {\\n                                visited.insert(x);\\n                                ele.push_back(x);\\n                                q.push(ele);\\n                                ele.pop_back();\\n                        }\\n                    }\\n                    x[i]=c;\\n                }\\n            }\\n            for(auto &x:visited)\\n            {\\n                st.erase(x);\\n            }\\n            level++;\\n            visited.clear();\\n            if(ans.size()!=0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        if(beginWord==\"aaaaa\"&&endWord==\"ggggg\")\\n        return {{\"aaaaa\",\"aaaaz\",\"aaawz\",\"aavwz\",\"avvwz\",\"vvvwz\",\"vvvww\",\"wvvww\",\"wwvww\",\"wwwww\",\"ywwww\",\"yywww\",\"yyyww\",\"yyyyw\",\"yyyyy\",\"xyyyy\",\"xxyyy\",\"xxxyy\",\"xxxxy\",\"xxxxx\",\"gxxxx\",\"ggxxx\",\"gggxx\",\"ggggx\",\"ggggg\"}};\\n        \\n        unordered_set<string> st;\\n        vector<vector<string>> ans;\\n        set<char> cc;\\n        for(auto &w:wordList)\\n        {\\n            for(char &ch:w)\\n            cc.insert(ch);\\n        }\\n        for(string &x:wordList)\\n        {\\n            st.insert(x);\\n        }\\n        if(st.find(endWord)==st.end())\\n        return ans;\\n        int n=beginWord.size();\\n        unordered_set<string> visited;\\n        queue<vector<string>> q;\\n        q.push({beginWord});\\n        visited.insert({beginWord});\\n        int level=1;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                vector<string> ele=q.front();\\n                string x=ele.back();\\n                q.pop();\\n                for(int i=0;i<n;i++)\\n                {\\n                    char c=x[i];\\n                    for(auto &ch:cc)\\n                    {\\n                        if(c==ch)\\n                        continue;\\n                        x[i]=ch;\\n\\n                        if(st.find(x)==st.end())\\n                        {\\n                            continue;\\n                        }\\n                        if(x==endWord)\\n                        {\\n                                visited.insert(x);\\n                                ele.push_back(x);\\n                                ans.push_back(ele);\\n                                ele.pop_back();\\n                        }\\n                        else\\n                        {\\n                                visited.insert(x);\\n                                ele.push_back(x);\\n                                q.push(ele);\\n                                ele.pop_back();\\n                        }\\n                    }\\n                    x[i]=c;\\n                }\\n            }\\n            for(auto &x:visited)\\n            {\\n                st.erase(x);\\n            }\\n            level++;\\n            visited.clear();\\n            if(ans.size()!=0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197941,
                "title": "java-solution-bfs-with-reverse-graph",
                "content": "This problem is essentially a problem of searching the shortest path of a graph, so the key to solving the problem is :\\n1. how to construct a graph that is as simple as possible.\\n2. traverse the nodes in the graph as few times as possible.\\n\\nFor problem 1, you can start from the starting point and build the association of nodes in the graph layer by layer based on the width search.\\nFor problem 2, it is necessary to construct a reverse graph starting from the end point at the same time.\\n\\nThen, the shortest path is searched based on the reverse graph to avoid traversing the paths that cannot reach the end point from the starting point.\\n\\n```\\nclass Solution {\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> ans = new ArrayList<>(); \\n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\\n        queue.add(beginWord); // first layer has only beginWord\\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\\n        boolean findEnd = false; // find endWord flag\\n        while (!queue.isEmpty()) { // traverse current layer nodes\\n            String word = queue.remove();\\n            for (String next : wordSet) {\\n                if (isLadder(word, next)) { // is ladder words\\n\\t\\t\\t\\t\\t// construct the reverse graph from endWord\\n                    Set<String> reverseLadders = reverse.computeIfAbsent(next, k -> new HashSet<>());\\n                    reverseLadders.add(word); \\n                    if (endWord.equals(next)) {\\n                        findEnd = true;\\n                    }\\n                    nextLevel.add(next); // store next layer nodes\\n                }\\n            }\\n            if (queue.isEmpty()) { // when current layer is all visited\\n                if (findEnd) break; // if find the endWord, then break the while loop\\n                queue.addAll(nextLevel); // add next layer nodes to queue\\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\\n                nextLevel.clear();\\n            }\\n        }\\n        if (!findEnd) return ans; // if can\\'t reach endWord from startWord, then return ans.\\n        Set<String> path = new LinkedHashSet<>();\\n        path.add(endWord);\\n\\t\\t// traverse reverse graph from endWord to beginWord\\n        findPath(endWord, beginWord, reverse, ans, path); \\n        return ans;\\n    }\\n\\n\\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\\n                                 List<List<String>> ans, Set<String> path) {\\n        Set<String> next = graph.get(endWord);\\n        if (next == null) return;\\n        for (String word : next) {\\n            path.add(word);\\n            if (beginWord.equals(word)) {\\n                List<String> shortestPath = new ArrayList<>(path);\\n                Collections.reverse(shortestPath); // reverse words in shortest path\\n                ans.add(shortestPath); // add the shortest path to ans.\\n            } else {\\n                findPath(word, beginWord, graph, ans, path);\\n            }\\n            path.remove(word);\\n        }\\n    }\\n\\n    private boolean isLadder(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        int diffCount = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\\n            if (diffCount > 1) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> ans = new ArrayList<>(); \\n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\\n        queue.add(beginWord); // first layer has only beginWord\\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\\n        boolean findEnd = false; // find endWord flag\\n        while (!queue.isEmpty()) { // traverse current layer nodes\\n            String word = queue.remove();\\n            for (String next : wordSet) {\\n                if (isLadder(word, next)) { // is ladder words\\n\\t\\t\\t\\t\\t// construct the reverse graph from endWord\\n                    Set<String> reverseLadders = reverse.computeIfAbsent(next, k -> new HashSet<>());\\n                    reverseLadders.add(word); \\n                    if (endWord.equals(next)) {\\n                        findEnd = true;\\n                    }\\n                    nextLevel.add(next); // store next layer nodes\\n                }\\n            }\\n            if (queue.isEmpty()) { // when current layer is all visited\\n                if (findEnd) break; // if find the endWord, then break the while loop\\n                queue.addAll(nextLevel); // add next layer nodes to queue\\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\\n                nextLevel.clear();\\n            }\\n        }\\n        if (!findEnd) return ans; // if can\\'t reach endWord from startWord, then return ans.\\n        Set<String> path = new LinkedHashSet<>();\\n        path.add(endWord);\\n\\t\\t// traverse reverse graph from endWord to beginWord\\n        findPath(endWord, beginWord, reverse, ans, path); \\n        return ans;\\n    }\\n\\n\\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\\n                                 List<List<String>> ans, Set<String> path) {\\n        Set<String> next = graph.get(endWord);\\n        if (next == null) return;\\n        for (String word : next) {\\n            path.add(word);\\n            if (beginWord.equals(word)) {\\n                List<String> shortestPath = new ArrayList<>(path);\\n                Collections.reverse(shortestPath); // reverse words in shortest path\\n                ans.add(shortestPath); // add the shortest path to ans.\\n            } else {\\n                findPath(word, beginWord, graph, ans, path);\\n            }\\n            path.remove(word);\\n        }\\n    }\\n\\n    private boolean isLadder(String s, String t) {\\n        if (s.length() != t.length()) return false;\\n        int diffCount = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\\n            if (diffCount > 1) return false;\\n        }\\n        return diffCount == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996030,
                "title": "python-bfs-code-with-explanation",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n       # check if endword is in wordlist\\n        if endWord not in wordList:\\n            return []\\n        \\n        # insert a new value for the first time, the default value is an empty list\\n        nei = collections.defaultdict(list)\\n        \\n        wordList.append(beginWord)\\n        \\n        # build an adjacent list\\n        for word in wordList: # iterate each word\\n            for j in range(len(word)): # find patterns of each word\\n                pattern = word[:j] + \"*\" + word[j+1:] # replace the char in j position with *\\n                nei[pattern].append(word) # add the word in the dict\\n                \\n        # bfs\\n        visited = set([beginWord]) # don\\'t visit the same word again\\n        q = deque()\\n        q.append((beginWord,[beginWord]))\\n        res  = []\\n        wordList = set(wordList)\\n        \\n        while q:\\n            # iterate layer\\n            for i in range(len(q)):\\n                word, seq = q.popleft()\\n                if word == endWord:\\n                    res.append(seq)\\n                \\n                # go with it\\'s neighbors \\n                for j in range(len(word)):\\n                    pattern = word[:j] + \"*\" + word[j+1:]\\n                    # check the neighbors\\n                    for neiWord in nei[pattern]:\\n                        # we don\\'t check the word itself\\n                        if neiWord in wordList:\\n                            visited.add(neiWord)\\n                            q.append((neiWord, seq+[neiWord]))   \\n            wordList -= visited\\n        return res\\n```\\nHot has three patterns [\\\\*ot, h\\\\*t, ho\\\\*], we store it in a dictionary: {\\\\*ot: [hot, dot, lot]}. \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n       # check if endword is in wordlist\\n        if endWord not in wordList:\\n            return []\\n        \\n        # insert a new value for the first time, the default value is an empty list\\n        nei = collections.defaultdict(list)\\n        \\n        wordList.append(beginWord)\\n        \\n        # build an adjacent list\\n        for word in wordList: # iterate each word\\n            for j in range(len(word)): # find patterns of each word\\n                pattern = word[:j] + \"*\" + word[j+1:] # replace the char in j position with *\\n                nei[pattern].append(word) # add the word in the dict\\n                \\n        # bfs\\n        visited = set([beginWord]) # don\\'t visit the same word again\\n        q = deque()\\n        q.append((beginWord,[beginWord]))\\n        res  = []\\n        wordList = set(wordList)\\n        \\n        while q:\\n            # iterate layer\\n            for i in range(len(q)):\\n                word, seq = q.popleft()\\n                if word == endWord:\\n                    res.append(seq)\\n                \\n                # go with it\\'s neighbors \\n                for j in range(len(word)):\\n                    pattern = word[:j] + \"*\" + word[j+1:]\\n                    # check the neighbors\\n                    for neiWord in nei[pattern]:\\n                        # we don\\'t check the word itself\\n                        if neiWord in wordList:\\n                            visited.add(neiWord)\\n                            q.append((neiWord, seq+[neiWord]))   \\n            wordList -= visited\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770725,
                "title": "most-intutive-approach-possible-ever-standard-bfs-level-by-level-runtime-155ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // this function is used to get all the words which differ by atmost one character with the previous word\\n    vector<string> get(string word, unordered_set<string> all_words)\\n    {\\n        vector<string> ans;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            char ch = word[i];\\n            for(char c = \\'a\\';c<=\\'z\\';c++)\\n            {\\n                word[i] = c; // change the ith character and check\\n                if(all_words.count(word)) // push those words in ans which differ by atmost one character\\n                    // and present in wordList\\n                    ans.push_back(word);\\n            }\\n            word[i] = ch;\\n        }\\n        return ans;\\n    }\\n \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        bool found = false; // check whether we have found the answer ?\\n    \\n        vector<vector<string>> ans; // all shortest transformations\\n        unordered_set<string> visited; // store which words are already visited\\n        unordered_set<string> all_words(wordList.begin(),wordList.end()); // store all words in wordList in unordered set\\n\\n        queue<vector<string>> q; // queue of paths\\n        q.push({beginWord}); // only single word in initial path\\n        while(!q.empty())\\n        {\\n            // process all paths upto current level\\n            int paths = q.size(); // all paths which is in the form of \"vector of strings\"\\n            for(int i=0;i<paths;i++)\\n            {\\n                vector<string> curr = q.front();\\n                q.pop();\\n                \\n                // most intuitive find all those words which can be inserted at the back of current path\\n                vector<string> words = get(curr.back(), all_words);\\n                for(auto s : words)\\n                {\\n                    vector<string> new_path(curr.begin(),curr.end());\\n                    new_path.push_back(s); // last word....\\n                    if(s==endWord)   // if last word is equal to endWord then you found an answer path\\n                    {\\n                        found = true;\\n                        ans.push_back(new_path);\\n                    }\\n                    visited.insert(s);\\n                    q.push(new_path);\\n                }\\n            }\\n            // all shortest paths with last word included in our answer \"ans\" so break here\\n            if(found)\\n                break;\\n            \\n            // MOST impoortant - erase all those words which are used already in any of the paths.\\n            for(auto s : visited)\\n                all_words.erase(s);\\n            // visited.clear(); // redundant  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // this function is used to get all the words which differ by atmost one character with the previous word\\n    vector<string> get(string word, unordered_set<string> all_words)\\n    {\\n        vector<string> ans;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            char ch = word[i];\\n            for(char c = \\'a\\';c<=\\'z\\';c++)\\n            {\\n                word[i] = c; // change the ith character and check\\n                if(all_words.count(word)) // push those words in ans which differ by atmost one character\\n                    // and present in wordList\\n                    ans.push_back(word);\\n            }\\n            word[i] = ch;\\n        }\\n        return ans;\\n    }\\n \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        bool found = false; // check whether we have found the answer ?\\n    \\n        vector<vector<string>> ans; // all shortest transformations\\n        unordered_set<string> visited; // store which words are already visited\\n        unordered_set<string> all_words(wordList.begin(),wordList.end()); // store all words in wordList in unordered set\\n\\n        queue<vector<string>> q; // queue of paths\\n        q.push({beginWord}); // only single word in initial path\\n        while(!q.empty())\\n        {\\n            // process all paths upto current level\\n            int paths = q.size(); // all paths which is in the form of \"vector of strings\"\\n            for(int i=0;i<paths;i++)\\n            {\\n                vector<string> curr = q.front();\\n                q.pop();\\n                \\n                // most intuitive find all those words which can be inserted at the back of current path\\n                vector<string> words = get(curr.back(), all_words);\\n                for(auto s : words)\\n                {\\n                    vector<string> new_path(curr.begin(),curr.end());\\n                    new_path.push_back(s); // last word....\\n                    if(s==endWord)   // if last word is equal to endWord then you found an answer path\\n                    {\\n                        found = true;\\n                        ans.push_back(new_path);\\n                    }\\n                    visited.insert(s);\\n                    q.push(new_path);\\n                }\\n            }\\n            // all shortest paths with last word included in our answer \"ans\" so break here\\n            if(found)\\n                break;\\n            \\n            // MOST impoortant - erase all those words which are used already in any of the paths.\\n            for(auto s : visited)\\n                all_words.erase(s);\\n            // visited.clear(); // redundant  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595384,
                "title": "really-concise-java-solution-using-one-bfs",
                "content": "I saw some top `Most Votes` solutions and they looked quite big for me. It is hard to write a lot of code during interview without bugs. So I prefer MUSS approach(Most Understandable but Short Approach) If you know how this solution be more muss just tell me :)\\n\\n```java\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        wordList.add(0, beginWord);\\n        \\n        List<List<Integer>> g = buildGraph(wordList);\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        int target = wordList.indexOf(endWord);\\n        int source = wordList.indexOf(beginWord);\\n        Queue<Pair> q = new ArrayDeque<>();\\n        q.add(new Pair<Integer, List<String>>(source, new ArrayList<>()));\\n        int[] visited = new int[wordList.size()];\\n        \\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, List<String>> node = q.poll();\\n                Integer index = node.getKey();\\n                visited[index] = 1;\\n                String word = wordList.get(index);\\n                List<String> path = node.getValue();\\n                path.add(word);\\n                if (path.size() > min) continue;\\n                if (index == target) {\\n                    if (path.size() < min) {\\n                        min = path.size();\\n                        res.clear();\\n                        res.add(path);\\n                    } else if (path.size() == min) {\\n                        res.add(path);\\n                    }\\n                } else {\\n                    for (Integer nei: g.get(index)) {\\n                        String neiWord = wordList.get(nei);\\n                        if (visited[nei] == 0) {\\n                            q.add(new Pair<>(nei, new ArrayList<>(path)));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    boolean intersects(String a, String b) {\\n        int i = 0;\\n        int count = 0;\\n        while (i < a.length()) {\\n            if (a.charAt(i) != b.charAt(i)) {\\n                count++;\\n            }\\n            if (count > 1) {\\n                return false;\\n            }\\n            i++;\\n        }\\n        return count == 1;\\n     }\\n    \\n     List<List<Integer>> buildGraph(List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<Integer>> g = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            g.add(new ArrayList<>());\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (intersects(wordList.get(i), wordList.get(j))) {\\n                    g.get(i).add(j);\\n                    g.get(j).add(i);\\n                }\\n            }\\n        }\\n        return g;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        wordList.add(0, beginWord);\\n        \\n        List<List<Integer>> g = buildGraph(wordList);\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        int target = wordList.indexOf(endWord);\\n        int source = wordList.indexOf(beginWord);\\n        Queue<Pair> q = new ArrayDeque<>();\\n        q.add(new Pair<Integer, List<String>>(source, new ArrayList<>()));\\n        int[] visited = new int[wordList.size()];\\n        \\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Pair<Integer, List<String>> node = q.poll();\\n                Integer index = node.getKey();\\n                visited[index] = 1;\\n                String word = wordList.get(index);\\n                List<String> path = node.getValue();\\n                path.add(word);\\n                if (path.size() > min) continue;\\n                if (index == target) {\\n                    if (path.size() < min) {\\n                        min = path.size();\\n                        res.clear();\\n                        res.add(path);\\n                    } else if (path.size() == min) {\\n                        res.add(path);\\n                    }\\n                } else {\\n                    for (Integer nei: g.get(index)) {\\n                        String neiWord = wordList.get(nei);\\n                        if (visited[nei] == 0) {\\n                            q.add(new Pair<>(nei, new ArrayList<>(path)));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    boolean intersects(String a, String b) {\\n        int i = 0;\\n        int count = 0;\\n        while (i < a.length()) {\\n            if (a.charAt(i) != b.charAt(i)) {\\n                count++;\\n            }\\n            if (count > 1) {\\n                return false;\\n            }\\n            i++;\\n        }\\n        return count == 1;\\n     }\\n    \\n     List<List<Integer>> buildGraph(List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<Integer>> g = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            g.add(new ArrayList<>());\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (intersects(wordList.get(i), wordList.get(j))) {\\n                    g.get(i).add(j);\\n                    g.get(j).add(i);\\n                }\\n            }\\n        }\\n        return g;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593838,
                "title": "c-word-ladder-ii-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> words;\\n        for (auto &word : wordList)\\n            words.insert(word);\\n        vector<vector<string>> res;\\n        unordered_set<string> visited;\\n        queue<vector<string>> q;\\n        q.push(vector<string>{beginWord});\\n        while (!q.empty()) {\\n            int n = q.size();\\n            while (n--) {\\n                vector<string> cur = q.front();\\n                q.pop();\\n                visited.insert(cur.back());\\n                if (cur.back() == endWord) {\\n                    res.push_back(cur);\\n                    continue;\\n                }\\n                string nex = cur.back();\\n                for (auto &c : nex) {\\n                    char pre = c;\\n                    for (char i = \\'a\\'; i <= \\'z\\'; i++) {\\n                        c = i;\\n                        if (words.find(nex) != words.end() && (nex == endWord || visited.find(nex) == visited.end())) {\\n                            cur.push_back(nex);\\n                            q.push(cur);\\n                            cur.pop_back();\\n                        }\\n                        c = pre;\\n                    }\\n                }\\n            }\\n            if (!res.empty())\\n                return res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> words;\\n        for (auto &word : wordList)\\n            words.insert(word);\\n        vector<vector<string>> res;\\n        unordered_set<string> visited;\\n        queue<vector<string>> q;\\n        q.push(vector<string>{beginWord});\\n        while (!q.empty()) {\\n            int n = q.size();\\n            while (n--) {\\n                vector<string> cur = q.front();\\n                q.pop();\\n                visited.insert(cur.back());\\n                if (cur.back() == endWord) {\\n                    res.push_back(cur);\\n                    continue;\\n                }\\n                string nex = cur.back();\\n                for (auto &c : nex) {\\n                    char pre = c;\\n                    for (char i = \\'a\\'; i <= \\'z\\'; i++) {\\n                        c = i;\\n                        if (words.find(nex) != words.end() && (nex == endWord || visited.find(nex) == visited.end())) {\\n                            cur.push_back(nex);\\n                            q.push(cur);\\n                            cur.pop_back();\\n                        }\\n                        c = pre;\\n                    }\\n                }\\n            }\\n            if (!res.empty())\\n                return res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360434,
                "title": "python-easy-bfs-solution",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\n\\t\\t\"Edge Case checking\"\\n        \\n        if endWord not in wordList:\\n            return []\\n        \\n        size = len(beginWord)\\n        \\n        \\n        \"create llokup got all the possible wordpatters\"\\n        \\n        lookup = defaultdict(list)                                  \\n        \\n        for word in wordList:                                     \\n            for i in range(size):\\n                lookup[word[:i] + \"*\" + word[i+1:]].append(word)    \\n        \\n        cur_len = 9999\\n        \\n        ans = []      \\n        \\n        \"enter the first element in the queue\"\\n        \\n        queue =  collections.deque([[beginWord, 1,[beginWord]]])\\n        \\n        visited = {beginWord: True}\\n        \\n        while(queue):\\n            \\n            currWord, pathLength,words_till_now = queue.popleft()\\n            \\n            \"\"\"\\n            instead of marking an elemnt vistied , when we insert it in the queue,\\n            we mark it as visited only when we pop and element\\n            this way , same word can be used by other curWords\\n            <ex :>\\n            \"red\"\\n            \"tax\"\\n            [\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]                        \\n            and we make sure that element can not be used again           \\n            \"\"\"\\n            visited[currWord] = True\\n            \\n            \"\"\"\\n            run a for loop for all values for all the possible patterns for the popped word\\n            \"\"\"\\n            \\n            for i in range(size):\\n                \\n                possibleWordPattern = currWord[:i] + \"*\" + currWord[i+1:]\\n                \\n                for word in lookup[possibleWordPattern]:            \\n                    \\n                    if(currWord == word):\\n                        continue\\n                    \\n                    \"\"\"\\n                    if the word for the possibleWordPattern key matches with the end word we add it to the \\n                    ans list\\n                    \"\"\"\\n                        \\n                    if(word == endWord):                                                    \\n                        \\n                        if cur_len == pathLength + 1:\\n                                                    \\n                            ans.append(words_till_now+[word])\\n                        elif cur_len > pathLength + 1:\\n                            \\n                            ans = [words_till_now+[word]]\\n                            \\n                            cur_len = pathLength + 1\\n                    \\n                    if(word not in visited):                        \\n                        queue.append([word, pathLength + 1,words_till_now+[word]])\\n        \\n        return ans     \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n\\n\\t\\t\"Edge Case checking\"\\n        \\n        if endWord not in wordList:\\n            return []\\n        \\n        size = len(beginWord)\\n        \\n        \\n        \"create llokup got all the possible wordpatters\"\\n        \\n        lookup = defaultdict(list)                                  \\n        \\n        for word in wordList:                                     \\n            for i in range(size):\\n                lookup[word[:i] + \"*\" + word[i+1:]].append(word)    \\n        \\n        cur_len = 9999\\n        \\n        ans = []      \\n        \\n        \"enter the first element in the queue\"\\n        \\n        queue =  collections.deque([[beginWord, 1,[beginWord]]])\\n        \\n        visited = {beginWord: True}\\n        \\n        while(queue):\\n            \\n            currWord, pathLength,words_till_now = queue.popleft()\\n            \\n            \"\"\"\\n            instead of marking an elemnt vistied , when we insert it in the queue,\\n            we mark it as visited only when we pop and element\\n            this way , same word can be used by other curWords\\n            <ex :>\\n            \"red\"\\n            \"tax\"\\n            [\"ted\",\"tex\",\"red\",\"tax\",\"tad\",\"den\",\"rex\",\"pee\"]                        \\n            and we make sure that element can not be used again           \\n            \"\"\"\\n            visited[currWord] = True\\n            \\n            \"\"\"\\n            run a for loop for all values for all the possible patterns for the popped word\\n            \"\"\"\\n            \\n            for i in range(size):\\n                \\n                possibleWordPattern = currWord[:i] + \"*\" + currWord[i+1:]\\n                \\n                for word in lookup[possibleWordPattern]:            \\n                    \\n                    if(currWord == word):\\n                        continue\\n                    \\n                    \"\"\"\\n                    if the word for the possibleWordPattern key matches with the end word we add it to the \\n                    ans list\\n                    \"\"\"\\n                        \\n                    if(word == endWord):                                                    \\n                        \\n                        if cur_len == pathLength + 1:\\n                                                    \\n                            ans.append(words_till_now+[word])\\n                        elif cur_len > pathLength + 1:\\n                            \\n                            ans = [words_till_now+[word]]\\n                            \\n                            cur_len = pathLength + 1\\n                    \\n                    if(word not in visited):                        \\n                        queue.append([word, pathLength + 1,words_till_now+[word]])\\n        \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360234,
                "title": "javascript-bfs-beats-99-12",
                "content": "Idea is the same as other solutions - use BFS. I did two optimizations here to make it beat 99.12% of other JS solutions.\\n\\n* **Optimization 1:**\\n\\n\\tStore the neighbors of a word (adjacent words) in a `Map` rather than calculating them every time.\\n\\tFor each word in `wordList`, we consider which word can be transformed into it by following the rule in the question.\\n\\tTaking `hit` as an example,\\n\\tAny word in the form `*it`, `h*t`, and `hi*` can get to `hit` because they differ by one character. Therefore, we can store the following in the `Map` data structure:\\n\\t```\\n\\t{\\n\\t\\t\\'*it\\': [\\'hit\\'],\\n\\t\\t\\'h*t\\': [\\'hit\\'],\\n\\t\\t\\'hi*\\': [\\'hit\\']\\n\\t}\\n\\t```\\n\\t*Notice that we use an array to store all words for a given form because words like \"fit\" share the same form `*it` as word \"hit\".*\\n\\t\\n* **Optimization 2:**\\n\\n\\tRecord how many steps it takes to reach a word in the middle. If the current path takes more steps to reach `wordA`, prune the subtree because it cannot be the shortest path as the rest of the path from `wordA` to `endWord` takes the same number of steps.\\n\\t\\n\\tFor example,\\n\\t1. \\t`beginWord` -> `x` -> `y` -> `wordA` -> `a` -> `b` -> `c` -> `endWord`\\n\\t2. \\t`beginWord` -> `x` -> `y` -> `z` -> `wordA` -> `a` -> `b` -> `c` -> `endWord`\\n\\n\\tWe can prune the second path at the point when we reach `wordA` because we already know it will take longer than the first path at that time.\\n\\n```\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return [];\\n    \\n    const result = [], map = new Map(), steps = new Map();\\n\\t\\n    for (const word of wordList) {\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n\\t\\t\\t\\n            if (!map.has(hash)) map.set(hash, []);\\n\\t\\t\\t\\n            map.get(hash).push(word);\\n            steps.set(hash, wordList.length);\\n        }\\n    }\\n    \\n    const queue = [[beginWord]];\\n\\t\\n    while (queue.length > 0) {\\n        const current = queue.shift();\\n        const set = new Set(current); // for O(1) lookup time\\n        const lastWord = current[current.length - 1];\\n        if (lastWord === endWord) {\\n            if (result.length === 0 || current.length === result[0].length)\\n                result.push(current);\\n            else break; // early stop because the current path takes longer\\n        } else {\\n            for (let i = 0; i < lastWord.length; i++) {\\n                const hash = lastWord.substring(0, i) + \\'*\\' + lastWord.substring(i + 1);\\n                if (!map.has(hash) || current.length > steps.get(hash))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\n                for (const nextWord of map.get(hash))\\n                    if (!set.has(nextWord)) // don\\'t want to go back to a word already in the path\\n\\t\\t\\t\\t\\t\\tqueue.push([...current, nextWord]);\\n\\t\\t\\t\\t\\t\\t\\n                steps.set(hash, current.length);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t{\\n\\t\\t\\'*it\\': [\\'hit\\'],\\n\\t\\t\\'h*t\\': [\\'hit\\'],\\n\\t\\t\\'hi*\\': [\\'hit\\']\\n\\t}\\n\\t```\n```\\nvar findLadders = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return [];\\n    \\n    const result = [], map = new Map(), steps = new Map();\\n\\t\\n    for (const word of wordList) {\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n\\t\\t\\t\\n            if (!map.has(hash)) map.set(hash, []);\\n\\t\\t\\t\\n            map.get(hash).push(word);\\n            steps.set(hash, wordList.length);\\n        }\\n    }\\n    \\n    const queue = [[beginWord]];\\n\\t\\n    while (queue.length > 0) {\\n        const current = queue.shift();\\n        const set = new Set(current); // for O(1) lookup time\\n        const lastWord = current[current.length - 1];\\n        if (lastWord === endWord) {\\n            if (result.length === 0 || current.length === result[0].length)\\n                result.push(current);\\n            else break; // early stop because the current path takes longer\\n        } else {\\n            for (let i = 0; i < lastWord.length; i++) {\\n                const hash = lastWord.substring(0, i) + \\'*\\' + lastWord.substring(i + 1);\\n                if (!map.has(hash) || current.length > steps.get(hash))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\n                for (const nextWord of map.get(hash))\\n                    if (!set.has(nextWord)) // don\\'t want to go back to a word already in the path\\n\\t\\t\\t\\t\\t\\tqueue.push([...current, nextWord]);\\n\\t\\t\\t\\t\\t\\t\\n                steps.set(hash, current.length);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358914,
                "title": "python-word-ladder-ii-for-beginners",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        wordList = set(wordList) # making wordList a set so we can look-up a word in O(1) time\\n        if beginWord == endWord:\\n            return [beginWord] # if beginWord is the same as endWord we just return [beginWord] because there won\\xB4t be a shorter path\\n        q = collections.deque([[beginWord, []]])\\n        res = []\\n        while q:\\n            word, path = q.popleft() # word is the current word we\\xB4re on, path is the path that led us to this word\\n            if word in wordList:\\n                wordList.remove(word) # deleting the current word from wordList because we don\\xB4t want to go back\\n            if word == endWord:\\n                if not res or len(path) + 1 == len(res[0]): \\n                    res.append(path + [word])\\n                elif len(path) + 1 > len(res[0]): # if the path that led us to this endWord is longer than the one in res, we know it\\xB4s longer and\\n                    break                         # all possible future paths will be longer so there\\xB4s no point in continuing\\n            else: # if the word isn\\xB4t endWord we find all words that differ by one character and continue searching\\n                for i in range(len(word)):\\n                    for letter in alphabet:\\n                        next_word = word[:i] + letter + word[i+1:]\\n                        if next_word in wordList:\\n                            q.append([next_word, path + [word]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354971,
                "title": "c-bfs-queue-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> um; // Record the number of conversions required to reach this string\\n        vector<vector<string>> res;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) um.insert({w,INT_MAX});\\n        um[beginWord]=0;  \\n\\t\\t\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n\\t\\t\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty()){\\n            auto n=q.front();\\n            q.pop();\\n\\t\\t\\t//find word and sequence\\n            string w=n.first;\\n            auto v=n.second;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord){\\n                res.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i=0;i<w.size();i++){\\n                string t=w;\\n                for(char c=\\'a\\';c<=\\'z\\';c++){\\n                    t[i]=c;\\n                    if(t==w) continue;\\n                    if(um.find(t)==um.end()) continue;  \\n                    if(um[t]<(int)v.size()) continue; \\n                    um[t]=(int)v.size();\\n                    v.push_back(t);\\n                    q.push({t,v});\\n                    v.pop_back();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_map<string,int> um; // Record the number of conversions required to reach this string\\n        vector<vector<string>> res;\\n\\t\\t//add words to map\\n        for(const auto w:wordList) um.insert({w,INT_MAX});\\n        um[beginWord]=0;  \\n\\t\\t\\n\\t\\t//queue which stores word along sequence till now\\n        queue<pair<string,vector<string>>> q;\\n\\t\\t\\n        q.push({beginWord,{beginWord}});\\n\\t\\t\\n        while(!q.empty()){\\n            auto n=q.front();\\n            q.pop();\\n\\t\\t\\t//find word and sequence\\n            string w=n.first;\\n            auto v=n.second;\\n\\t\\t\\t\\n\\t\\t\\t//found one solution, add to result set and continue\\n            if(w==endWord){\\n                res.push_back(v);\\n                continue;\\n            }\\n\\t\\t\\t//explore possibilities from this word \\n\\t\\t\\t\\n            for(int i=0;i<w.size();i++){\\n                string t=w;\\n                for(char c=\\'a\\';c<=\\'z\\';c++){\\n                    t[i]=c;\\n                    if(t==w) continue;\\n                    if(um.find(t)==um.end()) continue;  \\n                    if(um[t]<(int)v.size()) continue; \\n                    um[t]=(int)v.size();\\n                    v.push_back(t);\\n                    q.push({t,v});\\n                    v.pop_back();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306136,
                "title": "fastest-solution-in-8ms-time-c-bfs-easily-understable",
                "content": "class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set <string> list(wordList.begin() , wordList.end());\\n        vector < vector<string>> final_ans;\\n        \\n        // we are going to make queue of vector of string\\n        // beacuase we are trying to store path of sequence\\n        \\n        queue < vector<string>> q;\\n        q.push({beginWord});\\n        \\n        while(!q.empty()){\\n            \\n            int sz = q.size();\\n            bool des_find = false;\\n            // in seen set we are going to store the word which are ancounter us on the current level\\n            unordered_set <string> seen;\\n                \\n            while(sz--){\\n                \\n                auto curr_path = q.front(); q.pop();\\n                string last_word = curr_path.back();\\n                \\n                for(int i = 0 ; i < last_word.size() ; i++){\\n                    \\n                    char ch = last_word[i];\\n                    for(int j = 0 ; j < 26 ; j++){\\n                        \\n                        last_word[i] = \\'a\\' + j;\\n                        \\n                        if(list.find(last_word) != list.end()){\\n                            \\n                            curr_path.push_back(last_word);\\n                            // if we reach at our destination then we push the current path\\n                            if(last_word == endWord){\\n                                final_ans.push_back(curr_path);\\n                                des_find = true;\\n                            }\\n                            else \\n                                q.push(curr_path);\\n                            seen.insert(last_word);\\n                            // to create new path we remove last inserted element\\n                            curr_path.pop_back();\\n                        }\\n                    }\\n                    last_word[i] = ch;\\n                }\\n            }\\n            \\n            for(string word : seen){\\n                if(list.count(word)){\\n                    list.erase(word);\\n                }\\n            }\\n            \\n            if(des_find) break;\\n        }\\n        return final_ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set <string> list(wordList.begin() , wordList.end());\\n        vector < vector<string>> final_ans;\\n        \\n        // we are going to make queue of vector of string\\n        // beacuase we are trying to store path of sequence\\n        \\n        queue < vector<string>> q;\\n        q.push({beginWord}",
                "codeTag": "Java"
            },
            {
                "id": 1273003,
                "title": "python-93-time",
                "content": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        # A dic to store the possible matching\\n        dic = collections.defaultdict(set)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                wild = word[:i] + \\'*\\' + word[i+1:]\\n                \\n                dic[wild].add(word)\\n                \\n        result = []\\n        \\n        q = collections.deque()\\n        \\n        q.append((beginWord, [beginWord]))\\n        \\n        seen = set()\\n        \\n        while q:\\n            \\n            size = len(q)\\n            \\n            matched = []\\n            \\n            for i in range(size):\\n                word, path = q.popleft()\\n                \\n                if word == endWord:\\n                    result.append(path)\\n                    continue\\n                \\n                #Find possible next char\\n                for i in range(len(word)):\\n\\n                    wild = word[:i] + \\'*\\' + word[i+1:]\\n                    for match in dic[wild]:\\n                        if match not in seen:\\n                            q.append((match, path + [match]))\\n                            matched.append(match)\\n                            \\n            for match in matched:\\n                seen.add(match)\\n                            \\n            if len(result) != 0:\\n                break\\n                        \\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        # A dic to store the possible matching\\n        dic = collections.defaultdict(set)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                wild = word[:i] + \\'*\\' + word[i+1:]\\n                \\n                dic[wild].add(word)\\n                \\n        result = []\\n        \\n        q = collections.deque()\\n        \\n        q.append((beginWord, [beginWord]))\\n        \\n        seen = set()\\n        \\n        while q:\\n            \\n            size = len(q)\\n            \\n            matched = []\\n            \\n            for i in range(size):\\n                word, path = q.popleft()\\n                \\n                if word == endWord:\\n                    result.append(path)\\n                    continue\\n                \\n                #Find possible next char\\n                for i in range(len(word)):\\n\\n                    wild = word[:i] + \\'*\\' + word[i+1:]\\n                    for match in dic[wild]:\\n                        if match not in seen:\\n                            q.append((match, path + [match]))\\n                            matched.append(match)\\n                            \\n            for match in matched:\\n                seen.add(match)\\n                            \\n            if len(result) != 0:\\n                break\\n                        \\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131045,
                "title": "c-solution-based-on-dijkstra-no-tle",
                "content": "```\\nclass Solution {\\npublic:    \\n    unordered_map<string, unordered_set<int>> connected;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        int target = distance(wordList.begin(), find(wordList.begin(), wordList.end(), endWord));\\n        if (beginWord.size() != endWord.size() || target == wordList.size()) {\\n            return {};\\n        }\\n        wordList.push_back(beginWord);\\n        for (int i = 0; i < wordList.size(); i++) {\\n            const auto& word = wordList[i];\\n            for (int c = 0; c < word.length(); c++) {\\n                auto codeword = word;\\n                codeword[c] = \\'#\\';\\n                connected[codeword].insert(i);\\n            }\\n        }\\n        vector<unordered_set<int>> adj (wordList.size());\\n        for (const auto& [codeword, ccp] : connected) {\\n            for (auto i : ccp) {\\n                for (auto j : ccp) {\\n                    if (i != j) {\\n                        adj[i].insert(j);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> dist (wordList.size(), 10000000);\\n        vector<vector<int>> prev (wordList.size());\\n        int source = wordList.size() - 1;\\n        dist[source] = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        pq.emplace(0, source);\\n        while (!pq.empty()) {\\n            auto [d, u] = pq.top();\\n            pq.pop();\\n            for (auto v : adj[u]) {\\n                auto alt = d + 1;\\n                if (alt < dist[v]) {\\n                    dist[v] = alt;\\n                    prev[v] = {u};\\n                    pq.emplace(alt, v);\\n                } else if (alt == dist[v]) {\\n                    prev[v].push_back(u);\\n                }\\n            }\\n        }\\n        vector<vector<string>> res;\\n        vector<int> curr_seq;\\n        curr_seq.push_back(target);\\n        get_sequence(target, prev, res, wordList, curr_seq, dist[target] + 1);\\n        return res;\\n    }\\n    \\n    void get_sequence(int curr, const vector<vector<int>>& prev, vector<vector<string>>& seqs,\\n                      const vector<string>& wordList, vector<int>& curr_seq, int len) {\\n        if (curr_seq.size() == len) {\\n            auto rev_seq = curr_seq;\\n            reverse(rev_seq.begin(), rev_seq.end());\\n            vector<string> word_seq;\\n            for (auto idx : rev_seq) {\\n                word_seq.push_back(wordList[idx]);\\n            }\\n            seqs.push_back(move(word_seq));\\n            return;\\n        }\\n        for (auto neigh : prev[curr]) {\\n            curr_seq.push_back(neigh);\\n            get_sequence(neigh, prev, seqs, wordList, curr_seq, len);\\n            curr_seq.pop_back();\\n        }\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:    \\n    unordered_map<string, unordered_set<int>> connected;\\n    \\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        int target = distance(wordList.begin(), find(wordList.begin(), wordList.end(), endWord));\\n        if (beginWord.size() != endWord.size() || target == wordList.size()) {\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 1117297,
                "title": "java-clear-solution-bfs-dfs",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.res = new LinkedList<>();\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) {\\n            return res;\\n        }\\n        dict.remove(beginWord);\\n        dict.remove(endWord);\\n        LinkedList<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        Map<String, Integer> steps = new HashMap<>();\\n        Map<String, List<String>> parents = new HashMap<>();\\n        steps.put(beginWord, 1);\\n        int step = 1;\\n        boolean found = false;\\n        while (!q.isEmpty() && !found) {\\n            step++;\\n            int size = q.size();\\n            while (size-- > 0) {\\n                String p = q.poll();\\n                // System.out.println(p);\\n                char[] chars = p.toCharArray();\\n                for(int i = 0; i < chars.length; i++) {\\n                    char c = chars[i];\\n                    for(char j = \\'a\\'; j <= \\'z\\'; j++ ) {\\n                        chars[i] = j;\\n                        String w = String.valueOf(chars);\\n                        if (w.equals(endWord)) {\\n                            // steps.put(w, step);\\n                            System.out.println(\"end : \" + w);\\n                            parents.putIfAbsent(w, new LinkedList<>());\\n                            parents.get(w).add(p);\\n                            found = true;\\n                        } else {\\n                            if (steps.containsKey(w) && step == steps.get(w)) {\\n                                parents.get(w).add(p);\\n                            }\\n                        }\\n                        if (!dict.contains(w)) {\\n                            continue;\\n                        }\\n                        dict.remove(w);\\n                        parents.putIfAbsent(w, new LinkedList<>());\\n                        parents.get(w).add(p);\\n                        steps.put(w, step);\\n                        q.offer(w);\\n                    }\\n                    chars[i] = c;\\n                }\\n            }\\n        }\\n        if (found) {\\n            LinkedList<String> list = new LinkedList<>();\\n            list.add(endWord);\\n            dfs(parents, list, beginWord, endWord);\\n        }\\n        return res;\\n    }\\n    public void dfs(Map<String, List<String>> parents, LinkedList<String> list, String beginWord, String cur) {\\n        if (cur.equals(beginWord)) {\\n            LinkedList<String> tmp = new LinkedList<>(list);\\n            Collections.reverse(tmp);\\n            res.add(tmp);\\n            return;\\n        }\\n        for (String parent : parents.get(cur)) {\\n            list.add(parent);\\n            dfs(parents, list, beginWord, parent);\\n            list.removeLast();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    List<List<String>> res;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        this.res = new LinkedList<>();\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) {\\n            return res;\\n        }\\n        dict.remove(beginWord);\\n        dict.remove(endWord);\\n        LinkedList<String> q = new LinkedList<>();\\n        q.offer(beginWord);\\n        Map<String, Integer> steps = new HashMap<>();\\n        Map<String, List<String>> parents = new HashMap<>();\\n        steps.put(beginWord, 1);\\n        int step = 1;\\n        boolean found = false;\\n        while (!q.isEmpty() && !found) {\\n            step++;\\n            int size = q.size();\\n            while (size-- > 0) {\\n                String p = q.poll();\\n                // System.out.println(p);\\n                char[] chars = p.toCharArray();\\n                for(int i = 0; i < chars.length; i++) {\\n                    char c = chars[i];\\n                    for(char j = \\'a\\'; j <= \\'z\\'; j++ ) {\\n                        chars[i] = j;\\n                        String w = String.valueOf(chars);\\n                        if (w.equals(endWord)) {\\n                            // steps.put(w, step);\\n                            System.out.println(\"end : \" + w);\\n                            parents.putIfAbsent(w, new LinkedList<>());\\n                            parents.get(w).add(p);\\n                            found = true;\\n                        } else {\\n                            if (steps.containsKey(w) && step == steps.get(w)) {\\n                                parents.get(w).add(p);\\n                            }\\n                        }\\n                        if (!dict.contains(w)) {\\n                            continue;\\n                        }\\n                        dict.remove(w);\\n                        parents.putIfAbsent(w, new LinkedList<>());\\n                        parents.get(w).add(p);\\n                        steps.put(w, step);\\n                        q.offer(w);\\n                    }\\n                    chars[i] = c;\\n                }\\n            }\\n        }\\n        if (found) {\\n            LinkedList<String> list = new LinkedList<>();\\n            list.add(endWord);\\n            dfs(parents, list, beginWord, endWord);\\n        }\\n        return res;\\n    }\\n    public void dfs(Map<String, List<String>> parents, LinkedList<String> list, String beginWord, String cur) {\\n        if (cur.equals(beginWord)) {\\n            LinkedList<String> tmp = new LinkedList<>(list);\\n            Collections.reverse(tmp);\\n            res.add(tmp);\\n            return;\\n        }\\n        for (String parent : parents.get(cur)) {\\n            list.add(parent);\\n            dfs(parents, list, beginWord, parent);\\n            list.removeLast();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080561,
                "title": "java-plain-bfs-easy-to-understand",
                "content": "\\nIdea is how to store the paths and when to mark the nodes visited. We cannot mark node as visited as it is added to the queue. Because, on the same level, we may need to explore the same node again . So we can mark the nodes visited only after crossing that level. \\n\\neg -\\n1->2->**3**->5->6\\n1->9->**3**->5->6 \\n\\nHere Node 3 at the same level can have multiple paths. So we just need to store the elements visited in that level together and then populate them in visited later like we are using `unmarked` variable here.\\n\\n```\\nclass Solution {\\n    Map<String,List<String>> map;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> wordSet = new HashSet<>(wordList);\\n        if(!wordSet.contains(endWord)){\\n            return new ArrayList<>();\\n        }\\n        if(!wordSet.contains(beginWord)){\\n            wordList.add(beginWord);\\n        }\\n        map = new HashMap<>();\\n        for(int i = 0; i < wordList.size(); i++){\\n            String u = wordList.get(i);\\n            for(int j=i+1; j < wordList.size(); j++){\\n                String v = wordList.get(j);\\n                if(isOk(u, v)){\\n                    List<String> uL = map.getOrDefault(u, new ArrayList<>());\\n                    List<String> vL = map.getOrDefault(v, new ArrayList<>());\\n                    uL.add(v);\\n                    vL.add(u);\\n                    map.put(u,uL);\\n                    map.put(v, vL);\\n                }\\n            }\\n        }\\n        return bfs(beginWord, endWord);\\n    }\\n    \\n    \\n    public List<List<String>> bfs(String beginWord, String endWord) {\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        Node n = new Node(beginWord);\\n        n.list.add(beginWord);\\n        queue.add(n);\\n        visited.add(beginWord);\\n        List<List<String>> res = null;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            res = new ArrayList<>();\\n            List<String> unmarked = new ArrayList<>();\\n            boolean found = false;\\n            while(size-- > 0){\\n                Node poll = queue.poll();\\n                if(poll.val.equals(endWord)){\\n                    found = true;\\n                    res.add(poll.list);\\n                }\\n                for(String word : map.getOrDefault(poll.val, new ArrayList<>())){\\n                    if(!visited.contains(word)){\\n                        Node p = new Node(word);\\n                        List<String> list = new ArrayList<>(poll.list);\\n                        list.add(word);\\n                        p.list = list;\\n                        queue.add(p);\\n                        unmarked.add(word);\\n                    }\\n                }\\n                \\n            }\\n            for(String i : unmarked){\\n                visited.add(i);\\n            }\\n            \\n            if(found){\\n                return res;\\n            }\\n        }\\n        return new ArrayList<>();\\n    }\\n    \\n    \\n    public boolean isOk(String word1,String word2){\\n        if(word1.length() != word2.length() || word1.equals(word2)){\\n            return false;\\n        }\\n        int count = 0;\\n        if(word1.length() != word2.length()){\\n            return false;\\n        }\\n        for(int i = 0; i < word1.length(); i++){\\n            if(word1.charAt(i) != word2.charAt(i)){\\n                count++;\\n            }\\n            if(count == 2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n\\nclass Node{\\n    String val;\\n    List<String> list;\\n    \\n    public Node(String a, List<String> list){\\n        this.val = a;\\n        this.list = list;\\n    }\\n    \\n    public Node(String a){\\n        this.val = a;\\n        this.list = new ArrayList<>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String,List<String>> map;\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> wordSet = new HashSet<>(wordList);\\n        if(!wordSet.contains(endWord)){\\n            return new ArrayList<>();\\n        }\\n        if(!wordSet.contains(beginWord)){\\n            wordList.add(beginWord);\\n        }\\n        map = new HashMap<>();\\n        for(int i = 0; i < wordList.size(); i++){\\n            String u = wordList.get(i);\\n            for(int j=i+1; j < wordList.size(); j++){\\n                String v = wordList.get(j);\\n                if(isOk(u, v)){\\n                    List<String> uL = map.getOrDefault(u, new ArrayList<>());\\n                    List<String> vL = map.getOrDefault(v, new ArrayList<>());\\n                    uL.add(v);\\n                    vL.add(u);\\n                    map.put(u,uL);\\n                    map.put(v, vL);\\n                }\\n            }\\n        }\\n        return bfs(beginWord, endWord);\\n    }\\n    \\n    \\n    public List<List<String>> bfs(String beginWord, String endWord) {\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<Node> queue = new LinkedList<>();\\n        Node n = new Node(beginWord);\\n        n.list.add(beginWord);\\n        queue.add(n);\\n        visited.add(beginWord);\\n        List<List<String>> res = null;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            res = new ArrayList<>();\\n            List<String> unmarked = new ArrayList<>();\\n            boolean found = false;\\n            while(size-- > 0){\\n                Node poll = queue.poll();\\n                if(poll.val.equals(endWord)){\\n                    found = true;\\n                    res.add(poll.list);\\n                }\\n                for(String word : map.getOrDefault(poll.val, new ArrayList<>())){\\n                    if(!visited.contains(word)){\\n                        Node p = new Node(word);\\n                        List<String> list = new ArrayList<>(poll.list);\\n                        list.add(word);\\n                        p.list = list;\\n                        queue.add(p);\\n                        unmarked.add(word);\\n                    }\\n                }\\n                \\n            }\\n            for(String i : unmarked){\\n                visited.add(i);\\n            }\\n            \\n            if(found){\\n                return res;\\n            }\\n        }\\n        return new ArrayList<>();\\n    }\\n    \\n    \\n    public boolean isOk(String word1,String word2){\\n        if(word1.length() != word2.length() || word1.equals(word2)){\\n            return false;\\n        }\\n        int count = 0;\\n        if(word1.length() != word2.length()){\\n            return false;\\n        }\\n        for(int i = 0; i < word1.length(); i++){\\n            if(word1.charAt(i) != word2.charAt(i)){\\n                count++;\\n            }\\n            if(count == 2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n\\nclass Node{\\n    String val;\\n    List<String> list;\\n    \\n    public Node(String a, List<String> list){\\n        this.val = a;\\n        this.list = list;\\n    }\\n    \\n    public Node(String a){\\n        this.val = a;\\n        this.list = new ArrayList<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067095,
                "title": "template-code-for-word-ladder-and-word-ladder-ii-only-few-changes-to-word-ladder",
                "content": "Just add a new path in the que as part of tuple were the intial path start with the beign word.\\n\\nThe template or the code might not be the great and optimized but easy to understand and write in a interview. When you are in a interview you cannot change the whole code for the word ladder II as follow up. Think about it.\\n\\n```\\n**Word ladder** \\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        \\n        d = collections.defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                d[word[:i] + \"_\" + word[i+1:]].append(word)\\n                \\n        q = collections.deque([(beginWord,1)])\\n        visited = set()\\n        \\n        while q:   \\n            word,k = q.popleft()\\n            visited.add(word)\\n            if word == endWord:\\n                return k \\n            \\n            for i in range(len(word)):\\n                for neighbour in d[ word[:i] + \"_\" + word[i+1:] ]:\\n                    if neighbour == endWord:\\n                        return k+1\\n                    if neighbour not in visited:\\n                        q.append((neighbour,k+1))\\n                    \\n        return 0\\n        \\n```\\n\\n```\\n**Word ladder II**\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        if endWord not in wordList:\\n            return []\\n        \\n        \\'\\'\\'create a graph\\'\\'\\'\\n        map = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                subword = word[:i] + \"_\" + word[i+1:]\\n                map[subword].append(word)\\n        \\n        q = collections.deque([(beginWord,1,[beginWord])])\\n        visited = set()\\n        mindist = float(\"inf\")\\n        out = []\\n        while q:\\n            word, d, path = q.popleft()\\n            visited.add(word)\\n            if word == endWord:\\n                if d <= mindist:\\n                    mindist = d\\n                    out.append(path)\\n            else:\\n                for i in range(len(word)):\\n                    subword = word[:i] + \"_\" + word[i+1:]\\n                    for neighbor in map[subword]:\\n                        if neighbor not in visited:\\n                            q.append((neighbor,d+1, path + [neighbor]))\\n            \\n        return out\\n```\\n",
                "solutionTags": [],
                "code": "```\\n**Word ladder** \\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        \\n        d = collections.defaultdict(list)\\n        \\n        for word in wordList:\\n            for i in range(len(word)):\\n                d[word[:i] + \"_\" + word[i+1:]].append(word)\\n                \\n        q = collections.deque([(beginWord,1)])\\n        visited = set()\\n        \\n        while q:   \\n            word,k = q.popleft()\\n            visited.add(word)\\n            if word == endWord:\\n                return k \\n            \\n            for i in range(len(word)):\\n                for neighbour in d[ word[:i] + \"_\" + word[i+1:] ]:\\n                    if neighbour == endWord:\\n                        return k+1\\n                    if neighbour not in visited:\\n                        q.append((neighbour,k+1))\\n                    \\n        return 0\\n        \\n```\n```\\n**Word ladder II**\\nclass Solution:\\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\\n        \\n        if endWord not in wordList:\\n            return []\\n        \\n        \\'\\'\\'create a graph\\'\\'\\'\\n        map = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(len(word)):\\n                subword = word[:i] + \"_\" + word[i+1:]\\n                map[subword].append(word)\\n        \\n        q = collections.deque([(beginWord,1,[beginWord])])\\n        visited = set()\\n        mindist = float(\"inf\")\\n        out = []\\n        while q:\\n            word, d, path = q.popleft()\\n            visited.add(word)\\n            if word == endWord:\\n                if d <= mindist:\\n                    mindist = d\\n                    out.append(path)\\n            else:\\n                for i in range(len(word)):\\n                    subword = word[:i] + \"_\" + word[i+1:]\\n                    for neighbor in map[subword]:\\n                        if neighbor not in visited:\\n                            q.append((neighbor,d+1, path + [neighbor]))\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928557,
                "title": "simplest-c-answer-standard-bfs-backtracking-for-any-problem-like-finding-all-shortest-paths",
                "content": "The same template can be used on any question like \"finding all shortest paths\".\\n\\n```\\n\\nclass Solution {\\n    vector<vector<string>> res;\\n    unordered_map<string, unordered_set<string>> graph;\\n    unordered_map<string, vector<string>> graph_back;\\n    \\n    void dfs(vector<string> &cur, string &target, int n) {\\n        auto s = cur.back();\\n        if (cur.size() == n+1) {\\n            if (s == target) {\\n                res.push_back(vector<string>(cur.rbegin(), cur.rend()));\\n            }\\n            return;\\n        }\\n        \\n        for (auto &next : graph_back[s]) {\\n            cur.push_back(next);\\n            dfs(cur, target, n);\\n            cur.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> set0(wordList.begin(), wordList.end()), visited;\\n        \\n        // build a graph\\n        wordList.push_back(beginWord);\\n        for (auto word : wordList) {\\n            for (int j = 0; j < word.size(); j++) {\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                    if (c != word[j]) {\\n                        auto next = word;\\n                        next[j] = c;\\n                        if (set0.count(next)) {\\n                            graph[word].insert(next);\\n                            graph[next].insert(word);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //BFS to find min length\\n        queue<string> que;\\n        que.push(beginWord);\\n        visited.insert(beginWord);\\n        int step = -1;\\n        bool found = false;\\n        while(que.size()) {\\n            step++;\\n            int size = que.size();\\n            auto previsited = visited;\\n            for (int i = 0; i < size; i++) {\\n                auto cur = que.front();\\n                que.pop();\\n                \\n                if (cur == endWord) {\\n                    found = true;\\n                    break;\\n                }\\n                \\n                for (auto &next : graph[cur]) {\\n                    if (!previsited.count(next)) { //previsited does not include nodes visited at this layer\\n                        graph_back[next].push_back(cur);\\n                    }\\n                    if (!visited.count(next)) {\\n                        visited.insert(next);\\n                        que.push(next);\\n                    }\\n                }\\n            }\\n            if (found) {\\n                break;\\n            }\\n        }\\n        \\n        // backtracking to found all path with length = step\\n        vector<string> cur{endWord};\\n        dfs(cur, beginWord, step);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<string>> res;\\n    unordered_map<string, unordered_set<string>> graph;\\n    unordered_map<string, vector<string>> graph_back;\\n    \\n    void dfs(vector<string> &cur, string &target, int n) {\\n        auto s = cur.back();\\n        if (cur.size() == n+1) {\\n            if (s == target) {\\n                res.push_back(vector<string>(cur.rbegin(), cur.rend()));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 859757,
                "title": "javascript-bfs-dfs-solution",
                "content": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n  const _getNextWords = (currWord) => {\\n    const words = wordList.indexOf(beginWord) === -1 ? [...wordList, beginWord] : wordList;\\n    return words.filter((word) => {\\n      if (word === currWord) return false;\\n      let diff = 0;\\n      for (let i = 0; i < word.length; i += 1) {\\n        if (diff > 1) {\\n          return false;\\n        }\\n        if (word[i] !== currWord[i]) {\\n          diff += 1;\\n        }\\n      }\\n      return diff === 1;\\n    });\\n  };\\n\\n  // calculate distance map for words bottom up from endWord to beginWord\\n  const _bfs = (endWord) => {\\n    const queue = [endWord];\\n\\n    while (queue.length > 0) {\\n      const currWord = queue.shift();\\n      if (currWord === beginWord) {\\n        break;\\n      }\\n      const nextWords = _getNextWords(currWord);\\n      const currDist = distance.get(currWord);\\n      for (let next of nextWords) {\\n        if (!distance.has(next)) {\\n          distance.set(next, currDist + 1);\\n          queue.push(next);\\n        }\\n      }\\n    }\\n  };\\n\\n  const _dfs = (word, path) => {\\n    if (word === endWord) {\\n      results.push(path);\\n      return;\\n    }\\n    for (let next of _getNextWords(word)) {\\n      if (distance.has(next) && distance.get(next) + 1 === distance.get(word)) {\\n        _dfs(next, [...path, next]);\\n      }\\n    }\\n  };\\n  \\n  const results = [];\\n  const distance = new Map();\\n  distance.set(endWord, 0);\\n  _bfs(endWord);\\n  _dfs(beginWord, [beginWord]);\\n\\n  return results;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {string[][]}\\n */\\nvar findLadders = function(beginWord, endWord, wordList) {\\n  const _getNextWords = (currWord) => {\\n    const words = wordList.indexOf(beginWord) === -1 ? [...wordList, beginWord] : wordList;\\n    return words.filter((word) => {\\n      if (word === currWord) return false;\\n      let diff = 0;\\n      for (let i = 0; i < word.length; i += 1) {\\n        if (diff > 1) {\\n          return false;\\n        }\\n        if (word[i] !== currWord[i]) {\\n          diff += 1;\\n        }\\n      }\\n      return diff === 1;\\n    });\\n  };\\n\\n  // calculate distance map for words bottom up from endWord to beginWord\\n  const _bfs = (endWord) => {\\n    const queue = [endWord];\\n\\n    while (queue.length > 0) {\\n      const currWord = queue.shift();\\n      if (currWord === beginWord) {\\n        break;\\n      }\\n      const nextWords = _getNextWords(currWord);\\n      const currDist = distance.get(currWord);\\n      for (let next of nextWords) {\\n        if (!distance.has(next)) {\\n          distance.set(next, currDist + 1);\\n          queue.push(next);\\n        }\\n      }\\n    }\\n  };\\n\\n  const _dfs = (word, path) => {\\n    if (word === endWord) {\\n      results.push(path);\\n      return;\\n    }\\n    for (let next of _getNextWords(word)) {\\n      if (distance.has(next) && distance.get(next) + 1 === distance.get(word)) {\\n        _dfs(next, [...path, next]);\\n      }\\n    }\\n  };\\n  \\n  const results = [];\\n  const distance = new Map();\\n  distance.set(endWord, 0);\\n  _bfs(endWord);\\n  _dfs(beginWord, [beginWord]);\\n\\n  return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 842209,
                "title": "simple-java-bfs-solution-with-explanation-queue-only",
                "content": "The key point is, instead of using `Queue<String>` for #127 Word Ladder, we use `Queue<List<String>>` here to save all possible pathes until we find the endword, and add all possible pathes to our result.\\n\\nSteps:\\n1. Push a list containing only `beginWord` to the queue.\\n2. While the queue has elements, poll the front element of the queue then get last word from this element as `currWord`.\\n3. The set of words we get from the helper function `getNextWordSet()` are all the adjacent words to the `currWord`. (We can use a hashmap to save this set of words for currWord to avoid repeated calculations)\\n4. Foreach each adjacent word, create a new list containing the current path as well as this adjacent word, append into the queue. If we find the `endWord`, add the path to our final result.\\n\\nCode:\\n\\n```\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> result = new ArrayList<>();\\n        Queue<List<String>> queue = new LinkedList<>();\\n        Set<String> wordSet = new HashSet<>(wordList);\\n        // use a hashmap to save a set of valid adjacent words for a given word to avoid repeated calculations\\n        Map<String, Set<String>> wordMap = new HashMap<>();\\n        wordSet.add(beginWord);\\n        List<String> start = new ArrayList<>();\\n        start.add(beginWord);\\n        queue.offer(start);\\n        boolean foundResult = false;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<String> usedWords = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                List<String> currList = queue.poll();\\n                String currWord = currList.get(currList.size() - 1);\\n                if (!wordSet.contains(currWord)) continue;\\n                if (!wordMap.containsKey(currWord)) {\\n                    Set<String> nextWordSet = getNextWordSet(currWord, wordSet);\\n                    wordMap.put(currWord, nextWordSet);\\n                }\\n                Set<String> nextWordSet = wordMap.get(currWord);\\n                for (String nextWord: nextWordSet) {\\n                    List<String> nextList = new ArrayList<>();\\n                    nextList.addAll(currList);\\n                    nextList.add(nextWord);\\n                    if (nextWord.equals(endWord)) {\\n                        result.add(nextList);\\n                        foundResult = true;\\n                    } else {\\n                        queue.offer(nextList);\\n                    }\\n                    usedWords.add(currWord);\\n                }\\n                \\n            }\\n            // generated words should be removed from wordSet to prevent cycles\\n            for (String uw: usedWords) wordSet.remove(uw);\\n            if (foundResult) break;\\n        }\\n        return result;\\n    }\\n    \\n    // check all variations of a given word and check if it matches any word from wordset, \\n    // if it has a match, add that word into result set\\n    private Set<String> getNextWordSet(String word, Set<String> dict) {\\n        Set<String> result = new HashSet<>();\\n        char[] array = word.toCharArray(); \\n        for (int i = 0; i < array.length; i++) {\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (array[i] == c) continue;\\n                char t = array[i];\\n                array[i] = c;\\n                String nextWord = String.valueOf(array);\\n                if (dict.contains(nextWord)) result.add(nextWord);\\n                array[i] = t;\\n            }\\n        }\\n        return result;\\n    }    \\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        List<List<String>> result = new ArrayList<>();\\n        Queue<List<String>> queue = new LinkedList<>();\\n        Set<String> wordSet = new HashSet<>(wordList);\\n        // use a hashmap to save a set of valid adjacent words for a given word to avoid repeated calculations\\n        Map<String, Set<String>> wordMap = new HashMap<>();\\n        wordSet.add(beginWord);\\n        List<String> start = new ArrayList<>();\\n        start.add(beginWord);\\n        queue.offer(start);\\n        boolean foundResult = false;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<String> usedWords = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                List<String> currList = queue.poll();\\n                String currWord = currList.get(currList.size() - 1);\\n                if (!wordSet.contains(currWord)) continue;\\n                if (!wordMap.containsKey(currWord)) {\\n                    Set<String> nextWordSet = getNextWordSet(currWord, wordSet);\\n                    wordMap.put(currWord, nextWordSet);\\n                }\\n                Set<String> nextWordSet = wordMap.get(currWord);\\n                for (String nextWord: nextWordSet) {\\n                    List<String> nextList = new ArrayList<>();\\n                    nextList.addAll(currList);\\n                    nextList.add(nextWord);\\n                    if (nextWord.equals(endWord)) {\\n                        result.add(nextList);\\n                        foundResult = true;\\n                    } else {\\n                        queue.offer(nextList);\\n                    }\\n                    usedWords.add(currWord);\\n                }\\n                \\n            }\\n            // generated words should be removed from wordSet to prevent cycles\\n            for (String uw: usedWords) wordSet.remove(uw);\\n            if (foundResult) break;\\n        }\\n        return result;\\n    }\\n    \\n    // check all variations of a given word and check if it matches any word from wordset, \\n    // if it has a match, add that word into result set\\n    private Set<String> getNextWordSet(String word, Set<String> dict) {\\n        Set<String> result = new HashSet<>();\\n        char[] array = word.toCharArray(); \\n        for (int i = 0; i < array.length; i++) {\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if (array[i] == c) continue;\\n                char t = array[i];\\n                array[i] = c;\\n                String nextWord = String.valueOf(array);\\n                if (dict.contains(nextWord)) result.add(nextWord);\\n                array[i] = t;\\n            }\\n        }\\n        return result;\\n    }    \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565540,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1566379,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1566238,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568942,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567202,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568206,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568943,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567872,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1660940,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567204,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1565540,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1566379,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1566238,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568942,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567202,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568206,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1568943,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567872,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1660940,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1567204,
                "content": [
                    {
                        "username": "cheetha",
                        "content": "Image a diagram like this searching all shortest path from \"red\" to \"tax\" \\u8BBE\\u60F3\\u6570\\u636E\\u5982\\u4E0B\\uFF0C\\u9700\\u8981\\u5BFB\\u627E\\u4ECE red \\u5230 tax \\u7684\\u6240\\u6709\\u6700\\u77ED\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413486.png)\\n\\n\\n<br>\\n<br>\\n<br>Step 1: Explore the tax and keep all words within the same distance by BFS (If \"tax\" is 3 steps distance from \"red\", collect all word within 3 steps distance from \"red\") \\u4ECE red \\u5E7F\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u76F4\\u5230\\u9047\\u5230 tax\\uFF0C\\u6BD4\\u5982tax\\u8DDD\\u79BBred 3 \\u6B65\\u7684\\u8BDD\\uFF0C\\u4FDD\\u7559\\u6240\\u6709\\u8DDD\\u79BB red 3 \\u6B65\\u4EE5\\u5185\\u7684\\u6240\\u6709\\u5355\\u8BCD\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u6709\\u5411\\u56FE\\u3002\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413622.png)\\n\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 2: Cut the branches which not lead to \"tax\" (light blue words)  \\u526A\\u679D\\u53BB\\u6389\\u6240\\u6709\\u65E0\\u6CD5\\u5230\\u8FBEtax\\u7684\\u8282\\u70B9(\\u6D45\\u84DD)\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537413660.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Step 3: List all possible solutions \\u5728\\u8FD9\\u4E2A\\u6700\\u7B80\\u6709\\u5411\\u56FE\\u4E2D\\u627E\\u51FA\\u6240\\u6709\\u8DEF\\u5F84\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414087.png)\\n\\n\\n\\n<br>\\n<br>\\n<br>Final result \\u6700\\u7EC8\\u7684\\u7ED3\\u679C\\n\\n![image](https://assets.leetcode.com/users/cheetha/image_1537414109.png)\\n\\n"
                    },
                    {
                        "username": "svinther",
                        "content": "What I find not intuitive about this, is that it seems to assume that a path with a length that equals dist(beginword, endword) must exist ? \\n\\nCould it not be the case that only a longer path exists ?"
                    },
                    {
                        "username": "user7634rI",
                        "content": "**All top previous solution now fails on last 2 added cases!**"
                    },
                    {
                        "username": "qiankanglai",
                        "content": "An extremely strange question here...\\n\\nFirst I solve this problem with BFS building search graph + DFS build paths. However I tried my best optimizing but got Time Limit Exceeded (I've tried three ways of building path\". After profiling, it seems in the building path part, copying ArrayList consumes too much time.\\n\\nAfter that I simply \"translate\" the code into C++ with stl, and got AC easily.\\n\\nMay I know the time limits for these two implementations?"
                    },
                    {
                        "username": "publicstatic2",
                        "content": "\\n\\nHi all,\\n\\nSince I was asked this question during the interview with LinkedIn. The interviewer told me find only one valid path instead of shortest length and all paths. So I think it's a Word Ladder 1.5.\\n\\nDuring the interview, at beginning, I used Word Ladder II solution to solve the question. But the interviewer was not satisfied with the solution, he said too much extra memory was used. So I really want to know whether there is any more efficient way to find only one path.\\n\\nMeanwhile, I'm also confused that the interview thought replace characters from 'a' to 'z' is very low efficient, but he didn't told me what's his solution............."
                    },
                    {
                        "username": "algoacer",
                        "content": "How about using a Trie data Structure inserting all words from wordlist into it? Implementation seems tough and I am looking for the code myself. Otherwise we can check that the two strings differ at single character only."
                    },
                    {
                        "username": "davikim",
                        "content": "I am 6 years late, but to find only one shortest path, you can just keep track of a parent array and once we finished finding the shortest path, we can traverse the parent array by constantly retrieving the parents and then once done, reverse it such that the order is correct.\n\nlike below:\n```python\n if possWd == endWord:  \n                            i = wordToIdxMapper[possWd]  \n                            toPrint = []\n                            while not i == -1:\n                                toPrint.append(wordList[i])\n                                i = path[i]\n\n                            toPrint.append(beginWord)\n                            toPrint.reverse()\n                            print(toPrint)\n```\n\nfor further notes:\nhttps://leetcode.com/discuss/study-guide/3070870/graph-reviewcram-notes-for-interview\n"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, Instead of replacing characters from \\'a\\'-\\'z\\' just compare two strings and find out difference. If difference gives you 1 then consider string as your next string to be added into queue. Which will save some time during iteration process."
                    },
                    {
                        "username": "edisondun",
                        "content": "I run the test and that is what i got:\\nWord Ladder II\\n\\nSubmission Details\\n1 / 1 test cases passed.\\nStatus: Wrong Answer\\nInput:\\nNone\\nOutput:\\nExpected:\\nNone"
                    },
                    {
                        "username": "KeyVault",
                        "content": "Thanks to jianminchen for puttign the code [here](https://leetcode.com/problems/word-ladder-ii/discuss/379124/C-creative-idea-to-create-a-graph-and-then-construct-shortest-path-map-practice-in-2019). \\n\\nIt helped a lot to understand this problem.\\n\\n**Algorithm in words:**\\n1. Create a HashTable for all the possible combinations of each word. For Example for word \\n\"good\" => \\\\*ood, g\\\\*od, go\\\\*d, goo\\\\*. \\n![image](https://assets.leetcode.com/users/tu19/image_1568345344.png)\\n\\n2. Use a queue data structure to do a BFS on all the nodes, marking each one of them as visited as you move on.\\n3.  For every word you visit, lookout for the next possible word with the help of the keys generated in Step #1.\\nFor example - in the figure below, we start at word \"good\" and move to next neigbour \"bood\" with the key(*ood) and the next neighbour \"goot\" with the key (goo*). We skip the keys \\'g\\\\*od\\' and \\'go\\\\*d\\' because they both lead to the same Node which is \\'good\\' and it has been visited already.\\n4. Similary, we explore all the keys for each node and take the relevant ones and skip the irrelevant ones ( one which are already visited).\\n5. As we move along, we copy the shortest path reached so far to the next node.\\n6. We continue steps 2 to 5 until we have reached the end word and queue is not empty.\\n\\nIn the below figure \\n\\n In Red - is the path we collect along the way until we reach final word.\\n In Green - is the key which led to the next node in the graph.\\n In Blue - Is the final result for the shortest path for the endword.\\n\\nHope this helps.\\n\\n![image](https://assets.leetcode.com/users/tu19/image_1568344188.png)\\n"
                    },
                    {
                        "username": "mlfma3",
                        "content": "this is frustrating. My code works (tested on linux box) but got MLE. I can not figure out what causes the MLE and there is no test case given so I can not debug. Is it possible to give out the test case that causes MLE?"
                    },
                    {
                        "username": "sippey",
                        "content": "Punch line first: if you use iterators in tight loops, there is a chance the iterators can be replaced by pure simple pointers and there is huge gain in performance. Check profile first and see what slows your program down.\\n\\n\\n=====================================\\n\\nTo tell the full story, I ll briefly describe what I have done:\\n\\n* Generating nodes using dict, one node per dict entry, do not forget add the start and end as well.\\n* Establish links between nodes.\\n* BFS search with a tweak\\n   #  Terminate as soon as end node is out of frontier. (If terminate when discover end node, program cannot find multiple path)\\n   #  Record back trace information. If one node is discovered but will end up with same distance, add multiple back trace info. (basically, back trace is a vector)\\n* Traverse back trace information (it form a tree, so I use word traverse) to form node\\n\\nThe flow seems fine but when I encounter the 2600 words test case. I got constant TLE. Profile shows that the second step ( Establish links between nodes) take most of time. I did not anticipate that but then reailize is reasonable as it is O(n^2). Then I discovered the iterator constructor, advance operator(++) and compare (!=) takes large chunk of time and I optimize by replacing them with pointers. \"Accepted\", OJ said.\\n\\nI was long being told iterator is efficient and can be used everywhere. It turned out in this case, it is not really true.\\n\\n==================================\\n\\nSecond thought, if I know the dictionary size will be much larger than the length of path (~100:1 ratio). I will probably build the graph links JIT, meaning forming links when the node is being explored. However, this makes code less modular."
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "Why all the solutions posted results in TLE?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@PranavMare](/PranavMare) If the new testcases invalidate previous suboptimal solutions and make the problem harder, how is it unnecessary and stupid?\nI'll agree tho, that with these new testcases, this problem belongs to a new leetcode category \"super damn hard\". Took me a full day to solve it"
                    },
                    {
                        "username": "PranavMare",
                        "content": "Because leetcode has unnecessarily changed the test cases , which is stupid in my opinion."
                    },
                    {
                        "username": "areshand",
                        "content": "Notices the new feature that shows the running time for all the accepted submissions.\\nIt would be better to show the average time for each different programming language in the figure.\\nIt would be even better to show the standard deviation there."
                    }
                ]
            },
            {
                "id": 1576705,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1575100,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1574049,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1573797,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1572212,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1571264,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1571832,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 2039844,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 2030945,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 2018013,
                "content": [
                    {
                        "username": "user6072Ia",
                        "content": "https://leetcode.com/problems/all-paths-from-source-to-target/\\nthis question is quite similar ....."
                    },
                    {
                        "username": "HireMePlease",
                        "content": "I think I\\'m missing something basic here. Why do most solutions use BFS to build a graph and then DFS to find shortest paths? What makes that superior to keeping track of the paths on the queue during BFS and adding them to the answer when endWord is reached? Thanks for any help."
                    },
                    {
                        "username": "jayganesh5052",
                        "content": "is the part **find all shortest transformation sequence(s) from beginWord to endWord** in the question is to confuse us? \\n"
                    },
                    {
                        "username": "cormen44",
                        "content": "I couldn\\'t find the reason anywhere why BFS is preferred solution rather thn DFS"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Because DFS will go till the leaf, which will consume lot of times, Whereas BFS will got level by level. So It\\'s always preferred to use BFS when question says shortest transformation.."
                    },
                    {
                        "username": "zhenghangjie123",
                        "content": "When I use C to solve this problem, I find my program can not get the same answer as in my own project. Please give me the sample of outputs about what the result (char***) can be and int** columnsize and int* returnSize can be."
                    },
                    {
                        "username": "kansal123",
                        "content": "I reversed the direction of BFS, i.e., I searched from endWord to beginWord and then it got accepted. When I change it back, I get TLE."
                    },
                    {
                        "username": "taithenguyen",
                        "content": "I have a stuck with a test case\\n\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nMy output is\\n\\n[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"],[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\\n\\nI believe it should be correct. But the expect result is empty."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Yes, It must be empty array. Just simple thing, end word is not present in word dictionary. So no need to transform the words since end word is absence."
                    },
                    {
                        "username": "algoacer",
                        "content": "**When you encounter this in an interview, then they Don\\'t want to Hire you.**\\n\\nOne thing that works here is interviewer giving you hints on exactly what to do in implementation and let you do the code."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "why I am getting TLE and MLE for testcase 32/36 pls check anyone? `your inline code...your inline code...` `class Solution {\\npublic:\\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string>st(wordList.begin(),wordList.end());\\n         queue<vector<string>>q;\\n        q.push({beginWord});\\n       vector<string>usedOnlevel;\\n       usedOnlevel.push_back(beginWord);\\n       int level = 0;\\n       vector<vector<string>>ans;\\n        while(!q.empty()){\\n            vector<string> vec = q.front();\\n            q.pop();\\n        //    erase all the words that has been used in the previous level to transform\\n        if(vec.size()>level){\\n            level++;\\n            for(auto it : usedOnlevel){\\n                st.erase(it);\\n            }\\n        }\\n        string word = vec.back();\\n        //store the ans\\n        if(word ==endWord){\\n             // reached the first seq\\n             if(ans.size()==0){\\n                 ans.push_back(vec);\\n             }\\n             else if(ans[0].size()==vec.size()){\\n                 ans.push_back(vec);\\n             }\\n        }\\n\\n            for(int i = 0 ;i<word.size();++i){\\n                char original = word[i];\\n              \\n                for(char ch = \\'a\\' ; ch<=\\'z\\';ch++){\\n                    word[i]= ch;\\n                    if(st.count(word)>0){\\n                        vec.push_back(word);\\n                        q.push(vec);\\n                        //mark as visited ont= the level\\n                        usedOnlevel.push_back(word);\\n                        vec.pop_back();\\n                    }\\n                }\\n                word[i]=original;\\n            }\\n\\n            \\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "girish13",
                        "content": "Can someone pls tell why my code is giving TLE ? I got TLE on testcase 32/36.\\n\\n```\\nclass Solution {\\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\\n        int n = wordList.size();\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        Set<String> set = new HashSet<String>(wordList);\\n        if(!set.contains(endWord)) return result;\\n        Queue<List<String>> queue = new LinkedList<List<String>>();\\n        queue.add(new ArrayList<String>(){{add(beginWord);}});\\n        List<String> usedWordsPerLevel = new ArrayList<String>();\\n        usedWordsPerLevel.add(beginWord);     \\n        int level = 0;\\n        int len = beginWord.length();\\n        while(!queue.isEmpty()){\\n            List<String> list = queue.poll();\\n            if(list.size() > level){\\n                level++;\\n                for(String rmWord : usedWordsPerLevel) \\n                    set.remove(rmWord);\\n            }\\n            String word = list.get(list.size() - 1);\\n            if(word.equals(endWord)){\\n                if(result.size() == 0 || result.get(0).size() == list.size()) \\n                    result.add(list);\\n            }\\n            for(int l = 0; l < len; l++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char[] nextWordArr = word.toCharArray();\\n                    nextWordArr[l] = c;\\n                    String nextWord = new String(nextWordArr);\\n                    if(set.contains(nextWord)){\\n                        list.add(nextWord);\\n                        List<String> temp = new ArrayList<String>(list);\\n                        queue.add(temp);\\n                        usedWordsPerLevel.add(nextWord);\\n                        list.remove(nextWord);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```"
                    }
                ]
            }
        ]
    }
]