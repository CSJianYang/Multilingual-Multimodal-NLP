[
    {
        "title": "Prime Palindrome",
        "question_content": "Given an integer n, return the smallest prime palindrome greater than or equal to n.\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n\tFor example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n\tFor example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n&nbsp;\nExample 1:\nInput: n = 6\nOutput: 7\nExample 2:\nInput: n = 8\nOutput: 11\nExample 3:\nInput: n = 13\nOutput: 101\n&nbsp;\nConstraints:\n\n\t1 <= n <= 108",
        "solutions": [
            {
                "id": 146798,
                "title": "java-c-python-all-even-length-palindrome-are-divisible-by-11",
                "content": "# **Intuition**\\nWrite some example, you find all even length palindromes are divisible by 11.\\nSo we need to search only palindrome with odd length.\\n\\nWe can prove as follow:\\n11 % 11 = 0\\n1111 % 11 = 0\\n111111 % 11 = 0\\n11111111 % 11 = 0\\n\\n**So:**\\n1001 % 11 = (1111 - 11 * 10) % 11 = 0\\n100001 % 11 = (111111 - 1111 * 10) % 11 = 0\\n10000001 % 11 = (11111111 - 111111 * 10) % 11 = 0\\n\\nFor any palindrome with even length:\\nabcddcba % 11\\n= (a * 10000001 + b * 100001 * 10 + c * 1001 * 100 + d * 11 * 1000) % 11\\n= 0\\n\\nAll palindrome with even length is multiple of `11`.\\nSo among them, 11 is the only one prime\\n`if (8 <= N <= 11) return 11`\\n\\nFor other cases, **we consider only palindrome with odd dights.**\\n<br>\\n\\n# More Generally\\nExplanation from @chuan-chih:\\nA number is divisible by 11 if `sum(even digits) - sum(odd digits)` is divisible by 11.\\n**Base case: 0**\\n**Inductive step:**\\nIf there is no carry when we add 11 to a number, both sums +1.\\nWhenever carry happens, one sum -10 and the other +1.\\nThe invariant holds in both cases.\\n<br>\\n\\n# **Time Complexity**\\n`O(10000)` to check all numbers 1 - 10000.\\n`isPrime` function is `O(sqrt(x))` in worst case.\\nBut only `sqrt(N)` worst cases for `1 <= x <= N`\\nIn general it\\'s `O(logx)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n\\n**Python:**\\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 146766,
                "title": "c-o-1-0ms",
                "content": "base on exp, it should not be a big table; \\n\\n    class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            };\\n            return *lower_bound(tab.begin(), tab.end(), N);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 146788,
                "title": "getting-one-over-the-system-o-1-solution-in-java",
                "content": "So I spend 30 mins (and 5 bugs) trying to get my O(N^2) solution to work. It doesn\\'t. So I get mad and rage-generate an array of all the palindromic primes using 1553 ms. Next, I put them into my revenge array.\\n\\n```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\\nYou get the idea.\\nO(1) solution I got after brute-forcing all the primes I needed.\\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nIt didn\\'t nab me for memory usage LOL. Check out the C++ one also, its faster (coder used binary search) and was posted first.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158439,
                "title": "c-even-odd-length-palindrome-merge-sort-like-solution-interviewer-really-loves-it-kiss",
                "content": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 146950,
                "title": "python-3-construct-palindromes-first-and-then-check-if-prime",
                "content": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212297,
                "title": "why-even-number-of-digit-prime-palindromes-are-not-possible",
                "content": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "solutionTags": [],
                "code": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146888,
                "title": "java-solution-building-closest-palindrome",
                "content": "Inspired by [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/description/)\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146835,
                "title": "java-solution-6ms",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146930,
                "title": "faster-way-to-find-palindrome-accepted-c-solution",
                "content": "My solution is based on Finding a palindrome number (`>=N`)first and then I will check it for a prime or not.\\nGiven a number `N`, I will check it for a palindrome, if not - then I find the closest palindrome (`>N`)\\nTo find the closest palindrome is the hardest part of this program. Here is the whole discussion. The discussion based on \"array int\" but I implemented the number considering a string.\\n\\nIf you have any **question** regarding my **code**, please **comment**. I will try to answer.\\n\\nFor example, if the input number is \\u201C2 3 5 4 5\\u201D, the output should be \\u201C2 3 6 3 2\\u201D. And if the input number is \\u201C9 9 9\\u201D, the output should be \\u201C1 0 0 1\\u201D.\\n\\nThere can be three different types of inputs that need to be handled separately.\\n\\n1) The input number has all 9s. For example \\u201C9 9 9\\u201D. Output should be \\u201C1 0 0 1\\u201D i, e., `answer = input+2`\\n\\n2) For input \\u201C1 2 3 4\\u201D. Output should be \\u201C1 3 3 1\\u201D\\n\\nHow to convert a given number to a greater palindrome? To understand the solution, let us first define the following two terms:\\nLeft Side: The left half of given number. Left side of \\u201C1 2 3 4 5 6\\u201D is \\u201C1 2 3\\u201D and left side of \\u201C1 2 3 4 5\\u201D is \\u201C1 2\\u201D\\nRight Side: The right half of given number. Right side of \\u201C1 2 3 4 5 6\\u201D is \\u201C4 5 6\\u201D and right side of \\u201C1 2 3 4 5\\u201D is \\u201C4 5\\u201D\\nTo convert to palindrome, we can either take the mirror of its left side or take mirror of its right side. However, if we take the mirror of the right side, then the palindrome so formed is not guaranteed to be next larger palindrome. So, we must take the mirror of left side and copy it to right side. But there are some cases that must be handled in different ways. See the following steps.\\n\\nWe will start with two indices i and j. i pointing to the two middle elements (or pointing to two elements around the middle element in case of n being odd). We one by one move i and j away from each other.\\n\\n\\nStep 1. Initially, ignore the part of left side which is same as the corresponding part of right side. For example, if the number is \\u201C8 3 4 2 2 4 6 9\\u2033, we ignore the middle four elements. i now points to element 3 and j now points to element 6.\\n\\nStep 2. After step 1, following cases arise:\\n\\nCase 1: Indices i & j cross the boundary.\\nThis case occurs when the input number is palindrome. In this case, we just add 1 to the middle digit (or digits in case n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\nFor example, if the given number is \\u201C1 2 9 2 1\\u201D, we increment 9 to 10 and propagate the carry. So the number becomes \\u201C1 3 0 3 1\\u201D\\n\\nCase 2: There are digits left between left side and right side which are not same. So, we just mirror the left side to the right side & try to minimize the number formed to guarantee the next smallest palindrome.\\nIn this case, there can be two sub-cases.\\n\\n2.1) Copying the left side to the right side is sufficient, we don\\u2019t need to increment any digits and the result is just mirror of left side. Following are some examples of this sub-case.\\nNext palindrome for \\u201C7 8 3 3 2 2\\u2033 is \\u201C7 8 3 3 8 7\\u201D\\nNext palindrome for \\u201C1 2 5 3 2 2\\u2033 is \\u201C1 2 5 5 2 1\\u201D\\nNext palindrome for \\u201C1 4 5 8 7 6 7 8 3 2 2\\u2033 is \\u201C1 4 5 8 7 6 7 8 5 4 1\\u201D\\nHow do we check for this sub-case? All we need to check is the digit just after the ignored part in step 1. This digit is highlighted in above examples. If this digit is greater than the corresponding digit in right side digit, then copying the left side to the right side is sufficient and we don\\u2019t need to do anything else.\\n\\n2.2) Copying the left side to the right side is NOT sufficient. This happens when the above defined digit of left side is smaller. Following are some examples of this case.\\nNext palindrome for \\u201C7 1 3 3 2 2\\u2033 is \\u201C7 1 4 4 1 7\\u201D\\nNext palindrome for \\u201C1 2 3 4 6 2 8\\u2033 is \\u201C1 2 3 5 3 2 1\\u201D\\nNext palindrome for \\u201C9 4 1 8 7 9 7 8 3 2 2\\u2033 is \\u201C9 4 1 8 8 0 8 8 1 4 9\\u201D\\nWe handle this subcase like Case 1. We just add 1 to the middle digit (or digits in ase n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\n\\nRef: www.geeksforgeeks.org.\\n\\nThis is the way to get **all palindrome** number. For this problem to solve you can consider only **odd palindrome** for fast result.\\n\\nHere is my implementation, \\n\\n```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018872,
                "title": "c-easy-to-understand-math",
                "content": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool ispalindrom(int n)\\n    {\\n        int n1=n;\\n        int n2=0;\\n        while(n1>0){\\n            int a=n1%10;\\n            n2=n2*10+a;\\n            n1/=10;\\n        }\\n        if(n2==n)\\n            return true;\\n        return false;\\n    }\\n    int smallestno(int n)\\n    {\\n        if(ispalindrom(n))\\n            if(isprime(n))\\n                return n;\\n        return smallestno(n+1);\\n    }\\n\\n    int primePalindrome(int n) {\\n        \\n        if (1e7 <= n && n <= 1e8)\\n            return 100030001;\\n        int a=smallestno(n);\\n        return a;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1291185,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```\\nIF YOU LIKE THE SOLUTION, UPVOTE IT AND ENCOURAGE ME.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314332,
                "title": "python-code-summarizing-several-posts",
                "content": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "solutionTags": [],
                "code": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 179678,
                "title": "a-fast-way-to-check-is-prime-python",
                "content": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "solutionTags": [],
                "code": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 147065,
                "title": "javascript-solution-128ms",
                "content": "It\\'s tempted to **get stuck** in javascript when you only focus on how to find a prime quicker, because in that case your code will always **time out**. The only way to avoid time out when you focus on prime is to find all the solutions and then **save them as a const** to refer to.(then you\\'ll have no fun programming)\\n**The right way** to think of this problem is to `find the next palindrome`. There are big gaps between two close palindrome, and we can use those gaps to save time. So the key point of this solution lies in finding the next palindrome based on the palindrome we dealt before.\\n```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\nThe part of my code to find the next palindrome is not elegant. I tried to cut the code but failed. If you have any good idea about making it shorter, please let me know. Thanks `:)`",
                "solutionTags": [],
                "code": "```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433138,
                "title": "easy-solution-full-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can divide it into 4 parts:-\\n    1.Find if the number is palindrome or not.\\n    2.Find if the number is prime or not.\\n    3.If it satisfy both prime and palindrome than we return n.\\n    4.Else while(true) -> If n satisfy both prime and Palindrome -> return n. Else -> n++.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158651,
                "title": "c-using-prime-sieve-and-palindromic-check",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359417,
                "title": "java-iterate-odd-length-palindromes-generate-next-palindrome-beats-100",
                "content": "**Iterate odd-length palindromes**\\n\\nPrerequisite knowledge: [Divisibility Rule of 11](https://en.wikipedia.org/wiki/Divisibility_rule)\\nA number is divisible by 11 iff difference between sum of its odd digits (i.e. digits at odd places) and sum of its even digits is divisible by 11.\\n\\nThis implies that all even-length palindromes are divisible by 11 since sum(odd digits) = sum(even digits). So even-length palindromes can not be primes except the number 11 itself.\\n\\nSo we skip even-length palindromes and iterate only over odd-length palindromes to look for primes. Iterating palindromes sequentially means iterating over their left half and appending the reverse of the left half as right half to construct the palindrome.\\n\\n```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Generate next palindrome**\\n\\nWe can borrow our knowledge from [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/discuss/960052/Find-previous-and-next-palindromes-detailed-explanation) to calculate next palindrome from a number. Another problem that can be solved using next palindrome idea: [906. Super Palindromes](https://leetcode.com/problems/super-palindromes/discuss/1198415/Java-Build-next-palindrome-Solve-2-Hards)\\n\\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\nNote that ``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ``` is just an optimization to skip over even-length numbers of length 8. Even if we remove these lines, the code runs in ```8 ms. 97.10%``` which isn\\'t too bad.",
                "solutionTags": [],
                "code": "```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\n``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ```\n```8 ms. 97.10%```",
                "codeTag": "Java"
            },
            {
                "id": 147740,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354439,
                "title": "100-faster-c-improved-brute-force",
                "content": "## Improved Brute Force\\n\\n```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121912,
                "title": "python-100-faster-without-cheating-fully-commented",
                "content": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 887035,
                "title": "fermat-s-little-theorem-to-check-odd-palindrome-for-prime-in-o-log-n-time",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767277,
                "title": "c",
                "content": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475536,
                "title": "java-solution-beats-99-93-time",
                "content": "The idea is to maintain an array of the digits of N (actually only the first half of them) and increase them to form valid palindromes. Then we check if they are also a prime number.\\n\\nThe solution is arguably a bit convoluted because of all the low-level operations, but fast due to the fact that it doesn\\'t rely on string operations.\\n\\nI also added skipping even-digit palindromes after I read that they cannot be prime numbers ( -_-\\' ), which makes it even faster. \\n\\n````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148253,
                "title": "straightforward-c-solutions-with-detailed-explanations",
                "content": "**Solution #1:** For small values of N less than or equal to ```11```, simply return the smallest prime value.  For values of N greater than ```11```, the next prime palindrome is ```101```.  Use the value ```i``` from ```[10:999999]``` to represent the first \"half\" of a candidate integer palindrome.  The value ```i``` is converted to a string order to construct the odd length palindrome ```101``` ( by pushing ```1``` onto the end of ```10``` ) and to construct the even length palindrome ```1001``` ( by pusing ```01``` onto the end of ```10``` ).  Always check if the odd length integer palindrome is prime first (since it has a smaller value than the even length integer palindrome) and check if the even length integer palindrome is prime second.  Return the integer value of the first found prime integer palindrome in this order.\\n\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Note:** If this code looks strange, then just try stepping through the code for the first few values of ```i```.  As you can see, the integer value ```i``` is the first \"half\" of the palindrome:\\n\\n```i=10    odd=101    even=1001```\\n```i=11    odd=111    even=1111```\\n```i=12    odd=121    even=1221```\\n\\n```etc...```\\n\\n**Solution #2:** there are 782 prime palindrome (```PP```) candidates for the range ```1 <= N <= 10^8``` simply return the ```lower_bound``` of this ordered set ```PP```.  \\n**Note:** I printed this set as output from solution #1 above, so it is in ascending order.  I used ```iomanip``` to write to the ostream in hex left-padded with zeros so that the integer values are uniformly distributed along columns for enhanced readability.\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "solutionTags": [],
                "code": "```11```\n```11```\n```101```\n```i```\n```[10:999999]```\n```i```\n```101```\n```1```\n```10```\n```1001```\n```01```\n```10```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```i```\n```i```\n```i=10    odd=101    even=1001```\n```i=11    odd=111    even=1111```\n```i=12    odd=121    even=1221```\n```etc...```\n```PP```\n```1 <= N <= 10^8```\n```lower_bound```\n```PP```\n```iomanip```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553716,
                "title": "explained-fastest-solution-c-odd-length-palindromes",
                "content": "# Brute Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn brute force algorithm, we will iterate over all $i$ for $>=n$ && $<=2*10^8$ and check if that is prime and is palindrome or not. \\nAs soon as some i satisfies this equation, we will return the i.\\n\\nTime complexity to find if n is prime or not $O(sqrt(n))$\\nTime complexity to find if n is palindrome or not $O(log(n))$\\n\\nOverall this brute approach will take too much time complexity.\\n\\nThe optimized solution is deduced from one fact ------\\nAll even length palindrome are divisble by 11.\\nAnd among all even length palindrome only 11 is prime. \\nSo now we have to worry about only odd length palindrome.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow, we make such algorithm which only checks for odd length palindrome and checks if that is prime or not.\\n\\nThis question also teaches us how to print all odd length palindrome efficiently.\\n\\nBrute way would be to iterate over all possibilities and check if it is odd or not. \\n\\nThe optimised solution to get only odd length palindrome is by making odd length palindrome.\\n\\nNow we need to see that the answer lies between $[2,2*10^8]$. \\n200000000 ---It is of length 9.\\nSo the palindrome will be abcdedcba.\\nSo, if we iterate over all abcde, we can make a corresponding palindrome and it will be a odd length too.\\nSo by just iterating over abcde, i.e. 10^5. We can create all palindromes less than $2*10^8$ without iteration.\\n\\n# Individual Complexity\\n- Time complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere \\ni will be $1<=i<=1e5$\\nI checked time complexities of the inbuilt functions also ans \\nto_string(i)-------------------->$O(log(i))$\\nas there are $log(i)$ digits in integer $i$\\nreverse(s.begin(),s.end())-----> $O(log(i))$\\nstoi(s)-------------------------> $O(2*(log(i))-1)$ \\nas the total length will $log(i)+log(i)-1$\\nisprime(x)---------------------> $O(sqrt(x))$\\n\\n# Overall  Complexity\\nTime complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3499365,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\\n\\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359291,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1>Check if n is a palindrome. If it is, check if it is a prime number. If it is, return n.\\n2>Otherwise, increment n by 1 and repeat step 1 until a palindrome prime is found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm depends on the number of steps it takes to find a palindrome prime greater than or equal to n. The worst-case scenario is when n is a large prime number and the next palindrome prime is much large.\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(1) .\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056719,
                "title": "intuitive-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783372,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416992,
                "title": "python-very-fast-solution",
                "content": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283352,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216347,
                "title": "c-8-12-ms-with-5-8-5-9-mb",
                "content": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }\\n\\n        // Search until the prime palindrome is returned\\n        while(true)\\n        {         \\n            // Reset the mirrored nmb\\n            mirroredNmb = 0;\\n            // Set the current number which is to be checked if it\\'s palindrome\\n            temp = n;\\n\\n            // While there are digits to read...store them in mirroredNmb\\n            do\\n            {\\n                mirroredNmb = mirroredNmb * 10 + temp % 10;\\n                temp /= 10;\\n            }while(temp > 0);\\n            \\n            // Check if it\\'s a palindrome\\n            if(mirroredNmb == n)\\n            {\\n                // Store the limit to which the number the palindrome number can be checked if prime\\n                temp = sqrt(n);\\n                for(x=2;x<=temp;++x)\\n                {\\n                    // In case this is true then this number is not prime\\n                    if((n % x) == 0)\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                // If the iterator has gone above the limit then this is a prime\\n                if(x > temp)\\n                {\\n                    return n;    \\n                }                    \\n            }\\n            \\n            ++n;\\n            \\n            // After some time in which I couldn\\'t get it why the solution is not accepted...I\\'ve read their \\n\\t\\t\\t// solution and saw that in this interval there are no prime palindromes....\\n            // Therefore, set it to the next palindrome prime number :) All this I see it more like a hack...but whatevs\\n            if(n >= 10000000 && n <= 100000000)\\n            {\\n                n = 100030001;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1178225,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n1. \\u8D28\\u6570\\u7684\\u68C0\\u67E5\\uFF0C\\u53EA\\u68C0\\u67E5\\u4ECE2\\u5230sqrt(x)\\uFF0C\\u4F1A\\u4E0D\\u4F1A\\u6709\\u53EF\\u4EE5\\u6574\\u9664x\\u7684\\u6570\\u5B58\\u5728\\uFF0C\\u56E0\\u4E3A\\u540E\\u4E00\\u534A\\u80AF\\u5B9A\\u4E0D\\u4F1A\\uFF1B\\n2. \\u53EA\\u68C0\\u67E5\\u957F\\u5EA6\\u662F\\u5947\\u6570\\u7684\\u56DE\\u6587\\u6570\\uFF0C\\u56E0\\u4E3A\\u957F\\u5EA6\\u662F\\u5076\\u6570\\u7684\\u56DE\\u6587\\u6570\\u4E00\\u5B9A\\u4F1A\\u88AB11\\u6574\\u9664\\uFF1B\\n3. \\u7279\\u6B8A\\u60C5\\u51B5\\uFF1A\\u5728[8, 11]\\u8303\\u56F4\\u5185\\uFF0C\\u8FD4\\u56DE11\\uFF1B\\n4. \\u91C7\\u7528\\u5148\\u62FC\\u63A5\\u51FA\\u56DE\\u6587\\u6570\\uFF0C\\u518D\\u5224\\u65AD\\u662F\\u5426\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u4E0D\\u5C0F\\u4E8EN\\u4E14\\u662F\\u8D28\\u6570\\u3002",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845960,
                "title": "prime-palindrome",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 707393,
                "title": "python3-check-next-palindrome-prime-palindrome",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706379,
                "title": "866-prime-palindrome-c-innovative-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662232,
                "title": "python3-cheating-solution-there-s-only-782-prime-palindromes-less-than-100030002",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464397,
                "title": "ultra-fast-solution-beat-99-no-string-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421006,
                "title": "java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tN++;\\n\\t\\t\\t\\tif (10_000_000 < N && N < 100_000_000)\\n\\t\\t\\t\\t\\tN = 100_000_000;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean checkPalindrome(int N) {\\n\\t\\t\\tchar[] arr = Integer.toString(N).toCharArray();\\n\\t\\t\\tint len = arr.length;\\n\\t\\t\\tint i;\\n\\t\\t\\tint j;\\n\\t\\t\\tint mid = len / 2;\\n\\t\\t\\tif (len % 2 == 0) {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\twhile (i < j && i >= 0) {\\n\\t\\t\\t\\tif (arr[i--] != arr[j++]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// public int reverse(int x) {\\n\\t\\t//     int rev= 0;\\n\\t\\t//     while( x > 0){\\n\\t\\t//         rev= rev * 10 + x % 10;\\n\\t\\t//         x= x / 10;\\n\\t\\t//     }\\n\\t\\t//     return rev;\\n\\t\\t// }\\n\\n\\t\\tpublic boolean checkPrime(int N) {\\n\\t\\t\\tboolean flag = true;\\n\\t\\t\\tif (N < 2) return false;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i = 2; i <= (int)Math.sqrt(N); i++) {\\n\\t\\t\\t\\t\\tif (N % i == 0) {\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn flag;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 407131,
                "title": "python-faster-than-99-22-and-memory-usage-less-than-100-00",
                "content": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395539,
                "title": "o-lgn-solution-joke",
                "content": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243195,
                "title": "20ms-c-solution",
                "content": "1. find the first palindrome number by N++;\\n2. return if prime, or generate the next palindrome\\n\\nhere is the way to generate number:\\n1. start from the inner position, like number `3` in `123321` and `12321`;\\n2. if the number<9, add it, like `123321` -> `124421` or `12321` -> `12421`;\\n3. find < 9 number, like `2` in  `12999921`and add it, remember calculate the step careful\\n4. if all is 9, like `9999`, just add `2` and get `10001`\\n\\nthe following is my code\\n```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208246,
                "title": "c-20-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 146770,
                "title": "java-clear-solution-46ms",
                "content": "find the next Palindrome and check whether it\\'s Prime or not\\n\\nI find the next Palindrome code in https://stackoverflow.com/questions/7934519/a-better-algorithm-to-find-the-next-palindrome-of-a-number-string\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104344,
                "title": "c-fast-no-table-lookup-reduce-search-space",
                "content": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050066,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981167,
                "title": "python-solution",
                "content": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n\\t\\t3.since constriant of n is 10^8 .return 100030001 if n>=9989900",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```",
                "codeTag": "Python3"
            },
            {
                "id": 3969487,
                "title": "golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Whatever lee215 said. Truly the legend of this website.](https://leetcode.com/problems/prime-palindrome/solutions/146798/java-c-python-all-even-length-palindrome-are-divisible-by-11/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942893,
                "title": "python-100-light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928627,
                "title": "c-solution-using-basic-loops",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914488,
                "title": "by-prodonik-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888084,
                "title": "fastest-python-solution-using-a-bit-of-number-theory",
                "content": "# Intuition\\nThe difficulty with this problem was essentially to find a number that was both palindrome and prime. At this point I decided to divide the problem into 3 functions: one to form the palindrome number closest to n, one to create palindrome numbers that are bigger and closer to other palindromic numbers that have odd digits (to find out why I\\'ll write it later) and one to verify that they were prime numbers.\\n\\n# Approach\\nFirst I created a function which, taking n, returned a palindromic number that was the palindromic number immediately before n or immediately after. To do it was simple: I took the first half of the digits of n and flipped them to create a number. (it is not difficult to prove that this number is the largest but smallest palindrome with to n or the smallest but largest respect to n). This function is the def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)#Divisibility_tests). To create the next palindrome with odd digits it takes the middle digit and it increases it by 1. if the middle digit becames 10 though, it just increas by 1 the mirror part and the middle digit becames 0. To see if our number is prime we can use a clever trick: for the people who studied a bit of number theory, we know that all the primes number (except 2 and 3), are 1 or 5 (modulo 6), (it\\'s just a fancy way to say that the residue of p/6 is either 1 or 5). So we can just verify that the number is 2 or 3, or not divisible by 2 or 3, and then we can just verify that all the numbers that are 1 or 5 (modulo 6) and that are less or equal to the sqrt(n) of the number, do not divide the number, and we know for sure that the number is prime. \\n# Complexity\\n- Time complexity:\\nUnfortunally, since we are working with primes, we can\\'t know for sure it\\'s time complexity, but we can set a lower bound!: Time complexity >= O(2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869484,
                "title": "next-largest-prime-palindrome-c-did-not-see-another-solution-so-posting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the next palindrome and check if its prime.\\n\\niterate from both sides, if end < start then make end and start index values same since that is a larger number.\\n\\nIf end > start then make them same but pass a carry of 1 left of end index, process carry and check again if its a palindrome. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFind next palindrome and check if its prime. Mostly we need to do some manipulation to find the next smallest palindrome\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nFind palindrome O(Length(num) * 9) = O(Length(num))\\n\\nCheck Palindrome O(Length(num))\\n\\nIsPrime(O(sqrt(num)))\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(Length(n))\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832207,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3809835,
                "title": "typecript-easy-solution",
                "content": "# Code\\n```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794047,
                "title": "easy-and-acceptable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709363,
                "title": "my-c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696111,
                "title": "highly-efficient-concise-solution",
                "content": "# Intuition\\nThe brute-force method is just to check every integer after n. However, very few of these integers are palindromes. If we only check the palindromes, it will be much more efficient.\\n\\n# Approach\\nFor n<=100, we check from a very short list of prime palindromes. Otherwise, we generate palindromes for the bigger n values, and check if they are prime.\\n\\nAn important optimization is that we only need to check palindromes with an odd number of digits. Any palindrome with an even number of digits is a multiple of 11, per divisibility rules. They would all not be prime (except 11).\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694954,
                "title": "java",
                "content": "based on lee\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685475,
                "title": "beginners-friendly-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614274,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607188,
                "title": "2ms-96-39-5mb-73-iterate-only-palindrome-very-detailed-explanation",
                "content": "# Intuition\\nJust need to iterate only palindrome, so \\n1st step: find the bigger nearest palindrome\\n2nd step: generate next palindrome\\n3rd step: check is this palindrome is prime, else repeat from 2nd step\\n\\n# Implementation\\n- just hardcode for n <= 100\\n- Skip all even length palindrome, because its proved to be dividable by 11.\\n\\n\\n**1st Step:**\\n- Split n into left & right side, **example 435679328 (odd length of 9)**, split to **43567(left)** & **9328(right)**\\n- find the bigger nearest palindrome :\\n    **ignore the middle digit, which is 7**, and compare both side, for left side start from behind, for right side start from front:\\n\\ncompare 6 vs 9, if right side(9) is bigger, then increase the middle digit by 1 \\nand the **nearest parlindrom will be**\\nleftSide+1 concatenate reverse of leftSide.substring(0, leftSide.length-1) = \\n(43567+1) concatenate reverse of 4356 =\\n43568 concatenate 6534 = **435686534**\\n\\n**another example 754312609** , ignore the middle digit (1)\\ncompare 3 vs 2, if left side(3) is bigger, \\nthen **the nearest parlindrom will be**\\n75431 + reverse of 7543 = **754313457**\\n\\n**another example 961303782**, ignore the middle digit (0)\\nif both side are equal, compare the next digit\\ncompare 1(left) vs 7(right), if rightSide bigger, increase middle digit and you get the nearest parlindrom, else if leftSide is bigger, just concat leftSide & reverse of leftSide, if they are same again, compare next next digit, and so on... \\n**if all digits are same, then itself is palindrome.**\\n\\n\\n**2nd Step:**\\nOk, now we can start from the nearest palindrome we\\'ve found in step 1.\\nRemember we split number into leftSide and rightSide? But now we only need to increment leftSide by 1 , then it is the next nearest palindrome!! so discard rightSide, its useless now.\\n\\n**Using first example 435686534**, leftSide = 43568, \\nwhile true iteration :\\n\\ncheck if 435686534 is prime? \\nyes -> return;\\nno -> \\n    1. leftSide += 1 (43568 + 1 = 43569)\\n    2. form a new palindrome ( 435696534 )\\n\\nend while\\n\\n***Thats it!!***\\n\\n**Note**: Example n = 990, \\nleftSide = 99, palindrome = 99 concat 9, = 999\\nand when leftSide + 1 (=100)\\nsince we concat leftSide + reverse of leftSide.substring(0, leftSide.length-1), \\n= 100 concat 01 = 10001\\nthat means we are always concatenating evenLength + oddLength OR oddLength + evenLength, so it is always equal to oddLength (skipping evenLength palindrome.)\\n\\n# Complexity\\n- Time complexity:\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566299,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566230,
                "title": "easy-to-understand-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512734,
                "title": "maybe-i-m-just-dumb-well-commented-solution-kind-of-sort-of-cheating-with-the-final-max-num",
                "content": "Picture of my cat to make everything better. \\n\\n![20211003_173451.jpg](https://assets.leetcode.com/users/images/0cadf77c-6d75-419d-83cb-0b445925a599_1683814982.5276306.jpeg)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI figured just creating one list of all the prime-palindromes would reduce re-work, setup the list on solution creation, then all calls to PrimePalindrome(int n) just need to do one lookup in Log(n) time right? \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Sieve of Eratosthenes and an Is Palindrome function to populate our memory cache of valid possible numbers. \\n\\nMy sieveRange is actually incorrect as that\\'s just the range of input N being checked, had to manually add the max possible num to the list as this solution timed out if I increased the range to include that prime palindrome. \\n\\nThat misunderstanding of the range caused a lot of pain debugging. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI should quit to become a sheep herder in the Alps. \\n\\nSieve of Eratosthenes is typically considreed O(n log log n) so final for this solution is something like O(n * (Log(Log(n))) + Log(m)),\\nwhere m is size of the primePalindromes list. and that\\'s ignoring the time of palindrome check, but I\\'m too damn dumb to get this exactly right.\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nShould be something like O(n + m), where n is the sieveRange (for the primes array in the SieveOfEratosthenes function) and m is the size of the primePalindromes\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441070,
                "title": "208-ms",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419172,
                "title": "prime-palindrome",
                "content": "---------------------- Easy C++ Solution -------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339781,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319724,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306862,
                "title": "very-basic-approch-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301385,
                "title": "solution",
                "content": "# Intuition\\nTo solve this problem, we need to find the smallest prime palindrome greater than or equal to a given number n. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n One approach is to start checking numbers from n and incrementing by 1 until we find a number that is both a palindrome and a prime. We can use helper methods to check whether a number is a palindrome and a prime. Another approach is to exploit the patterns in the problem and optimize the algorithm, such as by narrowing down the search space to odd-digit palindromes and skipping even-length palindromes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the input value n and the efficiency of the prime and palindrome checking algorithms. In the worst case, we may need to check all numbers up to 10^8, which would take O(10^8) time. However, with the optimizations mentioned earlier, we reduce the search space and improve the performance. The isPalindrome() method takes O(log n) time, since it checks each digit of the number. The isPrime() method takes O(sqrt(n)) time, since it checks all divisors up to the square root of n. Therefore, the overall time complexity is roughly O(n * sqrt(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1), since we only need to store a few integer variables. The space used by the helper methods is also O(1), since they don\\'t use any additional data structures.\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141927,
                "title": "iterating-over-palindromes-c-runtime-beats-100",
                "content": "# Intuition\\nSome points to note:\\n- Far fewer numbers are palindrome than not\\n- Palindromes can easily be generated from their first half (for palindromes of odd length, including their middle digit)\\n- The numerical order of (odd length) palindromes is equal to the order of their first halves. Therefore, it is easy to iterate over all palindromes in ascending order by iterating over their first halves.\\n\\n# Approach\\n`oddPalindrome` generates an odd-length palindrome from the integer representing its first half (inclunding middle digit) by adding the string representation and its reverse, excluding the duplicate middle digit. \\n`IsPrime` is used to check whether the generated number is a prime number.\\n\\n# Complexity\\n- Time complexity:\\nChecking primeness: $$O(\\\\sqrt{n})$$ \\nFinding prime palindrome: Unknown, as palindromes can not be regarded as random integers and therefore, the density of prime palindromes is not equal to that of primes in general.\\n\\n- Space complexity:\\n$$O(log(n))$$, the extra memory increases with the length of the result in decimal representation.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060479,
                "title": "kotlin-beats-100-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993336,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983531,
                "title": "100-fastest-and-easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965600,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950329,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924931,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891591,
                "title": "java-it-s-easy-solution-but-low-speed-took-it-n-n-from-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831041,
                "title": "o-1-solution",
                "content": "# Intuition\\n##### We know there are pretty limited number of prim numbers in a  range, and palindromes are also rare , so , primepalindrome are even rarer...\\n##### we can just precompute the prime Palindromes and then Find the lowerbound of whatever number is asked in the testcase .\\n##### I have attached program I used to generate the list.\\n\\n# Code\\n```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\\n# This is the code that I used to geneerate the primepalindrome list.\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2710531,
                "title": "easy-java-solution-all-even-length-pallindrome-are-divisble-by-11",
                "content": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }\\n        for(int i = 3;i*i <= n;i++){\\n            if(n % i == 0)\\n               return false;\\n        }\\n        return true;\\n    }\\n    public int primePalindrome(int n) {\\n        if(n >= 8 && n <= 11)\\n            return 11;\\n         for (int i = 1; i < 100000; i++) {\\n            String s = Integer.toString(i);\\n            String r = new StringBuilder(s).reverse().toString(); \\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= n && isPrime(y)) \\n                return y;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2699888,
                "title": "python3-generating-palindromes-neglecting-4-6-8-digit-palindromes-checking-for-prime",
                "content": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}\\n        \\n        while True:\\n            x = nextPalindrome(x)\\n            intX = int(\\'\\'.join(x))\\n            if len(x) not in invalidLengths and intX>=n:\\n                if isPrime(intX):\\n                    return intX",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}",
                "codeTag": "Java"
            },
            {
                "id": 2673013,
                "title": "my-simple-python3-solution",
                "content": "For me, the main insight that fixed the excessive computation time for my code was this line: if 10\\\\**7 < n < 10**8 (which was taken from the formal solution). \\n\\nRuntime: 644 ms  (Beats 15%)\\nMemory : 13.9 MB (Beats 77.14%)\\n\\n# Code\\n```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618816,
                "title": "o-n-time-o-1-space-clear-explanation-only-odd-palindromes",
                "content": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "codeTag": "Python3"
            },
            {
                "id": 2567161,
                "title": "php-solution",
                "content": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519791,
                "title": "c-ispalindrome-and-prime-check-easy",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```\\n**If helpful Please Like Or Upvoke**",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465618,
                "title": "javascript-easy-solution",
                "content": "\\n\\n```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464988,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423771,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326905,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282027,
                "title": "no-math-all-logic-python",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "codeTag": "Java"
            },
            {
                "id": 2259031,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207599,
                "title": "2-different-java-solution",
                "content": "### 68ms runtime.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n### Time Limit Exceeded.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190884,
                "title": "prime-palindrome-java-easy-solution-brute-force",
                "content": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }\\n        for(int i = n;i <= (int)2*Math.pow(10,8);i++){\\n            if(isPrime(i) && isPalindrome(i)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        if (n == 2) {\\n            return true;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPalindrome(int n)\\n    {\\n          \\n        // Find reverse of n\\n        int rev = 0;\\n        for (int i = n; i > 0; i /= 10)\\n            rev = rev * 10 + i % 10;\\n              \\n        // If n and rev are same, \\n        // then n is palindrome\\n        return(n == rev) ? true : false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2161839,
                "title": "javascript-easy-to-understand-explained-in-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111308,
                "title": "javascript-iterate-palindromes-clean-and-simple-code-faster-than-90",
                "content": "High-level explanation:\\n\\n- This is an implementation of the \"iterate palindromes\" solution\\n- At the top level, we will iterate over the number of digits in the palindrome, starting with the number of digits in n (if n = 13, digits = 2, 3, 4, ...)\\n- Inside the loop, we will iterate palindromes (1001, 1111, 1221, ..., 9999). To do this, we generate the first half of the palindrome and double it.\\n- There are special cases depending on whether digits is even or odd (palindrome = 1001, 1111, ... vs palindrome = 10001, 10101, ...)\\n\\n```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045085,
                "title": "c-code-100",
                "content": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980487,
                "title": "python-my-ugly-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1][1:])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1][1:])\\n        else:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1])\\n    \\n    def isPrime(self, n):\\n        if n == 1: return False\\n        for i in range(2, int(sqrt(n))+1):\\n            if n % i == 0:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1930920,
                "title": "c-solution-a-discussion",
                "content": "Well, the multiplicative inverse for 10 (mod 11) is -1, because 1 = 11 * 1 - 10 * 1, \\nwhich means 1 (mod 11) = (0) (mod 11) - 1 * 10 (mod 11)\\nso, 1 = -1 * (10) (mod 11)\\nso, 10^-1 = -1 (#_#)/\\n\\nTherefore, for 8-digit palindrome, the equation of summation of ai(10^(7-i) + 10^i) can be replaced by -1 (mod 11)... skip all those 8-digit palindrome...\\n\\n... and in here, there is a way to check primality:\\n1. if n == 1, not prime\\n2. else if n < 4, prime\\n3. else if n % 2 == 0, not prime...\\n4. else if n < 9, prime\\n5. else if n % 3 == 0, not prime...\\n6. else\\n7. set f as next prime after 2, 3 = 5, upper bound = sqrt(n), while f <= upper bound do,\\n\\t8. if n % f == 0, there exist a factor, nope\\n\\t9. if n % (f + 2) == 0, nope\\n\\t10. f += 6 (so, all the multiples of 2, 3 = ignore)\\n\\nSo, that\\'s it...\\n\\n```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```\\n*Side-notes: I always feel like I cannot do mathy problems, it always sounds like an act of logical thinking only... the ability to connecting the dots, connecting different pieces of information together is important... that means \\'talent\\' right... the faster you can think, more talented you are right... yea, in this regard, I am average (or slightly below average). Nonetheless, I enjoyed my time doing all these stuff        \\\\\\\\(^_^)/*",
                "solutionTags": [],
                "code": "```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921422,
                "title": "python3-brute-force",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1830732,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764561,
                "title": "c-solution-prime-palindrome",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704938,
                "title": "simple-solution-c",
                "content": "# Following is my approach :\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```\\n#  Please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694137,
                "title": "c-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646496,
                "title": "0ms-c-faster-than-100",
                "content": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546567,
                "title": "easy-java-solution",
                "content": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522120,
                "title": "table-generation-concept",
                "content": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488677,
                "title": "python-3-brute-force-math-pruning-explanation",
                "content": "### Explanation\\n- Filtering out palindrome is very simple, but instead of filtering, we need to make up palindrome in order, so that we don\\'t waste on trying definitely useless numbers.\\n\\t- Make sure odd digits palindrome and even digits palindrome are both included.\\n- Other than making up palindrome, we can use **math** to filter values, below are not prime for sure\\n\\t- Have factor `5`: `5xxx5`, `5xx5`, everything start with `5`\\n\\t- Have factor `2`: `2xx2`, `4xx4`, `6xx6`, `8xx8` everything starts with `2, 4, 6, 8`\\n### Implementation\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458153,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345879,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308204,
                "title": "find-next-palindrome",
                "content": "The idea is simple, for given n, we first find a palindrom p greater than n, then we check whether it\\'s prime, if it\\'s a prime, we get the result, otherwise, we find next palindrome greater than p\\n\\nfor example\\n```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(n):\\n            if n<=2 or n&1==0:\\n                return n==2\\n            for i in range(3, int(n**0.5)+1, 2):\\n                if n%i==0:return False\\n            return True\\n        \\n        def nextPalindrome(n):\\n            s = str(n)\\n            l = len(s)\\n            if n < 10:\\n                return n+1\\n            # 123 12+1 ->131\\n\\t\\t\\t# if left half is smaller than right half, increase left help by one\\n            if s[:l//2]<=s[(l+1)//2:]:\\n                head = str(int(s[:(l+1)//2])+1)\\n            else:\\n                head = s[:(l+1)//2]\\n            ans = head+head[:l//2][::-1]\\n\\t\\t\\t# if the palindrom is the same, increase left halp by 1\\n            if ans==str(n):\\n                head = str(int(s[:(l+1)//2])+1)\\n                ans = head+head[:l//2][::-1]\\n            return int(ans)\\n\\t\\t# in case N is already a result, we start with N-1\\n        n = N-1\\n        while True:\\n            p = nextPalindrome(n)\\n            if isPrime(p):\\n                return p\\n            else:\\n                n = p\\n",
                "solutionTags": [],
                "code": "```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306489,
                "title": "js-faster-than-98",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238364,
                "title": "javascript-faster-than-100",
                "content": "Although the memory efficiency could be better, but the speed was very good. Here it is. If there is any room for improvement, please comment below\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174370,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161034,
                "title": "python3-easy-solution-with-explanation-and-comments-100-faster",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1158279,
                "title": "swift-236ms",
                "content": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146586,
                "title": "c-without-generating-prime-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136411,
                "title": "simplest-algorithm-but-without-primes-generator",
                "content": "it\\'s working on small range of numbers but i need to complete it with primes generator that got accepted without run time error\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046663,
                "title": "swift-solution-with-comments",
                "content": "According to one of the 11\\'s divisibility rule, form the alternating sum of the digits.\\nIf the result can be divisible by 11, the original number must be 11\\'s multiple. \\nex. 2486 => 2 - 4 + 8 - 6 = 0 * 11\\n\\nSo we can know: **any palindrome with even number of digits must be divisible by 11**\\nex. abba => a - b + b - a = 0 * 11\\n\\nThat is, any palindrome with even number of digits is not a prime. Then we can skip them.\\n\\n```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037653,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028591,
                "title": "java-solution-with-comments",
                "content": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011850,
                "title": "go",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995044,
                "title": "python3-find-palindromes-first-and-then-check-if-it-s-prime",
                "content": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990925,
                "title": "time-limit-exceeded",
                "content": "The following code runs fine in my pc with build time of around 700-900ms but leetcode says time limit exceeded.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886996,
                "title": "fermat-s-little-theorem-and-euler-theorem",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881250,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868157,
                "title": "python-creating-palindrome-list",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803639,
                "title": "go-0ms-solution",
                "content": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792259,
                "title": "get-the-set-of-palindromes-first-and-filter-out-non-prime-and-smaller-ones",
                "content": "With one optimization that cuts the search space by removing the even palindrome\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774233,
                "title": "go-100-8ms",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770493,
                "title": "c-solution-using-next-palindrome-method",
                "content": "Idea is to generate the next smallest palindrome in O(length(N)) time and then check if it is a prime number or not.\\n\\n```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 748585,
                "title": "scalable-and-comprehensible-solution-in-python-construct-palindrome",
                "content": "This solution is constructing palindrome, checking whether it is prime, and tail recurse with 1 more digit. Skip numbers with even digits, because lee215 proved that all palindrome with even length is multiple of 11. This is scalable when the number larger than 10 ** 8, as it iterate only on palindromes.\\n\\n```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744904,
                "title": "standard-java-solution",
                "content": "### Theory\\nSo apparently for some reason we can exclude 8 digit numbers. We can start from N, and scan our way up to a valid palindrome. Its important we check for palindrome competency first, vs doing the heavy lifting to determine if the candidate number is prime.\\n\\n### Solution\\n```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 730083,
                "title": "rust-translated",
                "content": "Runtime: 24 ms, faster than 100.00% of Rust online submissions for Prime Palindrome.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Prime Palindrome.\\n\\n```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726410,
                "title": "solution-based-on-mapping-numbers-to-odd-and-even-length-palindromes",
                "content": "Every number can be used to construct two palindromes.\\n\\n1. Odd-length palindrome by concating the sequence of digits in the number with the reverse of the digits in the quotient from dividing the number by 10, e.g., \"897\" + \"98\" = \"89798\"\\n2. Even-length palindrome by concating the sequence of digits in the number with the reverse of the same sequence, e.g., \"897\" + \"798\" = \"897798\".\\n\\nThe special cases can help simplify the logic in the main loop.\\n\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698063,
                "title": "bruteforce-approach",
                "content": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }\\n        return temp;\\n    }\\n    bool isPrime(int N){\\n        if(N<2) return false;\\n        for(int i=2;i*i<=N;i++){\\n            if(N%i==0) return false; \\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int N){\\n        long long int ans=0;\\n        int p=N;\\n        if(N<10) return true;\\n        while(N>0){\\n            int rem=N%10;\\n            ans=ans*10+rem;\\n                N=N/10;\\n        }\\n        if(p==ans) return true;\\n            else return false;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        while(true){\\n            if(N>=8 && N<=11) return 11;\\n        if(isPrime(N)&&isPalindrome(N)){\\n            return N;\\n        }\\n        int count=digit_count(N);\\n            if(count & 1){\\n                N++;\\n            }\\n            else{\\n                N=pow(10,count)+1;\\n            }\\n        \\n    }\\n        return N;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 683142,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 681686,
                "title": "pre-calculated-all-the-palindromes-in-a-list",
                "content": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643102,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621473,
                "title": "cheap-solution-faster-than-100-and-less-memory-than-100-python-3",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 587818,
                "title": "ultra-simple-c-solution-suggestions-for-optimization-are-welcomed-100",
                "content": "Runtime: 884 ms, faster than 100.00% of C online submissions \\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions\\n\\n```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578941,
                "title": "c-solution-faster-than-89-and-space-less-than-100",
                "content": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553261,
                "title": "faster-than-81-50-of-java-online-submissions",
                "content": "# Runtime: 29 ms, faster than 81.50% of Java online submissions for Prime Palindrome.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537994,
                "title": "this-is-an-tricky-question-not-good-for-interview",
                "content": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nRef: https://leetcode.com/problems/prime-palindrome/discuss/146798/JavaC%2B%2BPython-All-Even-Length-Palindrome-are-Divisible-by-11\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518737,
                "title": "solution-c-faster-than-66-and-space-less-than-100",
                "content": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 513998,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484821,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468244,
                "title": "python-recursive-method",
                "content": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 457047,
                "title": "go-build-odd-length-prime-solution",
                "content": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442570,
                "title": "c-first-palindrome-next-palindrome",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1907331,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1868032,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 2069858,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1926163,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            }
        ]
    }
]