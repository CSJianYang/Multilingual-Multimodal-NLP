[
    {
        "title": "Maximum Number of Accepted Invitations",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565900,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1567034,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 2060758,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1810428,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Customers With Positive Revenue this Year",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1942842,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1712159,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1990853,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sign of the Product of an Array",
        "question_content": "<p>There is a function <code>signFunc(x)</code> that returns:</p>\n\n<ul>\n\t<li><code>1</code> if <code>x</code> is positive.</li>\n\t<li><code>-1</code> if <code>x</code> is negative.</li>\n\t<li><code>0</code> if <code>x</code> is equal to <code>0</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code>. Let <code>product</code> be the product of all values in the array <code>nums</code>.</p>\n\n<p>Return <code>signFunc(product)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The product of all values in the array is 144, and signFunc(144) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,0,2,-3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The product of all values in the array is 0, and signFunc(0) = 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,1,-1,1,-1]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The product of all values in the array is -1, and signFunc(-1) = -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152555,
                "title": "java-solution-0-ms-seriously-why-we-need-2",
                "content": "We should just need to flip the count whenever encounter a negative number \\n```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476080,
                "title": "c-easy-approach-explained",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- ##### The problem asks us to determine the sign of the product of all the numbers in the given array. To solve this problem, we need to consider the following cases:\\n    1. ##### If the product of all the numbers is positive, the sign is 1.\\n    1. ##### If the product of all the numbers is negative, the sign is -1.\\n    1. ##### If the product of all the numbers is zero, the sign is 0.\\n- ##### To compute the product of all the numbers in the array, we can iterate over the array and count the total negative numbers. We can initialize the cnt as 0 and then update it at each step of the iteration.\\n- ##### At any index, if number is 0, simply return 0.\\n- ##### Once we have computed the product, we can determine the sign of the product using an if-else statement. If the cnt is odd, the sign is -1. If the cnt is even, the sign is 1.\\n\\n- ##### Therefore, we can write a function that takes an array as input, computes the count of negative numbers in the array, and returns the sign of the product.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152412,
                "title": "python3-line-sweep",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168505,
                "title": "c-simple-easy-code",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152450,
                "title": "java-2-straightforward-solutions",
                "content": "We only care about 0 and the occurence of negative numbers in the array. No need to calculate the final product.\\n```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\\n\\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475407,
                "title": "java-simple-math-beats-100-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837393,
                "title": "why-to-multiply-neat-and-simple-solution-o-n-72-ms",
                "content": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162480,
                "title": "easy-to-understand-and-implement-c-solution",
                "content": "**Intuition: why idea of finding product does not work:**\\nConsider this code:\\n```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\\nThis code passes successfully for small test cases where the input is small. Larger size of array can lead to Runtime Error:\\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\\n\\nSo a better solution would be to check if any of the element in the array is a zero. If yes, then return 0, If no, then count how many negative numbers are there. If their count is even, then return 1, else return 0.\\n\\n**Code for the same:**\\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```\\n**Time complexity: O(N)\\nSpace Complexity: O(1)**\\n\\nDo upvote this solution if it helped you. \\nPeace :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891235,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155733,
                "title": "python-multiple-solutions-tracking-sign-lazy-evaluation-branchless-and-one-liners",
                "content": "Using a loop, terminate early if a zero is encountered. Otherwise, invert the sign each time a negative value is encountered. This is the optimal solution in terms of complexity with O(N) ***in the worst case***.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\\nHowever, since we are using python, it is sometimes just as fast or faster to compute a list product if done correctly, even though computing the list product has complexity O(N) even if `nums` contains zeros. The best way to do this is to trade lazy evaluation in pure python for the blazing speed of functions pre-compiled in `Standard C`.\\n\\nWe can use `math.prod` to do this\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\\n\\nThe walrus assignment operator (`:=`) in `Python 3.8+` allows us to do this in one-line\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnother built-in way to compute list products is to use `functools.reduce` with the `mul` operator\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nUse can also define your own multiplication operator to use with `reduce` using lambdas\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnd finally, we can use a `generator comprehension` inside whichever list product method you like.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1153639,
                "title": "java-2-methods",
                "content": "**METHOD1:**\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\\n\\n**Method2:**\\nwe can see that answer is going to be 1,-1 or 0 .\\nwe just need to flip values when we encountered a negative value.\\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```\\n\\nComplexity:\\n`Time:O(n) and Space:O(1)` in both methods\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476195,
                "title": "java-100-faster-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to only predict the sign of the product of all the element in the array.\\n1. If we found 0 return 0 because anything one multipled to 0 will be 0 only.\\n2. Initalize a counter and count the total negative element present in the array.\\n3. If negative count is mutliple of 2 then the product output will be positive number so retrun 1.\\n4. If negative count is not a mutliple of 2 then the product output will be negative number so retrun 0.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475758,
                "title": "c-easy-2-methods-100-beat",
                "content": "# Intuition\\nWe neet to determine the number of postive number , Negative Number , or is there any Zero or not.\\n\\nMutiply as given in quetion\\n-> 1 if x is positive.\\n-> -1 if x is negative.\\n-> 0 if x is equal to 0.\\n\\nIf we have Zero in a array, then product will be zero no matter other Number , because 0*(any number) = 0\\n\\n# Approach 1\\nLet\\'s Count the Number of postive Number or Negativer number\\n\\nif there is any zero in array answer will be 0\\nif negative number is odd answer will be -1\\nif negative numbers are even answer be 1\\nEX \\n`-1*-1 = 1`\\n`-1*-1*-1 = 1`\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# code 1\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2\\nLet\\'s go dynamically \\n\\nif we found postive number multiply answer with 1 or leave as it is\\n\\nif we found 0 directly return 0\\n\\nif we found negetive multiply with -1\\n\\nfinally return our answer\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475335,
                "title": "check-the-sign-explained",
                "content": "The first thought probably is just to simulate it by calculating the product of `nums` and check the sign like what problem statement says. However, We don\\'t need to do that since we are not interested in the value but the sign. Therefore, we can just check the sign only. If we meet a zero, we can exit early since the final sign must be 0 anyway.\\n\\n<iframe src=\"https://leetcode.com/playground/fZuQh2vv/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nYou may notice that when the number is positive, basically it won\\'t change the sign. Hence, we can just focus on negative numbers and flip the sign when we meet one. Zero case remain unchanged.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Rust"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630408,
                "title": "simple-approach-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152626,
                "title": "python-two-solutions-functional-programming-and-tracking-negatives",
                "content": "Calculate the product using reduce and return the sign.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\\n\\nIf we encounter a 0, we can return immediately. Otherwise keep track of the negatives. If the count of negatives is odd, the product is negative. If the count of negatives is even, the product is positive.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3502314,
                "title": "best-solution-by-java-in-runtime-8ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/7f2e544c-bd28-4f74-9a69-02531ffef3a6_1683577246.8802.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476201,
                "title": "beat-98-in-javascript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou have initial state which is positive. Iterate through the array. \\n- Ignore all positive numbers\\n- When you see 0, immediately return 0\\n- If it is negative, swap the sign of the state  \\n\\n# Complexity\\n- Time complexity: O(N) in the worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750264,
                "title": "0ms-solution-with-explanation-c",
                "content": "This question was a bit tricky. At first I tried multiplying all the numbers in array to get product and then decide whether it\\'s positive or negative or it\\'s 0. But I got integer overflow error which probably could have been mitigated by $$long$$ or $$long$$ $$long$$ data types, but we have a better idea\\uD83D\\uDCA1\\n\\nLet\\'s multiply product by 1 if the element is positve instead of the whole number & -1 in case it\\'s negative. If it\\'s zero, we return 0.\\n\\nAnd then finally we will return product after this repetitive process. This saved us from the tedioud operation of multiplying the whole number and then storing it.. and as a result we get a much shorter runtime and better space complexity!\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```\\n\\n## if this explanation helped you please leave a upvote on this solution\\n\\n## Visit my GitHub: https://github.com/crimsonKn1ght\\n\\n## Happy coding \\uD83D\\uDE00",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194388,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152482,
                "title": "python-one-pass",
                "content": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086766,
                "title": "2023-fastest-solution-java-easy-to-understand",
                "content": "\\t* class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }else if(num==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\treturn product;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2752360,
                "title": "simple-python3-solution-0-n-time-0-1-space",
                "content": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402614,
                "title": "python-easy-solution",
                "content": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3476495,
                "title": "easily-understandable-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499851,
                "title": "solution-using-xor-and-only-a-bool-for-memory",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155462,
                "title": "c",
                "content": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152978,
                "title": "rust-fp-solution",
                "content": "Thanks to **rudy_** for help with shortest solution!\\n\\n```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477379,
                "title": "easy-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The input to the method arraySign is an array of integers called nums. The goal of the method is to return the sign of the product of all the elements in the array.\\n\\n- The method **signFunc** is called with **nums** as an argument. This method computes the sign of the product of all the elements in the array.\\n\\n- The variable **count** is initialized to 0. This variable will be used to count the number of negative elements in the array.\\n\\n- The loop **for(int i:nums)** iterates over all the elements in the array. For each element, if it is equal to 0, the method immediately returns 0 because the product of any number and 0 is 0.\\n\\n- If the element is negative (i.e., less than 0), the variable count is incremented by 1.\\n\\n- After the loop, the method checks whether the count of negative elements is even or odd. If it is even, the method returns 1 because the product of an even number of negative numbers is positive. If it is odd, the method returns -1 because the product of an odd number of negative numbers is negative.\\n\\n- Finally, the arraySign method returns the value returned by **signFunc**.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided arraySign method is O(n), where n is the length of the input array nums. This is because the method iterates over each element in the array exactly once.\\n- Space complexity:\\nThe space complexity of the method is O(1), because it only uses a constant amount of extra space to store the count variable. No additional data structures are used that depend on the size of the input array\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475342,
                "title": "simplest-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475334,
                "title": "daily-leetcoding-challenge-may-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Counting Negative Numbers\n\n  \n**Approach 2:** Tracking the Sign of the Product\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2789676,
                "title": "sign-of-the-product-of-an-array-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078722,
                "title": "sign-of-the-product-of-an-array-python-solution",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159862,
                "title": "sign-of-the-product-of-an-array-c-solution-explained-easy-to-understand",
                "content": "As  said that if the product of all the array element will negative than return -1, if the product will positive return 1 otherwise product is zero return 0. \\nthis is very easy we did not need to calculate the product of all array element just calculate how may negative value is there if total number of -ve value is even then product will surelly positive otherwise negative. if a single zero is present then only the product will zero.\\n\\nso  we calculate number of negative values and any zero if present.\\nby doing this we can reduse the time comlexity.\\nif we go to calculate product than there may be large value which generate some error.\\nso this method is very good use.\\n\\nif you understand upvote.\\n```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159844,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "[1822. Sign of the Product of an Array](https://leetcode.com/problems/sign-of-the-product-of-an-array/)\\n\\n\\nThe idea of this solution is elementary:\\n\\n* If the current number in `nums` is negative, then we can flip the sign\\n* If the current number in `nums` is equal to `0`, we can return `0` because any number multiplied by `0` is `0`. You might think that we can check for `if num == 0` after we have iterated, but that won\\'t work because we only switch the sign and don\\'t multiply by `0`, so we will never know whether there is a `0` in the array.\\n\\n``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152447,
                "title": "javascript-one-line-solution",
                "content": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476912,
                "title": "c-java-python-runtime-0-ms-beats-100-daily-leetcode-solution",
                "content": "# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476400,
                "title": "without-multiplication-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349017,
                "title": "beats-100-0-ms-very-easy-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## please Upvote..........................\\n```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159651,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054546,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513150,
                "title": "c-most-optimized-easy-to-understand",
                "content": "If element 0 found than return 0;\\nkeep a track for negative element \\nif negative elements are odd return -1\\nelse return 1;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477536,
                "title": "problem-of-the-day-very-easy-solution-best-approach",
                "content": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }\\n        \\n\\t\\t// if negative numbers are not even the result will be negative hence -1\\n\\t\\t\\n        if(neg % 2 != 0)\\n            return -1;\\n        \\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3477458,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477170,
                "title": "c-solution-easy-faster",
                "content": "# Intuition\\nIf you go on to multiply each value and check the answer at last then checking the constraints you will get a overflow error for sure.\\n\\nWe have to find a solution without computing the entire values.\\n\\n# Approach\\nFirst sort the entire vector and the ittitare till you find a positive or 0. Keep counting the number of occurances of negative values, if you encounter a zero then directly return 0 otherwise if count of negative is even then return 1 or else return -1.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475980,
                "title": "1-liner-using-reduce-method",
                "content": "# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3475396,
                "title": "2-liner-cool-clean-code-fast-efficient-c",
                "content": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475377,
                "title": "swift-good-interview-answer",
                "content": "**Good Interview Answer (accepted answer)**\\n\\nThis is good interview answer because:\\n1) It is simple, clear and concise. (One pass through the array, not a fancy sort + binary search, etc..)\\n2) Doesn\\'t use Multiplication (in theory faster)\\n3) Doesn\\'t use `.reduce()`, so can short-circuit at the first zero (faster).\\n\\nNote: Problem doesn\\'t state what to return for an empty array. Given constraints state that the array always has more than one element, but this would be a good followup with your interviewer to ask to remove the constraint and handle accordingly (return zero, throw, etc).\\n\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475346,
                "title": "solutions-in-c-python-and-java-look-at-once",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2996375,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the count of negative numbers. If the count is even , that means all the minus signs will cancel out each other and product will be postive otherwise negative.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly, if any number is 0 then product will be 0 so check for that first and no need to proceed further as we already encountered 0 final answer will also be 0 only.\\nthen, \\nIf count(negativeNumbers) is even, then return 1 otherwise return -1.\\n# Complexity\\n- Time complexity : O(N)\\n- Space complexity : O(1) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835158,
                "title": "java-easiest-solution-using-only-if-and-else",
                "content": "# Approach\\nCount the number of **negative integer**, if number of count is **divisible by 2 **that means it will be a ****positive value**** so the answer is going to be 1, if the number of count is** not divisibleby 2 **that means it will be a **negative number**. and if the array contains any 0 so the product is ultimately going to 0,so the answer is 0. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456697,
                "title": "python-solution-faster-than-95-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058671,
                "title": "naive-solution",
                "content": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1940922,
                "title": "python-3-lines-of-code-faster-than-96",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "codeTag": "Java"
            },
            {
                "id": 1484036,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463239,
                "title": "ruby-oneliner",
                "content": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3478304,
                "title": "java-solution-for-sign-of-the-product-of-an-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n The intuition behind this approach is that the sign of the product of an array of numbers is determined by the number of negative elements in the array. If the number of negative elements is even, the product is positive, otherwise, it is negative. If there is a zero in the array, then the product is zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis implementation counts the number of negative integers in the input array. If the count is even, the product of all numbers is positive, and signFunc() returns 1. If the count is odd, the product of all numbers is negative, and signFunc() returns -1. If the input array contains a zero, the product is zero, and signFunc() returns 0. This approach works well even for large length of nums.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses a constant amount of space to store the count of negative elements, so the space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477311,
                "title": "fastest-way-to-solve-this-question-beats-100",
                "content": "# What question says\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is a function signFunc(x) that returns:\\n\\n1 if x is positive.\\n-1 if x is negative.\\n0 if x is equal to 0.\\n\\nYou are given an integer array nums. Let product be the product of all values in the array nums.\\n\\n# Approach\\n\\n1. The arraySign method takes an integer array nums as input.\\n\\n2. The method initializes the product variable to 1, which represents a positive product.\\n\\n3. The loop iterates over each element num of the input array nums.\\n\\n4. If the current element num is equal to 0, then the method immediately returns 0, since the product of the array will also be 0.\\n\\n5. If the current element num is negative (num < 0), then the product variable is multiplied by -1, which effectively flips the sign of the product to negative.\\n\\n6. After the loop has finished iterating over all the elements, the method returns the value of product.\\n\\n7. If product is positive, the method returns 1, which represents a positive product.\\n\\n8. If product is negative, the method returns -1, which represents a negative product.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477050,
                "title": "easy-js-one-liner",
                "content": "# Code\\n```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476507,
                "title": "detailed-analysis-and-explanation-for-3-approach-in-python-with-time-comparison",
                "content": "## Simple approach but contains explanation to why I wrote what I wrote!\\nClearly, you cannot multiply each element and then return the sign of the product. This is not feasible as we will be storing large size of data.\\n\\n`Check the execution time for each approach in Python at the end of 3 python approaches`\\n# Code in Python: Approach 1\\n\\n1. Given that we have to `return 0` when we find a \\'0\\', simply put in a condition in the loop for this.\\n2. Initialize `sign` to 1 and if you find a **neg**ative **num**ber, **flip the sign**\\n3. Return the `sign` at the end.\\n``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\\n# Code in Python: Approach 2\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `sign=1`.\\n3. For each element, set `sign *= element//abs(element)`\\n\\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\\n# Code in Python: Approach 3\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `countOfNegatives=0`.\\n3. For each **neg**ative **ele**ment, set `countOfNegatives += 1`.\\n4. After the loop, **return 1** if `countOfNegatives % 2 == 0`. This means that there are even number of negatives.\\n**(-1)<sup>2*n</sup> = 1**\\n5. Else, return -1\\n**(-1)<sup>2*n+1</sup> = -1**\\n\\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\\n<br>\\n\\n# Comparing Python execution time using timeit (in ms)\\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\\n\\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\\n\\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\\n---\\n\\n# Code in C\\n1. Use an **int** **var**iable for `sign` and initialize to 1.\\n2. When you find a negative number, **flip the sign**.\\n3. At the end, return the `sign`.\\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```\\n\\n### Please consider upvoting if you liked it or comment if you have a better alternative! Thank you!",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476425,
                "title": "two-approach-without-product-and-with-product-c-beats-100",
                "content": "# Intuition\\nFirst Approach-01:\\nIn this we create a `signFunc` as stated in the question \\nThen We simply do the product of all elements in vector and then pass it to the `signFunc` \\nMain trick to this Question is **Modulo operator**\\nAs the product will exceed the int or long long Range so to overcome that we have to use a number to limit the product and to limit a number so that it dont cross a specific range we use Modulo operator \\n\\nThe task is to determine which number we can take as the upper limit\\nSo for that we will go for 1e9+7 (i.e. 1000000007) as it is the highest prime number close to the range of int data type.\\n*P.S. you can google it to know more about it *\\n\\nSecond Approach-02:(**Easy and Brainer way**)\\nIn this method we are counting the no. of negative elements and if we found a zero we will return the 0\\n\\nif we dont then we simply check the count of negative number,\\nif count is multiple of two then the resultant product will always be a positive number \\nelse it will be a negative number\\n\\n\\n\\n# Approach-01-Code\\n```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\\n# Approach-02-Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476268,
                "title": "o-n-solution-java-python-easy-explained",
                "content": "# Intuition\\n- if any one is 0 all will get 0 \\n- if count of neg is even they will cancel each of them we will get positive \\n- if count of neg is odd it will be negative \\n\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\\n# Java \\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```\\n# Complexity \\n- TC: O(n)\\n- SC: O(1)",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475884,
                "title": "python-shortest-1-liner-functional-programming",
                "content": "# Approach\\n1. Let `sign` be a function that returns `1` for positive numbers, `-1` for negative, and `0` for zero. We can define this as:\\n`sign = lambda x: (x > 0) - (x < 0)`\\n\\n2. Apply `sign` to each number in `nums`.\\n\\n3. Return the product of the signs.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475742,
                "title": "easy-java-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475616,
                "title": "java-solutions-easy-to-understand-100",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475415,
                "title": "easy-java-solution-using-iteration-beginner-friendly",
                "content": "# Intuition\\nIn Multiplciation\\n1. If any element is 0, multiplication is 0\\n2. if number if negative element are odd, multiplication is negative\\n3. multiplication is positive in other case\\n\\n# Approach\\n1. Count number of negative elements\\n2. If you see 0 while traversing, return 0 immediately\\n3. At the end if number of negative numbers is odd, return -1 else return 1 \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475402,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274865,
                "title": "c-2-solutions-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/7990c4ba-a757-4a76-9eed-0d4cba0b8b5c_1678339994.0675652.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266151,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**, we can track the **sign** of the product without actually make the operation.  \\n\\n*At each iteration* we have to do three operations:\\n1) If the **number is zero**, `return 0` this because the product of every number with zero is zero;\\n2) If the **number is negative**, change the sign of the result;\\n3) If the **number is positive** go to the next iteration, this case does not change the sign of the result.\\n\\n**Note:** Is important *to not make the operation* because the product of lots of high numbers can generate an **overflow** (this happen when the operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits).\\n\\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 74.72%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226033,
                "title": "brute-force-but-beginner-friendly-code-c-62-69-beats",
                "content": "# Intuition\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/ff5c7348-6a3c-4428-886c-5682f8b40092_1678369404.0709472.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128152,
                "title": "simple-javascript-solution-using-reduce-method-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068013,
                "title": "simple-solution-with-explanation-on-swift",
                "content": "# Explanation\\n1. Check if nums array contains zero. __0 * n = 0__\\n2. Find how many negative numbers in array\\n3. if its even: __-2 * -2 = 4__. So result will be 1.\\n4. if its odd: __-2 * -2 * -1 = -4__. In this way result will be -1.\\n# Code\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```\\n### Please upvote if my solution was helpful to you!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926532,
                "title": "superb-logic-in-python3-java-golang",
                "content": "# 1. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\\n# 2. Golang Solution \\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\\n# 3. Java Solution\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\\n# 4. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761996,
                "title": "fully-explained-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will maintain a counter to calculate the negative values in the array.\\nIf the counter got the even value after traversing the whole array, it means the product of all array elements will be positive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the array, \\nIf any element in the array appears to be 0, simply return 0;\\nIf we encounter any negative value then we will increase our negativeCount by 1;\\n\\nWe dont have to deal with positive values as positive*positive is always positive.\\n\\nIn the last we will check if negativeCount is even or not, if its even, then product will be positive, else it will be negative.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723756,
                "title": "one-line-python-code",
                "content": "Don\\'t use this for interview, just for fun :)\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627194,
                "title": "java-solution-no-need",
                "content": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2577104,
                "title": "easy-solution-fast-cpp",
                "content": "solution in CPP:\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }\\n        if(prod<0)\\n            return -1;\\n        else\\n            return 1;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298279,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224875,
                "title": "python3-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990967,
                "title": "java-easy-solution-faster-than-100",
                "content": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1913659,
                "title": "c-simple-solution-96-beats",
                "content": "Here I looped through the vector and with every element, I determined the sign of the product into a variable .\\nThis way we dont have to store huge valued data into a variable.\\n\\nTime Complexity : O(n)\\n\\n```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```\\n\\n**Upvote** if you find this helpful. Thanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897009,
                "title": "java-solution-100-beats-tc-o-n-sc-o-1",
                "content": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }\\n            else if(nums[i]<0){\\n                sign=-sign;\\n            }\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1819961,
                "title": "c-simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if you understood :-)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818106,
                "title": "rust-one-liner-with-bit-op",
                "content": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200880,
                "title": "weeb-does-python-beats-99-32",
                "content": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "codeTag": "Java"
            },
            {
                "id": 1155585,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152844,
                "title": "c-easy-and-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892204,
                "title": "simply-code-beat-100-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672974,
                "title": "c-code-0ms-runtime-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }\\n      else if(nums[i]==0){\\n         return 0;\\n      }\\n     \\n  }\\n   \\n    if(d%2==0){\\n        return 1;\\n    }\\n   return -1;\\n\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3522902,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe only need to check the sign of each integer in the given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n>make a variable ans = 1;\\n>iterate through the array\\n> if the number is positive, multiply 1 to the ans\\n>if the number is negative, numtiply -1 to ans\\n>if the number is zero, make ans = 0;\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478995,
                "title": "o-1-space-c-easy-solution-traverse-the-array",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a variable neg =0;\\n2. increase neg every time the value of array is less than 0.\\n\\n\\n $$if$$ 0 is present in array, then return 0;\\n$$else if$$ neg is present **\\'even\\'** times, then return 1;\\n$$else$$ return -1;\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478965,
                "title": "easy-understable-code-javascript",
                "content": "ja# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the array find the value \\nif value is greater than zero return 1\\nif value is lesser than zero return -1\\nif value is equal to zero return 1\\n\\n\\n# Complexity\\n- Time complexity: linear time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478763,
                "title": "1-line-math-sign",
                "content": "# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478296,
                "title": "2-liner-smart-code-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477862,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the array contains odd numbers of negative numbers, than answer is -1.\\nIf not than answer is 1.If zero exist\\xA0in the array, then the answer is 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount how many times negative exist in the array by traversing whole array.If zero exist\\xA0in the array, then return 0. if odd numbers of negative numbers than return -1.otherwise return 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477534,
                "title": "golang-solution-with-good-description",
                "content": "# Intuition\\nThe task is to find the sign of the product of the elements in the array `nums`. The initial idea is to iterate through each element of the array and determine the sign of the final product based on the properties of the signs of the numbers.\\n\\n# Approach\\nWe can use a single loop to solve this problem. In the loop, we go through each element of the array. If the current element is equal to zero, we immediately return 0, as the product will be zero. If the current element is less than zero, we increment the counter of negative numbers (`result`). After going through the loop, if the number of negative numbers is odd, we return -1; otherwise, we return 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the number of elements in the array `nums`. The time complexity is linear since we iterate through each element of the array.\\n\\n- Space complexity: $$O(1)$$, as we only use a constant amount of additional space for storing the result and loop variables.\\n\\n\\n# Code\\n```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476913,
                "title": "javascript-simple-and-neat-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476587,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476428,
                "title": "simple-solution-in-java-cpp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach will be to multiply all numbers and then see whether product is 0, positive or negative.\\n\\n__BUT__ on a closer inspection it can be seen that the numbers that affect the naswer are the ones that are less than equal to 0, Positive number don\\'t change the sign of the product\\n> -4 * 2 = -8.\\n0 * 2 = 0\\n4 * 2 = 8\\n__Whatever sign of the first term was, is continued when multiplied with a positive number, hence we dont really need to know how many positives do we have in the array.__\\n\\n__Two observations are needed to solve this question__\\n\\n>__1)__ If an element in the array is 0, product will be 0, no need   to multiply anything anymore, that how powerful 0 is here!!\\n__2)__ If the number of negative integers in the array, the answer be negative, else positive\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1) Traverse the array/vector\\n>2) Check if the element is 0 or not\\n>> If the element is 0, the answer or product will stay 0, no matter what is multiplied to it now, therefore return 0\\n\\n>3) Check if the number is negative\\n>>If the number is negative track the frequency of the negative numbers\\nElse Continue\\n\\n>4) If in Nothing has been return so far, check if the frequency of the negatives is odd \\n>> If, yes : return -1\\nElse Return 1\\n\\n# Complexity\\n- Time complexity $$O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```\\n__Do Upvote, If it Helped :)__\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476342,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476194,
                "title": "easy-c-solution",
                "content": "# Intuition\\n\\n- If there are even negative numbers in the array then the result always be a positive number.\\n\\n- If there are odd negative numbers in the array then the result always be a negative number.\\n\\n# Approach\\n\\nIterate over an array and count the number of negative integers in the entire array. Check a base condition If there is any zero return answer as zero.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476142,
                "title": "java-code",
                "content": "# Intuition\\nBy seeing question we can  easily understand that we have to just multiply all elsement of index.\\n\\n# Approach\\njust brute force and efficient approch\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475997,
                "title": "c-easy-solution-for-easy-problem",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475743,
                "title": "typescript-one-liner",
                "content": "# Intuition\\nInitial thoughts were to approach as described: find the product and validate. \\n\\n# Approach\\nRealised after writing a solution with initial thoughts that could actually be simplified by checking/validating based on context resulting in expected products. E.g. if `0` exists then product will always be `0` or if there\\'s an odd number of negative integers then it\\'ll alaways end up at 0.\\n\\nAfter running a basic comparison of the two approaches it appeared that checking the underlying contexts was faster on larger arrays than using a reducer to find the product. After this I simplified the function down to a one liner.\\n\\n# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475646,
                "title": "solution-with-simple-foreach-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475494,
                "title": "super-easy-code-for-this-super-easy-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475435,
                "title": "numpy-one-liner",
                "content": "# Approach\\nDid you know you could use numpy on LeetCode? I didn\\'t.\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475429,
                "title": "java-xor-shift-100-fast",
                "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327954,
                "title": "java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210258,
                "title": "scala-oneliner",
                "content": "# Code\\n```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193644,
                "title": "simple-c-solution-count-number-of-minus-numbers-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem you simply need to count the number of minus numbers in the array. If the number of minuses is odd, the result will be negative (-1 * 1 = -1), otherwise it will be positive (-1 * -1 = 1). Also if you ever see a zero, return 0 as anything multiplied by zero is zero..\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183410,
                "title": "simple-and-easy-to-understand-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```\\n\\nIf you like the code implementation, make sure to upvote :) \\u270C\\nKeep Coding.....\\nKeep chilling...",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149267,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)    , N= array size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086440,
                "title": "easy-basic-solution-brute-force-using-loops-only",
                "content": "# Intuition\\nJust count number of negative numbers in the array, if count is even then return 1 else -1.\\nand also if one of the number in the array is zero then product will also be zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026709,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2924655,
                "title": "compact-and-fast-beats-100",
                "content": "# Approach\\nChanging bool value while encountering any negetive value and just returning 0 when encountering any 0 in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842760,
                "title": "easy-simple-short-c-solution",
                "content": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2823195,
                "title": "java-o-n-simple-sign-of-the-product-of-an-array",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772511,
                "title": "java-o-n-in-just-0-ms",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767166,
                "title": "very-easy-solution-to-understand-in-python3-faster-than-99",
                "content": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```\\n![image](https://assets.leetcode.com/users/images/eb8c431b-a56d-46dc-91a1-53b8ee387f77_1667314069.145179.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749204,
                "title": "golang-solution-easy-understand",
                "content": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656027,
                "title": "c-easy-solution-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count = -count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2613866,
                "title": "python-simple-solution",
                "content": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593029,
                "title": "with-explanation-comments-time-5-ms-83-42-space-10-3-mb-43-03",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }\\n        \\n        //if all are positive | there\\'re even number of negative values-> positive & return 1\\n        return sign;\\n    }\\n\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578810,
                "title": "python3-optimized-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a6785442-0746-4fdb-9d2b-762ad6c565d5_1663232354.791573.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567281,
                "title": "easiest-solution-o-n-time-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```\\n\\nPlease do upvote and share : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397096,
                "title": "javascript-easy-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351669,
                "title": "java-0ms-solution",
                "content": "```class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }else if(nums[i]>0){\\n                pos++;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2276614,
                "title": "javascript-fast-without-calculating-the-actual-product",
                "content": "Check elements of array.  Product sign is influenced by 0 and number of negative numbers.\\nIf the arr contains 0, return 0.\\n\\nAdvantages: When array is very large product will reach Infinite value. Infinite*0 = NaN\\n\\nWe could just return sign directly, but in problem description was mentioned the use of ```signFunc```\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```signFunc```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228229,
                "title": "javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224321,
                "title": "simple-fast-javascript-solution",
                "content": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157800,
                "title": "accepted-100-faster-with-0ms-run-time",
                "content": "When we read the question the first intuitive approach comes to our mind is that we calculate product of each number in array and then if product is less then 0 then print -1 and if product is greater than 0 then 1 and 0 otherwise.\\n**Problem with intuitive Approach:** The biggest problem that comes is the length of integer. Due to cyclic property of datatypes if the value goes out of bound it tries to bring it in the range of integer and if we use long int then its ;\\nTime Complexity: O(n)\\nSpace Complexity: long will take more space than int.\\n\\n**Optimal Approach: **\\n\\nWe know that in multiplication if a single zero is present then ans will be zero and if number of negative is even then by the rule ***negative  negative = positive*** we will get positive answer.\\nSo simply calculate number of negative numbers in nums array, if they are even ans is positive else negative and simultaneously check if a single zero is present return 0.**\\n\\nJava Code:-\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```\\n**Do upvote if you liked the approach and comment if you have any query.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053925,
                "title": "python-fast-and-easy-solution-with-comments-faster-than-98-92",
                "content": "Fast abd Easy solution for Python .\\n\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937467,
                "title": "c-solution-easy-to-understand",
                "content": "We don\\'t need to calculate the whole product of the elements of the given vector..\\nWe\\'ll simply initialise a int variable \"prod\" with a value = 1;\\nThen we will simply form a for loop to iterate over all the elements of the vector;\\nNow, we have 3 cases:\\n1) We\\'ll simply return 0 if any of the elements is found to be 0..\\n2) We\\'ll multiply -1 to the prod if the element is < 0..\\n3) We\\'ll keep the value of the prod intact if the element is > 0..\\n \\nPlease upvote the solution if you find this helpful....\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926125,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nTime Complexity : O(n)\\n```\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nTime Complexity : O(n)\\n```\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902604,
                "title": "c-short-code-with-simple-logic",
                "content": "Simply change the sign of the variable sign when encountered with a negative number. **Return 0** if get 0 as an element because the product will be going to be zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(N)** where N is the size of array.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846503,
                "title": "c-4-solutions-advanced-techniques-linq-expression-matching-switch-clamping",
                "content": "**Solution 1:**\\nLINQ 2 lines\\n```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\\n\\n----------\\n\\n**Solution 2:**\\nLINQ 1 Line\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\\n\\n\\n---- \\n\\n**Solution 3:**\\nSwitch Expression Matching With Relational Operators\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n--------\\n\\n**Solution 4:**\\nOnly count negatives\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815568,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809773,
                "title": "easytounderstand-fast-0ms-without-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808101,
                "title": "easy-simple-java-solution",
                "content": "1. negative * negative = positive\\n2. negative * positive = negative\\n\\n* We count the total number of negative numbers. If the count is even then product will turn positive else negative.\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```\\n\\nplease upvote if you think this is simple and easy to understand. Thanks :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806477,
                "title": "c-simple-approach-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676196,
                "title": "java-most-concise-o-n-time-o-1-space-solution",
                "content": "I am seeing a lot of solutions using `int` to store the product, or `int` to keep track of the sign by performing multiplication. \\n\\nThere is a much more concise way -- use a `bool`. Start with a boolean `sign` set to `false`. When we come across a number that is negative, negate `sign`. Once we\\'ve passed through every element of the array, just check if `sign` is `true`. If it is, return `-1`, else return `1`. \\n\\nOh, also, we know that any number multiplied by `0` is just going to be `0`, so if at any point we encounter a `0` in our traversal, we can just return `0` right away and be done. \\n\\n```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649505,
                "title": "javascript-typescript-easy-100",
                "content": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0a5ecfa9-a724-4b12-9a03-8fcab9a3ed5e_1640571384.0467677.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585927,
                "title": "c-90-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541342,
                "title": "easy-java-solution",
                "content": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424377,
                "title": "python-87-using-reduce-with-lambda-argument",
                "content": "I took this approach since I have a bit of a Javascript background. The reduce function returns 1 value after it completes the lambda operations.\\n\\nMake sure to import functools. \\n\\n```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363191,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250512,
                "title": "java-math-0ms-beats-100-t-c-o-n-s-c-o-1",
                "content": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "solutionTags": [],
                "code": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1197853,
                "title": "c-easy-concise-o-n-o-1",
                "content": "The sign depends upon weather the -ve\\'s are even (return 1) or odd(return -1).\\nIf you caught a zero it will give a product zero .Hence no need to traverse further , just return 0;\\n\\n```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166799,
                "title": "python3-one-pass",
                "content": "Initialize a variable \"sign\" to be 1, and update it when passing every number if the list.\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```\\nPlease upvote if you find it helpful. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 2049095,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1671670,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1880393,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1746054,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2072011,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2045904,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1987192,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1977976,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1965940,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1917526,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1912323,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1899081,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884875,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884366,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880420,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880271,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880234,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880200,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880174,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880129,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880125,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880124,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880122,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880110,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880098,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880046,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880028,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880001,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879991,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879969,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879940,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879922,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879878,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879873,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879864,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879861,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879853,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879851,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879820,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879806,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879802,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879801,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879777,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879766,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879764,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879753,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879741,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879737,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879695,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784254,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Winner of the Circular Game",
        "question_content": "<p>There are <code>n</code> friends that are playing a game. The friends are sitting in a circle and are numbered from <code>1</code> to <code>n</code> in <strong>clockwise order</strong>. More formally, moving clockwise from the <code>i<sup>th</sup></code> friend brings you to the <code>(i+1)<sup>th</sup></code> friend for <code>1 &lt;= i &lt; n</code>, and moving clockwise from the <code>n<sup>th</sup></code> friend brings you to the <code>1<sup>st</sup></code> friend.</p>\n\n<p>The rules of the game are as follows:</p>\n\n<ol>\n\t<li><strong>Start</strong> at the <code>1<sup>st</sup></code> friend.</li>\n\t<li>Count the next <code>k</code> friends in the clockwise direction <strong>including</strong> the friend you started at. The counting wraps around the circle and may count some friends more than once.</li>\n\t<li>The last friend you counted leaves the circle and loses the game.</li>\n\t<li>If there is still more than one friend in the circle, go back to step <code>2</code> <strong>starting</strong> from the friend <strong>immediately clockwise</strong> of the friend who just lost and repeat.</li>\n\t<li>Else, the last friend in the circle wins the game.</li>\n</ol>\n\n<p>Given the number of friends, <code>n</code>, and an integer <code>k</code>, return <em>the winner of the game</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png\" style=\"width: 500px; height: 345px;\" />\n<pre>\n<strong>Input:</strong> n = 5, k = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, k = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<p>Could you solve this problem in linear time with constant space?</p>\n",
        "solutions": [
            {
                "id": 1152594,
                "title": "c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int x=k;\\n            while(x>1){\\n                int r=q.front();\\n                q.pop();\\n                q.push(r);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int x=k;\\n            while(x>1){\\n                int r=q.front();\\n                q.pop();\\n                q.push(r);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601186,
                "title": "c-3-approach-easy-understanding",
                "content": "The 3 Easy Approaches are : Circular Linked List, Recursive and Iterative.\\n\\n# 1. **Brute Force Solution : CIRCULAR LINKED LIST**\\n```\\n/* Time Complexity : O(n*k)  Space Complexity : O(n) */\\n```\\nIf we look at the question, it says that the people are playing the game on a round table. That means, A Circular Linked List can be used to visualize the round table. We store 1,2,3,4,.......,n as the nodes of our List and go on deleting every kth node that we encounter. When we are left with only 1 node i.e. the head node, it is our WINNER. Since we are consuming extra space for Circular Linked List so, our Space Complexity goes to O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(ListNode *head,int k){\\n        ListNode *temp=head;  //For traversing through the List and delete every kth Node \\n        while(head->next!=head){   //Till the last Node remains in the list i.e. the winner\\n            ListNode *pre=NULL;\\n            for(int i=1; i<k; i++){\\n                pre=temp;\\n                temp=temp->next;\\n            }\\n            //Deletion procedure\\n            if(temp==head)\\n                head=head->next;\\n            pre->next=temp->next;\\n            delete(temp);\\n            temp=pre->next;\\n        }\\n        //The last node remaining becomes the head of the Circular Linked List i.e. Winner\\n        return head->val;\\n    }\\n    int findTheWinner(int n, int k) {\\n        if(k==1)\\n            return n;\\n        //Designing Circular Linked List for Node 1,2,3,4,.....,n\\n        ListNode *head=NULL,*tail=NULL;\\n        for(int i=1; i<=n; i++){\\n            ListNode *node=new ListNode(i);\\n            if(head==NULL)\\n                head=tail=node;\\n            else{\\n                tail->next=node;\\n                tail=node;\\n            }\\n            tail->next=head;\\n        }\\n        //Helper function will eliminate the nodes and give us the winner\\n        return helper(head,k);\\n    }\\n};\\n```\\n\\n# 2. **Simple Solution : RECURSION**\\n```\\n/* Time Complexity : O(n)  Space Complexity : O(n) */\\n```\\nThis problem can also be solved using Recursion. If you observe, you can see that we are doing the same activity again and again i.e. deleting every kth element we encounter. Therefore, we can think towards the recursive approach also.\\nIntution : If I have  the winner for \\'n-1\\' and \\'k\\'. I can find the winner for \\'n\\' and \\'k\\' by moving on to the next kth person (i.e. f(n) = f(n-1)+k). Keeping in mind that they are sitting on a round table we have to rotate also (i.e. f(n) = (f(n-1)+k)%n).\\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (helper(n-1,k) + k) % n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for converting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\\n**Note : You might think that you have not taken any extra space in for the problem so the space complexity is O(1) but this is not true. The function calls are stored in the Stack memory of the machine and therefore these recursive calls end up making a Stack at the machine end. So, the Space Complexity for this program goes to O(n). INTERESTING HUH XD**\\n# 3. **Optimised Solution : ITERATIVE APPROACH**\\n```\\n/* Time Complexity : O(n)  Space Complexity : O(1) */\\n```\\nWe can simply convert our Recursive Solution into Iterative Solution. This will bring no change in the Time Complexity but the Space Complexity will be optimised from O(n) to O(1). Our intution remains the same and looks very much similar to our Recursive Solution.\\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for conterting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\\n**Note : Since, we are doing the problem Iteratively. So, extra space is not consumed neither from our side nor from machine\\'s side. Therefore the space complexity of our program is optimised to O(1).**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/* Time Complexity : O(n*k)  Space Complexity : O(n) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(ListNode *head,int k){\\n        ListNode *temp=head;  //For traversing through the List and delete every kth Node \\n        while(head->next!=head){   //Till the last Node remains in the list i.e. the winner\\n            ListNode *pre=NULL;\\n            for(int i=1; i<k; i++){\\n                pre=temp;\\n                temp=temp->next;\\n            }\\n            //Deletion procedure\\n            if(temp==head)\\n                head=head->next;\\n            pre->next=temp->next;\\n            delete(temp);\\n            temp=pre->next;\\n        }\\n        //The last node remaining becomes the head of the Circular Linked List i.e. Winner\\n        return head->val;\\n    }\\n    int findTheWinner(int n, int k) {\\n        if(k==1)\\n            return n;\\n        //Designing Circular Linked List for Node 1,2,3,4,.....,n\\n        ListNode *head=NULL,*tail=NULL;\\n        for(int i=1; i<=n; i++){\\n            ListNode *node=new ListNode(i);\\n            if(head==NULL)\\n                head=tail=node;\\n            else{\\n                tail->next=node;\\n                tail=node;\\n            }\\n            tail->next=head;\\n        }\\n        //Helper function will eliminate the nodes and give us the winner\\n        return helper(head,k);\\n    }\\n};\\n```\n```\\n/* Time Complexity : O(n)  Space Complexity : O(n) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (helper(n-1,k) + k) % n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for converting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\n```\\n/* Time Complexity : O(n)  Space Complexity : O(1) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for conterting 0-based indexing to 1-based indexing\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157717,
                "title": "java-full-solution-and-explanation",
                "content": "*Note : I realized I used the word kill instead of loose. It\\'s just because I was thinking of the original Josephus problem when writing it. To comply exactly to the leetcode problem, just replace kill by loose when you read it.*\\n# Solution to the problem in Java\\n## First approach (Naive)\\nThe first approach could be to just translate the problem we have into code. Let\\'s assume we define a classe `Node` with a `num` value (the integer 1, 2, 3, ...) and a `prev` and `next` values, which both are of type `Node`. Then we would have a class which represents what we have, a number as label, a follower and a previous.\\n\\n```\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n}\\n```\\n\\nThen, what happend when we kill a `Node` ? We simply set the previous of the follower to be the previous of the current `Node` and same for the follower of the previous :\\n\\n```\\npublic void kill(){\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n```\\n\\nSo now we have defined the Node with the behavior, let\\'s start by initializing the nodes in the solution :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // We set the first node and keep it (to be able to set it as the follower of the last node we will create)\\n        Node firstNode = new Node(1);\\n\\t\\t// This is just part of our loop\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n\\t\\t// Then set the last and first nodes\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n    }\\n}\\n```\\n\\nNow, what we have to do is pretty easy. Start from the last Node (the one before the first) and count k each time, and kill the `Node` on which we are. As the current `Node` will be the one killed, its next will be the one that we will start with. So we are still before the first one to start with :\\n\\n```\\nNode currentNode = prevNode;\\nfor(int i=0; i<n; i++) {\\n\\tfor(int j=0; j<k; j++) {\\n\\t\\tcurrentNode = currentNode.next;\\n\\t}\\n\\tcurrentNode.kill();\\n}\\n```\\n\\nAll we have to do finally is to return the `num` of the next node, the only one surviving.\\n\\n```\\nreturn currentNode.next.num;\\n```\\n\\nSo the final solution is :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Node firstNode = new Node(1);\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n        \\n        \\n        Node currentNode = prevNode;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<k; j++) {\\n                currentNode = currentNode.next;\\n            }\\n            currentNode.kill();\\n        }\\n        return currentNode.next.num;\\n    }\\n}\\n\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n    \\n    public void kill(){\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n}\\n```\\n\\n### Complexity\\n\\nTime complexity is O(n \\xD7 k) as we count `k` times for the `n` turns.\\nSpace complexity is O(k) as we create `k` nodes for playing the game\\n\\n## Second Approach (Code optimization using Data Structure)\\nRemember good code is based in three criterias :\\n\\n* Time complexity\\n* Space complexity\\n* Readability\\n\\nA good first step could be to reduce the code drastically, to make it more readable. What we can do here is using `LinkedList` instead of our `Node` custom class. The logic will just to pass the first value to the last one until we arrive to the one to kill. Let\\'s see with `n=5` and `k=2` how we will perform.\\n\\n```\\n=== Initialization ===\\n1 => 2 => 3 => 4 => 5\\n=== First round ===\\n1) we put the 1 to the end :\\n2 => 3 => 4 => 5 => 1\\n2) Second step, meaning current step = k, we just poll the node :\\n3 => 4 => 5 => 1\\n=== Second round ===\\n1) We put 3 at the end\\n4 => 5 => 1 => 3\\n2) We poll 4\\n5 => 1 => 3\\n=== Third round ===\\n1) We put 5 at the end\\n1 => 3 => 5\\n2) We poll 1\\n3 => 5\\n=== Forth round ===\\n1) We put 3 at the end\\n5 => 3\\n2) We poll 5\\n3\\n```\\n\\nNow that it is clear, the question could be, how to put the first value to the last position in a LinkedList. Actually, it\\'s quite easy : polling it and adding to the LinkedList: `linkedList.add(linkedList.poll())`\\n\\nThat being said, let\\'s translate this into code :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // Initialisation of the LinkedList\\n        LinkedList<Integer> participants = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t    participants.add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint lastKilled = 0;\\n\\t\\t// Run the game\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k-1; j++) {\\n\\t\\t\\t    participants.add(participants.poll());\\n\\t\\t\\t}\\n            lastKilled = participants.poll();\\n        }\\n        // Return the last one killed\\n        return lastKilled;\\n    }\\n}\\n```\\n\\n### Complexity\\nTime complexity is O(n \\xD7 k) as we count `k` times for the `n` turns.\\nSpace complexity is O(k) as we create `k` nodes for playing the game\\n*In terms of time with LeetCode, the first solution is better than this one, especially because (add(poll)) is really time consuming in Java.*\\n\\n### Interview tips\\nIn an interview, the first or second solution will be good. But interviewer may ask you is there a better approach, and then, you can talk about time consumed by the first solution, and code complexity of the first one, and tell that you would make trade-offs based in this.\\n\\n## Third approach (Mathematical)\\n\\n### Basic approach\\nLet\\'s assume we have f(n,k) which will give you the one remaining after nth turn in a group of nth people if we count k person at each turn. If you don\\'t have any tool, it may take you few hours to realize how to calculate f(n,2). For the generic k, it will take you few hours just to understand the demonstration. So of course, this solution will never be expected from you in an interview.\\nSo let\\'s assume all participants are numbered 0 based, and that f(1,k) = 0 (if we have only one participant, numbered 0 as it is the first one, of course it\\'s the one who will remain).\\nThen f(n,k) = (f(n-1, k)+k) mod n. Considering this, it\\'s easy to code the solution :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(n == 1) {\\n            return 0;\\n        } else {\\n            return (findTheWinner0Based(n - 1, k) + k) % n;\\n        }\\n    }\\n}\\n```\\n\\n#### Complexity\\nAs we can see, we will iterate on the function n times, the time complexity is O(n).\\nOf course, calling recursive functions will have a space complexity of O(n) (storing all the temporary results of the method called)\\n\\n### Removing recursive function to have a space complexity of O(1)\\n\\nWe could remove the recursive calls in order to achieve a space complexity of O(1). Instead of starting from the last item and counting down until 1, we could start at one, and counting up until we reach n :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result + 1;\\n    }\\n}\\n```\\n\\n*This last solution will give you a result of 0ms on leetcode, so you may think that you came up with the best solution. Actually, it\\'s possible to make it even faster.*\\n\\n### Improving time complexity\\n\\nIt\\'s possible to decrease time complexity for certain scenarii using mathematical formulas. It\\'s possible to achieve a time complexity of O(k \\xD7 log(n)) which may be faster than O(n) especially when n is huge and k is little.\\n\\nDon\\'t try to understand this if you\\'re not a mathematician (I\\'m not) ;-)\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(k == 1) return n-1;\\n        if(n == 1) return 0;\\n        if(k <= n) {\\n            return findTheWinnerForLargeN(n, k);\\n        } else {\\n            return findTheWinnerForSmallN(n, k);\\n        }\\n    }\\n    \\n    public int findTheWinnerForLargeN(int n, int k) {\\n        int np = n - (n/k);\\n        int result = (k*(((findTheWinner0Based(np, k) - n%k)+np) % np))/(k-1);\\n        return result;\\n    }\\n    \\n    public int findTheWinnerForSmallN(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n### Complexity\\nTime complexity is O(k \\xD7 log(n)) if n is higher than k, O(n) otherwise.\\nSpace complexity is the same as time complexity as we are using recursive functions.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n}\\n```\n```\\npublic void kill(){\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // We set the first node and keep it (to be able to set it as the follower of the last node we will create)\\n        Node firstNode = new Node(1);\\n\\t\\t// This is just part of our loop\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n\\t\\t// Then set the last and first nodes\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n    }\\n}\\n```\n```\\nNode currentNode = prevNode;\\nfor(int i=0; i<n; i++) {\\n\\tfor(int j=0; j<k; j++) {\\n\\t\\tcurrentNode = currentNode.next;\\n\\t}\\n\\tcurrentNode.kill();\\n}\\n```\n```\\nreturn currentNode.next.num;\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Node firstNode = new Node(1);\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n        \\n        \\n        Node currentNode = prevNode;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<k; j++) {\\n                currentNode = currentNode.next;\\n            }\\n            currentNode.kill();\\n        }\\n        return currentNode.next.num;\\n    }\\n}\\n\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n    \\n    public void kill(){\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n}\\n```\n```\\n=== Initialization ===\\n1 => 2 => 3 => 4 => 5\\n=== First round ===\\n1) we put the 1 to the end :\\n2 => 3 => 4 => 5 => 1\\n2) Second step, meaning current step = k, we just poll the node :\\n3 => 4 => 5 => 1\\n=== Second round ===\\n1) We put 3 at the end\\n4 => 5 => 1 => 3\\n2) We poll 4\\n5 => 1 => 3\\n=== Third round ===\\n1) We put 5 at the end\\n1 => 3 => 5\\n2) We poll 1\\n3 => 5\\n=== Forth round ===\\n1) We put 3 at the end\\n5 => 3\\n2) We poll 5\\n3\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // Initialisation of the LinkedList\\n        LinkedList<Integer> participants = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t    participants.add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint lastKilled = 0;\\n\\t\\t// Run the game\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k-1; j++) {\\n\\t\\t\\t    participants.add(participants.poll());\\n\\t\\t\\t}\\n            lastKilled = participants.poll();\\n        }\\n        // Return the last one killed\\n        return lastKilled;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(n == 1) {\\n            return 0;\\n        } else {\\n            return (findTheWinner0Based(n - 1, k) + k) % n;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(k == 1) return n-1;\\n        if(n == 1) return 0;\\n        if(k <= n) {\\n            return findTheWinnerForLargeN(n, k);\\n        } else {\\n            return findTheWinnerForSmallN(n, k);\\n        }\\n    }\\n    \\n    public int findTheWinnerForLargeN(int n, int k) {\\n        int np = n - (n/k);\\n        int result = (k*(((findTheWinner0Based(np, k) - n%k)+np) % np))/(k-1);\\n        return result;\\n    }\\n    \\n    public int findTheWinnerForSmallN(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152585,
                "title": "o-n-o-klg-n-with-table-explanation",
                "content": "This is the josephus problem, [wikipedia](https://en.wikipedia.org/wiki/Josephus_problem)\\nThe classic algorithm to this problem is very weird, let me talk with the example1 in \"leetcode problem description\". \\nAt first [aaa,bbb,cac,ddd,eee] is playing this game.\\n\\n| #alive | aaa | bbb | cac | ddd | eee |\\n|-------------|-----|-----|-----|-----|-----|\\n| 5           | 1   | 2   | 3   | 4   | 5   |\\n| 4           | 4   | (\\u2191eliminated)  | 1   | 2   | 3   |\\n| 3           | 2   |     | 3   |  (0)   | 1   |\\n| 2           |     |     | 1   |     | 2   |\\n| 1           |     |     | 1   |     |   |\\n\\nEvery different round, we name these people using different number sequences.\\nEvery time someone died, the number sequence start again from 1.\\nThe table describes how we name these people.\\n\\nThe winner have a number `1` in the last round. \\nYou have to induce his(cac) \\'s number in the first round.\\nSuppose when there are `i` people alive, cac\\'s number is `f(i,\\'cac\\')`. And when there are `i+1` people alive, cac\\'s number is `f(i+1,\\'cac\\')`.\\nThen `f(i+1,\\'cac\\') == (k + f(i,\\'cac\\') - 1 )%(i+1) + 1`.\\n\\n<details><summary> prove </summary><p>\\n\\n**When there are `i+1` people alive**, person with number *`k % (i+1)`* will be eliminated \\n\\n**When `i` people alive**, He(\\u2191) has a dummy number 0 . So count the next `f(i,\\'cac\\')` people , ( turn back to round when `i+1` people alive ) number *`(k+f(i,\\'cac\\')) % (i+1)`* is the value of *`f(i+1, \\'cac\\')`* . \\n\\nA good example from this table is when `i==3`. `f(i,\\'cac\\')` is `3`, \\'ddd\\' will be eliminated, `f(i+1, \\'cac\\')` is *`(2+f(i,\\'cac\\'))%4`*.\\n\\nNotice, `f(i+1,\\'cac\\')` can\\'t be zero, you need change it to *`(k+f(i,\\'cac\\')-1)%(i+1)+1`*. ( for example, when `i==2`, the value of *`(k+f(i,\\'cac\\'))%(i+1)`* maybe `0,1,2`, but indeed, we need `3,1,2`, so additionally map `0` into `3` while remeining other values unchanged. ). \\n\\nTo avoid this problem, you can make all indices in this problem start from 0, i.e. map all indices from `i` to `i-1`. \\n\\n---\\n</p></details>\\n\\nThen you can build a relation between each round and finally get the correct answer.\\n\\nThere is also a `O(klg(n))` hybrid algorithm, I will introduce later.\\nThere is also a time `O(lgn)` space `O(1)` formula/algorithm when `k` is `2`, refer to wikipedia.\\n## code\\n-----\\n\\ntop-down recursion: time \\u0398(n) space \\u0398(n)\\n```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        if n==1: return 1\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\\n\\nbottom-up time \\u0398(n) space \\u0398(1)\\n\\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    p = 1\\n    for i in range(1,n):\\n        # here i represent number of alive people\\n\\t\\t# p is f(i,\\'cac\\')\\n        p=(k+p-1)%(i+1)+1\\n\\t\\t# p is f(i+1, \\'cac\\')\\n    return p\\n```\\n\\n## advanced code1\\nhttps://stackoverflow.com/a/69891445/7721525\\n## advanced code2\\n-----\\n\\nlet\\'s use `g(n,k)` to represent answer of this problem.\\nIn the previous section, we know for any positive n,k, `g(n,k) = (k + g(n-1, k) -1)%n + 1`.\\n\\nWhen `n >= k and k!=1`, we can eliminate `floor(n/k)` people in a round, and then use new indices.\\nFor example, `n=11, k=3`\\n\\nhere for convenience, index start from 0\\n\\n|||||||||||foo||\\n|---|---|---|---|---|---|---|---|---|---|---|----|\\n| y | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\\n| z | 2 | 3 | / | 4 | 5 | / | 6 | 7 | / | 0 | 1  |\\n| x | 0 | 1 | / | 2 | 3 | / | 4 | 5 | / | 6 | 7  |\\n|y-x| 0 | 0 |   | 1 | 1 |   | 2 | 2 |   | 3 | 3  |\\n\\nAs table, on the same column, `x,y,z` are different indices on the same person. From row1 to row2, eliminate `floor(n/k)` people, the indices start again on foo.\\n  \\n+ `nextn = n - floor(n/k)`\\n+ `x = (z-n%k) mod nextn ` (`x>=0`)\\n+ `y = x + floor(x/(k-1))`\\n+ so let  `z = g(nextn,k)` we can get `g(n,k)` from `y`\\n\\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    if n==1: \\n        return 1\\n    elif k==1:\\n        return n\\n    elif n>=k:\\n        next_n = n - n//k\\n        z = self.findTheWinner(next_n, k) - 1\\n        x = (z-n%k + next_n) % next_n\\n        return x + x//(k-1) + 1\\n    else:\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\\n\\nthe time complexity `O(klg(n))`, space `O(klg(n))`\\n\\nSolve `T(n) = T(n*k/(k+1)) + O(1) if n>k else T(n)=T(n-1)+1`, \\n`(k/(k+1))^(T(n)-k) = k/n` \\n> `T(n) = (log(n/k))/(log(k+1)-log(k)) + k`\\n>> `1/(log(k+1)-log(k)) \\u2248 k + 0.5` ( logarithm base `math.e`)\\n>> \\n> `T(n) \\u2248 klog(n/k) + k`\\n\\nSo `klg(n)` is an upper bound, also refer to wikipedia.\\n\\n## similar problems\\n-----\\n\\n+ leetcode #390 (hard on log(n) solution)\\n+ leetcode #1900 (super hard on log(n) solution )\\n\\n## where I learn from \\n\\n+ https://maskray.me/blog/2013-08-27-josephus-problem-two-log-n-solutions, but there are some mistakes.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        if n==1: return 1\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    p = 1\\n    for i in range(1,n):\\n        # here i represent number of alive people\\n\\t\\t# p is f(i,\\'cac\\')\\n        p=(k+p-1)%(i+1)+1\\n\\t\\t# p is f(i+1, \\'cac\\')\\n    return p\\n```\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    if n==1: \\n        return 1\\n    elif k==1:\\n        return n\\n    elif n>=k:\\n        next_n = n - n//k\\n        z = self.findTheWinner(next_n, k) - 1\\n        x = (z-n%k + next_n) % next_n\\n        return x + x//(k-1) + 1\\n    else:\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152460,
                "title": "java-queue-self-explanatory",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            queue.offer(i);\\n        }\\n        \\n        while(queue.size()>1){\\n            int delete = k-1;\\n            while(delete>0){\\n                queue.offer(queue.remove());\\n                delete--;\\n            }\\n            \\n            queue.remove();\\n        }\\n        \\n        return queue.remove();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            queue.offer(i);\\n        }\\n        \\n        while(queue.size()>1){\\n            int delete = k-1;\\n            while(delete>0){\\n                queue.offer(queue.remove());\\n                delete--;\\n            }\\n            \\n            queue.remove();\\n        }\\n        \\n        return queue.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152420,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums = list(range(n))\\n        i = 0 \\n        while len(nums) > 1: \\n            i = (i + k-1) % len(nums)\\n            nums.pop(i)\\n        return nums[0] + 1\\n```\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ans = 0\\n        for x in range(2, n+1): ans = (ans + k) % x\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums = list(range(n))\\n        i = 0 \\n        while len(nums) > 1: \\n            i = (i + k-1) % len(nums)\\n            nums.pop(i)\\n        return nums[0] + 1\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ans = 0\\n        for x in range(2, n+1): ans = (ans + k) % x\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152617,
                "title": "josephus-problem-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k)\\n    {\\n        if(n==1) return 0;\\n        int x=solve(n-1,k);\\n        int y=(x+k)%n;\\n        return y;\\n    }\\n    int findTheWinner(int n, int k) {\\n       if(k>n) k=k%n;\\n        return solve(n,k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k)\\n    {\\n        if(n==1) return 0;\\n        int x=solve(n-1,k);\\n        int y=(x+k)%n;\\n        return y;\\n    }\\n    int findTheWinner(int n, int k) {\\n       if(k>n) k=k%n;\\n        return solve(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626018,
                "title": "5-lines-java-solution-0ms-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nProblem is same as famous \"Josephus Problem\".\\n\\nclass Solution {\\n\\n    public int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;\\n    }\\n    public int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (helper(n-1,k)+k)%n;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1490558,
                "title": "python-simulation-solution-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Simulation**\\n```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = [i for i in range(1, n+1)]\\n        lastIndex = 0\\n        while len(circle) > 1:\\n            lastIndex = (lastIndex + k - 1) % len(circle)\\n            del circle[lastIndex]\\n            lastIndex = lastIndex % len(circle)\\n        return circle[0]\\n```\\nComplexity:\\n- Time: `O(K * N)`, where `K <= N <= 500`.\\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = [i for i in range(1, n+1)]\\n        lastIndex = 0\\n        while len(circle) > 1:\\n            lastIndex = (lastIndex + k - 1) % len(circle)\\n            del circle[lastIndex]\\n            lastIndex = lastIndex % len(circle)\\n        return circle[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181025,
                "title": "c-solution-josephus-problem",
                "content": "This is the standard **[Josephus Problem](https://en.wikipedia.org/wiki/Josephus_problem)**. \\nThis solution uses recursion to eliminate one person in each round and return the last standing person.\\n\\n![image](https://assets.leetcode.com/users/images/3ca609dc-d55a-416c-bcb7-27f891932e1a_1655869639.4225068.gif)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void josephus(vector<int> &v, int start, int k){\\n        if(v.size()==1){             //Return last standing person\\n            return;\\n        }\\n        start+=k;                    //Position of person form start which is to be eliminated\\n        int s = v.size();\\n        start%=s;                    //Taking remainder so that index does not go above the size of array\\n        v.erase(v.begin()+start);      //Eliminating the person\\n        josephus(v,start,k);             //Recusive call\\n        return;\\n    }\\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        vector<int> v(n);\\n        k--;\\n        for(int i=1; i<=n; i++){\\n            v[i-1]=i;\\n        }\\n        josephus(v,0,k);\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void josephus(vector<int> &v, int start, int k){\\n        if(v.size()==1){             //Return last standing person\\n            return;\\n        }\\n        start+=k;                    //Position of person form start which is to be eliminated\\n        int s = v.size();\\n        start%=s;                    //Taking remainder so that index does not go above the size of array\\n        v.erase(v.begin()+start);      //Eliminating the person\\n        josephus(v,start,k);             //Recusive call\\n        return;\\n    }\\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        vector<int> v(n);\\n        k--;\\n        for(int i=1; i<=n; i++){\\n            v[i-1]=i;\\n        }\\n        josephus(v,0,k);\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152829,
                "title": "javascript-solution-with-explanation-queue-iterative",
                "content": "```\\nEXAMPLE: You are given an array [1,2,3,4,5] and you are asked to delete every second element while visualizing these numbers (elements of array) in a circle.\\n\\nYou are probably picturing this: \\n 1-2-3-4-5 ---> 1-3-4-5 ----> 1-3-5 ----> 3-5----> 3 Answer!\\n ```\\n \\n`Approach 1: ` Pick (k-1) elements from the front of the array and push/append it to the back of this array while deleting the kth element  at every step .\\n \\n `How to implement? `\\n- Use queue data structure\\n-  Iteratively dequeue(remove from front) k-1 elements from it\\n-  Enqueue(push/append) the removed (k-1) elements to the back of the same array.\\n-  Delete the kth element\\n- Now you have a que of length of (previous-queue-length -1)\\n- Repeat this until you have only one number left in your queue\\n- Return the number from your queue! \\n\\n\\n\\n\\n\\n```\\nconst findTheWinner = function(n, k) {\\n// Build queue\\n    let que = [] \\n    for(let i = 1; i <= n;i++){\\n        que.push(i)\\n    }\\n\\n    while(que.length > 1){\\n\\t\\tlet deleteCount = k-1\\n\\t\\t\\twhile(deleteCount > 0){\\n\\t\\t\\t\\tque.push(que.shift())    //Rotate Elements  \\n\\t\\t\\t\\tdeleteCount--\\n\\t\\t\\t}\\n        que.shift()                    // Delete kth element\\n    }\\n    return que.shift()  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nEXAMPLE: You are given an array [1,2,3,4,5] and you are asked to delete every second element while visualizing these numbers (elements of array) in a circle.\\n\\nYou are probably picturing this: \\n 1-2-3-4-5 ---> 1-3-4-5 ----> 1-3-5 ----> 3-5----> 3 Answer!\\n ```\n```\\nconst findTheWinner = function(n, k) {\\n// Build queue\\n    let que = [] \\n    for(let i = 1; i <= n;i++){\\n        que.push(i)\\n    }\\n\\n    while(que.length > 1){\\n\\t\\tlet deleteCount = k-1\\n\\t\\t\\twhile(deleteCount > 0){\\n\\t\\t\\t\\tque.push(que.shift())    //Rotate Elements  \\n\\t\\t\\t\\tdeleteCount--\\n\\t\\t\\t}\\n        que.shift()                    // Delete kth element\\n    }\\n    return que.shift()  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155396,
                "title": "short-and-easy-python3-beats-100",
                "content": "\\tclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ls=list(range(1,n+1))\\n        while len(ls)>1:\\n            i=(k-1)%len(ls)\\n            ls.pop(i)\\n            ls=ls[i:]+ls[:i]\\n        \\n        return ls[0]\\n\\n![image](https://assets.leetcode.com/users/images/1d40eef7-fc62-4764-a8d0-3eccd859c9c8_1618255596.4814124.png)\\n\\n**Edit: Even faster and shorter code**\\n\\n\\tclass Solution:\\n\\tdef findTheWinner(self, n: int, k: int) -> int:\\n\\t\\tls=list(range(1,n+1))\\n\\t\\twhile len(ls)>1:\\n\\t\\t\\ti=(k-1)%len(ls)\\n\\t\\t\\tls=ls[i+1:]+ls[:i]\\n\\n\\t\\treturn ls[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ls=list(range(1,n+1))\\n        while len(ls)>1:\\n            i=(k-1)%len(ls)\\n            ls.pop(i)\\n            ls=ls[i:]+ls[:i]\\n        \\n        return ls[0]\\n\\n![image](https://assets.leetcode.com/users/images/1d40eef7-fc62-4764-a8d0-3eccd859c9c8_1618255596.4814124.png)\\n\\n**Edit: Even faster and shorter code**\\n\\n\\tclass Solution:\\n\\tdef findTheWinner(self, n: int, k: int) -> int:\\n\\t\\tls=list(range(1,n+1))\\n\\t\\twhile len(ls)>1:\\n\\t\\t\\ti=(k-1)%len(ls)\\n\\t\\t\\tls=ls[i+1:]+ls[:i]\\n\\n\\t\\treturn ls[0]",
                "codeTag": "Java"
            },
            {
                "id": 1152544,
                "title": "c-simulation",
                "content": "Sure, there is a mathematical solution, and there is a list/queue solution.\\n\\nThough, since we are limted to `500` elements, we can just use a boolean array and skip through empty elements.\\n\\n```cpp\\nint findTheWinner(int n, int k) {\\n    vector<bool> f(n, true);\\n    int i = 0, cnt = n;\\n    while (cnt > 1) {\\n        for (int j = 0; j < k; ++j, ++i) {\\n            while(!f[i % n])\\n                ++i;\\n        }\\n        f[(i - 1) % n] = false;\\n        --cnt;\\n    }\\n    for (i = 0; !f[i]; ++i);\\n    return i  + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint findTheWinner(int n, int k) {\\n    vector<bool> f(n, true);\\n    int i = 0, cnt = n;\\n    while (cnt > 1) {\\n        for (int j = 0; j < k; ++j, ++i) {\\n            while(!f[i % n])\\n                ++i;\\n        }\\n        f[(i - 1) % n] = false;\\n        --cnt;\\n    }\\n    for (i = 0; !f[i]; ++i);\\n    return i  + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152474,
                "title": "josephus-problem",
                "content": "Read about Josephus problem here -> https://en.wikipedia.org/wiki/Josephus_problem\\n\\nQuite simply, you can use list.pop(i) to delete each number (and get his ID) in a loop. Then, we just have to worry about wrapping the indices, which you can do just by taking the skipped index mod the number of remaining numbers.\\n\\nSo then, the question solution becomes\\n\\n```\\ndef josephus(ls, skip):\\n    skip -= 1 \\n    idx = skip\\n    while len(ls) > 1:\\n        ls.pop(idx)\\n        idx = (idx + skip) % len(ls)\\n    return ls[0]\\n```\\n\\n```\\n\\n\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        n = list(range(1,n+1))\\n        return self.josephus(n, k)\\n        \\n    def josephus(self, ls, skip):\\n        skip -= 1 \\n        idx = skip\\n        while len(ls) > 1:\\n            ls.pop(idx)\\n            idx = (idx + skip) % len(ls)\\n        return ls[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef josephus(ls, skip):\\n    skip -= 1 \\n    idx = skip\\n    while len(ls) > 1:\\n        ls.pop(idx)\\n        idx = (idx + skip) % len(ls)\\n    return ls[0]\\n```\n```\\n\\n\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        n = list(range(1,n+1))\\n        return self.josephus(n, k)\\n        \\n    def josephus(self, ls, skip):\\n        skip -= 1 \\n        idx = skip\\n        while len(ls) > 1:\\n            ls.pop(idx)\\n            idx = (idx + skip) % len(ls)\\n        return ls[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847011,
                "title": "python-code-with-intuition-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution code is of few lines. You just need to understand the pattern here.\\n\\n## 1) Iterating over queue (If you know how to can skip this)\\nBefore that understand how to iterate over the circular queue.\\nSuppose no of students in circular queue are 6 starting from 0 index till 5th index.\\nLet\\'s say we are at 4th index \\n\\n![image.png](https://assets.leetcode.com/users/images/d6ca01b4-fbed-4669-87c2-a074d6db46da_1669362182.4144485.png)\\n\\nincrementing to the next element is no brainer add just to the index\\nNow we are at 5th.\\nincrementing from here will reach to 6th index which is out of bound.\\nUse modulus for incrementing\\n## next_index = (current_index+1) % total_students\\n  next_index = (5+1) % 6 = 0\\nThis will work for index less than 6 \\n  next_index = (4+1) % 6 = 5\\n\\n## 2) Understanding the pattern\\n\\nSuppose there are 7 friends are seating in linear way.\\n### n = 7 and k = 4\\n\\n![image.png](https://assets.leetcode.com/users/images/3cb740df-6209-45d3-bda9-914ac9ef33f3_1669362717.3768306.png)\\n\\nstarting from 0th index counting till 4 friend at index 3 will loose.\\n\\n![image.png](https://assets.leetcode.com/users/images/bc1b95ea-48a5-47fb-a3c1-a68b01a62958_1669362875.6951969.png)\\n\\n>  Keep  in mind that we are counting in circular way even if they are seating in linear. \\n\\nThe number of students remain are\\nn - 1 = 7 - 1 = 6\\n\\nStarting from 4 the next friend to loose will be at index 0\\n\\n![image.png](https://assets.leetcode.com/users/images/2821b9b5-ea44-43d3-ab13-6289a6b2dc34_1669363225.32804.png)\\n\\n### In linear way\\n\\n![image.png](https://assets.leetcode.com/users/images/b51242ec-1a48-428a-8cfe-831d632380d7_1669363437.5197673.png)\\n\\nThere are 6 friends now seating in circular fashion and their indices are\\n4 5 6 0 1 2\\nSo we need to find out which friend will leave the queue if there are 6 friends and k is 4. (k has not changed.)\\n\\n![image.png](https://assets.leetcode.com/users/images/e5677ad2-a0e1-4e4c-a7e5-71b54407da71_1669363806.16414.png)\\n\\nKeep faith in recursion that it will return correct result for n=6 and k=4\\n\\nbut after the results will be returned we need to find out the relation between our current indices and index returned from the recursion.\\n\\nObserving first 3 element we can observe that after adding 4 to the indices are n=6 we can get indices of level n=7\\n\\n![image.png](https://assets.leetcode.com/users/images/a38d40f1-375c-4e1c-94f8-cafbccfdb251_1669364000.7314184.png)\\n\\nNow to iterate over start index again we will use modulus as it is circular queue.\\n\\nwe are at level n=7 , k = 4\\nthe formula for conversion will be \\n#### (findTheWinner(n-1) + k) % n\\n\\n![image.png](https://assets.leetcode.com/users/images/dbad1e65-d9f2-4556-bbca-f408d2c8f3c4_1672772120.906986.png)\\n\\n\\nThus we can retrieve the indices from the n-1 levels.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        return self.helper(n,k)+1\\n\\n    def helper(self, n:int, k:int)-> int:\\n        if(n==1):\\n            return 0\\n        prevWinner = self.helper(n-1, k)\\n        return (prevWinner + k) % n\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        return self.helper(n,k)+1\\n\\n    def helper(self, n:int, k:int)-> int:\\n        if(n==1):\\n            return 0\\n        prevWinner = self.helper(n-1, k)\\n        return (prevWinner + k) % n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149752,
                "title": "c-josephus-problem-best-explanation-recursion-queue",
                "content": "We need to return the last person standing after every ```k```th person leaves the circle.\\n\\n* Let\\'s say ```n = 6``` and ```k = 2```. \\n\\n* After killing the person standing at position ```2```, there are ```5``` people remaining. So we can solve this problem by calling ```f (5, 2)```.\\n\\n* But there\\'s a catch here. While solving the problem with ```5``` people and ```k = 2```, we start from at position ```1```. \\n\\n* But for ```f (6, 2)```, after killing ```2```, we start from ```3```. \\n\\n* See the image below:\\n![image](https://assets.leetcode.com/users/images/f904aba6-4dd4-4faa-b0cf-6e9c8d35ab15_1655183599.8877122.png)\\n\\n* So we need to convert the ```1``` of ```f (5, 2)``` to ```3```, ```2``` to ```4```, ```3``` to ```5```, ```4``` to ```6``` and ```5``` to ```1```.\\n\\n* Try doing ```(k-1)%n + 1```. It works!.\\n\\n* So we\\'ve defined the recursion function: ```f(n, k) = ( f(n-1, k) + (k-1) )%n + 1```.\\n\\n* Ofcourse``` f(1, k) = 1``` is the base condition.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n == 1) return 1;\\n        \\n        return (findTheWinner(n-1, k) + k-1) % n + 1;\\n    }\\n};\\n```\\n\\n**QUEUE:**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) q.push(i);\\n        \\n        while(q.size() > 1) {\\n            int i = k;\\n            while(i > 1) {\\n                auto f = q.front(); q.pop();\\n                q.push(f);\\n                i--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```k```\n```n = 6```\n```k = 2```\n```2```\n```5```\n```f (5, 2)```\n```5```\n```k = 2```\n```1```\n```f (6, 2)```\n```2```\n```3```\n```1```\n```f (5, 2)```\n```3```\n```2```\n```4```\n```3```\n```5```\n```4```\n```6```\n```5```\n```1```\n```(k-1)%n + 1```\n```f(n, k) = ( f(n-1, k) + (k-1) )%n + 1```\n``` f(1, k) = 1```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n == 1) return 1;\\n        \\n        return (findTheWinner(n-1, k) + k-1) % n + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) q.push(i);\\n        \\n        while(q.size() > 1) {\\n            int i = k;\\n            while(i > 1) {\\n                auto f = q.front(); q.pop();\\n                q.push(f);\\n                i--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158697,
                "title": "java-simple-using-arraylist",
                "content": "```\\n   public int findTheWinner(int n, int k) {\\n     \\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            ans.add(i);\\n        }\\n        int cur=0;\\n        while(ans.size()>1){\\n            cur=(cur+k-1)%ans.size();\\n            ans.remove(cur);\\n        }\\n        return ans.get(0);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   public int findTheWinner(int n, int k) {\\n     \\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            ans.add(i);\\n        }\\n        int cur=0;\\n        while(ans.size()>1){\\n            cur=(cur+k-1)%ans.size();\\n            ans.remove(cur);\\n        }\\n        return ans.get(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254512,
                "title": "c-simple-approach-using-josephus-solution-tc-o-n",
                "content": "int findTheWinner(int n, int k) {\\n        \\n        if(n==1) return n;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n            \\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "int findTheWinner(int n, int k) {\\n        \\n        if(n==1) return n;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n            \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152433,
                "title": "clean-python-3-doubly-linked-list-o-nk",
                "content": "Time: `O(nk)`\\nSpace: `O(n)`\\n```\\nclass ListNode(object):\\n    def __init__(self, val, prev=None, next=None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        head = prev = ListNode(1)\\n        for i in range(2, n+1):\\n            node = ListNode(i)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        head.prev = prev\\n        prev.next = head\\n        curr = head.prev\\n        while curr.next is not curr:\\n            for _ in range(k):\\n                curr = curr.next\\n            curr.prev.next = curr.next\\n            curr.next.prev = curr.prev\\n        return curr.val\\n```\\nSame idea with deque, credit to @JummyEgg\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = collections.deque(list(range(1, n + 1)))\\n        cnt = 0\\n        while len(q) > 1:\\n            cnt += 1\\n            val = q.popleft()\\n            if cnt % k: q.append(val)\\n        return q[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode(object):\\n    def __init__(self, val, prev=None, next=None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        head = prev = ListNode(1)\\n        for i in range(2, n+1):\\n            node = ListNode(i)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        head.prev = prev\\n        prev.next = head\\n        curr = head.prev\\n        while curr.next is not curr:\\n            for _ in range(k):\\n                curr = curr.next\\n            curr.prev.next = curr.next\\n            curr.next.prev = curr.prev\\n        return curr.val\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = collections.deque(list(range(1, n + 1)))\\n        cnt = 0\\n        while len(q) > 1:\\n            cnt += 1\\n            val = q.popleft()\\n            if cnt % k: q.append(val)\\n        return q[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633909,
                "title": "java-intuitive-solution-queue-approach-faster-than-95-easiest",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer>qu=new LinkedList<>() ;\\n        for(int i=1;i<=n;i++)\\n        {\\n            qu.offer(i);\\n        }\\n        while (qu.size()!=1)\\n        {\\n            for(int i=1;i<=k-1;i++)\\n            {\\n                qu.offer(qu.poll());\\n            }\\n            qu.poll();\\n        }\\n        return qu.poll();\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer>qu=new LinkedList<>() ;\\n        for(int i=1;i<=n;i++)\\n        {\\n            qu.offer(i);\\n        }\\n        while (qu.size()!=1)\\n        {\\n            for(int i=1;i<=k-1;i++)\\n            {\\n                qu.offer(qu.poll());\\n            }\\n            qu.poll();\\n        }\\n        return qu.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321253,
                "title": "c-easy-solution-queue",
                "content": "```\\nint findTheWinner(int n, int k) {\\n        queue<int> q;\\n        //pushing the elements from 1 to k in a queue\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int temp=k;    \\n            for(temp=k;temp>1;temp--){\\n                int first=q.front();\\n                q.pop();\\n                q.push(first);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n\\n\\n**Please Upvote if it was helpful**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nint findTheWinner(int n, int k) {\\n        queue<int> q;\\n        //pushing the elements from 1 to k in a queue\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int temp=k;    \\n            for(temp=k;temp>1;temp--){\\n                int first=q.front();\\n                q.pop();\\n                q.push(first);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n\\n\\n**Please Upvote if it was helpful**",
                "codeTag": "Unknown"
            },
            {
                "id": 1152581,
                "title": "java-1-liner-josephus-problem",
                "content": "# Just one line of code\\nThis is a standard Josephus problem. To learn more about it, visit [Josephus Problem](https://en.wikipedia.org/wiki/Josephus_problem#:~:text=In%20computer%20science%20and%20mathematics,a%20certain%20counting%2Dout%20game.). \\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return (n == 1) ? 1 : (findTheWinner(n - 1, k) + k - 1) % n + 1;\\n    }\\n}\\n```\\n\\n`Time Complexity : O(n)`",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return (n == 1) ? 1 : (findTheWinner(n - 1, k) + k - 1) % n + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726522,
                "title": "java-similar-to-josephus-problem",
                "content": "At first problem seems to be simple but circular sitting arrangement makes it a bit complex.\\n\\nTake a look to the given example:\\n**Tricky part** is to handle the ignoring part that once the number/node is removed how will our code come to know that it is removed from the game. \\n\\n\\n![image](https://assets.leetcode.com/users/images/813244c8-3213-4f8c-b76e-a1a31d84500c_1666285853.7795105.png)\\n\\nIf you draw all values of n from 1 to 5 with k = 2 to **understand the pattern** to be used for recursion \\n```\\nsolve(n, k) depends upon previous step, i.e. solve(n - 1, k), \\nsolve(n, k) = (solve(n - 1, k) + k) but what if it result in value greater than n? Then if it result in greater value then we will use mod of n with it \\n\\nn = 1, k = 2 --> winner = 1\\n\\tsolve(1, 2) = (0 + 2) % 1 = 0\\n\\nn = 2, k = 2 --> winner = 1\\n\\tsolve(2, 2) --> (solve(1, 2) + k) % n = (1 + 2) % 2 = 1 \\n\\nn = 3, k = 2 --> winner = 3\\n\\tsolve(3, 2) --> (solve(2, 2) + k) % n = (1 + 2) = 3\\n\\t\\nn = 4, k = 2 --> winner = 1\\n\\tsolve(4, 2) --> (solve(3, 2) + k) % n = (3 + 2) % 4 = 1\\n\\t\\nn = 5, k = 2 --> winner = 3\\n\\tsolve(5, 2) --> (solve(4, 2) + k) % n = (1 + 2) = 3\\n\\n```\\nCode\\n```\\nclass Solution {\\n    static int solve(int n, int k) {\\n\\t    /* if there is only one friend left */\\n        if (n == 1)\\n            return 0; \\n        return (solve(n - 1, k) + k) % n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n         return solve(n, k) + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nsolve(n, k) depends upon previous step, i.e. solve(n - 1, k), \\nsolve(n, k) = (solve(n - 1, k) + k) but what if it result in value greater than n? Then if it result in greater value then we will use mod of n with it \\n\\nn = 1, k = 2 --> winner = 1\\n\\tsolve(1, 2) = (0 + 2) % 1 = 0\\n\\nn = 2, k = 2 --> winner = 1\\n\\tsolve(2, 2) --> (solve(1, 2) + k) % n = (1 + 2) % 2 = 1 \\n\\nn = 3, k = 2 --> winner = 3\\n\\tsolve(3, 2) --> (solve(2, 2) + k) % n = (1 + 2) = 3\\n\\t\\nn = 4, k = 2 --> winner = 1\\n\\tsolve(4, 2) --> (solve(3, 2) + k) % n = (3 + 2) % 4 = 1\\n\\t\\nn = 5, k = 2 --> winner = 3\\n\\tsolve(5, 2) --> (solve(4, 2) + k) % n = (1 + 2) = 3\\n\\n```\n```\\nclass Solution {\\n    static int solve(int n, int k) {\\n\\t    /* if there is only one friend left */\\n        if (n == 1)\\n            return 0; \\n        return (solve(n - 1, k) + k) % n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n         return solve(n, k) + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051013,
                "title": "simple-recursion-josephus-problem-aditya-verma",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    //Josephus Problem\\n    \\n    void solve(int i ,int k , vector<int> &v, int &ans)\\n    {\\n        if(v.size()==1)\\n        {\\n            ans = v[0];\\n            return;\\n        }\\n        \\n        // index moves around to kill\\n        i = (i+k)%v.size();\\n        v.erase(v.begin() + i);        \\n        \\n        solve( i, k , v ,ans);\\n        \\n    }\\n    \\n    int findTheWinner(int n, int k) {\\n        \\n    vector<int> v(n,0);\\n    \\n    for(int i =0; i<n; i++) v[i] = i+1;\\n    k--;\\n    \\n    int ans;\\n    \\n    solve(0,k,v,ans);\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    //Josephus Problem\\n    \\n    void solve(int i ,int k , vector<int> &v, int &ans)\\n    {\\n        if(v.size()==1)\\n        {\\n            ans = v[0];\\n            return;\\n        }\\n        \\n        // index moves around to kill\\n        i = (i+k)%v.size();\\n        v.erase(v.begin() + i);        \\n        \\n        solve( i, k , v ,ans);\\n        \\n    }\\n    \\n    int findTheWinner(int n, int k) {\\n        \\n    vector<int> v(n,0);\\n    \\n    for(int i =0; i<n; i++) v[i] = i+1;\\n    k--;\\n    \\n    int ans;\\n    \\n    solve(0,k,v,ans);\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472212,
                "title": "c-josephus-problem-recursion-with-explanation",
                "content": "//In the given test case when 2 gets removed we are left with 3 4 5 1 now we will change the numbering of 3 4 5 1 //to 1 2 3 4 respectively and it will happen for all calls until n==1.Now while going back in  recursion we change //the numbers back to their original value using the formula **((ans+k-1)%n)+1**\\n\\n//if we started the count from 0 instead of 1, then the formula would have been **(ans+k)%n**\\n\\n\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        else{\\n        int ans=findTheWinner(n-1,k);\\n        int finalans=((ans+k-1)%n)+1;\\n        return finalans;\\n    }\\n    }\\n};\\n\\t//pls upvote if you like my solution :)",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1152461,
                "title": "java-list-solution",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for( int i = 0; i < n; i++ ){\\n            list.add(i+1);\\n        }\\n       \\n        return eliminate(list, 0, k-1);\\n    }\\n    private int eliminate(List<Integer> list, int start, int k){\\n        if(list.size() == 1)\\n            return list.get(0);\\n        start = (start+k) % list.size();\\n        list.remove(start);\\n        return eliminate(list, start, k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for( int i = 0; i < n; i++ ){\\n            list.add(i+1);\\n        }\\n       \\n        return eliminate(list, 0, k-1);\\n    }\\n    private int eliminate(List<Integer> list, int start, int k){\\n        if(list.size() == 1)\\n            return list.get(0);\\n        start = (start+k) % list.size();\\n        list.remove(start);\\n        return eliminate(list, start, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403097,
                "title": "find-the-winner-of-circular-game-josephus-problem-java-recursive-approach",
                "content": "```\\nclass Solution {\\n    int output = -1;\\n    \\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t}\\n        permutationFind(n, k - 1, 0, list);\\n\\t\\treturn output;\\n    }\\n    \\n    public void permutationFind(int n, int k, int index, ArrayList<Integer> list) {\\n        /* base condition */\\n\\t\\tif (n == 1) {\\n\\t\\t\\toutput = list.get(0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n        index = (index + k) % list.size();\\n\\t\\tlist.remove(index);\\n\\n        /* hypothesis */\\n\\t\\tpermutationFind(n - 1, k, index, list);\\n\\t}\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int output = -1;\\n    \\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t}\\n        permutationFind(n, k - 1, 0, list);\\n\\t\\treturn output;\\n    }\\n    \\n    public void permutationFind(int n, int k, int index, ArrayList<Integer> list) {\\n        /* base condition */\\n\\t\\tif (n == 1) {\\n\\t\\t\\toutput = list.get(0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n        index = (index + k) % list.size();\\n\\t\\tlist.remove(index);\\n\\n        /* hypothesis */\\n\\t\\tpermutationFind(n - 1, k, index, list);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331147,
                "title": "c-iterative-and-recursive-solution-100-faster",
                "content": "Iterative\\n```\\n  /*josephus problem*/\\nclass Solution {\\npublic:\\n    int res=0;\\n    int findTheWinner(int n, int k) {\\n      \\n     \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n    return res+1;\\n    }\\n};\\n```\\n\\nRecursion\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        \\n        solve(v,k-1,0);\\n        \\n        return v[0];\\n    }\\n    \\n    void solve(vector<int>&v, int k, int i)\\n    {\\n        if(v.size()==1)\\n            return ;\\n        \\n        int index = (i+k)%v.size();\\n        v.erase(v.begin()+index);\\n        solve(v,k,index) ;\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  /*josephus problem*/\\nclass Solution {\\npublic:\\n    int res=0;\\n    int findTheWinner(int n, int k) {\\n      \\n     \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n    return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        \\n        solve(v,k-1,0);\\n        \\n        return v[0];\\n    }\\n    \\n    void solve(vector<int>&v, int k, int i)\\n    {\\n        if(v.size()==1)\\n            return ;\\n        \\n        int index = (i+k)%v.size();\\n        v.erase(v.begin()+index);\\n        solve(v,k,index) ;\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315446,
                "title": "c-josephus-problem-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        if (n == 1)\\n            return n;\\n        return (((findTheWinner(n - 1, k) + k - 1 ) % n) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        if (n == 1)\\n            return n;\\n        return (((findTheWinner(n - 1, k) + k - 1 ) % n) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152946,
                "title": "java-queue",
                "content": "```\\npublic int findTheWinner(int n, int k) {\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=1;i<=n;i++) queue.offer(i);\\n\\twhile(queue.size() > 1) {\\n\\t\\tfor(int i=0;i<k-1;i++)\\n\\t\\t\\tqueue.offer(queue.poll());\\n\\t\\tqueue.poll();\\n\\t}\\n\\treturn queue.poll();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheWinner(int n, int k) {\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=1;i<=n;i++) queue.offer(i);\\n\\twhile(queue.size() > 1) {\\n\\t\\tfor(int i=0;i<k-1;i++)\\n\\t\\t\\tqueue.offer(queue.poll());\\n\\t\\tqueue.poll();\\n\\t}\\n\\treturn queue.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152488,
                "title": "python-one-loop-with-slicing",
                "content": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        r, i = [e for e in range(1,n+1)], 0\\n        while len(r)>1:\\n            i = (i+k-1)%len(r)\\n            r = r[:i]+r[i+1:]\\n        return r[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        r, i = [e for e in range(1,n+1)], 0\\n        while len(r)>1:\\n            i = (i+k-1)%len(r)\\n            r = r[:i]+r[i+1:]\\n        return r[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152472,
                "title": "c-using-recursion-only-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648100,
                "title": "3-lines-solution-better-than-100-in-runtime-better-than-98-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we know winner of n - 1 friends, we can easily know the winner of n friends.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake the example as n = 5 and k = 3:\\nif only 1 person had been there, then winner = 1\\nnow 2nd person comes, move two times: 1 -> 2 -> 1 -> 2 winner = 2\\nnow 3rd person comes, move two times: 1 -> 2 -> 3 -> 1 winner = 1\\nnow 4th person comes, move two times: 3 -> 4 -> 1 -> 2 winner = 2\\nnow 5th person comes, move two times: 1 -> 2 -> 3 -> 4 winner = 4\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788850,
                "title": "c-winner-of-the-circular-game-using-queue-itretive-approach",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int x=k;\\n            while(x>1){\\n                int f=q.front();\\n                q.pop();\\n                q.push(f);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\nif it helps plzz don\\'t forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int x=k;\\n            while(x>1){\\n                int f=q.front();\\n                q.pop();\\n                q.push(f);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\nif it helps plzz don\\'t forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666619,
                "title": "c-iterative-solution-with-linear-space-complexity",
                "content": "# Intuition\\nThink about the recursive approach\\n\\n# Approach\\nBasically, we know that at last, who ever gets the kth turn is lost. Now this k is including the current player, so if the current player is x, we know x+k, will be the person just after person eliminated. At last, the person \\'just after the person eliminated\\' on the table will be the winner. So in the recursion, one can say that base condition is number of players (n) == 1, so answer is the player sitting at index 0. For rest of the number of players (2 to n), we know that answer will be-> F(n) = (F(n-1)+k)%n, so we can have a recursion for that, but recursion stack will make space complexity O(n). So instead of recursion we have an iterative approach. \\nAtlast, add +1 to the index found, cause our index starts from 0 but player\\'s index starts from 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int n, int k)\\n    {\\n        int ans = 0;\\n        for(int i=2; i<=n; i++)\\n            ans = (ans+k)%i;\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n, int k)\\n    {\\n        int ans = 0;\\n        for(int i=2; i<=n; i++)\\n            ans = (ans+k)%i;\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561365,
                "title": "java-easy-arraylist-clean-readable-easy-understanding-code-josephus-problem",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=1;i<=n;i++) al.add(i);\\n        int index=0;\\n        while(al.size()>1){\\n            index=(index+k-1)%(al.size());\\n            al.remove(index);\\n        }\\n        return al.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=1;i<=n;i++) al.add(i);\\n        int index=0;\\n        while(al.size()>1){\\n            index=(index+k-1)%(al.size());\\n            al.remove(index);\\n        }\\n        return al.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528009,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        k = k-1\\n        index = 0\\n        li = [i for i in range(1,n+1)]\\n        def cal(k,index):\\n            if len(li) == 1:\\n                return li[0]\\n            index = (index + k)% len(li)\\n            del li[index]\\n            return cal(k,index)\\n        return cal(k,index)\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        k = k-1\\n        index = 0\\n        li = [i for i in range(1,n+1)]\\n        def cal(k,index):\\n            if len(li) == 1:\\n                return li[0]\\n            index = (index + k)% len(li)\\n            del li[index]\\n            return cal(k,index)\\n        return cal(k,index)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043294,
                "title": "c-recursive-approach-easy-to-understand",
                "content": "**//PLEASE UPVOTE IF IT IS HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840889,
                "title": "4-solutions",
                "content": "**straightforward simulation/tombstones**\\n**time: `O(n*n)`; space: `O(n)`**\\n![image](https://assets.leetcode.com/users/images/5510dad9-fe1d-4860-a75a-18e8353c4a37_1647281429.7793665.png)\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint t{};\\n\\tfor(int m{n}, v[500]{} ; m; --m)\\n\\t{           \\n\\t\\tfor(int c{k-1}; c; t=(t+1)%n)\\n\\t\\t\\tc -= 1-v[t];\\n\\t\\tfor( ; v[t]; t=(t+1)%n);\\n\\t\\tv[t] = 1;\\n\\t}\\n\\treturn t+1;\\n}\\n```\\n**\"linked-list\" simulation**\\n**time: `O(n*k)`; space: `O(n)`**\\n![image](https://assets.leetcode.com/users/images/c3b694a7-3c41-4b81-be8e-9558877b315e_1647281583.6727467.png)\\n\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tif(k==1) return n;\\n\\tint v[500]{};\\n\\tiota(begin(v), begin(v)+n-1, 1);\\n\\n\\tint t{};\\n\\tfor( ; v[t]!=t; )\\n\\t{   \\n\\t\\tfor(int i{k-1}; --i; t = v[t]);\\n\\t\\tt = v[t] = v[v[t]];\\n\\t}\\n\\treturn t+1;\\n}\\n```\\n**dp/recursion/top-bottom**\\n**time: `O(n)`; space: `O(n)(recursion stack)`**\\n![image](https://assets.leetcode.com/users/images/87890844-e9a0-4673-b294-bfe1bb76829d_1647278821.084183.png)\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n   return n==1 ? 1 : (findTheWinner(n-1, k)+k-1)%n+1;\\n}\\n```\\n**dp/iteration/bottom-top**\\n**time: `O(n)`; space: `O(1)`**\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint out{1};\\n\\tfor(int i{2}; i<=n; ++i)\\n\\t\\tout = (out+k-1)%i+1;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findTheWinner(int n, int k) \\n{\\n\\tint t{};\\n\\tfor(int m{n}, v[500]{} ; m; --m)\\n\\t{           \\n\\t\\tfor(int c{k-1}; c; t=(t+1)%n)\\n\\t\\t\\tc -= 1-v[t];\\n\\t\\tfor( ; v[t]; t=(t+1)%n);\\n\\t\\tv[t] = 1;\\n\\t}\\n\\treturn t+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tif(k==1) return n;\\n\\tint v[500]{};\\n\\tiota(begin(v), begin(v)+n-1, 1);\\n\\n\\tint t{};\\n\\tfor( ; v[t]!=t; )\\n\\t{   \\n\\t\\tfor(int i{k-1}; --i; t = v[t]);\\n\\t\\tt = v[t] = v[v[t]];\\n\\t}\\n\\treturn t+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n   return n==1 ? 1 : (findTheWinner(n-1, k)+k-1)%n+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint out{1};\\n\\tfor(int i{2}; i<=n; ++i)\\n\\t\\tout = (out+k-1)%i+1;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839508,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 45 ms, faster than 77.07% of Python3 online submissions for Find the Winner of the Circular Game.\\n# Memory Usage: 13.9 MB, less than 61.73% of Python3 online submissions for Find the Winner of the Circular Game.\\nclass Solution:\\n    def findTheWinner(self, n, k):\\n        result, start = [i for i in range(1,n+1)], 0\\n        while len(result)>1:\\n            loser = (start+k-1)%len(result)\\n            del result[loser]\\n            start = loser if loser<=len(result) else 0\\n        return result[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 45 ms, faster than 77.07% of Python3 online submissions for Find the Winner of the Circular Game.\\n# Memory Usage: 13.9 MB, less than 61.73% of Python3 online submissions for Find the Winner of the Circular Game.\\nclass Solution:\\n    def findTheWinner(self, n, k):\\n        result, start = [i for i in range(1,n+1)], 0\\n        while len(result)>1:\\n            loser = (start+k-1)%len(result)\\n            del result[loser]\\n            start = loser if loser<=len(result) else 0\\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829183,
                "title": "c-solution-with-comments-and-example-using-queue-easy-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k == 1)\\n            return n;\\n        queue<int> q; // store friends from 1 to n\\n        for(int i = 1; i <= n; i++)\\n            q.push(i);\\n        int count = 1, temp;\\n        while(!q.empty() && q.size() > 1){\\n            if(count == k){ // leaves the circle\\n                q.pop();\\n                count = 1;\\n            }//end if\\n            else{\\n                temp = q.front();\\n                q.pop();\\n                q.push(temp); // make circle via move the front to the end \\n                count++;\\n            }//end else\\n        }//end while\\n        return q.front();\\n    }\\n};\\n\\n/*\\nFor example :\\nn = 5, k = 2\\n---------------\\nq = {1, 2, 3, 4, 5} count = 1 \\n1) q = {2, 3, 4, 5, 1} count++\\n2) q = {3, 4, 5, 1}    Friend 2 leaves ---> count = 1\\n3) q = {4, 5, 1, 3}    count++\\n4) q = {5, 1, 3}       Friend 4 leaves---> count = 1\\n5) q = {1, 3, 5}       count++\\n6) q = {3, 5}          Friend 1 leaves ---> count = 1 \\n6) q = {3}             Friend 5 leaves ---> count = 1 \\nfriend 3 is left, so they are the winner\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k == 1)\\n            return n;\\n        queue<int> q; // store friends from 1 to n\\n        for(int i = 1; i <= n; i++)\\n            q.push(i);\\n        int count = 1, temp;\\n        while(!q.empty() && q.size() > 1){\\n            if(count == k){ // leaves the circle\\n                q.pop();\\n                count = 1;\\n            }//end if\\n            else{\\n                temp = q.front();\\n                q.pop();\\n                q.push(temp); // make circle via move the front to the end \\n                count++;\\n            }//end else\\n        }//end while\\n        return q.front();\\n    }\\n};\\n\\n/*\\nFor example :\\nn = 5, k = 2\\n---------------\\nq = {1, 2, 3, 4, 5} count = 1 \\n1) q = {2, 3, 4, 5, 1} count++\\n2) q = {3, 4, 5, 1}    Friend 2 leaves ---> count = 1\\n3) q = {4, 5, 1, 3}    count++\\n4) q = {5, 1, 3}       Friend 4 leaves---> count = 1\\n5) q = {1, 3, 5}       count++\\n6) q = {3, 5}          Friend 1 leaves ---> count = 1 \\n6) q = {3}             Friend 5 leaves ---> count = 1 \\nfriend 3 is left, so they are the winner\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670710,
                "title": "recursive-solution-java",
                "content": "In this problem it can be clearly seen we need to divide it into further subproblems.\\nHence recursive approach is mostly followed.\\nFirst, we need to find the kth element.\\nIt can be simply found by the formula `(k+start)%n` where start is the position to start counting.\\nSince this position changes after every pass we will follow a reverse recursive approach i.e. implement recursion in a way such that the functional calls when popped from stack simulate the entire procedure.\\nThus, we will keep the base condition to return 0 so that the start initially is 0.\\nAnd then calculate.\\nThe code is as follows :\\n```\\n    class Solution {\\n        public int findTheWinner(int n, int k) {\\n            return helper(n,k)+1;\\n        }\\n        public int helper(int size, int k){\\n            if(size==1)return 0;\\n            return (helper(size-1,k)+k)%size;\\n        }\\n    }\\n```\\nPlease upvote if you found this helpful :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    class Solution {\\n        public int findTheWinner(int n, int k) {\\n            return helper(n,k)+1;\\n        }\\n        public int helper(int size, int k){\\n            if(size==1)return 0;\\n            return (helper(size-1,k)+k)%size;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571615,
                "title": "simple-c-solution-0ms-100-with-2-ways-just-2-lines",
                "content": "Solution using recursion\\nn = 2 -> the winner index is (0 + k) % 2 (base-0)\\nn = 3 -> the winner index is (f(2) + k) % 3 (base-0)\\nwith n -> the winner index is (f(n-1) + k) % n (base-0)\\n\\n```\\nint findTheWinner(int n, int k){\\n    if(n == 1) return 1;\\n    return (findTheWinner(n-1, k) + k - 1) % n + 1;\\n}\\n```\\n\\nSolution with linear time, O(1) extra space\\n```\\nint findTheWinner(int n, int k){\\n    int result = 0;\\n    for(int i = 1; i<=n; ++i)\\n        result = (result + k) % i;\\n    return result + 1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint findTheWinner(int n, int k){\\n    if(n == 1) return 1;\\n    return (findTheWinner(n-1, k) + k - 1) % n + 1;\\n}\\n```\n```\\nint findTheWinner(int n, int k){\\n    int result = 0;\\n    for(int i = 1; i<=n; ++i)\\n        result = (result + k) % i;\\n    return result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549751,
                "title": "python-deque",
                "content": "Idea is to rotate deque k times, and delete the last element\\n\\n```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n       \\n        d = collections.deque([i for i in range(1, n + 1)])\\n        while(len(d) != 1):\\n            d.rotate(-k)\\n            d.pop()\\n        return d.pop() \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n       \\n        d = collections.deque([i for i in range(1, n + 1)])\\n        while(len(d) != 1):\\n            d.rotate(-k)\\n            d.pop()\\n        return d.pop() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345985,
                "title": "java-josephus-problem-solution",
                "content": "This question is also known as **Josephus problem**.\\nThis problem states that:-\\n*there are **n** people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. Given the total number of persons **n** and a number  **k** which indicates that **k-1** persons are skipped and kth person is killed in circle. The task is to choose the place in the initial circle so that you are the last one remaining and so survive.*\\n Now we\\'ll use recursion as follows\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if (n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k) + k - 1) % n + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if (n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k) + k - 1) % n + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337153,
                "title": "queue-solution-c",
                "content": "**I was wondering if anyone had a solution using queue but couldn\\'t find one recently. So, here\\'s mine with queue implementation in C++, though it is not so fast.**\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) {\\n            q.push(i);\\n        }\\n        while(q.size() > 1) {\\n            for(int i=1; i<k; i++) {\\n               int x = q.front();\\n               q.pop();\\n               q.push(x);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) {\\n            q.push(i);\\n        }\\n        while(q.size() > 1) {\\n            for(int i=1; i<k; i++) {\\n               int x = q.front();\\n               q.pop();\\n               q.push(x);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985873,
                "title": "beginner-friendly-simple-solution-with-using-queue-ds-on-python3",
                "content": "# Intuition\\nLet\\'s briefly explain the task and provide some `pseudocode`:\\n```\\n# There\\'re n-friends, playing a game\\nfriends = [1,2,3,4,5]\\n\\n# at each step there\\'s an option to SKIP some players in order\\nn = 2\\ni = 0\\n\\n# to EXCLUDE the player, that the pointer has stopped on\\n# [1, (2), 3, 4, 5]\\n# i=1 i=2==k\\n\\nfriends = [1, 3, 4, 5]\\n\\n# the process continues UNTIL there will only ONE player\\nfriends = [3]\\n```\\nThis example leads us to create a `queue`, that\\'ll represent a source of players, that will leave the `queue`, when the `i` **points** at a particular player.\\n\\n# Approach\\n1. initialize a `q` and map `x+1` to the current player\\n2. create a loop, that\\'ll stop, when there\\'ll only **one player** inside of a `q`\\n3. at each `c = k-1` step exclude the participant, and continue to iterate\\n4. once there\\'is only one player, return it\\'s index from `q`\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque([x + 1 for x in range(n)])\\n\\n        while len(q) > 1:\\n            c = k - 1\\n\\n            while c:\\n                q.append(q.popleft())\\n                c -= 1\\n            \\n            q.popleft()\\n\\n        return q[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n# There\\'re n-friends, playing a game\\nfriends = [1,2,3,4,5]\\n\\n# at each step there\\'s an option to SKIP some players in order\\nn = 2\\ni = 0\\n\\n# to EXCLUDE the player, that the pointer has stopped on\\n# [1, (2), 3, 4, 5]\\n# i=1 i=2==k\\n\\nfriends = [1, 3, 4, 5]\\n\\n# the process continues UNTIL there will only ONE player\\nfriends = [3]\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque([x + 1 for x in range(n)])\\n\\n        while len(q) > 1:\\n            c = k - 1\\n\\n            while c:\\n                q.append(q.popleft())\\n                c -= 1\\n            \\n            q.popleft()\\n\\n        return q[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446043,
                "title": "find-the-winner-of-the-circular-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, idx=0, x;\\n\\n        // Make a array and store the integers from 1 to n\\n        vector<int> nums;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            nums.push_back(i+1);\\n        }\\n\\n        // In each iteration remove the element at position x and then update the value of x \\n        while(nums.size()>1)\\n        {\\n            x = (idx+k-1)%nums.size();\\n            nums.erase(nums.begin()+x);\\n            idx = (x)%nums.size();\\n        }\\n        return nums[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/555fb03e-4e6b-430c-9817-686986aeaa7f_1682612811.6249762.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, idx=0, x;\\n\\n        // Make a array and store the integers from 1 to n\\n        vector<int> nums;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            nums.push_back(i+1);\\n        }\\n\\n        // In each iteration remove the element at position x and then update the value of x \\n        while(nums.size()>1)\\n        {\\n            x = (idx+k-1)%nums.size();\\n            nums.erase(nums.begin()+x);\\n            idx = (x)%nums.size();\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303326,
                "title": "simple-python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums=[]\\n        for i in range(1,n+1):\\n            nums.append(i)\\n        j=0\\n        while len(nums)!=1:\\n           j=(j+k-1)%len(nums)\\n           nums.remove(nums[j])\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums=[]\\n        for i in range(1,n+1):\\n            nums.append(i)\\n        j=0\\n        while len(nums)!=1:\\n           j=(j+k-1)%len(nums)\\n           nums.remove(nums[j])\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964194,
                "title": "josephus-problem-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasily solved by Josephus\\' problem-solving method.\\nThe formula is (func(n-1,k)+k)%n; calculate in a recursive way and return the answer by adding 1, as 1 is the minimum number here.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\nAn iterative approach can solve it in O(1) SC.\\xA0\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n         if(n==1)return 0;\\n        return (((solve(n-1,k))+k)%n);\\n    }\\n    int findTheWinner(int n, int k) {\\n       return 1+solve(n,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n         if(n==1)return 0;\\n        return (((solve(n-1,k))+k)%n);\\n    }\\n    int findTheWinner(int n, int k) {\\n       return 1+solve(n,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749184,
                "title": "c-3-lines-easiest-approach",
                "content": "```\\n    int findTheWinner(int n, int k) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++) ans = (ans+k)%i;\\n        return ans+1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findTheWinner(int n, int k) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++) ans = (ans+k)%i;\\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736702,
                "title": "1ms-java-solution",
                "content": "```\\nclass Solution {\\n   public int findTheWinner(int n, int k) {\\n        return result(n, k - 1) + 1; // result here is finding the Winner Helper\\n    }\\n    \\n    private int result(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return ((k + 1) % n + result(n - 1, k)) % n;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int findTheWinner(int n, int k) {\\n        return result(n, k - 1) + 1; // result here is finding the Winner Helper\\n    }\\n    \\n    private int result(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return ((k + 1) % n + result(n - 1, k)) % n;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579859,
                "title": "queue-solution-python-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque(range(n))\\n        while len(q) > 1:\\n            for _ in range(k - 1):\\n                q.append(q.popleft())\\n            q.popleft()\\n        return q[0] + 1\\n    # Time: O(n * k)\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque(range(n))\\n        while len(q) > 1:\\n            for _ in range(k - 1):\\n                q.append(q.popleft())\\n            q.popleft()\\n        return q[0] + 1\\n    # Time: O(n * k)\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384915,
                "title": "java-josephus-problem-easy-recursion-approach-using-list",
                "content": "**Josephus Problem**\\n\\nEasy understanding recursive approach:\\n1. Create an **ArrayList** and initialize it with **1 to n**\\n2. Create a tracking variable **i** initially indexed at **0**\\n3. Call **help()** method to return; help() calls itself recursively\\n4. Move **i** to **(k-1)th** index from current position of i\\n5. remove **i th** element from list; therefore size of the list decreases\\n6. When we call it recursively and list size becomes 1, return the only left element of list\\n\\n```\\n /* Recursion using List */\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) list.add(i);\\n        return help(k, list, 0);\\n    }\\n    \\n    public int help(int k, List<Integer> list, int i){\\n        if(list.size() == 1) return list.get(0);\\n        i = (i + k - 1) % list.size();\\n        list.remove(i);\\n        return help(k, list, i);\\n    }\\n```\\n\\nHope it helps!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n /* Recursion using List */\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) list.add(i);\\n        return help(k, list, 0);\\n    }\\n    \\n    public int help(int k, List<Integer> list, int i){\\n        if(list.size() == 1) return list.get(0);\\n        i = (i + k - 1) % list.size();\\n        list.remove(i);\\n        return help(k, list, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377190,
                "title": "python-simple-queue-solution-no-recursion",
                "content": "**<<< Do uptvote if you liked my solution. If you have any queries I am happy to answer.**\\n\\nInitial queue = [5, 4, 3, 2, 1]\\nk = 2\\n\\nPop and Push k-1 friends to the back of queue\\n[1, 5, 4, 3, 2]\\n\\nPop front element\\n[1, 5, 4, 3] --> **2** (looses)\\n\\nRepeat\\n[3, 1, 5, 4]\\n[3, 1, 5] --> **4**\\n\\n[5, 3, 1]\\n[5, 3] --> **1**\\n\\n[3, 5]\\n[3] --> **5**\\n\\nWinner **3**!!\\n\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        queue = list(range(n, 0, -1))    #Creates list of n to 1\\n        cur_k = k - 1\\n        while len(queue) != 1:\\n            while cur_k != 0:\\n                queue.insert(0, queue.pop())    #Popping front element and pushing it to the end of queue\\n                cur_k -= 1\\n            queue.pop()      #Popping the friend that looses\\n            cur_k = k - 1    #Resetting\\n        \\n        return queue.pop()   #Winner\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        queue = list(range(n, 0, -1))    #Creates list of n to 1\\n        cur_k = k - 1\\n        while len(queue) != 1:\\n            while cur_k != 0:\\n                queue.insert(0, queue.pop())    #Popping front element and pushing it to the end of queue\\n                cur_k -= 1\\n            queue.pop()      #Popping the friend that looses\\n            cur_k = k - 1    #Resetting\\n        \\n        return queue.pop()   #Winner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374851,
                "title": "aditya-verma-c-solution-very-easy",
                "content": "class Solution {\\npublic:\\n    \\n   void solve(vector<int> v , int k , int index , int& ans)\\n    {\\n        //base case\\n        if(v.size()==1)\\n        {ans=v[0];\\n         return;\\n        }\\n       index =(index+k)%(v.size());\\n       v.erase(v.begin()+index);\\n       solve(v,k,index,ans);\\n    }\\n    \\n    \\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        int ans=-1,index=0;k--;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n         v.push_back(i);\\n        solve(v,k,index,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   void solve(vector<int> v , int k , int index , int& ans)\\n    {\\n        //base case\\n        if(v.size()==1)\\n        {ans=v[0];\\n         return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177733,
                "title": "learn-use-of-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        queue<int>q;\\n        int i;\\n        // so we are making queue and storing all the indexes in the queue\\n        for(i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        // now the basic priniciple of queue tells that the the number pops onj doing q.pop is the least recent num,bner added means if i added some number in thje first that will be removed first basically opposite of stack in stck it is lifo last in first out but in queue fifo first in first out\\n        //so we will iterate till size of q is greater than 1\\n        while(q.size()>1)\\n        {\\n            //now we will do the operation of removinbg and adding till each just one before kth number\\n            for(i=1;i<k;i++)\\n            {\\n                int temp = q.front();\\n                // we are stroing it in temp variable because we want to remobve and then add it\\n                q.pop();\\n                // nikal gya ab fir se add kr denge\\n                q.push(temp);\\n                \\n            }\\n            q.pop();\\n            // yahha k th nbumber nikal jkaega kyuki usko dynamically add or remove hmlog nhi kiye\\n        }\\n        int res = q.front();\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        queue<int>q;\\n        int i;\\n        // so we are making queue and storing all the indexes in the queue\\n        for(i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        // now the basic priniciple of queue tells that the the number pops onj doing q.pop is the least recent num,bner added means if i added some number in thje first that will be removed first basically opposite of stack in stck it is lifo last in first out but in queue fifo first in first out\\n        //so we will iterate till size of q is greater than 1\\n        while(q.size()>1)\\n        {\\n            //now we will do the operation of removinbg and adding till each just one before kth number\\n            for(i=1;i<k;i++)\\n            {\\n                int temp = q.front();\\n                // we are stroing it in temp variable because we want to remobve and then add it\\n                q.pop();\\n                // nikal gya ab fir se add kr denge\\n                q.push(temp);\\n                \\n            }\\n            q.pop();\\n            // yahha k th nbumber nikal jkaega kyuki usko dynamically add or remove hmlog nhi kiye\\n        }\\n        int res = q.front();\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913216,
                "title": "easy-c-solution-100-faster-self-explanatory",
                "content": "```\\n                      //Do upvote if this helps you :)\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int p=n;\\n        for(int i=1; i<=n; i++)\\n            v.push_back(i);\\n        k--;\\n        int j=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            v.erase(v.begin()+((k+j)%p));\\n            j=(k+j)%p;   \\n            p--; \\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n                      //Do upvote if this helps you :)\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int p=n;\\n        for(int i=1; i<=n; i++)\\n            v.push_back(i);\\n        k--;\\n        int j=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            v.erase(v.begin()+((k+j)%p));\\n            j=(k+j)%p;   \\n            p--; \\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851435,
                "title": "c-linked-list-approach-simple-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        ListNode *prev = NULL;\\n        int x = 1;\\n        \\n        // making linked list from the array \\n        for(int i=n; i>=1; i--){\\n            ListNode *temp = new ListNode(i);\\n            temp->next = prev;\\n            prev = temp;\\n        }\\n        \\n        // making it circular linked list\\n        ListNode *head = prev, *curr = prev;\\n        while(head->next != NULL) \\n            head = head->next;\\n        head->next = prev;\\n        \\n        if(k == 1)\\n            return n; // best case\\n        \\n        while(n != 1){\\n            if(x == k-1){\\n                curr->next = curr->next->next; // deleting the friend of k position\\n                x = 1;\\n                n--;\\n            }else\\n                x++;\\n            curr = curr->next;\\n        }\\n        \\n        return curr->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        ListNode *prev = NULL;\\n        int x = 1;\\n        \\n        // making linked list from the array \\n        for(int i=n; i>=1; i--){\\n            ListNode *temp = new ListNode(i);\\n            temp->next = prev;\\n            prev = temp;\\n        }\\n        \\n        // making it circular linked list\\n        ListNode *head = prev, *curr = prev;\\n        while(head->next != NULL) \\n            head = head->next;\\n        head->next = prev;\\n        \\n        if(k == 1)\\n            return n; // best case\\n        \\n        while(n != 1){\\n            if(x == k-1){\\n                curr->next = curr->next->next; // deleting the friend of k position\\n                x = 1;\\n                n--;\\n            }else\\n                x++;\\n            curr = curr->next;\\n        }\\n        \\n        return curr->val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1741852,
                "title": "3-java-solution-from-o-n-to-o-1-space-josephus-problem",
                "content": "For problem understanding watch ->\\nhttps://www.youtube.com/watch?v=uCsD3ZGzMgE&t=7s\\n# Recursive\\n```\\n public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tlist.add(i);\\n\\t\\t}\\n\\t\\treturn findTheWinner(0, k - 1, list);\\n\\t}\\n\\t//keep on removing till 1 element left\\n\\tprivate int findTheWinner(int start, int k, List<Integer> list) {\\n\\t\\tif (list.size() == 1) {\\n\\t\\t\\treturn list.get(0);\\n\\t\\t}\\n\\t\\t//index which needed to be removed.modulo used just to make with-in boundary of list\\n\\t\\tstart = (start + k) % list.size();\\n\\t\\tlist.remove(start);\\n\\t\\treturn findTheWinner(start, k, list);\\n\\t}\\n```\\n# Iterative\\n```\\npublic int findTheWinner(int n, int k) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tlist.add(i);\\n\\t}\\n\\tint start=0;\\n\\tk--;\\n\\twhile(list.size()>1) {\\n\\t\\tstart=(start+k)%list.size();\\n\\t\\tlist.remove(start);\\n\\t}\\n\\treturn list.get(0);\\n}\\n```\\n\\n# Approach 3-> constant space\\nWe can optimize the code and can remove use of list. since we need to delete kth person always.\\n\\n```\\npublic int findTheWinner(int n, int k) {\\n\\tint start=0;\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tstart=(start+k)%i;\\n\\t}\\n\\treturn start+1; //+1 is for converting 0-based index to 1-based index\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tlist.add(i);\\n\\t\\t}\\n\\t\\treturn findTheWinner(0, k - 1, list);\\n\\t}\\n\\t//keep on removing till 1 element left\\n\\tprivate int findTheWinner(int start, int k, List<Integer> list) {\\n\\t\\tif (list.size() == 1) {\\n\\t\\t\\treturn list.get(0);\\n\\t\\t}\\n\\t\\t//index which needed to be removed.modulo used just to make with-in boundary of list\\n\\t\\tstart = (start + k) % list.size();\\n\\t\\tlist.remove(start);\\n\\t\\treturn findTheWinner(start, k, list);\\n\\t}\\n```\n```\\npublic int findTheWinner(int n, int k) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tlist.add(i);\\n\\t}\\n\\tint start=0;\\n\\tk--;\\n\\twhile(list.size()>1) {\\n\\t\\tstart=(start+k)%list.size();\\n\\t\\tlist.remove(start);\\n\\t}\\n\\treturn list.get(0);\\n}\\n```\n```\\npublic int findTheWinner(int n, int k) {\\n\\tint start=0;\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tstart=(start+k)%i;\\n\\t}\\n\\treturn start+1; //+1 is for converting 0-based index to 1-based index\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635633,
                "title": "simple-java-solution-queue",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i=1;i<k;i++)\\n                q.offer(q.poll());\\n            q.poll();\\n        }\\n     return q.poll();   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i=1;i<k;i++)\\n                q.offer(q.poll());\\n            q.poll();\\n        }\\n     return q.poll();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604228,
                "title": "simple-golang-solution",
                "content": "```\\nfunc findTheWinner(n int, k int) int {\\n\\tif n == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tm := []int{}\\n\\t// 0 based indexing\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm = append(m, i)\\n\\t}\\n\\n    start := 0\\n\\tfor len(m) != 1 {\\n\\t\\tout := (start + k - 1) % len(m)\\n\\t\\t// delete element at index k\\n\\t\\tm = append(m[:out], m[out+1:]...)\\n\\t\\tstart = out\\n\\t}\\n\\n\\treturn m[0] + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findTheWinner(n int, k int) int {\\n\\tif n == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tm := []int{}\\n\\t// 0 based indexing\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm = append(m, i)\\n\\t}\\n\\n    start := 0\\n\\tfor len(m) != 1 {\\n\\t\\tout := (start + k - 1) % len(m)\\n\\t\\t// delete element at index k\\n\\t\\tm = append(m[:out], m[out+1:]...)\\n\\t\\tstart = out\\n\\t}\\n\\n\\treturn m[0] + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592907,
                "title": "fastest-c-solution-time-complexity-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int jos(int n, int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (jos(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return jos(n,k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jos(int n, int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (jos(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return jos(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567505,
                "title": "python-linked-list",
                "content": "The idea is just simulate the game using the linked list. We pass through the list and remove every `k`th element until we left with just one element.\\n\\nTime: in worst case when `n` === `k` we have to scan whole list until we remove an element so complexity is **O(n*k)** \\nSpace: **O(n)** for the linked list\\n\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n\\t\\tclass Node:\\n\\t\\t\\tdef __init__(self, val):\\n\\t\\t\\t\\tself.val = val\\n\\t\\t\\t\\tself.next = None\\n\\t\\t\\t\\t\\n        if n == 1:\\n            return 1\\n\\t\\t\\t\\t\\n        # create linked list\\n        head = Node(1)\\n        cur = head\\n        for i in range(2, n + 1):\\n            cur.next = Node(i)\\n            cur = cur.next\\n        \\n\\t\\t# connect tail to the head to create a circle\\n        cur.next = head\\n        \\n        i = 1\\n\\t\\t# remove each kth element\\n        while cur != cur.next:   \\n            if i % k == 0:\\n                cur.next = cur.next.next # remove element\\n            else:\\n                cur = cur.next\\n                \\n            i += 1\\n            \\n        return cur.val\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n\\t\\tclass Node:\\n\\t\\t\\tdef __init__(self, val):\\n\\t\\t\\t\\tself.val = val\\n\\t\\t\\t\\tself.next = None\\n\\t\\t\\t\\t\\n        if n == 1:\\n            return 1\\n\\t\\t\\t\\t\\n        # create linked list\\n        head = Node(1)\\n        cur = head\\n        for i in range(2, n + 1):\\n            cur.next = Node(i)\\n            cur = cur.next\\n        \\n\\t\\t# connect tail to the head to create a circle\\n        cur.next = head\\n        \\n        i = 1\\n\\t\\t# remove each kth element\\n        while cur != cur.next:   \\n            if i % k == 0:\\n                cur.next = cur.next.next # remove element\\n            else:\\n                cur = cur.next\\n                \\n            i += 1\\n            \\n        return cur.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502654,
                "title": "c-josephus-problem",
                "content": "class Solution\\n{\\npublic:\\n\\n    void solve(vector<int> &v, int k, int cont_1)\\n    {\\n        if (v.size() == 1)\\n        {\\n            return;\\n        }\\n\\n        cont_1 = ((cont_1 + k) % v.size());\\n        v.erase(v.begin() + cont_1);\\n        solve(v, k, cont_1);\\n    }\\n\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int cont_1 = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            v.push_back(i);\\n        }\\n        k -= 1;\\n        solve(v, k, cont_1);\\n        return v[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    void solve(vector<int> &v, int k, int cont_1)\\n    {\\n        if (v.size() == 1)\\n        {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1350541,
                "title": "josephus-problem-with-explanation",
                "content": "Formulating recursive solution:\\n\\n`function(n, k)` -> returns the winner if there are `n` players and `kth` players is killed in each step\\n`function(n-1, k)` -> return the winner if there are `n-1` players and `kth` players is killed in each step\\nand so on.\\n\\nIf the number of player is `n` then its ```0```   to `n-1` \\nIf the number of player is `n-1` then its `0`   to `n-2`\\n```\\n\\tfunction(n, k){\\n\\t\\tint winner = find(n-1, k)\\n\\t\\t// map the winner from the group of n-1 players to group of n players\\n\\t\\t// Let\\'s take an example of n = 6, and k = 3\\n\\t}\\n```\\n`n = 6, k = 3`\\nSo the `6` players are from `0` to `n - 1`, i.e ` 0 1 2 3 4 5`\\nAt first round 3rd players gets killed i.e player `2` will be killed.\\nSo, the remaining players are `0 1 ~ 3 4 5`\\n\\nNow, we\\'ll solve the problem for size `5` with players `0 1 2 3 4`  and we\\'ll map `(k + 1)`th player as a first player in new problem.\\n`` 0 1 2 3 4 5 `` -> `` 3 4 - 0 1 2 ``\\nSo if our subproblem of size `n-1` return `x` as a winner and original winner `y` can be derived by using \\n```  \\ny = (x + k) % n\\n```\\nSo our final solution to Josephus problem\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findWinner(n, k) + 1;   // 1 for converting 0 indexed to 1 indexed\\n    }\\n    \\n    public int findWinner(int n, int k){\\n        if(n == 1) return 0;\\n        int x = findWinner(n-1, k);\\n        int y = (x  + k )% n;\\n        return y;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```0```\n```\\n\\tfunction(n, k){\\n\\t\\tint winner = find(n-1, k)\\n\\t\\t// map the winner from the group of n-1 players to group of n players\\n\\t\\t// Let\\'s take an example of n = 6, and k = 3\\n\\t}\\n```\n```  \\ny = (x + k) % n\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findWinner(n, k) + 1;   // 1 for converting 0 indexed to 1 indexed\\n    }\\n    \\n    public int findWinner(int n, int k){\\n        if(n == 1) return 0;\\n        int x = findWinner(n-1, k);\\n        int y = (x  + k )% n;\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285122,
                "title": "c-clean-concise-code-100-one-liner-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return n==1 ? 1:((k + findTheWinner(n-1, k) - 1)%n + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return n==1 ? 1:((k + findTheWinner(n-1, k) - 1)%n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187817,
                "title": "4-line-solution-with-simple-explanation-100-time-98-space-could-be-tweaked-to-get-100",
                "content": "Let\\'s work 0-based so the first person has number 0. We will add 1 in the end to make up for that.\\n\\nAlso for a change let us assume that we start the game at position -k. After the first round we will end up at position 0. Subsequently we play the original game with n replaced by n-1. Assume we have already computed that w was the winner of the latter game, then it would also be the winner of the former game. But if we change the starting position from -k to 0 that only shifts the winner by k (mod n). So given that w is the winner of the game with n-1, the winner of the game with n is (w+k)%n.\\n\\nWe use this to iteratively determine the winner. If there is only one player (numbered 0), she is the winner. We then update the game for i=2 players, i=3 players up to i=n players and voila, we are done.\\n\\nWe could obtain optimum space complexity by getting rid of the iterator i, using n instead. Do you see how? This seems a bit contrived though.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int winner=0;\\n        for(int i=2;i < = n;++i)\\n            winner=(winner+k)%i;\\n        return winner+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int winner=0;\\n        for(int i=2;i < = n;++i)\\n            winner=(winner+k)%i;\\n        return winner+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1181024,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(1,n+1))\\n        i = 0\\n        while len(l) > 1:\\n            i = (i + k - 1)%len(l)\\n            l.pop(i)\\n        return l[0]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(1,n+1))\\n        i = 0\\n        while len(l) > 1:\\n            i = (i + k - 1)%len(l)\\n            l.pop(i)\\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159389,
                "title": "simple-c-solution-using-a-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (k==1) return n;\\n        queue<int> rotation;\\n        for (int i=1; i<=n; ++i) {\\n            rotation.push(i);\\n        }\\n        while (rotation.size()>1) {\\n            for (int i=1; i<k; ++i) {\\n                rotation.push(rotation.front());\\n                rotation.pop();\\n            }\\n            rotation.pop();\\n        }\\n        return rotation.front();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (k==1) return n;\\n        queue<int> rotation;\\n        for (int i=1; i<=n; ++i) {\\n            rotation.push(i);\\n        }\\n        while (rotation.size()>1) {\\n            for (int i=1; i<k; ++i) {\\n                rotation.push(rotation.front());\\n                rotation.pop();\\n            }\\n            rotation.pop();\\n        }\\n        return rotation.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152725,
                "title": "c-simple-o-n-josephus-circle-problem",
                "content": "```csharp\\npublic int FindTheWinner(int n, int k)\\n{\\n\\tint result = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tresult = (result + k) % i;\\n\\t}\\n\\n\\treturn result + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int FindTheWinner(int n, int k)\\n{\\n\\tint result = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tresult = (result + k) % i;\\n\\t}\\n\\n\\treturn result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152631,
                "title": "javascript-joseph-ring-rotated-array-100ms",
                "content": "reference:\\nhttps://en.wikipedia.org/wiki/Josephus_problem\\nhttps://programming.vip/docs/joseph-problem-of-data-structure-and-algorithms.html\\n```\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    for (let i = 0; i < n - 1; i++) {\\n        remove = (remove + k - 1) % (n - i);\\n        a.splice(remove, 1);\\n    } \\n    return a;\\n};\\n\\n////////////////////// Another version  124ms ////////////////\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    while (a.length > 1) {\\n        remove = (remove + k - 1) % a.length;\\n        a.splice(remove, 1);\\n    }\\n    return a;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    for (let i = 0; i < n - 1; i++) {\\n        remove = (remove + k - 1) % (n - i);\\n        a.splice(remove, 1);\\n    } \\n    return a;\\n};\\n\\n////////////////////// Another version  124ms ////////////////\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    while (a.length > 1) {\\n        remove = (remove + k - 1) % a.length;\\n        a.splice(remove, 1);\\n    }\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152611,
                "title": "python-5-lines",
                "content": "```python\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        remaining, index = [x for x in range(1,n+1)], 0\\n        while remaining:\\n            index = (index+k-1) % len(remaining)\\n            result = remaining.pop(index)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        remaining, index = [x for x in range(1,n+1)], 0\\n        while remaining:\\n            index = (index+k-1) % len(remaining)\\n            result = remaining.pop(index)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152502,
                "title": "short-easy-recursive-solution-1-liner-solution-w-explanation",
                "content": "We have following recursive structure - \\n\\n1. If last member remaining - **return 1**.\\n2. Recurse for remaining n - 1 members. Just `findTheWinner(n-1, k)` would mean that we are starting from 0. So, we adjust the new position by adding `k - 1` (denotes that we skip *`k - 1`* players) and modding with `n` for wrap-around. `+1` in the below equation accounts for the index starting from 1 and not from 0. \\n\\tSo final recursive equation becomes - **`1 + findTheWinner(n - 1, k) + k - 1) % n`**\\n\\n```\\nint findTheWinner(int n, int k) {\\n\\treturn (n == 1 ? 1 : 1 + (findTheWinner(n - 1, k) + k - 1) % n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheWinner(int n, int k) {\\n\\treturn (n == 1 ? 1 : 1 + (findTheWinner(n - 1, k) + k - 1) % n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152495,
                "title": "java-easy-to-understand-simulation-using-linkedlist",
                "content": "Java\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        // using linked list is easier to simulate and run faster\\n        LinkedList<Integer> ll = new LinkedList<>();\\n        for(int i = 1; i <= n; i++){\\n            ll.add(i);\\n        }\\n\\n        // follow the rules and remove the loser\\n        int ind = 0;\\n        while(ll.size() > 1){\\n            ind = ind + k-1;\\n            while(ind >= ll.size())\\n                ind -= ll.size();\\n            ll.remove(ind);\\n        }\\n        return ll.getFirst();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        // using linked list is easier to simulate and run faster\\n        LinkedList<Integer> ll = new LinkedList<>();\\n        for(int i = 1; i <= n; i++){\\n            ll.add(i);\\n        }\\n\\n        // follow the rules and remove the loser\\n        int ind = 0;\\n        while(ll.size() > 1){\\n            ind = ind + k-1;\\n            while(ind >= ll.size())\\n                ind -= ll.size();\\n            ll.remove(ind);\\n        }\\n        return ll.getFirst();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152410,
                "title": "c-easy-implemation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n    else\\n        return (findTheWinner(n - 1, k) + k-1) % n + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n    else\\n        return (findTheWinner(n - 1, k) + k-1) % n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909580,
                "title": "3-c-solutions-iterative-recursive-and-o-1-space-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Iterative approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        while(q.size() != 1){\\n            int count = 0;\\n            while(++count != k){\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        if(q.size() == 1)\\n            return;\\n\\n        int count = 0;\\n        while(++count != k){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        q.pop();\\n\\n        solve(q, k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// O(1) space approach\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Recursion",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n// Iterative approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        while(q.size() != 1){\\n            int count = 0;\\n            while(++count != k){\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        if(q.size() == 1)\\n            return;\\n\\n        int count = 0;\\n        while(++count != k){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        q.pop();\\n\\n        solve(q, k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// O(1) space approach\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595667,
                "title": "queue-c-easiest-explanation",
                "content": "# Intuition\\nEliminate a person after every k turns until a single person is left.\\nn and k have really small values. Simply simulate the process.\\n\\n# Approach\\n- Create a queue which initially contains numbers from 1 to n.\\n- For k-1 times, shift the first element of the queue to the end of the queue and pop the element from queue at the kth turn.\\n- Do above step until queue have only 1 element left which is the required answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int temp=k-1;\\n            while(temp>0){\\n                int t=q.front();\\n                q.pop();\\n                q.push(t);\\n                temp--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int temp=k-1;\\n            while(temp>0){\\n                int t=q.front();\\n                q.pop();\\n                q.push(t);\\n                temp--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476490,
                "title": "java-easy-solution-using-recursion-and-100-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int solve(int n,int k){\\n        if(n==1) return 0;\\n     return (solve(n-1,k)+k)%n;\\n     \\n    }\\n    public int findTheWinner(int n, int k) {\\n        return solve(n,k)+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int solve(int n,int k){\\n        if(n==1) return 0;\\n     return (solve(n-1,k)+k)%n;\\n     \\n    }\\n    public int findTheWinner(int n, int k) {\\n        return solve(n,k)+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409108,
                "title": "circular-linked-list-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    We can represent the circle using a queue of integers, where each integer corresponds to a person in the circle.\\n\\n    To simulate the elimination process, we can repeatedly remove the k-th person from the front of the queue and add them to the back of the queue until only one person is left.\\n\\n    Finally, we return the remaining person as the winner. Since the queue is 0-indexed, we need to add 1 to the result before returning it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Create a queue and add all the elements from 1 to n to the queue\\n    2. Start a loop until there is only one element remaining in the queue.\\n    3. In each iteration, remove k-1 elements from the front of the queue and add them to the rear of the queue.\\n    4. Remove the kth element from the front of the queue.\\n    5. Repeat steps 3-4 until only one element remains in the queue.\\n    6. The remaining element is the winner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = i + 1;\\n        }\\n\\n        int index = 0;\\n        while (n > 1) {\\n            // Move k steps in the linked list\\n            index = (index + k - 1) % n;\\n            // Remove the node at the current index\\n            nums.erase(nums.begin() + index);\\n            n--;\\n        }\\n\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = i + 1;\\n        }\\n\\n        int index = 0;\\n        while (n > 1) {\\n            // Move k steps in the linked list\\n            index = (index + k - 1) % n;\\n            // Remove the node at the current index\\n            nums.erase(nums.begin() + index);\\n            n--;\\n        }\\n\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361846,
                "title": "easy-solution-using-queue-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList();\\n\\n        for(int i = 1;i<n+1;i++){\\n            q.add(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i = k-1;i>0;i--){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n\\n        return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList();\\n\\n        for(int i = 1;i<n+1;i++){\\n            q.add(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i = k-1;i>0;i--){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308840,
                "title": "josephus-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findTheWinner(int n, int k) {\\n         if(n<=1)\\n            return 1;\\n        return ((findTheWinner(n-1,k)+k-1)%n)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findTheWinner(int n, int k) {\\n         if(n<=1)\\n            return 1;\\n        return ((findTheWinner(n-1,k)+k-1)%n)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251106,
                "title": "queue-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()>1){\\n            for(int i=0;i<k-1;i++){\\n                q.offer(q.remove());\\n            }\\n            q.remove();\\n        }\\n        return q.peek()+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()>1){\\n            for(int i=0;i<k-1;i++){\\n                q.offer(q.remove());\\n            }\\n            q.remove();\\n        }\\n        return q.peek()+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078610,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList();\\n\\n        for(int i = 0; i<n; i++){\\n            list.add(i+1);\\n        }\\n\\n        int ind = k-1;\\n\\n        while(list.size() != 1){\\n\\n            if(ind>=list.size() ){\\n\\n                ind = ind%list.size();                \\n            }\\n\\n            list.remove(ind);\\n            ind+=k-1;\\n        }\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList();\\n\\n        for(int i = 0; i<n; i++){\\n            list.add(i+1);\\n        }\\n\\n        int ind = k-1;\\n\\n        while(list.size() != 1){\\n\\n            if(ind>=list.size() ){\\n\\n                ind = ind%list.size();                \\n            }\\n\\n            list.remove(ind);\\n            ind+=k-1;\\n        }\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076604,
                "title": "0ms-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n\\n    }\\n    public int solve(int n,int k){\\n        if(n==1) return 0;\\n        return (solve(n-1,k)+k)%n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n\\n    }\\n    public int solve(int n,int k){\\n        if(n==1) return 0;\\n        return (solve(n-1,k)+k)%n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071585,
                "title": "0ms-100-faster-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int solve(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (solve(n-1,k)+k)%n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (solve(n-1,k)+k)%n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059116,
                "title": "simple-solution-using-recursion-josephus-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findAns(int n,int k){\\n        if(n==1)return 0;\\n        else\\n        return (findAns(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return findAns(n,k)+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findAns(int n,int k){\\n        if(n==1)return 0;\\n        else\\n        return (findAns(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return findAns(n,k)+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058518,
                "title": "flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion",
                "content": "\\n# Approach\\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# !!!PLZ UPVOTE IF YOU LIKE THE SOLUTION!!!\\n![WhatsApp Image 2023-01-16 at 5.05.00 PM.jpeg](https://assets.leetcode.com/users/images/46113a3c-1599-43ad-adcb-5234ea95788c_1673868980.7228653.jpeg)\\n\\n\\n**# Code\\n```\\nclass Solution {\\npublic:\\n    int myjos(int n, int k)\\n    {\\n        //if n is itself 1 then no matter how many k we took it will always come to that person so return 0.\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        //1)WHY n-1??\\n        //Because we want to decrease the number of persons as mentioned in the question.At one time we are decreasing one person at a time so n-1\\n\\n        //2)WHY +k??\\n        //I am attaching a page,while explaining look into that page.\\n        //Lets think like what would have happened if we have not inluded +k? \\n        //eg-: n=5 k=3 -->(let us consider n is from 0)-->0,1,2,3,4-->(delete 2)-->0,1,3,4-->now it should start from 3 as mentioned in question but what happens is it will again start from 0-->0,1,4 it is deleting 3 but in reality it should delete 1        \\n        else{\\n            return (myjos(n-1,k)+k)%n;\\n        }\\n    }\\n    int findTheWinner(int n, int k) {\\n        //myjos function is from 0 to n-1 i.e n is starting from 0 to n-1 so to start from 1 just add 1 to the function.\\n        return myjos(n,k)+1;\\n    }\\n};\\n```\\n# **!!!PLZ UPVOTE IF YOU LIKE THE SOLUTION!!!**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int myjos(int n, int k)\\n    {\\n        //if n is itself 1 then no matter how many k we took it will always come to that person so return 0.\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        //1)WHY n-1??\\n        //Because we want to decrease the number of persons as mentioned in the question.At one time we are decreasing one person at a time so n-1\\n\\n        //2)WHY +k??\\n        //I am attaching a page,while explaining look into that page.\\n        //Lets think like what would have happened if we have not inluded +k? \\n        //eg-: n=5 k=3 -->(let us consider n is from 0)-->0,1,2,3,4-->(delete 2)-->0,1,3,4-->now it should start from 3 as mentioned in question but what happens is it will again start from 0-->0,1,4 it is deleting 3 but in reality it should delete 1        \\n        else{\\n            return (myjos(n-1,k)+k)%n;\\n        }\\n    }\\n    int findTheWinner(int n, int k) {\\n        //myjos function is from 0 to n-1 i.e n is starting from 0 to n-1 so to start from 1 just add 1 to the function.\\n        return myjos(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945734,
                "title": "java-solution-using-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int rec(int n, int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (rec(n-1, k)+k)%n;\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        int ans = rec(n,k)+1;\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int rec(int n, int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (rec(n-1, k)+k)%n;\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        int ans = rec(n,k)+1;\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937048,
                "title": "python3-solutions",
                "content": "# Approach 1: Straight Forward\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] #setup player numbers\\n        idx = 0 #starting player index\\n        while len(players)>1:\\n            idx = (idx+k-1) % len(players) #get last counter player, mod len(remaining_players) to avoid out of bounds\\n            players.pop(idx) #pop because it\\'s faster than remove\\n        return players[0] #return last remaining player numbber\\n```\\n# Approach 2: Recurrsion\\n```\\nclass Solution:\\n    def sol(self, n, k, arr, i=0):\\n        if len(arr) == 1:\\n            return arr[0]\\n        else:\\n            index = (i + k - 1) % len(arr)\\n            arr.pop(index)\\n            i = index\\n            return self.sol(n, k, arr, i)\\n\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        arr = list(range(1, n + 1))\\n        return self.sol(n, k, arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] #setup player numbers\\n        idx = 0 #starting player index\\n        while len(players)>1:\\n            idx = (idx+k-1) % len(players) #get last counter player, mod len(remaining_players) to avoid out of bounds\\n            players.pop(idx) #pop because it\\'s faster than remove\\n        return players[0] #return last remaining player numbber\\n```\n```\\nclass Solution:\\n    def sol(self, n, k, arr, i=0):\\n        if len(arr) == 1:\\n            return arr[0]\\n        else:\\n            index = (i + k - 1) % len(arr)\\n            arr.pop(index)\\n            i = index\\n            return self.sol(n, k, arr, i)\\n\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        arr = list(range(1, n + 1))\\n        return self.sol(n, k, arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784018,
                "title": "how-recursion-brings-answer-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n\\n```\\n\\t// Lets understand with an example\\n\\t/*   n = 5   k = 2  x --> dead\\n\\t\\t 0 1 2 3 4\\n\\t\\t 0 x 2 x 4\\n\\t\\t x x 2 x x \\n\\t\\t 2(0 indexed) i.e 3(1 indexed) survives\\n\\t\\t \\n\\t\\t note : for any value of k if n = 1 then surviver is 1(1 indexed)\\n\\t\\t \\n\\t\\t we have n = 5 and k = 3\\n\\t\\t 1 2 3 4 5\\n\\t\\t 1 st kill is of 3 -->\\n\\t\\t 1 2 x 4 5\\n\\t\\t after this bring [1 2] to the end ->\\n\\t\\t 4 5 1 2 (here n becomes 4 and k is 2) \\n\\t\\t \\n\\t\\t lets map 1 2 3 4 with above values\\n\\t\\t i.e 1 -> 4 , 2 -> 5 , 3 -> 1 , 4 -> 2\\n\\t\\t \\n\\t\\t how these are related ?\\n\\t\\t 4 is (1 + 3) % 5 = 4 \\n\\t\\t 5 is (2 + 3) % 5 = 0 (needs special handelling)\\n\\t\\t 3 is (3 + 3) % 5 = 1\\n\\t\\t 4 is (4 + 3) % 5 = 2\\n\\t\\t \\n\\t\\t in genral y is (x + k) % n\\n\\t\\t \\n\\t\\t we repeat the above till only 1 player remains and as we always index him as 1, by using \\n\\t\\t the formula we go on converting back the value and we arrive at the answer\\n\\t*/\\n```\\n\\tpublic int findTheWinner(int n, int k) {\\n        if(n == 1)\\n            return 1;\\n        \\n        int x = findTheWinner(n - 1, k);\\n        int y = (x + k) % n;\\n        if(y == 0)\\n            return n;\\n        return y ;\\n    }\\n\\t\\n```\\n// to get clear idea you can watch this video (credits : pepcoding)\\n[https://www.youtube.com/watch?v=dzYq5VEMZIg&list=PL-Jc9J83PIiE-181crLG1xSIWhTGKFiMY&index=4](http://)",
                "solutionTags": [],
                "code": "```\\n\\t// Lets understand with an example\\n\\t/*   n = 5   k = 2  x --> dead\\n\\t\\t 0 1 2 3 4\\n\\t\\t 0 x 2 x 4\\n\\t\\t x x 2 x x \\n\\t\\t 2(0 indexed) i.e 3(1 indexed) survives\\n\\t\\t \\n\\t\\t note : for any value of k if n = 1 then surviver is 1(1 indexed)\\n\\t\\t \\n\\t\\t we have n = 5 and k = 3\\n\\t\\t 1 2 3 4 5\\n\\t\\t 1 st kill is of 3 -->\\n\\t\\t 1 2 x 4 5\\n\\t\\t after this bring [1 2] to the end ->\\n\\t\\t 4 5 1 2 (here n becomes 4 and k is 2) \\n\\t\\t \\n\\t\\t lets map 1 2 3 4 with above values\\n\\t\\t i.e 1 -> 4 , 2 -> 5 , 3 -> 1 , 4 -> 2\\n\\t\\t \\n\\t\\t how these are related ?\\n\\t\\t 4 is (1 + 3) % 5 = 4 \\n\\t\\t 5 is (2 + 3) % 5 = 0 (needs special handelling)\\n\\t\\t 3 is (3 + 3) % 5 = 1\\n\\t\\t 4 is (4 + 3) % 5 = 2\\n\\t\\t \\n\\t\\t in genral y is (x + k) % n\\n\\t\\t \\n\\t\\t we repeat the above till only 1 player remains and as we always index him as 1, by using \\n\\t\\t the formula we go on converting back the value and we arrive at the answer\\n\\t*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2770302,
                "title": "simple-approach-bf",
                "content": "# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(n))\\n        s = 0\\n        while len(l) > 1:\\n            i = (k%len(l) + s)%len(l)\\n            l = l[: i] + l[i+1: ]\\n            s = i-1\\n        return l[0] or n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(n))\\n        s = 0\\n        while len(l) > 1:\\n            i = (k%len(l) + s)%len(l)\\n            l = l[: i] + l[i+1: ]\\n            s = i-1\\n        return l[0] or n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706729,
                "title": "c-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>v, int i, int k){\\n        int n=v.size();\\n        if(n==1)\\n            return v[0];\\n        int nxt=(i+k-1)%n;\\n        v.erase(v.begin()+nxt);\\n       // nxt=(nxt+1)%(n);\\n        return f(v,nxt,k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n        }\\n        return f(v,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>v, int i, int k){\\n        int n=v.size();\\n        if(n==1)\\n            return v[0];\\n        int nxt=(i+k-1)%n;\\n        v.erase(v.begin()+nxt);\\n       // nxt=(nxt+1)%(n);\\n        return f(v,nxt,k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n        }\\n        return f(v,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583677,
                "title": "c-using-queue-data-structure",
                "content": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n     queue<int>circle;\\n        for(int i=1;i<=n;i++)\\n        {\\n            circle.push(i);\\n        }\\n        while(circle.size()!=1)\\n        {\\n            int kk=k;\\n            while(kk>1)\\n            {\\n                int f=circle.front();\\n                circle.pop();\\n                circle.push(f);\\n                kk--;\\n            }\\n            circle.pop();\\n        }\\n        return circle.front();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n     queue<int>circle;\\n        for(int i=1;i<=n;i++)\\n        {\\n            circle.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2576185,
                "title": "java-solution-arraylist",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            list.add(i);\\n        }\\n        \\n        int i = 0;\\n        while(list.size() > 1){\\n            i = i+k-1;\\n            i = i%list.size();\\n            list.remove(i);\\n        }\\n        \\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            list.add(i);\\n        }\\n        \\n        int i = 0;\\n        while(list.size() > 1){\\n            i = i+k-1;\\n            i = i%list.size();\\n            list.remove(i);\\n        }\\n        \\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549575,
                "title": "python-simple-logic-without-recursion",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[i for i in range(1,n+1)]\\n        start=0\\n        r=0\\n        while(len(l)!=1):\\n            r=(start + k-1)%len(l)\\n            l.pop(r)\\n            start=r\\n                \\n        return l[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[i for i in range(1,n+1)]\\n        start=0\\n        r=0\\n        while(len(l)!=1):\\n            r=(start + k-1)%len(l)\\n            l.pop(r)\\n            start=r\\n                \\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531293,
                "title": "java-queue-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new ArrayDeque<>();\\n        for(int i=1;i<=n;i++)q.offer(i);\\n        int ok=k;\\n        while(q.size()>1){\\n            k=ok;\\n            while(k-->1){\\n                q.offer(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new ArrayDeque<>();\\n        for(int i=1;i<=n;i++)q.offer(i);\\n        int ok=k;\\n        while(q.size()>1){\\n            k=ok;\\n            while(k-->1){\\n                q.offer(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460185,
                "title": "easy-java-solution-using-queue",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.add(i);\\n        }\\n        \\n        while(q.size()!=1){\\n            for(int i=0;i<k-1;i++){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2268868,
                "title": "simplest-explaination-time-0-n-space-o-1",
                "content": "As usual we follow zero-base indexing hence for n=5,k=3\\nFriends initially : 0 1 2 3 4\\n\\nwe keep removing friends a total for n-1 time\\nThus when only one friend (**winner**) is left we return its position as we know it will obviously be 0th position as it was only one left.\\nWe keep backtracking, using the previous position value to find the **winner** position at the currently backtracked cycle. To do this we put to use formula : **{(fn(n-1,k)+k)%n}**\\n\\nfinally we add 1 to the answer to get the final answer in 1 based indexing.\\n\\n```\\nvar findTheWinner = function(n, k) {\\n   let y=n;\\n    function ans(n,k){\\n        if(n==1){\\n            return 0;\\n        }\\n        else{\\n            return (ans(n-1,k)+k)%(n);    \\n        }\\n    }\\n    \\n    return ans(n,k)+1;\\n};\\n```\\n\\n***Do upvote if it helped ! TIA ;)***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvar findTheWinner = function(n, k) {\\n   let y=n;\\n    function ans(n,k){\\n        if(n==1){\\n            return 0;\\n        }\\n        else{\\n            return (ans(n-1,k)+k)%(n);    \\n        }\\n    }\\n    \\n    return ans(n,k)+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219645,
                "title": "python-easy-understand-clear-approach",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[]\\n        curr=0\\n        for i in range(n):\\n            l.append(i+1)\\n        while n>1:\\n            l.pop(((curr-1+k)%n))\\n            curr=(curr-1+k)%n\\n            n=n-1\\n        return l[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[]\\n        curr=0\\n        for i in range(n):\\n            l.append(i+1)\\n        while n>1:\\n            l.pop(((curr-1+k)%n))\\n            curr=(curr-1+k)%n\\n            n=n-1\\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212758,
                "title": "c-100ms-2-line-of-code",
                "content": "***DO UPVOTE IF IT HELPS !!***\\n\\n\\tint findTheWinner(int n, int k) {\\n        \\n        if(n==1) return 1;\\n        \\n        return (findTheWinner(n-1,k)+k-1)%(n) + 1;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!***\\n\\n\\tint findTheWinner(int n, int k) {\\n        \\n        if(n==1) return 1;\\n        \\n        return (findTheWinner(n-1,k)+k-1)%(n) + 1;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2183257,
                "title": "c-5-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        int res=0;\\n        while(q.size()!=1)\\n        {\\n            for(int i=1;i<k;i++)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n            \\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        int res=0;\\n        while(q.size()!=1)\\n        {\\n            for(int i=1;i<k;i++)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n            \\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156455,
                "title": "c-easy-solution-2-line-code-100-faster",
                "content": "**It is a Standard Josephus Problem\\nyou can search it on google you will find lot of content there**\\n\\n**C++ Easy Solution**\\n```\\n// It is a Josephus Problem\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**\\n\\n[](https://www.youtube.com/watch?v=ULUNeD0N9yI)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// It is a Josephus Problem\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142395,
                "title": "without-using-queue-c",
                "content": "Here\\'s My code\\n**EXPLANATION:-**\\n\\nmake a while loop untill the size of vector goes 1\\nkeep erasing the elements at kth position including just after the deleted element\\nafter erasing the vector automatically resizes itself and u are on the element next to\\nthe deleted position element now again move to the kth position and del that element \\n\\n**NOTE**\\nif u are exceeding the vector length then use modulo operator to be in range\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n    \\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(i+1);\\n        }\\n        \\n        int i=0,m;\\n     while(v.size()!=1)\\n     {\\n              m=k-1;\\n              if(v.size()==1)\\n                  break;\\n              while(m--)\\n              {\\n                   i++;       \\n              } \\n              i=i%v.size();\\n              \\n              v.erase(v.begin()+i);          \\n         }\\n        return v[0];\\n    }\\n};\\n```\\n\\nTHANK U\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n    \\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(i+1);\\n        }\\n        \\n        int i=0,m;\\n     while(v.size()!=1)\\n     {\\n              m=k-1;\\n              if(v.size()==1)\\n                  break;\\n              while(m--)\\n              {\\n                   i++;       \\n              } \\n              i=i%v.size();\\n              \\n              v.erase(v.begin()+i);          \\n         }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071722,
                "title": "python-straight-forward-simulation",
                "content": "It takes exactly ```n-1``` times to remove ```n-1``` people off the ```n```-person circle. In the simulation, we simply make a circle (which is just a list running from 0 to ```n-1```). \\n\\nNote that because we count ```k``` people inclusively each time, algorithmically we subtract ```k``` by one before we start the for-loop. \\n\\nEach time inside the for-loop, we calculate the index ```curr_pos``` at which the next \"victim\" would be (we need to take mod by the length of the circle here), and pop the \"victim\". Note that after popping, the ```curr_pos``` automatically takes care of going to the next person in the circle for the next round.\\n\\n```\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = list(range(n))\\n        curr_pos = 0\\n        k -= 1\\n        for i in range(n-1):\\n            curr_pos = (curr_pos + k) % (n-i)\\n            _ = circle.pop(curr_pos)\\n        return circle[0] + 1\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```n-1```\n```n-1```\n```n```\n```n-1```\n```k```\n```k```\n```curr_pos```\n```curr_pos```\n```\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = list(range(n))\\n        curr_pos = 0\\n        k -= 1\\n        for i in range(n-1):\\n            curr_pos = (curr_pos + k) % (n-i)\\n            _ = circle.pop(curr_pos)\\n        return circle[0] + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1963208,
                "title": "java-recursion",
                "content": "\\n1. Fill an ArrayList with the numbers from 1 to n.\\n2. Return a helper function.\\n3. The helper function takes a list of integers as argument, k and current k (current k is the value which has to be dropped from the game).\\n4. Update the current k, with the value that has to be dropped and call the recursion function until you are left with only one element in the arraylist and return it. \\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> lis = new ArrayList<Integer>();\\n        for(int i=1; i<=n; i++){\\n            lis.add(i);\\n        }\\n        return helper(lis, k, 0);        \\n    }\\n    private int helper(List<Integer> lis, int k, int curr){\\n        if(lis.size()==1){\\n            return lis.get(0);\\n        }\\n        //int cur = 0;\\n        curr = (curr+k-1)%lis.size();\\n        //k=k%lis.size();\\n        lis.remove(curr);\\n        return helper(lis, k, curr);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> lis = new ArrayList<Integer>();\\n        for(int i=1; i<=n; i++){\\n            lis.add(i);\\n        }\\n        return helper(lis, k, 0);        \\n    }\\n    private int helper(List<Integer> lis, int k, int curr){\\n        if(lis.size()==1){\\n            return lis.get(0);\\n        }\\n        //int cur = 0;\\n        curr = (curr+k-1)%lis.size();\\n        //k=k%lis.size();\\n        lis.remove(curr);\\n        return helper(lis, k, curr);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944207,
                "title": "one-line-code-c-faster-than-100-memory-usage-less-than-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n          int index=0;\\n        for(int i=1;i<=n;++i){\\n        index = (index+k)%i;\\n    }\\n        return index+1;\\n      }\\n};\\n```\\nENJOY !!!",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n          int index=0;\\n        for(int i=1;i<=n;++i){\\n        index = (index+k)%i;\\n    }\\n        return index+1;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912428,
                "title": "java-100-fast",
                "content": "Method1: Recursion 100% Fast\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k) + 1;\\n    }\\n    \\n    public int helper(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return (helper(n-1, k) + k) % n;\\n    }\\n}\\n```\\n\\nMethod2: Loop 81% Fast\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int res = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            res = (res + k) % i;\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k) + 1;\\n    }\\n    \\n    public int helper(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return (helper(n-1, k) + k) % n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int res = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            res = (res + k) % i;\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895622,
                "title": "java-recursive-iterative-both-beats-100",
                "content": "**--> RECURSIVE**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return recur(n,k)+1;\\n    }\\n    int recur(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (recur(n-1,k)+k)%n;\\n    }\\n}\\n```\\n**-->ITERATIVE**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans+1;\\n    }\\n}\\n```\\n**EXPLAINATION-**\\n-->Here we are eliminating  the kth person from the start and then starting the next recursion from (k+1)th person assuming it as the first person and subtracting 1 from n because 1 person is eliminated in each call reducing the total number of friends.when there is only one person left then he will be the winner and 0th person so we are returning 0 when n=1 and we are adding 1 to make it 1 indexed \\n\\n**DRY RUN**\\nn=5 and k=2\\n```\\n0 1 2 3 4 --> n=5,Eliminate 1\\n    2 3 4 0 -->n=4,Eliminate 3\\n\\t    4 0 2 -->n=3,Eliminate 0\\n\\t\\t    2 4-->n=2,Eliminate 4\\n\\t\\t\\t  2-->n=1\\n\\t\\t\\t  \\n\\t2+1=3 is winner\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return recur(n,k)+1;\\n    }\\n    int recur(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (recur(n-1,k)+k)%n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans+1;\\n    }\\n}\\n```\n```\\n0 1 2 3 4 --> n=5,Eliminate 1\\n    2 3 4 0 -->n=4,Eliminate 3\\n\\t    4 0 2 -->n=3,Eliminate 0\\n\\t\\t    2 4-->n=2,Eliminate 4\\n\\t\\t\\t  2-->n=1\\n\\t\\t\\t  \\n\\t2+1=3 is winner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882108,
                "title": "c-easy-solution-0-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\t\\n        queue<int> list;\\n        for(int i=1;i<=n;i++){\\n            list.push(i);\\n        }\\n        while(list.size()!=1){\\n            for(int j=1;j<k;j++){\\n                int r=list.front();\\n                list.push(r);\\n                list.pop();\\n            }\\n            list.pop();\\n        }\\n        return list.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\t\\n        queue<int> list;\\n        for(int i=1;i<=n;i++){\\n            list.push(i);\\n        }\\n        while(list.size()!=1){\\n            for(int j=1;j<k;j++){\\n                int r=list.front();\\n                list.push(r);\\n                list.pop();\\n            }\\n            list.pop();\\n        }\\n        return list.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796693,
                "title": "simplest-solution-easiest-to-understand-0ms-runtime-faster-than-100",
                "content": "Approach-1:\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        \\n        int res=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n        \\n        return res+1;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        \\n        int res=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n        \\n        return res+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734671,
                "title": "c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()!=1){\\n            int x = k;\\n            while(x>1){\\n                int a = q.front();\\n                q.pop();\\n                q.push(a);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()!=1){\\n            int x = k;\\n            while(x>1){\\n                int a = q.front();\\n                q.pop();\\n                q.push(a);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723325,
                "title": "simplest-recursive-solution-c-2-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return myjos(n,k)+1;\\n    }\\n        \\n    int myjos(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (myjos(n-1,k)+k)%n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return myjos(n,k)+1;\\n    }\\n        \\n    int myjos(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (myjos(n-1,k)+k)%n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712196,
                "title": "it-s-a-standard-josephus-problem",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;    //return ans+1 because the helper returns ans based on 0 based indexing\\n    }\\n    private int helper(int n, int k){\\n        if(n==1) return 0;    // base case\\n        \\n        return (helper(n-1, k)+k) % n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;    //return ans+1 because the helper returns ans based on 0 based indexing\\n    }\\n    private int helper(int n, int k){\\n        if(n==1) return 0;    // base case\\n        \\n        return (helper(n-1, k)+k) % n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691145,
                "title": "c-two-methods-very-simple-and-clear-solution-100-faster",
                "content": "```\\nint solve(int n, int k)\\n{\\n\\tif(n==1)\\n\\t\\treturn 0;\\n\\treturn (solve(n-1,k)+k)%n;\\n}\\n\\nint findTheWinner(int n, int k)\\n{\\n\\treturn solve(n, k)+1;\\n}\\n```\\n\\n```\\nint findTheWinner(int n, int k)\\n    {\\n        int res=0;\\n        for (int i=1; i<=n; i++)\\n            res=(res+k)%i;\\n        return res+1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint solve(int n, int k)\\n{\\n\\tif(n==1)\\n\\t\\treturn 0;\\n\\treturn (solve(n-1,k)+k)%n;\\n}\\n\\nint findTheWinner(int n, int k)\\n{\\n\\treturn solve(n, k)+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k)\\n    {\\n        int res=0;\\n        for (int i=1; i<=n; i++)\\n            res=(res+k)%i;\\n        return res+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688605,
                "title": "java-recursion-iterative-easy-self-explanatory",
                "content": "// Iterative \\n\\t\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)    \\n            list.add(i);\\n\\t\\t\\t\\n        int start = 0;\\n        while(list.size() > 1){\\n            int ind = (start+k-1)%list.size();\\n            list.remove(ind);\\n            start = (ind)%list.size();\\n        }\\n        return list.get(0);\\n    }\\n\\n \\n ```\\n //Recursion \\n \\n   public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)\\n            list.add(i);\\n        return josephus(n, k, 0, list);\\n    }\\n\\t\\n   public int josephus(int n, int k, int start, ArrayList<Integer> list){\\n        if(n > 1) {\\n            int curr = (start + k - 1 )% n;\\n            list.remove(list.get(curr));\\n            josephus(n - 1, k, curr, list);\\n        }\\n        return list.get(0);\\n    }\\n```\\n\\n\"Make sure to upVote if you understood\"",
                "solutionTags": [],
                "code": "```\\n //Recursion \\n \\n   public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)\\n            list.add(i);\\n        return josephus(n, k, 0, list);\\n    }\\n\\t\\n   public int josephus(int n, int k, int start, ArrayList<Integer> list){\\n        if(n > 1) {\\n            int curr = (start + k - 1 )% n;\\n            list.remove(list.get(curr));\\n            josephus(n - 1, k, curr, list);\\n        }\\n        return list.get(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646380,
                "title": "faster-than-100-and-memory-usage-beats-89-59-of-cpp-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int a = soln(n,k);\\n        a+=1;                   // added 1 in \\'a\\' as the index of a vector starts from 0;\\n        return a;\\n    }\\n\\n    int soln(int n, int k){\\n        if(n==1) return 0;      // return 0 when n=1;\\n        int x = soln(n-1, k);   // final element x always is 0 as returned when n=1;\\n        int y = (x+k) % n;      // the actual mapping of the final \\n                                // element to our original number of person ;\\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int a = soln(n,k);\\n        a+=1;                   // added 1 in \\'a\\' as the index of a vector starts from 0;\\n        return a;\\n    }\\n\\n    int soln(int n, int k){\\n        if(n==1) return 0;      // return 0 when n=1;\\n        int x = soln(n-1, k);   // final element x always is 0 as returned when n=1;\\n        int y = (x+k) % n;      // the actual mapping of the final \\n                                // element to our original number of person ;\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619957,
                "title": "c-deque-easy-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k==1) return n;\\n        deque<int> dq;\\n        \\n        for(int i=1; i<=n; i++){\\n            dq.push_back(i);\\n        }\\n        \\n        while(dq.size()!=1){\\n            for(int i=0; i<k-1; i++){\\n                int x = dq.front();\\n                dq.pop_front();\\n                dq.push_back(x);\\n            }\\n             dq.pop_front();\\n        }\\n         return dq.front();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k==1) return n;\\n        deque<int> dq;\\n        \\n        for(int i=1; i<=n; i++){\\n            dq.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615677,
                "title": "my-python-solution-deque",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circular_queue = deque(range(1, n+1))\\n        \\n        circular_queue.rotate(-k)\\n        while len(circular_queue) != 1:\\n            circular_queue.pop()\\n            circular_queue.rotate(-k)\\n        \\n        return circular_queue.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circular_queue = deque(range(1, n+1))\\n        \\n        circular_queue.rotate(-k)\\n        while len(circular_queue) != 1:\\n            circular_queue.pop()\\n            circular_queue.rotate(-k)\\n        \\n        return circular_queue.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598341,
                "title": "simple-js-solution-using-array",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    let friends = Array.from({length: n}, (_, index) => index + 1)\\n    let start = 0;\\n    while(friends.length != 1){\\n        start += (k - 1)\\n        start = start % friends.length\\n        friends.splice(start,1)\\n    }\\n    return friends[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    let friends = Array.from({length: n}, (_, index) => index + 1)\\n    let start = 0;\\n    while(friends.length != 1){\\n        start += (k - 1)\\n        start = start % friends.length\\n        friends.splice(start,1)\\n    }\\n    return friends[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580669,
                "title": "c-solution-queue-simulation",
                "content": "We can mimic the process with simple queue.\\nwe can remove the Kth element while we can rotate all else elements in the queue until there\\'s only one element exists which is our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        queue<int>q;\\n        for(auto i = 1;i<=n;i++)\\n            q.push(i);\\n        int kk = 1;\\n        while(q.size()!=1)\\n        {\\n            if(kk==k)\\n            {\\n                kk = 1;\\n                q.pop();\\n            }\\n            else\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                q.push(temp);\\n                kk++;\\n            }\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        queue<int>q;\\n        for(auto i = 1;i<=n;i++)\\n            q.push(i);\\n        int kk = 1;\\n        while(q.size()!=1)\\n        {\\n            if(kk==k)\\n            {\\n                kk = 1;\\n                q.pop();\\n            }\\n            else\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                q.push(temp);\\n                kk++;\\n            }\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561818,
                "title": "go-recursion-100",
                "content": "```\\nfunc findTheWinner(n int, k int) int {\\n    return joseph(n, k)\\n}\\n\\nfunc joseph(n int, k int) int {\\n    if n==1 {\\n        return 1\\n    }\\n    return (joseph(n-1, k)+k-1)%n+1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheWinner(n int, k int) int {\\n    return joseph(n, k)\\n}\\n\\nfunc joseph(n int, k int) int {\\n    if n==1 {\\n        return 1\\n    }\\n    return (joseph(n-1, k)+k-1)%n+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526389,
                "title": "0-ms-best-solution-recusion-3-line-code",
                "content": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(n==1){\\n           return 1; \\n        }\\n        int x = findTheWinner(n-1,k);\\n        int y = (x+k) % n==0 ? n :(x+k) % n ;\\n        return y;\\n                 \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(n==1){\\n           return 1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1473088,
                "title": "c-easy-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) { \\n        vector<int>v(n);\\n        for(int i=1;i<=n;i++)v[i-1]=i;\\n        int i=0;\\n        while(v.size()>1){ \\n            i=( (i+k-1) %v.size() );\\n            v.erase( v.begin()+i );\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) { \\n        vector<int>v(n);\\n        for(int i=1;i<=n;i++)v[i-1]=i;\\n        int i=0;\\n        while(v.size()>1){ \\n            i=( (i+k-1) %v.size() );\\n            v.erase( v.begin()+i );\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459225,
                "title": "java-clean-concise-optimal-code-josephus-problem-o-n-time",
                "content": "```\\nclass Solution {\\n    \\n    private int josephusProblem (int n, int k) {\\n        \\n        return n == 1 ? 0 : (josephusProblem (n - 1, k) + k) % n;\\n    }\\n    \\n    public int findTheWinner(int n, int k) {\\n        \\n        return 1 + josephusProblem (n, k);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int josephusProblem (int n, int k) {\\n        \\n        return n == 1 ? 0 : (josephusProblem (n - 1, k) + k) % n;\\n    }\\n    \\n    public int findTheWinner(int n, int k) {\\n        \\n        return 1 + josephusProblem (n, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441103,
                "title": "simple-c-code-using-vector",
                "content": "I am using vector to get index of next element to be deleted in O(1) time and then deleting the element using vector::erase() function.\\n```\\nint findTheWinner(int n, int k) {\\n\\tif(k==1)\\n\\t\\treturn n;\\n\\n\\tvector<int> v;\\n\\tfor(int i=1 ; i<=n ; ++i)\\n\\t\\tv.push_back(i);\\n\\n\\tint offset = 0;\\n\\twhile(v.size()>1) {\\n\\t\\toffset = (offset+k-1)%v.size();\\n\\t\\tv.erase(v.begin()+offset);\\n\\t}\\n\\treturn v[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findTheWinner(int n, int k) {\\n\\tif(k==1)\\n\\t\\treturn n;\\n\\n\\tvector<int> v;\\n\\tfor(int i=1 ; i<=n ; ++i)\\n\\t\\tv.push_back(i);\\n\\n\\tint offset = 0;\\n\\twhile(v.size()>1) {\\n\\t\\toffset = (offset+k-1)%v.size();\\n\\t\\tv.erase(v.begin()+offset);\\n\\t}\\n\\treturn v[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430864,
                "title": "c-one-line-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, res=0;\\n        for(i=1; i<=n; i++) res = (res + k) % i;\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, res=0;\\n        for(i=1; i<=n; i++) res = (res + k) % i;\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430861,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int n, int k){\\n        if(n==1) return 1;\\n        return (fun(n-1, k)+ k-1)% n +1;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return fun(n, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int n, int k){\\n        if(n==1) return 1;\\n        return (fun(n-1, k)+ k-1)% n +1;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return fun(n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398924,
                "title": "find-the-winner-of-the-circular-game-cpp-c-with-explanation",
                "content": "**Explanation**\\nThis is a classic josephus problem. It\\'s very easy to implement but the main part of this question is to understand that what it is saying. Let\\'s solve this together.\\n\\nSo, the question says, there are n friends sitting in a circle and we have also one more variable k. As the rule says, start from the 1st friend and count the next k friends in clockwise direction including the friend you started at. Now, the last friend you counted after k leaves the circle and loses the game. See figure below,\\n\\n![image](https://assets.leetcode.com/users/images/9376ff8c-443a-4a77-bc08-4e6b4258f516_1628752294.7855227.png)\\n\\nIn the figure you can see that n=5, and k=2. If you will dry run this example you will endup having 3 as a winner of the game. So, now we have understood the problem so far.\\n\\nNow, if we flatten the cirlce into an array, so it will be\\n`1, 2, 3, 4, 5` for `n = 5, k=2`\\n\\nNow, here we know that the players are leaving the game after the k count, or effectively we can say that the elements are getting deleted. Also, let\\'s design our hypothesis function that how it will work.\\n\\n![image](https://assets.leetcode.com/users/images/8baf6a95-cbb1-4328-b4cf-0c4391bbd90a_1628752433.7937167.png)\\n\\nWe can see that from the figure above the ele from the array is deleted after every call but there is one catch here. We can see that we are at 5 now from the above figure, but don\\'t know how to move further because if we do so we will have index overflow problem. So, to remove this we have to do something like, `index = (index + k) % v.size()`\\n\\nNow, we have solved the index overflow also. Now, we have everything set, Let\\'s talk about the base:\\n* If the array size is 1 then just return the element because we have a winner.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    //Time: O(N), Space: O(N)\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        \\n        k = k-1;\\n        int index = 0;\\n        int result = -1;\\n        helper(v, k, index, result);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& v, int k, int index, int& result){\\n        //Base condition\\n        if(v.size() == 1){\\n            result = v[0];\\n            return;\\n        }\\n        \\n        //handles the index overflow\\n        index = (index + k) % v.size();\\n        //player will leave the circle\\n        v.erase(v.begin() + index);\\n        helper(v, k, index, result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(N), Space: O(N)\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        \\n        k = k-1;\\n        int index = 0;\\n        int result = -1;\\n        helper(v, k, index, result);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& v, int k, int index, int& result){\\n        //Base condition\\n        if(v.size() == 1){\\n            result = v[0];\\n            return;\\n        }\\n        \\n        //handles the index overflow\\n        index = (index + k) % v.size();\\n        //player will leave the circle\\n        v.erase(v.begin() + index);\\n        helper(v, k, index, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354796,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> v, int idx, int k, int &ans){\\n        //base case\\n        if(v.size()==1){\\n            ans=v[0];\\n            return;\\n        }\\n        idx = (idx + k) % v.size();\\n        v.erase(v.begin() + idx);\\n        solve(v, idx, k, ans);\\n        \\n    }\\n    int findTheWinner(int n, int k) {\\n        vector<int> vec;\\n        for(int i = 1 ; i <= n ; i++){\\n            vec.push_back(i);\\n        }\\n        k = k - 1;\\n        int ans;\\n        solve(vec ,0, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> v, int idx, int k, int &ans){\\n        //base case\\n        if(v.size()==1){\\n            ans=v[0];\\n            return;\\n        }\\n        idx = (idx + k) % v.size();\\n        v.erase(v.begin() + idx);\\n        solve(v, idx, k, ans);\\n        \\n    }\\n    int findTheWinner(int n, int k) {\\n        vector<int> vec;\\n        for(int i = 1 ; i <= n ; i++){\\n            vec.push_back(i);\\n        }\\n        k = k - 1;\\n        int ans;\\n        solve(vec ,0, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344087,
                "title": "everyone-is-running-behind-the-suggested-ds-how-a-circular-linked-list-will-help-you",
                "content": "What if we can build a circular linked list ?\\n1->2->3->4->5->1, k=2,  currNode=1\\n1. Find (k-1)-th node from currNode and delete next of currNode.\\n2. Recure for remains linked list.\\n3. Base case :\\n\\t\\t1. \\t\\tIf you have linkedList of size 1, then just return the data at that node (Keep track of length so that you can find the length in each recursive call in constant time).\\n\\t\\t2. \\t\\tSecond base case which will violate our algo is when k=1, then in this case we have to delete our crrNode, so we wouldn\\'t able to linked the prev of currNode to the next of currNode, but wait; Is it really need to process k==1? No, We all know each time each player removed and at the end last one be remains.\\n\\n```\\nclass Solution {\\n   public:\\n    int solve(int k, Node* curr, int len) {\\n        if (len == 1) {\\n            return curr->data;\\n        }\\n        int x = 1;\\n        while (x < k - 1) {\\n            curr = curr->next;\\n            x++;\\n        }\\n        Node* del = curr->next;\\n        curr->next = del->next;\\n        delete del;\\n        return solve(k, curr->next, len - 1);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        if (k == 1) return n;\\n        Node *node = nullptr, *tell = nullptr;\\n        int i = 1;\\n        while (i <= n) {\\n            if (node == nullptr) {\\n                node = new Node(i);\\n                tell = node;\\n            } else {\\n                tell->next = new Node(i);\\n                tell = tell->next;\\n            }\\n            i++;\\n        }\\n        tell->next = node;\\n        return solve(k, node, n);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int solve(int k, Node* curr, int len) {\\n        if (len == 1) {\\n            return curr->data;\\n        }\\n        int x = 1;\\n        while (x < k - 1) {\\n            curr = curr->next;\\n            x++;\\n        }\\n        Node* del = curr->next;\\n        curr->next = del->next;\\n        delete del;\\n        return solve(k, curr->next, len - 1);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        if (k == 1) return n;\\n        Node *node = nullptr, *tell = nullptr;\\n        int i = 1;\\n        while (i <= n) {\\n            if (node == nullptr) {\\n                node = new Node(i);\\n                tell = node;\\n            } else {\\n                tell->next = new Node(i);\\n                tell = tell->next;\\n            }\\n            i++;\\n        }\\n        tell->next = node;\\n        return solve(k, node, n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294041,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        \\n        int store=findTheWinner(n-1,k)+k;\\n        if(store%n==0)\\n            return n;\\n        return store%n;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        \\n        int store=findTheWinner(n-1,k)+k;\\n        if(store%n==0)\\n            return n;\\n        return store%n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1252137,
                "title": "using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n       vector<int> temp;\\n        for(int i = 1;i<=n;i++)\\n            temp.push_back(i);\\n        int j = 0;\\n        while(temp.size()>1)\\n        {   int len = temp.size();\\n            j= (j+k-1)%len;\\n            temp.erase(temp.begin()+j);\\n            j--;\\n            j = (j+1)%temp.size();\\n        }\\n        return temp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n       vector<int> temp;\\n        for(int i = 1;i<=n;i++)\\n            temp.push_back(i);\\n        int j = 0;\\n        while(temp.size()>1)\\n        {   int len = temp.size();\\n            j= (j+k-1)%len;\\n            temp.erase(temp.begin()+j);\\n            j--;\\n            j = (j+1)%temp.size();\\n        }\\n        return temp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225476,
                "title": "c-recursion-time-o-n-space-o-n",
                "content": "```]\\nclass Solution {\\npublic:\\n    int find_winner(int n,int k){\\n         \\n        if(n == 1)\\n            return n;\\n        // this is a simple math that if n people are in a circle then remainder(k%n) shows the kth\\n        // person starting from 1 after (int)(k/n) complete cycles.\\n        // if remainder is 0 that means nth person is kth person starting \\n        // from 1 after (int)(k/n)  complete cycles.\\n        \\n        int killed = ( k % n == 0) ? n : (k % n);\\n        \\n        \\n        // getting the winner from (n-1,k) and mapping it with (n,k)\\n        // so mapping is like this:-\\n        // next person after killed person in circle(n,k) will be 1st person in new circle(n-1,k)\\n        // so suppose winner of the child circle (n-1,k) is w, then in the \\n        // parent circle (n,k), new winner is killed of(n,k) + w( that is winner(n-1,k) )\\n        // sometimes what happens is that killed(n,k) + w( that is winner(n-1,k) ) becomes more than n\\n        // that is why we want modulo of position of new winner with n once again\\n        \\n        int winner = killed + find_winner(n-1,k);\\n        return (winner % n == 0) ? n : (winner % n);\\n    }\\n    int findTheWinner(int n, int k) {\\n        \\n        return find_winner(n,k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find_winner(int n,int k){\\n         \\n        if(n == 1)\\n            return n;\\n        // this is a simple math that if n people are in a circle then remainder(k%n) shows the kth\\n        // person starting from 1 after (int)(k/n) complete cycles.\\n        // if remainder is 0 that means nth person is kth person starting \\n        // from 1 after (int)(k/n)  complete cycles.\\n        \\n        int killed = ( k % n == 0) ? n : (k % n);\\n        \\n        \\n        // getting the winner from (n-1,k) and mapping it with (n,k)\\n        // so mapping is like this:-\\n        // next person after killed person in circle(n,k) will be 1st person in new circle(n-1,k)\\n        // so suppose winner of the child circle (n-1,k) is w, then in the \\n        // parent circle (n,k), new winner is killed of(n,k) + w( that is winner(n-1,k) )\\n        // sometimes what happens is that killed(n,k) + w( that is winner(n-1,k) ) becomes more than n\\n        // that is why we want modulo of position of new winner with n once again\\n        \\n        int winner = killed + find_winner(n-1,k);\\n        return (winner % n == 0) ? n : (winner % n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1215438,
                "title": "java-bottom-up-dp-time-o-n-space-o-1",
                "content": "```\\npublic int findTheWinner(int n, int k) {\\n\\tint winner = 1;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\twinner = (winner+k-1)%i+1;\\n\\t}\\n\\treturn winner;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheWinner(int n, int k) {\\n\\tint winner = 1;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\twinner = (winner+k-1)%i+1;\\n\\t}\\n\\treturn winner;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197745,
                "title": "java-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {        \\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            list.add(i+1);\\n        }\\n        \\n        int ans = helper(list, k - 1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    private static int helper(List<Integer> list, int k, int index) {\\n        int size = list.size();\\n        \\n        if (size == 1) {\\n            return list.get(0);\\n        }\\n        \\n        index = (index + k) % size;\\n        list.remove(index);\\n        \\n        return helper(list, k, index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {        \\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            list.add(i+1);\\n        }\\n        \\n        int ans = helper(list, k - 1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    private static int helper(List<Integer> list, int k, int index) {\\n        int size = list.size();\\n        \\n        if (size == 1) {\\n            return list.get(0);\\n        }\\n        \\n        index = (index + k) % size;\\n        list.remove(index);\\n        \\n        return helper(list, k, index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158457,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        li = [i for i in range(1,n+1)]\\n        k = k-1\\n        offset = k\\n        while len(li) >1:\\n            li.pop(offset)\\n            offset = (offset+k) % len(li)\\n        return li[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        li = [i for i in range(1,n+1)]\\n        k = k-1\\n        offset = k\\n        while len(li) >1:\\n            li.pop(offset)\\n            offset = (offset+k) % len(li)\\n        return li[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155597,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func findTheWinner(_ n: Int, _ k: Int) -> Int {\\n        var friends = Array(1...n), loser = 0\\n        for i in 1..<n {\\n            loser = (loser + k - 1) % friends.count\\n            friends.remove(at: loser)\\n        }\\n        return friends.first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheWinner(_ n: Int, _ k: Int) -> Int {\\n        var friends = Array(1...n), loser = 0\\n        for i in 1..<n {\\n            loser = (loser + k - 1) % friends.count\\n            friends.remove(at: loser)\\n        }\\n        return friends.first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154159,
                "title": "c-1823-find-the-winner-of-the-circular-game",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n); \\n        for (int i = 0; i < n; ++i) \\n            nums[i] = i + 1; \\n        \\n        int i = 0; \\n        while (nums.size() > 1) {\\n            i = (i + k - 1) % nums.size(); \\n            nums.erase(nums.begin() + i); \\n        }\\n        return nums[0]; \\n    }\\n};\\n```\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0; \\n        for (int x = 2; x <= n; ++x)\\n            ans = (ans + k) % x; \\n        return ans + 1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n); \\n        for (int i = 0; i < n; ++i) \\n            nums[i] = i + 1; \\n        \\n        int i = 0; \\n        while (nums.size() > 1) {\\n            i = (i + k - 1) % nums.size(); \\n            nums.erase(nums.begin() + i); \\n        }\\n        return nums[0]; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0; \\n        for (int x = 2; x <= n; ++x)\\n            ans = (ans + k) % x; \\n        return ans + 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152920,
                "title": "java-list-simple-qn-query-reply-solution",
                "content": "Don\\'t be too picky!! Do what the question wants!!\\n```\\nclass Solution {\\n\\n\\tpublic int findTheWinner(int n, int k) {\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\tint lastInd = 0;\\n\\t\\twhile (list.size() != 1) {\\n\\t\\t\\tlastInd = (lastInd + k - 1) % (list.size());\\n\\t\\t\\tlist.remove(lastInd);\\n\\t\\t}\\n\\t\\treturn list.get(0);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tpublic int findTheWinner(int n, int k) {\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\tint lastInd = 0;\\n\\t\\twhile (list.size() != 1) {\\n\\t\\t\\tlastInd = (lastInd + k - 1) % (list.size());\\n\\t\\t\\tlist.remove(lastInd);\\n\\t\\t}\\n\\t\\treturn list.get(0);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152740,
                "title": "easy-queue-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue <int> q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()>1)\\n        {\\n            int t=k;\\n            while(--t>=1)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue <int> q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()>1)\\n        {\\n            int t=k;\\n            while(--t>=1)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152561,
                "title": "arraylist",
                "content": "```\\n    fun findTheWinner(n: Int, k: Int): Int {\\n        val group = ArrayList<Int>()\\n        for (i in 1..n) group.add(i)\\n        var prevIdx = 0\\n        while (group.size != 1) {\\n            val loserIdx = (prevIdx + k - 1) % group.size\\n            group.removeAt(loserIdx)\\n            prevIdx = loserIdx\\n        }\\n        return group[0]\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun findTheWinner(n: Int, k: Int): Int {\\n        val group = ArrayList<Int>()\\n        for (i in 1..n) group.add(i)\\n        var prevIdx = 0\\n        while (group.size != 1) {\\n            val loserIdx = (prevIdx + k - 1) % group.size\\n            group.removeAt(loserIdx)\\n            prevIdx = loserIdx\\n        }\\n        return group[0]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152503,
                "title": "c-simple-solution-with-comments-do-as-directed",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        //Temp array to hold the active candidates.\\n        vector<int> circular(n);        \\n        for(int i = 0; i< n; i++){\\n            circular[i] = i+1;            \\n        }\\n        \\n        \\n        int start = 0;        \\n        while(true){      \\n            //Check if only one element is remaining.\\n            if(circular.size() ==  1)\\n                break;\\n                        \\n            start += (k-1);                         //Add k to current (start is inclusive.)\\n            start %= circular.size();               //Array size is changing, remain in boundary\\n            circular.erase(circular.begin() + start);//Erase the selected candidate.\\n        }\\n        \\n        return circular[0]; //Return the winner, only 1st element.                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        //Temp array to hold the active candidates.\\n        vector<int> circular(n);        \\n        for(int i = 0; i< n; i++){\\n            circular[i] = i+1;            \\n        }\\n        \\n        \\n        int start = 0;        \\n        while(true){      \\n            //Check if only one element is remaining.\\n            if(circular.size() ==  1)\\n                break;\\n                        \\n            start += (k-1);                         //Add k to current (start is inclusive.)\\n            start %= circular.size();               //Array size is changing, remain in boundary\\n            circular.erase(circular.begin() + start);//Erase the selected candidate.\\n        }\\n        \\n        return circular[0]; //Return the winner, only 1st element.                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152444,
                "title": "c-using-list",
                "content": "```\\npublic int FindTheWinner(int n, int k) {\\n        var list = new List<int>();\\n        for (var i = 1; i <= n; i++)\\n            list.Add(i);\\n        \\n        var index = 0;\\n        while (list.Count > 1)\\n        {\\n            index = (index + k - 1) % list.Count;\\n            list.RemoveAt(index);\\n        }\\n        \\n        return list[0];\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int FindTheWinner(int n, int k) {\\n        var list = new List<int>();\\n        for (var i = 1; i <= n; i++)\\n            list.Add(i);\\n        \\n        var index = 0;\\n        while (list.Count > 1)\\n        {\\n            index = (index + k - 1) % list.Count;\\n            list.RemoveAt(index);\\n        }\\n        \\n        return list[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4052776,
                "title": "easy-cirular-linkelist",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(k==1){\\n            return n;\\n        }\\n        ListNode head =new ListNode(1);\\n        ListNode temp=head;\\n        for(int i=2; i<=n; i++){\\n            temp.next=new ListNode(i);\\n            temp=temp.next;\\n        }\\n        temp.next=head;\\n        int count=n;\\n        while(count>1){\\n            for(int i=1; i<k-1 ; i++){\\n                head=head.next;\\n            }\\n            head.next=head.next.next;\\n            head=head.next;\\n            --count;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(k==1){\\n            return n;\\n        }\\n        ListNode head =new ListNode(1);\\n        ListNode temp=head;\\n        for(int i=2; i<=n; i++){\\n            temp.next=new ListNode(i);\\n            temp=temp.next;\\n        }\\n        temp.next=head;\\n        int count=n;\\n        while(count>1){\\n            for(int i=1; i<k-1 ; i++){\\n                head=head.next;\\n            }\\n            head.next=head.next.next;\\n            head=head.next;\\n            --count;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046763,
                "title": "js-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036733,
                "title": "circular-linked-list-you-will-learn-so-many-concepts-from-my-code-check-it-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public class Node {\\n        int data;\\n        Node next;\\n\\n        public Node(int data) {\\n            this.data = data;\\n        }\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        Node prev = newone(n);\\n        Node curr=prev.next;\\n        \\n      \\n\\n        while (n > 1) {\\n            \\n            int count = (k-1) % n;\\n            while(count>0) {\\n                prev = curr;\\n                curr = curr.next;\\n                count--;\\n            }\\n\\n            prev.next = curr.next;\\n            curr = curr.next;\\n            n--;\\n        }\\n\\n        return curr.data;\\n    }\\n    public Node newone(int n)\\n    {\\n        Node first=new Node(1);\\n        Node curr=first;\\n        for (int i = 2; i <= n; i++) {\\n            Node temp=new Node(i);\\n            curr.next=temp;\\n            curr=temp;\\n\\n        }\\n        curr.next=first;\\n        return curr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public class Node {\\n        int data;\\n        Node next;\\n\\n        public Node(int data) {\\n            this.data = data;\\n        }\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        Node prev = newone(n);\\n        Node curr=prev.next;\\n        \\n      \\n\\n        while (n > 1) {\\n            \\n            int count = (k-1) % n;\\n            while(count>0) {\\n                prev = curr;\\n                curr = curr.next;\\n                count--;\\n            }\\n\\n            prev.next = curr.next;\\n            curr = curr.next;\\n            n--;\\n        }\\n\\n        return curr.data;\\n    }\\n    public Node newone(int n)\\n    {\\n        Node first=new Node(1);\\n        Node curr=first;\\n        for (int i = 2; i <= n; i++) {\\n            Node temp=new Node(i);\\n            curr.next=temp;\\n            curr=temp;\\n\\n        }\\n        curr.next=first;\\n        return curr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972902,
                "title": "simple-vector-solution-faster-than-100",
                "content": "# Intuition\\nCreating the temp vector: The vector is used to simulate the circle of people, with values from 1 to n representing the positions of individuals in the circle.\\n\\nThe while loop: This loop continues until there\\'s only one person left in the circle.\\n\\nCalculating t: In each iteration of the loop, the size of the temp vector is calculated (t = temp.size()). This represents the number of people remaining in the circle.\\n\\nUpdating i: The line i = (i + k - 1) % t is responsible for finding the position of the person to be eliminated in the current iteration. The i variable keeps track of the current position in the circle, and (i + k - 1) % t calculates the new position after counting k steps around the circle. The % t operation ensures that the counting wraps around when the end of the circle is reached.\\n\\nRemoving the person: The line temp.erase(temp.begin() + i) removes the person at the calculated position from the temp vector, simulating their elimination from the circle.\\n\\nLoop continues: The loop continues until there\\'s only one person left in the circle. This process models the elimination of every k-th person until only one person remains.\\n\\nReturning the winner: Once the loop finishes, the remaining person\\'s position is the winner of the game, and their position (index) in the temp vector is returned.\\n\\n# Approach\\nInitialization: Create a vector temp containing integers from 1 to n, representing the initial positions of people in the circle.\\n\\nLoop: Enter a loop that continues as long as there is more than one person remaining in the circle (temp.size() > 1).\\n\\nPosition Calculation (i update): Calculate the new position to eliminate using the formula i = (i + k - 1) % t, where:\\n\\ni is the current position to start counting from.\\nk is the step size, indicating how many people to skip before eliminating someone.\\nt is the number of remaining people in the circle (temp.size()).\\nThis formula calculates the position of the person to be eliminated in the current iteration. The -1 is needed to account for the 0-based index.\\n\\nElimination: Remove the person at the calculated position (temp[i]) from the vector temp. This simulates their elimination from the circle.\\n\\nLoop Continuation: The loop continues, repeating steps 3 and 4, until only one person remains in the circle.\\n\\nResult: After the loop finishes, return the value of the last remaining person in the temp vector, which corresponds to the 0-based index of the winner.\\n\\nThe key insight of this approach is that it models the elimination process iteratively. In each iteration of the loop, the person at the calculated position is removed, effectively skipping over k-1 people before eliminating someone. This approach ensures that the elimination process progresses in a circular manner until only one person is left standing. The position update formula (i = (i + k - 1) % t) is crucial for determining the next person to eliminate.\\n\\n# Complexity\\n- Time complexity:\\n- O(N*N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>temp;\\n\\n        for(int i=1;i<=n;i++) temp.push_back(i);\\n\\n        int i=0;\\n\\n        while(temp.size()>1){\\n            int t=temp.size();\\n            i=(i+k-1)%t;\\n            temp.erase(temp.begin()+i);\\n        }\\n        return *temp.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Recursion",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>temp;\\n\\n        for(int i=1;i<=n;i++) temp.push_back(i);\\n\\n        int i=0;\\n\\n        while(temp.size()>1){\\n            int t=temp.size();\\n            i=(i+k-1)%t;\\n            temp.erase(temp.begin()+i);\\n        }\\n        return *temp.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926739,
                "title": "100-faster-using-recursion-7-lines-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(int n,int k){\\n     if(n==1){\\n         return 0;\\n     }\\n    return  (solve(n-1,k) +k)%n;\\n }\\n    int findTheWinner(int n, int k) {\\n        int ans= solve(n,k) +1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(int n,int k){\\n     if(n==1){\\n         return 0;\\n     }\\n    return  (solve(n-1,k) +k)%n;\\n }\\n    int findTheWinner(int n, int k) {\\n        int ans= solve(n,k) +1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867537,
                "title": "find-the-winner-of-the-circular-game-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> arr = new LinkedList<>();\\n        for(int i=1; i<=n; i++){\\n            arr.add(i);\\n        }\\n\\n        while(arr.size() != 1){\\n            for(int i=k-1; i>0; i--){\\n                arr.add(arr.poll());\\n            }\\n            arr.poll();\\n        }\\n        return arr.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> arr = new LinkedList<>();\\n        for(int i=1; i<=n; i++){\\n            arr.add(i);\\n        }\\n\\n        while(arr.size() != 1){\\n            for(int i=k-1; i>0; i--){\\n                arr.add(arr.poll());\\n            }\\n            arr.poll();\\n        }\\n        return arr.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1679552,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1693744,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1820347,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2017651,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1932480,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1879886,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1760384,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2067307,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2011165,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1988298,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1679552,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1693744,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1820347,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2017651,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1932480,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1879886,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1760384,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2067307,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2011165,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1988298,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Sideway Jumps",
        "question_content": "<p>There is a <strong>3 lane road</strong> of length <code>n</code> that consists of <code>n + 1</code> <strong>points</strong> labeled from <code>0</code> to <code>n</code>. A frog <strong>starts</strong> at point <code>0</code> in the <strong>second </strong>lane<strong> </strong>and wants to jump to point <code>n</code>. However, there could be obstacles along the way.</p>\n\n<p>You are given an array <code>obstacles</code> of length <code>n + 1</code> where each <code>obstacles[i]</code> (<strong>ranging from 0 to 3</strong>) describes an obstacle on the lane <code>obstacles[i]</code> at point <code>i</code>. If <code>obstacles[i] == 0</code>, there are no obstacles at point <code>i</code>. There will be <strong>at most one</strong> obstacle in the 3 lanes at each point.</p>\n\n<ul>\n\t<li>For example, if <code>obstacles[2] == 1</code>, then there is an obstacle on lane 1 at point 2.</li>\n</ul>\n\n<p>The frog can only travel from point <code>i</code> to point <code>i + 1</code> on the same lane if there is not an obstacle on the lane at point <code>i + 1</code>. To avoid obstacles, the frog can also perform a <strong>side jump</strong> to jump to <strong>another</strong> lane (even if they are not adjacent) at the <strong>same</strong> point if there is no obstacle on the new lane.</p>\n\n<ul>\n\t<li>For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.</li>\n</ul>\n\n<p>Return<em> the <strong>minimum number of side jumps</strong> the frog needs to reach <strong>any lane</strong> at point n starting from lane <code>2</code> at point 0.</em></p>\n\n<p><strong>Note:</strong> There will be no obstacles on points <code>0</code> and <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png\" style=\"width: 500px; height: 244px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,1,2,3,0]\n<strong>Output:</strong> 2 \n<strong>Explanation:</strong> The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,1,1,3,3,0]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no obstacles on lane 2. No side jumps are required.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,2,1,0,3,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The optimal solution is shown by the arrows above. There are 2 side jumps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obstacles.length == n + 1</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= obstacles[i] &lt;= 3</code></li>\n\t<li><code>obstacles[0] == obstacles[n] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152665,
                "title": "java-c-python-dp-o-1-space",
                "content": "# **Explanation**\\ndp[0] = minimum jump to reach lane 1\\ndp[1] = minimum jump to reach lane 2\\ndp[2] = minimum jump to reach lane 3\\nIf meet a stone, set its `dp[i]` to infinity.\\nresult equals to  `min(dp)`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minSideJumps(int[] A) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1000000;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = Math.min(dp[i], Math.min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return Math.min(dp[0], Math.min(dp[1], dp[2]));\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minSideJumps(vector<int>& A) {\\n        int dp[] = {1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1e6;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = min(dp[i], min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return min(dp[0], min(dp[1], dp[2]));\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minSideJumps(self, A):\\n        dp = [1, 0, 1]\\n        for a in A:\\n            if a:\\n                dp[a - 1] = float(\\'inf\\')\\n            for i in xrange(3):\\n                if a != i + 1:\\n                    dp[i] = min(dp[i], dp[(i + 1) % 3] + 1, dp[(i + 2) % 3] + 1)\\n        return min(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minSideJumps(int[] A) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1000000;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = Math.min(dp[i], Math.min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return Math.min(dp[0], Math.min(dp[1], dp[2]));\\n    }\\n```\n```cpp\\n    int minSideJumps(vector<int>& A) {\\n        int dp[] = {1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1e6;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = min(dp[i], min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return min(dp[0], min(dp[1], dp[2]));\\n    }\\n```\n```py\\n    def minSideJumps(self, A):\\n        dp = [1, 0, 1]\\n        for a in A:\\n            if a:\\n                dp[a - 1] = float(\\'inf\\')\\n            for i in xrange(3):\\n                if a != i + 1:\\n                    dp[i] = min(dp[i], dp[(i + 1) % 3] + 1, dp[(i + 2) % 3] + 1)\\n        return min(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152411,
                "title": "python-c-clean-dp-solution-with-explanation-o-n",
                "content": "**Idea**\\n\\nWe can use DP to solve this problem. `dp[i][r]` means the minimum jumps when the frog gets to point `i` lane `r` (0-index).\\n\\nThe base cases are:\\n\\n- `dp[0][0], dp[0][1], dp[0][2] = 1, 0, 1`\\n- `dp[i][r] = inf` when there\\'s obstacle at `(i, r)` or `(i+1, r)` \\n\\nAnd the transition function is:\\n\\n- `dp[i][r] = min([dp[i-1][r], dp[i-1][(r+1)%3] + 1,  dp[i-1][(r+2)%3] + 1]) for r = 0, 1, 2`\\n\\n`dp[i-1][r]` means the frog comes from the same lane, so there\\'s no jump needed; otherwise, the frog moves from point `i-1` to point `i` on another lane and jumps to `(i, r)`.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)` or `O(1)` if we use rolling array\\n\\n</br>\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def minSideJumps(self, arr: List[int]) -> int:\\n        n = len(arr) - 1\\n        dp = [[0] * 3 for _ in range(n)]\\n        dp[0][0] = dp[0][2] = 1\\n        \\n        for i in range(1, n):\\n            for r in range(3):\\n                if arr[i] == r+1 or arr[i+1] == r+1:\\n                    dp[i][r] = float(\\'inf\\')\\n                else:\\n                    dp[i][r] = min([dp[i-1][r],\\n                                    dp[i-1][(r+1)%3] + 1, \\n                                    dp[i-1][(r+2)%3] + 1])\\n        return min(dp[-1])\\n```\\n\\n</br>\\n\\n**C++**\\n```C++\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size() - 1;\\n        int dp[n][3];\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int r = 0; r < 3; ++r) {\\n                if (arr[i] == r+1 || arr[i+1] == r+1)\\n                    dp[i][r] = n;\\n                else\\n                    dp[i][r] = min(dp[i-1][r], min(dp[i-1][(r+1)%3],  dp[i-1][(r+2)%3]) + 1);\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minSideJumps(self, arr: List[int]) -> int:\\n        n = len(arr) - 1\\n        dp = [[0] * 3 for _ in range(n)]\\n        dp[0][0] = dp[0][2] = 1\\n        \\n        for i in range(1, n):\\n            for r in range(3):\\n                if arr[i] == r+1 or arr[i+1] == r+1:\\n                    dp[i][r] = float(\\'inf\\')\\n                else:\\n                    dp[i][r] = min([dp[i-1][r],\\n                                    dp[i-1][(r+1)%3] + 1, \\n                                    dp[i-1][(r+2)%3] + 1])\\n        return min(dp[-1])\\n```\n```C++\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size() - 1;\\n        int dp[n][3];\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int r = 0; r < 3; ++r) {\\n                if (arr[i] == r+1 || arr[i+1] == r+1)\\n                    dp[i][r] = n;\\n                else\\n                    dp[i][r] = min(dp[i-1][r], min(dp[i-1][(r+1)%3],  dp[i-1][(r+2)%3]) + 1);\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153269,
                "title": "java-recursion-memoization-top-down-explained",
                "content": "**Upvote if you found this helpful. :)**\\n```\\nclass Solution { \\n    public int minSideJumps(int[] obstacles) {\\n\\t    // 4 rows (lanes) -0,1,2,3 (ignore 0th row) || obstacles.length columns\\n        int dp[][] = new int[4][obstacles.length];\\n        for(int[] a : dp)\\n         Arrays.fill(a, -1); // fill whole dp with -1;\\n\\t\\t \\n        return minSideJumps( obstacles, 0, 2, dp); // start at 0th point at 2nd lane,\\n    }\\n    \\n    private int minSideJumps(int [] ob, int p, int lane, int dp[][]){\\n        if(p == ob.length-1) return 0;             // reached last point \\n        if( ob[p]==lane) return Integer.MAX_VALUE; // if encountered an obstacle\\n        if(dp[lane][p]!=-1) return dp[lane][p];    // if sub problem already solved\\n        \\n        if(ob[p+1]!=lane){                    // if the next point in lane has no obstacle\\n             dp[lane][p] =  minSideJumps(ob, p+1, lane, dp);\\n        }else{                                // if the next point in lane has  obstacle then we have 2 choices\\n            int l1 = lane-1 !=0 ? lane-1 : lane+2;\\n            int l2 = lane+1!=4 ? lane+1 : lane-2;\\n                                                //get the min of two choices\\n             dp[lane][p] =  1+ Math.min(minSideJumps(ob, p, l1, dp), minSideJumps(ob, p, l2, dp)); \\n        }\\n        return  dp[lane][p];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution { \\n    public int minSideJumps(int[] obstacles) {\\n\\t    // 4 rows (lanes) -0,1,2,3 (ignore 0th row) || obstacles.length columns\\n        int dp[][] = new int[4][obstacles.length];\\n        for(int[] a : dp)\\n         Arrays.fill(a, -1); // fill whole dp with -1;\\n\\t\\t \\n        return minSideJumps( obstacles, 0, 2, dp); // start at 0th point at 2nd lane,\\n    }\\n    \\n    private int minSideJumps(int [] ob, int p, int lane, int dp[][]){\\n        if(p == ob.length-1) return 0;             // reached last point \\n        if( ob[p]==lane) return Integer.MAX_VALUE; // if encountered an obstacle\\n        if(dp[lane][p]!=-1) return dp[lane][p];    // if sub problem already solved\\n        \\n        if(ob[p+1]!=lane){                    // if the next point in lane has no obstacle\\n             dp[lane][p] =  minSideJumps(ob, p+1, lane, dp);\\n        }else{                                // if the next point in lane has  obstacle then we have 2 choices\\n            int l1 = lane-1 !=0 ? lane-1 : lane+2;\\n            int l2 = lane+1!=4 ? lane+1 : lane-2;\\n                                                //get the min of two choices\\n             dp[lane][p] =  1+ Math.min(minSideJumps(ob, p, l1, dp), minSideJumps(ob, p, l2, dp)); \\n        }\\n        return  dp[lane][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152455,
                "title": "java-c-python-dp-greedy-bonus",
                "content": "#### DP\\n\\nFor each step, we first determine a lane with an obstacle, and set its number of jumps to a large number.\\n\\nFor every other lane, the number of side jumps is the smallest among:\\n- The number of jumps for the current lane, or\\n- The number of jums for other lines plus 1.\\n\\nHere is the annotated example from the problem description:\\n![image](https://assets.leetcode.com/users/images/5a088469-1201-4daa-8ecf-d0db02471bec_1618118068.5978096.png)\\n\\n**Java**\\n```java\\npublic int minSideJumps(int[] obstacles) {\\n    int[] dp = {1000000,1,0,1};\\n    for (var i : obstacles) {\\n        dp[i] = dp[0];\\n        for (var j = 1; j < 4; ++j)\\n            if (j != i)\\n                for (var k = 1; k < 4; ++k)\\n                    dp[j] = Math.min(dp[j], dp[k] + (j == k ? 0 : 1));\\n    }\\n    return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n}\\n```\\n**C++**\\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    array<int, 4> dp{1000000, 1, 0, 1};\\n    for (auto i : obs) {\\n        dp[i] = dp[0];\\n        for (auto j = 1; j <= 3; ++j)\\n            if (i != j)\\n                dp[j] = min({dp[1] + (j != 1), dp[2] + (j != 2), dp[3] + (j != 3)});\\n    }\\n    return min({dp[1], dp[2], dp[3]});\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: List[int]) -> int:\\n        dp = [1000000, 1, 0, 1]\\n        for i in obs:\\n            dp[i] = dp[0]\\n            for j in range(1, 4):\\n                dp[j] = min(dp[1] + (1 if j != 1 else 0),\\n                           dp[2] + (1 if j != 2 else 0),\\n                           dp[3] + (1 if j != 3 else 0)) if j != i else dp[j]\\n        return min(dp)\\n```\\n\\n#### Greedy\\nThe idea - suggested by [voidp](https://leetcode.com/voidp/) - is that when we hit an obstacle, we can greedily choose a lane where the next obstacle is further out. \\n\\nThis works because we can jump to any line with the same `+1` penalty. \\n\\n**C++**\\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    int res = 0, cur = 2;\\n    for (auto i = 0; i + 1 < obs.size(); ++i) {\\n        if (cur == obs[i + 1]) {\\n            ++res;\\n            for (bool b[4] = {}; i < obs.size(); ++i) {\\n                b[obs[i]] = true;\\n                if (b[1] && b[2] && b[3])\\n                    break;\\n            }\\n            cur = obs[i];\\n            i -= 2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minSideJumps(int[] obstacles) {\\n    int[] dp = {1000000,1,0,1};\\n    for (var i : obstacles) {\\n        dp[i] = dp[0];\\n        for (var j = 1; j < 4; ++j)\\n            if (j != i)\\n                for (var k = 1; k < 4; ++k)\\n                    dp[j] = Math.min(dp[j], dp[k] + (j == k ? 0 : 1));\\n    }\\n    return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n}\\n```\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    array<int, 4> dp{1000000, 1, 0, 1};\\n    for (auto i : obs) {\\n        dp[i] = dp[0];\\n        for (auto j = 1; j <= 3; ++j)\\n            if (i != j)\\n                dp[j] = min({dp[1] + (j != 1), dp[2] + (j != 2), dp[3] + (j != 3)});\\n    }\\n    return min({dp[1], dp[2], dp[3]});\\n}\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: List[int]) -> int:\\n        dp = [1000000, 1, 0, 1]\\n        for i in obs:\\n            dp[i] = dp[0]\\n            for j in range(1, 4):\\n                dp[j] = min(dp[1] + (1 if j != 1 else 0),\\n                           dp[2] + (1 if j != 2 else 0),\\n                           dp[3] + (1 if j != 3 else 0)) if j != i else dp[j]\\n        return min(dp)\\n```\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    int res = 0, cur = 2;\\n    for (auto i = 0; i + 1 < obs.size(); ++i) {\\n        if (cur == obs[i + 1]) {\\n            ++res;\\n            for (bool b[4] = {}; i < obs.size(); ++i) {\\n                b[obs[i]] = true;\\n                if (b[1] && b[2] && b[3])\\n                    break;\\n            }\\n            cur = obs[i];\\n            i -= 2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152537,
                "title": "c-memoised-dp-solution",
                "content": "First write down the recursive solution and then memoize it to approach it in a simple way. \\n\\nStart with lane 2 and we have the following options:-\\n1) If no obstacle on current lane on next position then we can move forward in same lane.\\n2) If we have an obstacle at the next pos, we can jump to either of the other two lanes (L1 and L2).\\nSo, here we have 3 options :-\\ni) If we have an obstacle at L1 at same pos, jump to L2.\\nii) If we have an obstacle at L2 at same pos, jump to L1.\\niii) If no obstacle at either L2 or L1 at this pos, take minimum of both.\\nRepeat the same for the new current lane until we reach the second last position.\\n\\n3) If we reached second last pos, we can return the ans.\\n\\n**Recursive Solution: (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return 0;\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return solve(obstacles, pos+1, lane);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return 1 + solve(obstacles, pos+1, l2);\\n            else if(obstacles[pos]==l2)\\n                return 1 + solve(obstacles, pos+1, l1);\\n            else\\n                return 1 + min(solve(obstacles, pos+1, l1), solve(obstacles, pos+1, l2));\\n        }\\n        return 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(obstacles, 0, 2);\\n    }\\n};\\n```\\n\\n**Memoized Approach (Accepted)**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane, vector<vector<int>>&dp)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return dp[pos][lane] = 0;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return dp[pos][lane] = solve(obstacles, pos+1, lane, dp);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l2, dp);\\n            else if(obstacles[pos]==l2)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l1, dp);\\n            else\\n                return dp[pos][lane] = 1 + min(solve(obstacles, pos+1, l1, dp), solve(obstacles, pos+1, l2, dp));\\n        }\\n        return dp[pos][lane] = 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size()+1, vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return 0;\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return solve(obstacles, pos+1, lane);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return 1 + solve(obstacles, pos+1, l2);\\n            else if(obstacles[pos]==l2)\\n                return 1 + solve(obstacles, pos+1, l1);\\n            else\\n                return 1 + min(solve(obstacles, pos+1, l1), solve(obstacles, pos+1, l2));\\n        }\\n        return 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(obstacles, 0, 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane, vector<vector<int>>&dp)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return dp[pos][lane] = 0;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return dp[pos][lane] = solve(obstacles, pos+1, lane, dp);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l2, dp);\\n            else if(obstacles[pos]==l2)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l1, dp);\\n            else\\n                return dp[pos][lane] = 1 + min(solve(obstacles, pos+1, l1, dp), solve(obstacles, pos+1, l2, dp));\\n        }\\n        return dp[pos][lane] = 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size()+1, vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152416,
                "title": "python3-dp-solution",
                "content": "```\\ndef minSideJumps(self, obstacles: List[int]) -> int:\\n        # Approach: DP.\\n        # Idea: dp[i][j] means minimum number of side jumps to reach i-th position at j-th lane.\\n        #       \\'inf\\' values in resulting dp array mean unreachable states.\\n        \\n        # init dp\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(len(obstacles))]\\n        dp[0] = [1, 0, 1]\\n        \\n        # run dp process\\n        for i in range(1, len(obstacles)):\\n            # 1. fill next position trying to move without side jumps\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = dp[i - 1][j]\\n            # 2. update dp for i-th position with possible side jumps\\n            min_cur = min(dp[i])\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = min(dp[i][j], min_cur + 1)\\n        return min(dp[-1])\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef minSideJumps(self, obstacles: List[int]) -> int:\\n        # Approach: DP.\\n        # Idea: dp[i][j] means minimum number of side jumps to reach i-th position at j-th lane.\\n        #       \\'inf\\' values in resulting dp array mean unreachable states.\\n        \\n        # init dp\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(len(obstacles))]\\n        dp[0] = [1, 0, 1]\\n        \\n        # run dp process\\n        for i in range(1, len(obstacles)):\\n            # 1. fill next position trying to move without side jumps\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = dp[i - 1][j]\\n            # 2. update dp for i-th position with possible side jumps\\n            min_cur = min(dp[i])\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = min(dp[i][j], min_cur + 1)\\n        return min(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152422,
                "title": "java-dp-time-o-n-space-o-1-brief-explanation",
                "content": "`dp[i][j]`: the min jump to arrive at lane `j` at point `i`\\n\\nSince the frog starts at lane 2, the initial states should be,\\n`dp[0][2] = 0`, \\n`dp[0][1] = 1`,\\n`dp[0][3] = 1`.\\n\\nThis is an space `O(1)` solution.\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[] dp = new int[4];\\n        dp[1] = dp[3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            int[] temp = new int[4];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    temp[j] = Integer.MAX_VALUE;\\n                } else {\\n                    temp[j] = dp[j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(temp[1], Math.min(temp[2], temp[3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                temp[j] = Math.min(min+1, temp[j]);\\n            }\\n            dp = temp;\\n        }\\n        return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n    }\\n}\\n```\\n\\nWe can also have an space `O(n)` solution,\\n\\n ```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[][] dp = new int[n][4];\\n\\t\\t//initial point\\n        dp[0][1] = dp[0][3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(dp[i][1], Math.min(dp[i][2], dp[i][3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                dp[i][j] = Math.min(min+1, dp[i][j]);\\n            }\\n        }\\n        return Math.min(dp[n-1][1], Math.min(dp[n-1][2], dp[n-1][3]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[] dp = new int[4];\\n        dp[1] = dp[3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            int[] temp = new int[4];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    temp[j] = Integer.MAX_VALUE;\\n                } else {\\n                    temp[j] = dp[j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(temp[1], Math.min(temp[2], temp[3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                temp[j] = Math.min(min+1, temp[j]);\\n            }\\n            dp = temp;\\n        }\\n        return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[][] dp = new int[n][4];\\n\\t\\t//initial point\\n        dp[0][1] = dp[0][3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(dp[i][1], Math.min(dp[i][2], dp[i][3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                dp[i][j] = Math.min(min+1, dp[i][j]);\\n            }\\n        }\\n        return Math.min(dp[n-1][1], Math.min(dp[n-1][2], dp[n-1][3]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152429,
                "title": "easy-o-n-dp-solution-c-with-explanation-top-down-and-iterative-solution",
                "content": "\\nExplanation: Initially we are in lane2 ,and for index=0,we can jump to lane1 and lane3 .\\nAfter that for reaching every lane ,we have two options  either continue from last index,or jump from other lane to this lane,\\n\\n\\n```\\n```\\n \\n Top Down approach:-\\n \\n \\n ```\\nclass Solution {\\npublic:\\n    //  Dp state= {index of frog position, lane of frog position}\\n\\tvector<vector<long>>dp;\\n\\tint n;\\n    int minSideJumps(vector<int>& obstacles) {\\n\\t\\tn=obstacles.size()-1;\\n\\t\\t// Declaring size of Dp with n and number of lanes\\n\\t\\tdp.resize(n+1,vector<long>(4,-1));\\n\\t\\t// Find the answer for index 0 and lane 2\\n\\t\\treturn find(obstacles,0,2);\\n    }\\n\\tlong find(vector<int>&obstacles,int idx,int lane){\\n\\t\\t// Reach end return 0\\n\\t\\tif(idx==n) return 0;\\n\\t\\t// Current Position has Obstacle return INT_MAX, we can\\'t be here\\n\\t\\tif(obstacles[idx]==lane) return INT_MAX;\\n\\t\\t// return if previously calculated\\n\\t\\tif(dp[idx][lane]!=-1) return dp[idx][lane];\\n\\t\\t// Going in Current forward\\n\\t\\tlong res=find(obstacles,idx+1,lane);\\n\\t\\t// Iterating over all lanes\\n\\t\\tfor(int i=1;i<4;i++){\\n\\t\\t\\t// Going in same lane is not possible\\n\\t\\t\\tif(lane==i) continue;\\n\\t\\t\\t// if ith lane has obsatacle we can\\'t go there\\n\\t\\t\\tif(obstacles[idx]==i) continue;\\n\\t\\t\\t// Calculating for idx+1 in ith lane and adding one extra cost\\n\\t\\t\\tres=min(res,find(obstacles,idx+1,i)+1);\\n\\t\\t}\\n\\t\\treturn dp[idx][lane]=res;\\n\\t}\\n};\\n```\\nIterative solution:-\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>&v) {\\n        int n=v.size();\\n        int mx=10000000;\\n        vector<vector<int>>dp(n+1,vector<int>(4,mx));\\n        \\n        dp[0][1]=1;dp[0][2]=0;dp[0][3]=1;\\n        for(int i=1;i<n;++i){\\n           \\n            \\n            // continuing the previous lane\\n            \\n            if(v[i]!=1)dp[i][1]=dp[i-1][1];\\n            if(v[i]!=2)dp[i][2]=dp[i-1][2];\\n            if(v[i]!=3)dp[i][3]=dp[i-1][3];\\n            \\n            // jumping from other lane\\n            \\n            if(v[i]!=1)\\n            dp[i][1]=min(dp[i][1],min(dp[i][2]+1,dp[i][3]+1));\\n            if(v[i]!=2)\\n            dp[i][2]=min(dp[i][2],min(dp[i][3]+1,dp[i][1]+1));\\n            if(v[i]!=3)\\n            dp[i][3]=min(dp[i][3],min(dp[i][1]+1,dp[i][2]+1));\\n           \\n        }\\n        return min(dp[n-1][1],min(dp[n-1][2],dp[n-1][3]));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\nclass Solution {\\npublic:\\n    //  Dp state= {index of frog position, lane of frog position}\\n\\tvector<vector<long>>dp;\\n\\tint n;\\n    int minSideJumps(vector<int>& obstacles) {\\n\\t\\tn=obstacles.size()-1;\\n\\t\\t// Declaring size of Dp with n and number of lanes\\n\\t\\tdp.resize(n+1,vector<long>(4,-1));\\n\\t\\t// Find the answer for index 0 and lane 2\\n\\t\\treturn find(obstacles,0,2);\\n    }\\n\\tlong find(vector<int>&obstacles,int idx,int lane){\\n\\t\\t// Reach end return 0\\n\\t\\tif(idx==n) return 0;\\n\\t\\t// Current Position has Obstacle return INT_MAX, we can\\'t be here\\n\\t\\tif(obstacles[idx]==lane) return INT_MAX;\\n\\t\\t// return if previously calculated\\n\\t\\tif(dp[idx][lane]!=-1) return dp[idx][lane];\\n\\t\\t// Going in Current forward\\n\\t\\tlong res=find(obstacles,idx+1,lane);\\n\\t\\t// Iterating over all lanes\\n\\t\\tfor(int i=1;i<4;i++){\\n\\t\\t\\t// Going in same lane is not possible\\n\\t\\t\\tif(lane==i) continue;\\n\\t\\t\\t// if ith lane has obsatacle we can\\'t go there\\n\\t\\t\\tif(obstacles[idx]==i) continue;\\n\\t\\t\\t// Calculating for idx+1 in ith lane and adding one extra cost\\n\\t\\t\\tres=min(res,find(obstacles,idx+1,i)+1);\\n\\t\\t}\\n\\t\\treturn dp[idx][lane]=res;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>&v) {\\n        int n=v.size();\\n        int mx=10000000;\\n        vector<vector<int>>dp(n+1,vector<int>(4,mx));\\n        \\n        dp[0][1]=1;dp[0][2]=0;dp[0][3]=1;\\n        for(int i=1;i<n;++i){\\n           \\n            \\n            // continuing the previous lane\\n            \\n            if(v[i]!=1)dp[i][1]=dp[i-1][1];\\n            if(v[i]!=2)dp[i][2]=dp[i-1][2];\\n            if(v[i]!=3)dp[i][3]=dp[i-1][3];\\n            \\n            // jumping from other lane\\n            \\n            if(v[i]!=1)\\n            dp[i][1]=min(dp[i][1],min(dp[i][2]+1,dp[i][3]+1));\\n            if(v[i]!=2)\\n            dp[i][2]=min(dp[i][2],min(dp[i][3]+1,dp[i][1]+1));\\n            if(v[i]!=3)\\n            dp[i][3]=min(dp[i][3],min(dp[i][1]+1,dp[i][2]+1));\\n           \\n        }\\n        return min(dp[n-1][1],min(dp[n-1][2],dp[n-1][3]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152446,
                "title": "c-greedy-o-n-with-comments-and-proof-100",
                "content": "### Algorithm\\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n\\n### Proof by Contradiction:\\n\\nSay we don\\'t choose the `Farthest lane (A)`, instead there is one `optimal` lane (B) passing by, But if B is an optimal lane and `not the Farthest` there is one `extra jump` required in Lane B (Surely as obstacle is going to be before the farthest lane.).\\n\\nSo for time being, lets assume we choose the `farthest lane` and delay this  unnecessary `extra Jump` once fathest lane hits the obstacle we jump to the `optimal lane`. Now if question arise what if we can\\'t jump on the optimal lane (optimal lane is having the obstacle `at the same point`: that can be the only case), that won\\'t be the case as at any point in time there is obstacle at only ``ONE LANE``. Also if optimal lane is having obstacle then there are `two many` obstacle on the optimal lane, which won\\'t be the `optimal`  .     \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int jumps = 0;\\n        int lane = 2;   //Starting lane.\\n        \\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n        for(int i = 0; i < obstacles.size(); ){        \\n            if(i+1 < obstacles.size() && obstacles[i+1] == lane){ \\n                \\n                //Obstacle, jump required.\\n                jumps++;\\n                \\n                //Find the farthest lane without obstacle\\n                int farthest = i;\\n                unordered_set<int> lanes_with_obstacle;\\n                lanes_with_obstacle.reserve(2);\\n                while(farthest < obstacles.size()){\\n                    \\n                    if(obstacles[farthest] != 0)\\n                        lanes_with_obstacle.insert(obstacles[farthest]);\\n                    \\n                    if(lanes_with_obstacle.size() == 2)\\n                        break;\\n                    farthest++;\\n                }\\n                \\n                \\n                //Jump to the farthest lane\\n                i = farthest;\\n                for(int farthest_laneidx = 1; farthest_laneidx <= 3; farthest_laneidx++){\\n                    if(lanes_with_obstacle.find(farthest_laneidx) == lanes_with_obstacle.end())\\n                        lane = farthest_laneidx;                    \\n                }\\n            }else\\n                i++;\\n        }        \\n        \\n        return jumps;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int jumps = 0;\\n        int lane = 2;   //Starting lane.\\n        \\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n        for(int i = 0; i < obstacles.size(); ){        \\n            if(i+1 < obstacles.size() && obstacles[i+1] == lane){ \\n                \\n                //Obstacle, jump required.\\n                jumps++;\\n                \\n                //Find the farthest lane without obstacle\\n                int farthest = i;\\n                unordered_set<int> lanes_with_obstacle;\\n                lanes_with_obstacle.reserve(2);\\n                while(farthest < obstacles.size()){\\n                    \\n                    if(obstacles[farthest] != 0)\\n                        lanes_with_obstacle.insert(obstacles[farthest]);\\n                    \\n                    if(lanes_with_obstacle.size() == 2)\\n                        break;\\n                    farthest++;\\n                }\\n                \\n                \\n                //Jump to the farthest lane\\n                i = farthest;\\n                for(int farthest_laneidx = 1; farthest_laneidx <= 3; farthest_laneidx++){\\n                    if(lanes_with_obstacle.find(farthest_laneidx) == lanes_with_obstacle.end())\\n                        lane = farthest_laneidx;                    \\n                }\\n            }else\\n                i++;\\n        }        \\n        \\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152499,
                "title": "python-one-pass-with-saving-state",
                "content": "```\\nclass Solution(object):\\n    def minSideJumps(self, obstacles):\\n        path,res,i = [2],0,0\\n        while i < len(obstacles):\\n            if obstacles[i] in path:\\n                if len(path) == 1:\\n                    res+=1\\n                    if obstacles[i] == 1:\\n                        path= [2,3]\\n                    if obstacles[i] == 2:\\n                        path = [1,3]\\n                    if obstacles[i] == 3:\\n                        path = [1,2]\\n                    i-=1\\n                if len(path)==2:\\n                    if path[0] == obstacles[i]:\\n                        path = [path[1]]\\n                    elif path[1] == obstacles[i]:\\n                        path.pop()\\n            i+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSideJumps(self, obstacles):\\n        path,res,i = [2],0,0\\n        while i < len(obstacles):\\n            if obstacles[i] in path:\\n                if len(path) == 1:\\n                    res+=1\\n                    if obstacles[i] == 1:\\n                        path= [2,3]\\n                    if obstacles[i] == 2:\\n                        path = [1,3]\\n                    if obstacles[i] == 3:\\n                        path = [1,2]\\n                    i-=1\\n                if len(path)==2:\\n                    if path[0] == obstacles[i]:\\n                        path = [path[1]]\\n                    elif path[1] == obstacles[i]:\\n                        path.pop()\\n            i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152515,
                "title": "c-w-o-dp-beats-100-with-comments",
                "content": "Time: 308 ms\\nMemory: 162.2 MB\\n```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int minSideJumps(vector<int>& obstacles) {\\n\\xA0 \\xA0 \\xA0 \\xA0 int sidejumps=0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int curr=2;\\n\\xA0 \\xA0 \\xA0 \\xA0 int lane1=1;int lane=3;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0;i<obstacles.size()-1;i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(obstacles[i+1]==curr){\\n                // find the occurance of obstacles in the rest 2 lanes for the rest of the path\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto x=find(obstacles.begin()+i,obstacles.end(),lane1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto y= find(obstacles.begin()+i,obstacles.end(),lane);\\n\\t\\t\\t\\t// if there is no obstacle in any lane till the end jump to that lane and break\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(x==obstacles.end() || y==obstacles.end()){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 sidejumps++;break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int r=x-obstacles.begin();int s=y-obstacles.begin();\\n                     // otherwise move to that lane in which the occurance of obstacle is at later stage so we can get min no. of jumps\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(r>s){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane1); //make this lane as the current lane\\n\\t\\t\\t\\t\\t\\tsidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane);sidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 continue;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return sidejumps;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int minSideJumps(vector<int>& obstacles) {\\n\\xA0 \\xA0 \\xA0 \\xA0 int sidejumps=0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int curr=2;\\n\\xA0 \\xA0 \\xA0 \\xA0 int lane1=1;int lane=3;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0;i<obstacles.size()-1;i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(obstacles[i+1]==curr){\\n                // find the occurance of obstacles in the rest 2 lanes for the rest of the path\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto x=find(obstacles.begin()+i,obstacles.end(),lane1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto y= find(obstacles.begin()+i,obstacles.end(),lane);\\n\\t\\t\\t\\t// if there is no obstacle in any lane till the end jump to that lane and break\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(x==obstacles.end() || y==obstacles.end()){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 sidejumps++;break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int r=x-obstacles.begin();int s=y-obstacles.begin();\\n                     // otherwise move to that lane in which the occurance of obstacle is at later stage so we can get min no. of jumps\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(r>s){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane1); //make this lane as the current lane\\n\\t\\t\\t\\t\\t\\tsidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane);sidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 continue;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return sidejumps;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756264,
                "title": "recursive-top-down-bottom-up-space-optimization",
                "content": "\\nWe are checking all the possibilies and taking the minimum, so basically recursion!\\n\\n1. if there is no obstacle in the lane we are standing at i.e. (`currLane`) then we will simply move to the next index (no jumps needed).\\n\\n2. Now if there is an obstacle, then obiviously we can\\'t stay in the same lane i.e. `i!=currLane` && there must not be an obstacle in the lane we gonna move i.e. `obstacles[idx]!=i`. Here we are taking a jump so +. \\n\\n3. We will take minimum of all the possiblities \\n\\n**Recursion (gives TLE)**\\n```\\nint solve(int idx, int currLane, vector<int>& obstacles){\\n        if(idx == obstacles.size() -1) return 0;\\n        // 1\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles);\\n        // 2\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n        // 3\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(0, 2, obstacles);\\n    }\\n```\\n\\nNow if you can write the recurrence then writing top down is childplay.\\nJust store the computed values so that we can use them later when required.\\n\\n**Top-down (Memoization)** \\n```\\n int solve(int idx, int currLane, vector<int>& obstacles, vector<vector<int>>& dp){\\n        if(idx == obstacles.size()-1) return 0;\\n        if(dp[idx][currLane] != -1) return dp[idx][currLane];\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles, dp);\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles, dp));\\n            }\\n        }\\n        return dp[idx][currLane] = mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int> (4, -1));\\n        return solve(0, 2, obstacles, dp);\\n    }\\n```\\nWe will write tabulation to get ride of the recursive stack space.\\n\\nBottom-up is starting with the base cases (reverse of top-down). So we will first write the base case in top down our idx was going from 0 to n-1 so here we will do the opposite. Other thing will remain same\\n\\n\\n**Bottom-up (Tabulation)** \\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<vector < int>> dp(n, vector<int> (3, 1e9));\\n            for (int i = 0; i <= 2; i++) dp[n - 1][i] = 0;\\n\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) dp[idx][currLane] = dp[idx + 1][currLane];\\n                    else\\n                    {\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + dp[idx + 1][i]);\\n                            }\\n                        }\\n                        dp[idx][currLane] = mn;\\n                    }\\n                }\\n            }\\n            return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n```\\n\\nWe can notice that we only need values for idx & idx+1, so why store the whole vector. instead of this we will initilize two 1D arrays curr and prev, and keep on updating them in each iteration\\n\\n**Space Optimized to O(n)**\\n\\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<int> curr(3, 1e9), prev(3, 0);\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) curr[currLane] = prev[currLane];\\n                    else{\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + prev[i]);\\n                            }\\n                        }\\n                        curr[currLane] = mn;\\n                    }\\n                }\\n                prev = curr;\\n            }\\n            return min(prev[1], 1 + min(prev[0], prev[2]));\\n    }\\n\\n```\\n\\nPlease upvote if you find this helpful :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int idx, int currLane, vector<int>& obstacles){\\n        if(idx == obstacles.size() -1) return 0;\\n        // 1\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles);\\n        // 2\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n        // 3\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(0, 2, obstacles);\\n    }\\n```\n```\\n int solve(int idx, int currLane, vector<int>& obstacles, vector<vector<int>>& dp){\\n        if(idx == obstacles.size()-1) return 0;\\n        if(dp[idx][currLane] != -1) return dp[idx][currLane];\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles, dp);\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles, dp));\\n            }\\n        }\\n        return dp[idx][currLane] = mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int> (4, -1));\\n        return solve(0, 2, obstacles, dp);\\n    }\\n```\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<vector < int>> dp(n, vector<int> (3, 1e9));\\n            for (int i = 0; i <= 2; i++) dp[n - 1][i] = 0;\\n\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) dp[idx][currLane] = dp[idx + 1][currLane];\\n                    else\\n                    {\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + dp[idx + 1][i]);\\n                            }\\n                        }\\n                        dp[idx][currLane] = mn;\\n                    }\\n                }\\n            }\\n            return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n```\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<int> curr(3, 1e9), prev(3, 0);\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) curr[currLane] = prev[currLane];\\n                    else{\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + prev[i]);\\n                            }\\n                        }\\n                        curr[currLane] = mn;\\n                    }\\n                }\\n                prev = curr;\\n            }\\n            return min(prev[1], 1 + min(prev[0], prev[2]));\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1386249,
                "title": "easy-c-bfs-easy-to-understand",
                "content": "We can use basic idea of BFS here just make a visited array and count total steps to reach nth location and subract the horizontal distance n from total steps.\\n\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size()-1,step=0;\\n        vector<vector<int>> vis(4,vector<int>(n+1,0));\\n        queue<pair<int,int>> q;\\n        q.push({2,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int p=0;p<sz;p++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x>3||x<1||y>n||y<0||vis[x][y]==1||obs[y]==x) continue;  // eliminate the invalid points \\n                if(y==n) return step-n;  // subract horizontal distance->n\\n                vis[x][y]=1;                    // mark visited\\n                q.push({x-1,y});              // onr step up  \\n                q.push({x-2,y});             //two steps up\\n                \\n                q.push({x+1,y});           //one step down\\n                q.push({x+2,y});           //two steps down \\n                \\n                q.push({x,y+1});         //one step right\\n                //(if any case is invalid it will get eliminated by if condition)\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "We can use basic idea of BFS here just make a visited array and count total steps to reach nth location and subract the horizontal distance n from total steps.\\n\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size()-1,step=0;\\n        vector<vector<int>> vis(4,vector<int>(n+1,0));\\n        queue<pair<int,int>> q;\\n        q.push({2,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int p=0;p<sz;p++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x>3||x<1||y>n||y<0||vis[x][y]==1||obs[y]==x) continue;  // eliminate the invalid points \\n                if(y==n) return step-n;  // subract horizontal distance->n\\n                vis[x][y]=1;                    // mark visited\\n                q.push({x-1,y});              // onr step up  \\n                q.push({x-2,y});             //two steps up\\n                \\n                q.push({x+1,y});           //one step down\\n                q.push({x+2,y});           //two steps down \\n                \\n                q.push({x,y+1});         //one step right\\n                //(if any case is invalid it will get eliminated by if condition)\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1152951,
                "title": "greedy-c-choose-lane-with-farthest-obstacle",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> v(3, vector<int>(n, n)); //v[k][i] -> position of next obstacle on lane k if currently standing at position i\\n        for (int i=n-2; i >=0; i--)\\n        {\\n            for (int k=0; k<3; k++)\\n            {\\n                v[k][i] = v[k][i+1];\\n            }\\n            if (obstacles[i]) v[obstacles[i]-1][i] = i;\\n        }\\n        int ret = 0;\\n        for (int i=0, lane=1; i<n-1; i++)\\n        {\\n            if (obstacles[i+1] - 1 == lane)\\n            {\\n                if (v[(lane+1)%3][i] > v[(lane+2)%3][i]) lane = (lane+1)%3;\\n                else lane = (lane+2)%3;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> v(3, vector<int>(n, n)); //v[k][i] -> position of next obstacle on lane k if currently standing at position i\\n        for (int i=n-2; i >=0; i--)\\n        {\\n            for (int k=0; k<3; k++)\\n            {\\n                v[k][i] = v[k][i+1];\\n            }\\n            if (obstacles[i]) v[obstacles[i]-1][i] = i;\\n        }\\n        int ret = 0;\\n        for (int i=0, lane=1; i<n-1; i++)\\n        {\\n            if (obstacles[i+1] - 1 == lane)\\n            {\\n                if (v[(lane+1)%3][i] > v[(lane+2)%3][i]) lane = (lane+1)%3;\\n                else lane = (lane+2)%3;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152670,
                "title": "c-dp-solution-using-top-down-approach-in-o-n",
                "content": "**KEY POINTS :**\\n* The state of dp[lane][i] will be storing the minimum no. of side moves to be taken to reach n.\\n* If the current state i.e dp[lane][i] is having obstacle , we return with a large value as it is not possible to go through this obstacle .\\n* The lane are taken as { 0 , 1 , 2 } instead of { 1 , 2 , 3 } .\\n```\\nint dp[3][1000000] ;\\nint n ;\\nint dfs(vector<int>& obstacles , int lane , int i )\\n{\\n    if(i >= n)\\n        return 0 ;\\n    if(dp[lane][i] != -1)\\n        return dp[lane][i] ;\\n    if(obstacles[i] == lane + 1)\\n        return 1e9 ;\\n    int lane2 = (lane+1) % 3 , lane3 = (lane+2) % 3 ;\\n    dp[lane][i] = dfs(obstacles , lane , i+1) ;\\n    if(obstacles[i] != lane2 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane2 , i+1) + 1) ;\\n    if(obstacles[i] != lane3 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane3 , i+1) + 1) ;\\n    return dp[lane][i] ;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size() ;\\n        memset(dp , -1 , sizeof(dp)) ;\\n        return dfs(obstacles , 1 , 0 ) ;\\n    }\\n};\\n\\n```\\nHope you understand it very clearly. \\n**keep coding :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nint dp[3][1000000] ;\\nint n ;\\nint dfs(vector<int>& obstacles , int lane , int i )\\n{\\n    if(i >= n)\\n        return 0 ;\\n    if(dp[lane][i] != -1)\\n        return dp[lane][i] ;\\n    if(obstacles[i] == lane + 1)\\n        return 1e9 ;\\n    int lane2 = (lane+1) % 3 , lane3 = (lane+2) % 3 ;\\n    dp[lane][i] = dfs(obstacles , lane , i+1) ;\\n    if(obstacles[i] != lane2 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane2 , i+1) + 1) ;\\n    if(obstacles[i] != lane3 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane3 , i+1) + 1) ;\\n    return dp[lane][i] ;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size() ;\\n        memset(dp , -1 , sizeof(dp)) ;\\n        return dfs(obstacles , 1 , 0 ) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480169,
                "title": "c-best-approach-o-1-space-optimised-solution-3-different-mehtods",
                "content": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dpmemo;\\n    \\n    int SolveByMemo(vector<int>& obstacles, int index  , int lane)\\n    {\\n        if(index  == obstacles.size()-1)\\n            return 0;\\n        \\n        if(dpmemo[index][lane] != -1)\\n            return dpmemo[index][lane];\\n        \\n      \\n        if(obstacles[index+1] != lane+1)\\n            return dpmemo[index][lane] = SolveByMemo(obstacles, index+1, lane);\\n      \\n        int ans = 10e5;\\n            for(int i = 0 ; i < 3 ; i++)\\n            {\\n                if(i == lane || obstacles[index] == i+1)\\n                    continue;\\n                ans = min(ans, SolveByMemo(obstacles, index, i));\\n                if(ans == 0)\\n                    break;\\n            }\\n         return dpmemo[index][lane] = 1 + ans;\\n    }\\n    \\n    int SolveByTab(vector<int> obstacles)\\n    {\\n        vector<vector<int>>  dp = vector<vector<int>> (obstacles.size() , vector<int> (3, 10e6) );\\n        \\n        int n = obstacles.size();\\n        dp[n-1][0] = dp[n-1][1] = dp[n-1][2] =  0;\\n        \\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    dp[i][j] = dp[i+1][j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + dp[i+1][k]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n    \\n     int SolveBySpaceOptimisation(vector<int> obstacles)\\n    {\\n       vector<int> curr(3, 10e6) , prev(3, 0);\\n         \\n        int n = obstacles.size();\\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    curr[j] = prev[j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + prev[k]);\\n                    }\\n                    curr[j] = ans;\\n                }\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        return min(curr[1] , 1 + min(curr[0], curr[2]));\\n    }\\n    \\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        // 1. By Recursion + Memoization  \\n        // dpmemo = vector<vector<int>> (obstacles.size() , vector<int> (3, -1) );\\n        //     return SolveByMemo(obstacles, 0 , 1) ;\\n        \\n        // 2. By Tabulation Method\\n        //return SolveByTab(obstacles);\\n        \\n        //3. By Tabulation and Space optimisation \\n        return SolveBySpaceOptimisation(obstacles);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dpmemo;\\n    \\n    int SolveByMemo(vector<int>& obstacles, int index  , int lane)\\n    {\\n        if(index  == obstacles.size()-1)\\n            return 0;\\n        \\n        if(dpmemo[index][lane] != -1)\\n            return dpmemo[index][lane];\\n        \\n      \\n        if(obstacles[index+1] != lane+1)\\n            return dpmemo[index][lane] = SolveByMemo(obstacles, index+1, lane);\\n      \\n        int ans = 10e5;\\n            for(int i = 0 ; i < 3 ; i++)\\n            {\\n                if(i == lane || obstacles[index] == i+1)\\n                    continue;\\n                ans = min(ans, SolveByMemo(obstacles, index, i));\\n                if(ans == 0)\\n                    break;\\n            }\\n         return dpmemo[index][lane] = 1 + ans;\\n    }\\n    \\n    int SolveByTab(vector<int> obstacles)\\n    {\\n        vector<vector<int>>  dp = vector<vector<int>> (obstacles.size() , vector<int> (3, 10e6) );\\n        \\n        int n = obstacles.size();\\n        dp[n-1][0] = dp[n-1][1] = dp[n-1][2] =  0;\\n        \\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    dp[i][j] = dp[i+1][j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + dp[i+1][k]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n    \\n     int SolveBySpaceOptimisation(vector<int> obstacles)\\n    {\\n       vector<int> curr(3, 10e6) , prev(3, 0);\\n         \\n        int n = obstacles.size();\\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    curr[j] = prev[j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + prev[k]);\\n                    }\\n                    curr[j] = ans;\\n                }\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        return min(curr[1] , 1 + min(curr[0], curr[2]));\\n    }\\n    \\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        // 1. By Recursion + Memoization  \\n        // dpmemo = vector<vector<int>> (obstacles.size() , vector<int> (3, -1) );\\n        //     return SolveByMemo(obstacles, 0 , 1) ;\\n        \\n        // 2. By Tabulation Method\\n        //return SolveByTab(obstacles);\\n        \\n        //3. By Tabulation and Space optimisation \\n        return SolveBySpaceOptimisation(obstacles);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194847,
                "title": "c-fully-detailed-solution-o-n-solution",
                "content": "# \\n# So before I explain my intutuion to you guys let\\'s look over the complexities\\n# \\n# Time Complexity - O(n) \\n# Space Complexity - O(3*n) --> O(n)\\n# So I sacrifice the space complexity for the time complexity I will tell you reason why\\n\\n# Intution - \\n# Problem - \\nSo at any position let\\'s suppose frog is at lan 2 and at next point their is obstacle in the lan to avoid collision I have two choices to make that is I can go to Lan1 or Lan3\\nNow question comes in my mind how would i select which lane should I move when i know next point in the current lan leads to collision.. \\nIf I know which lan to move optimally than I can reduce the side jumps and can reach to destination with the minimum side jumps.\\n\\n# To answer the question comes in my mind of choosing the optimal lan \\n\\nSo I know that whether frog will collide in its next jump or not\\nIf frog going to collide in the next jum than i have to change the lan\\n\\nTo appropriately select which lan i need to know at current point which lan is most far away from the obstacles in their lan\\n\\nSo to know how far is the obstacle from the current point we can use three arrays for each lan.\\nI know not good to use the three lan but I don\\'t get any other way to know the furthest distance obstacle from the current point\\n\\nSo I created three array  **Lan1,Lan2,Lan3**\\nLan1 tells me at current point farthest obstacle and similarly other for their respective Lan\\n\\n# Let\\'s go through the example to easily understand my intution - \\n![image](https://assets.leetcode.com/users/images/64d58173-5bd2-4709-8b04-9e554fde25cb_1620324981.0937715.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/72de722c-07c4-4e2d-927f-f1c0279c683b_1620324924.2989788.png)\\n\\nSo let\\'s build Lan1\\n We have 4 points we start from the end \\n \\n#  At point 4\\nWe know their never be the obstacle so we will give **-1**  \\n# lan1[4] = -1\\n\\n# At point 3\\nNow obstacle[3] = 3 so their is no obstacle at point 3 and from lan1[4] = -1 we know that after point 3 also their is no obstacle so we can have **lan1[3] = -1** because we don\\'t have any obstacles after point 3(including the point 3)\\n\\n# At point 2\\nobstacles[2] = 2 so still no obstacle at lan1 and also at point 2 lan2[2] = -1 so we don\\'t have any obstacles after the point 2(including the point 2)\\n# lan1[2] = -1\\n\\n# At point 1\\n\\nNow obstacles[1] = 1 so we encounter the obstacle so find what is the distance of the point 1 from the obstacle in the lan1 \\nDistance is = 1 - 1 = 0 because it is present in the current point so \\n# Now we will assign the lan1[1] = 0\\n\\n# At point 0\\n\\nobstacles[0] = 0 which mean no obstacles is present in any lan but in lan1 we know that lan1[1] = 0 which means we have the obstacle after point 0 so we need the distance of point 0 from the obstacle\\n\\n# Distance = lan[1] + 1 = 0 + 1 = 1\\n\\nbecause we are just one point away from the point 1 so that means if point 1 is 0 distance far away from the obstacle than point 0 will be the 1 distance away\\n\\n# So resultant Lan1 array looks like - \\n\\n![image](https://assets.leetcode.com/users/images/aeccd72e-3717-48ec-b6bb-00ea6729b5e4_1620325759.1817436.png)\\n\\nSimilarly you guys can fill the lan2 and lan3 array\\n\\n# Lan2 array - \\n\\n![image](https://assets.leetcode.com/users/images/3b328f24-af90-4596-8458-548efa53c6aa_1620325815.7243474.png)\\n\\n\\n# Lan 3 array - \\n\\n![image](https://assets.leetcode.com/users/images/b3fd3aeb-ebc3-4152-b3c7-7eb15758cddc_1620325878.3202064.png)\\n\\nNow we have all three arrays for Lan1,Lan2 ,Lan3\\n\\nNow all we need to do whenever we encounter the obstacle search in the rest of the two lan and find out which point in the respective lan is most far away from the obstacle and select that lan\\n\\nCode - \\n```\\nclass Solution {\\npublic:\\n    \\n    void fill_lan(vector<int> obstacles,int lan_no,vector<int>& lan){\\n        int n = obstacles.size();\\n        lan[n-1] = -1;\\n        for(int i=n-2;i>=0;i--){\\n            if(obstacles[i]==lan_no){\\n                lan[i] = 0;\\n            }else{\\n                if(lan[i+1]!=-1) lan[i] = lan[i+1]+1;\\n                else lan[i] = -1;\\n            }\\n        }\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<int> lan1(n,0);\\n        vector<int> lan2(n,0);\\n        vector<int> lan3(n,0);\\n        \\n        fill_lan(obstacles,1,lan1);\\n        fill_lan(obstacles,2,lan2);\\n        fill_lan(obstacles,3,lan3);\\n        \\n        int res = 0;\\n        int curr_lan = 2;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(curr_lan==obstacles[i+1]){\\n                if(curr_lan==1){\\n                    if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }\\n                }else if(curr_lan==2){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }else if(curr_lan==3){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]<lan2[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]>lan2[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```\\n\\nHopefully my intution and code is enough for you guys to understand the question",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void fill_lan(vector<int> obstacles,int lan_no,vector<int>& lan){\\n        int n = obstacles.size();\\n        lan[n-1] = -1;\\n        for(int i=n-2;i>=0;i--){\\n            if(obstacles[i]==lan_no){\\n                lan[i] = 0;\\n            }else{\\n                if(lan[i+1]!=-1) lan[i] = lan[i+1]+1;\\n                else lan[i] = -1;\\n            }\\n        }\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<int> lan1(n,0);\\n        vector<int> lan2(n,0);\\n        vector<int> lan3(n,0);\\n        \\n        fill_lan(obstacles,1,lan1);\\n        fill_lan(obstacles,2,lan2);\\n        fill_lan(obstacles,3,lan3);\\n        \\n        int res = 0;\\n        int curr_lan = 2;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(curr_lan==obstacles[i+1]){\\n                if(curr_lan==1){\\n                    if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }\\n                }else if(curr_lan==2){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }else if(curr_lan==3){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]<lan2[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]>lan2[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166811,
                "title": "c-memoization-easy-and-small",
                "content": "```\\nclass Solution {\\npublic:int n;\\n\\n    int help(int lane,int i,vector<int>&ob,vector<vector<int>>& dp)\\n    {\\n        \\n        if(i==n-1)\\n            return 0;\\n        if(ob[i]==lane+1)\\n            return INT_MAX;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        if(ob[i+1]!=lane+1)\\n            return dp[i][lane]=help(lane,i+1,ob,dp);\\n        return dp[i][lane]=1+min(help((lane+1)%3,i,ob,dp),help((lane+2)%3,i,ob,dp));\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n=obstacles.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));\\n        return help(1,0,obstacles,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:int n;\\n\\n    int help(int lane,int i,vector<int>&ob,vector<vector<int>>& dp)\\n    {\\n        \\n        if(i==n-1)\\n            return 0;\\n        if(ob[i]==lane+1)\\n            return INT_MAX;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        if(ob[i+1]!=lane+1)\\n            return dp[i][lane]=help(lane,i+1,ob,dp);\\n        return dp[i][lane]=1+min(help((lane+1)%3,i,ob,dp),help((lane+2)%3,i,ob,dp));\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n=obstacles.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));\\n        return help(1,0,obstacles,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480131,
                "title": "python-3-dp-explanation",
                "content": "### Explanation\\n- 3 rows, for each index `i`, frog can only come from either **same row, column `i-1`** or **different row, same column `i`**\\n- Based on above, we can get our transition function:\\n\\t- DP state: `dp[i][j]` number of side steps to reach row `i`, column `j`\\n\\t- Initial value: `dp[0][0] = dp[2][0] = 1, dp[1][0] = 0`\\n\\t- Transition function:\\n\\t\\t```\\n\\t\\tdp[i][j] = dp[i][j-1] if obstacles[j] != 1 else sys.maxsize\\n\\t\\tif obstacles[i] != 1: # for first row\\n\\t\\t\\tfor j in [1, 2]:  # side jump from other 2 rows\\n\\t\\t\\t\\tdp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n\\t\\t```\\n\\t- Final result: `min(dp[0][-1], dp[1][-1], dp[2][-1])`\\n### Implementation\\n- `O(n) space & time solution`\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        dp = [[sys.maxsize] * n for _ in range(3)]\\n        dp[0][0]= 1\\n        dp[1][0]= 0\\n        dp[2][0]= 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize\\n            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize\\n            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                for j in [1, 2]:\\n                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                for j in [0, 2]:\\n                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                for j in [0, 1]:\\n                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n```\\n- `O(1) space solution`, since only the value from `i-1` is used\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        a, b, c = 1, 0, 1\\n        for i in range(1, n):\\n            a = a if obstacles[i] != 1 else sys.maxsize\\n            b = b if obstacles[i] != 2 else sys.maxsize\\n            c = c if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                a = min(a, b + 1 if obstacles[i] != 2 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                b = min(b, a + 1 if obstacles[i] != 1 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                c = min(c, a + 1 if obstacles[i] != 1 else sys.maxsize, b + 1 if obstacles[i] != 2 else sys.maxsize)\\n        return min(a, b, c)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\tdp[i][j] = dp[i][j-1] if obstacles[j] != 1 else sys.maxsize\\n\\t\\tif obstacles[i] != 1: # for first row\\n\\t\\t\\tfor j in [1, 2]:  # side jump from other 2 rows\\n\\t\\t\\t\\tdp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n\\t\\t```\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        dp = [[sys.maxsize] * n for _ in range(3)]\\n        dp[0][0]= 1\\n        dp[1][0]= 0\\n        dp[2][0]= 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize\\n            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize\\n            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                for j in [1, 2]:\\n                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                for j in [0, 2]:\\n                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                for j in [0, 1]:\\n                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        a, b, c = 1, 0, 1\\n        for i in range(1, n):\\n            a = a if obstacles[i] != 1 else sys.maxsize\\n            b = b if obstacles[i] != 2 else sys.maxsize\\n            c = c if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                a = min(a, b + 1 if obstacles[i] != 2 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                b = min(b, a + 1 if obstacles[i] != 1 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                c = min(c, a + 1 if obstacles[i] != 1 else sys.maxsize, b + 1 if obstacles[i] != 2 else sys.maxsize)\\n        return min(a, b, c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279177,
                "title": "easy-c-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        //for every point we are calculating the minimum sideway jumps that can be jump to the a lane from thr other two lanes\\n        \\n        vector<int> jumps(3,0);\\n        jumps[0]=1; //at first frog is in lane 2 so it requires 1 sideway jump \\n        //to get on to lane 1 (1-based indexing)\\n        jumps[2]=1; \\n        \\n        for(int k=0;k<obstacles.size();k++)\\n        {\\n            if(obstacles[k]>0)\\n            {\\n                //a obstacle is present make the value in the current lane to infinite \\n                jumps[obstacles[k]-1]=1e6;\\n            }\\n            //for every lane check whether other way exists to get on to the current lane from other lane which has minimum sideway jumps than the current\\n           for(int i=0;i<3;i++)\\n           {\\n               if(i!=obstacles[k]-1) {//if the obstacle is not present in current lane\\n               //i+1%3 and i+2%3 returns the other two lanes indices (0-based)\\n               \\n               //and also add 1 as we are jumping from other lane to current lane\\n               //ie., minimum of current sideway jumps to reach the current lane \\n               //and the other lanes sideway jumps+1\\n                jumps[i]=min(jumps[i],min(jumps[(i+1)%3],jumps[(i+2)%3])+1);\\n               }\\n           }\\n        }\\n        //have reached point n\\n        //jumps[0] stores the sideway jumps to get on to lane 0\\n        //jumps[1] stores the sideway jumps to get on to lane 1\\n        //jumps[2] stores the sideway jumps to get on to lane 2\\n        //get the minimum of them\\n        return min(jumps[0],min(jumps[1],jumps[2]));\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        //for every point we are calculating the minimum sideway jumps that can be jump to the a lane from thr other two lanes\\n        \\n        vector<int> jumps(3,0);\\n        jumps[0]=1; //at first frog is in lane 2 so it requires 1 sideway jump \\n        //to get on to lane 1 (1-based indexing)\\n        jumps[2]=1; \\n        \\n        for(int k=0;k<obstacles.size();k++)\\n        {\\n            if(obstacles[k]>0)\\n            {\\n                //a obstacle is present make the value in the current lane to infinite \\n                jumps[obstacles[k]-1]=1e6;\\n            }\\n            //for every lane check whether other way exists to get on to the current lane from other lane which has minimum sideway jumps than the current\\n           for(int i=0;i<3;i++)\\n           {\\n               if(i!=obstacles[k]-1) {//if the obstacle is not present in current lane\\n               //i+1%3 and i+2%3 returns the other two lanes indices (0-based)\\n               \\n               //and also add 1 as we are jumping from other lane to current lane\\n               //ie., minimum of current sideway jumps to reach the current lane \\n               //and the other lanes sideway jumps+1\\n                jumps[i]=min(jumps[i],min(jumps[(i+1)%3],jumps[(i+2)%3])+1);\\n               }\\n           }\\n        }\\n        //have reached point n\\n        //jumps[0] stores the sideway jumps to get on to lane 0\\n        //jumps[1] stores the sideway jumps to get on to lane 1\\n        //jumps[2] stores the sideway jumps to get on to lane 2\\n        //get the minimum of them\\n        return min(jumps[0],min(jumps[1],jumps[2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456225,
                "title": "recursive-memoization-tabulation-space-optimization-beats-95",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ $$ tabulation, space Optimization $$ \\n\\n- Space complexity: $$O(1)$$ $$ space Optimization$$\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        // return helperRec(obstacles, 2, 0);\\n\\n        // int[][] dp = new int[4][obstacles.length];\\n        // for(int row[] : dp) Arrays.fill(row, -1);\\n        // return helperMem(obstacles, 2, 0, dp);\\n\\n        // return helperTab(obstacles);\\n\\n        return helperSO(obstacles);\\n    }\\n    \\n    // RECURSIVE APPROACH\\n    public int helperRec(int[] obstacles, int lane, int index){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        // CONTINUING TO THE SAME LANE\\n        if(obstacles[index + 1] != lane){\\n            return helperRec(obstacles, lane, index + 1);\\n        }\\n        // MEET OBSTACLE IN SAME LANE THEN TRYING SIDE JUMPS\\n        else{ \\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperRec(obstacles, i, index));\\n            }\\n            return ans;\\n        }\\n    }\\n\\n    // MEMOIZATION APPROACH\\n    public int helperMem(int[] obstacles, int lane, int index, int[][] dp){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        //MEMOIZATION CHECK\\n        if(dp[lane][index] != -1) return dp[lane][index];\\n        if(obstacles[index + 1] != lane){\\n            return helperMem(obstacles, lane, index + 1, dp);\\n        }else{\\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperMem(obstacles, i, index, dp));\\n            }\\n            return dp[lane][index] = ans;\\n        }\\n    }\\n\\n    // TABULATION APPROACH\\n    public int helperTab(int[] obstacles){\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][obstacles.length];\\n        // mod because max value m kuch bhi add krenge to negative chlna jayega value, mod is defined globally\\n        for(int row[] : dp) Arrays.fill(row, mod);\\n        \\n        // BASE CASE ANALYSIS\\n        for(int i = 0; i <= 3; i++) dp[i][n-1] = 0;\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    dp[lane][index] = dp[lane][index + 1];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        // index + 1 because humara for loop 1 se 3 pe jara h, if 3 ka ans nikla nhi h to uski jgah to 1e9 hoga\\n                        // and 1 lane m mano obstackle h to usse side jump nhi ho skta, to mtlb hum lane 2 m lane 3 se aaye hai\\n                        // and if 3rd lane ka ans calculate nhi hua to udhr 1e9 hoga jisse humara ans 1e9 + 1 hojayega\\n                        // jo pura glt h that\\'s why hum usko next index p depend kra dete h\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + dp[i][index + 1]);\\n                    }\\n                    dp[lane][index] = ans;\\n                }\\n            }\\n        }\\n        //BECASUSE IF FIRST LANE SE 2 H, 2ND LANE M 5, AND 3RD LANE M 3 H TO, HUM 1ST AND 3RD LANE SE EK EXTRA SIDE JUMP LEKE\\n        // BHI TO 2,0 STARTING POSTION TK PAHUCH SKTE H TO UNME 1 ADD KRKE min le liya\\n        return Math.min(dp[1][0] + 1, Math.min(dp[2][0], dp[3][0] + 1));\\n    }\\n\\n    // SPACE OPTIMIZATION APPROACH\\n    public int helperSO(int[] obstacles){\\n        int n = obstacles.length;\\n\\n        int[] curr = new int[4];\\n        int[] next = new int[4];\\n        Arrays.fill(curr, mod);\\n        // BASE CASE ANALYSIS\\n        Arrays.fill(next, 0);\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    curr[lane] = next[lane];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n        return Math.min(next[1] + 1, Math.min(next[2], next[3] + 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        // return helperRec(obstacles, 2, 0);\\n\\n        // int[][] dp = new int[4][obstacles.length];\\n        // for(int row[] : dp) Arrays.fill(row, -1);\\n        // return helperMem(obstacles, 2, 0, dp);\\n\\n        // return helperTab(obstacles);\\n\\n        return helperSO(obstacles);\\n    }\\n    \\n    // RECURSIVE APPROACH\\n    public int helperRec(int[] obstacles, int lane, int index){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        // CONTINUING TO THE SAME LANE\\n        if(obstacles[index + 1] != lane){\\n            return helperRec(obstacles, lane, index + 1);\\n        }\\n        // MEET OBSTACLE IN SAME LANE THEN TRYING SIDE JUMPS\\n        else{ \\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperRec(obstacles, i, index));\\n            }\\n            return ans;\\n        }\\n    }\\n\\n    // MEMOIZATION APPROACH\\n    public int helperMem(int[] obstacles, int lane, int index, int[][] dp){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        //MEMOIZATION CHECK\\n        if(dp[lane][index] != -1) return dp[lane][index];\\n        if(obstacles[index + 1] != lane){\\n            return helperMem(obstacles, lane, index + 1, dp);\\n        }else{\\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperMem(obstacles, i, index, dp));\\n            }\\n            return dp[lane][index] = ans;\\n        }\\n    }\\n\\n    // TABULATION APPROACH\\n    public int helperTab(int[] obstacles){\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][obstacles.length];\\n        // mod because max value m kuch bhi add krenge to negative chlna jayega value, mod is defined globally\\n        for(int row[] : dp) Arrays.fill(row, mod);\\n        \\n        // BASE CASE ANALYSIS\\n        for(int i = 0; i <= 3; i++) dp[i][n-1] = 0;\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    dp[lane][index] = dp[lane][index + 1];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        // index + 1 because humara for loop 1 se 3 pe jara h, if 3 ka ans nikla nhi h to uski jgah to 1e9 hoga\\n                        // and 1 lane m mano obstackle h to usse side jump nhi ho skta, to mtlb hum lane 2 m lane 3 se aaye hai\\n                        // and if 3rd lane ka ans calculate nhi hua to udhr 1e9 hoga jisse humara ans 1e9 + 1 hojayega\\n                        // jo pura glt h that\\'s why hum usko next index p depend kra dete h\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + dp[i][index + 1]);\\n                    }\\n                    dp[lane][index] = ans;\\n                }\\n            }\\n        }\\n        //BECASUSE IF FIRST LANE SE 2 H, 2ND LANE M 5, AND 3RD LANE M 3 H TO, HUM 1ST AND 3RD LANE SE EK EXTRA SIDE JUMP LEKE\\n        // BHI TO 2,0 STARTING POSTION TK PAHUCH SKTE H TO UNME 1 ADD KRKE min le liya\\n        return Math.min(dp[1][0] + 1, Math.min(dp[2][0], dp[3][0] + 1));\\n    }\\n\\n    // SPACE OPTIMIZATION APPROACH\\n    public int helperSO(int[] obstacles){\\n        int n = obstacles.length;\\n\\n        int[] curr = new int[4];\\n        int[] next = new int[4];\\n        Arrays.fill(curr, mod);\\n        // BASE CASE ANALYSIS\\n        Arrays.fill(next, 0);\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    curr[lane] = next[lane];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n        return Math.min(next[1] + 1, Math.min(next[2], next[3] + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513903,
                "title": "python3-solution-dp-o-n-time-o-1-space",
                "content": "`Time Complexity` : `O(N)`\\n`Space Complexity` : `O(1)`\\n```\\nclass Solution:\\n    def minSideJumps(self, obs):\\n        n = len(obs)\\n        dp = [0] * 4\\n        for i in range(n - 2, 0, -1):\\n            if obs[i] == 0 or obs[i] == obs[i - 1]: continue    # this line can be ignored\\n            dp[obs[i]] = min(dp[j] for j in range(1, 4) if obs[i] != j and obs[i-1] != j) + 1\\n        return dp[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obs):\\n        n = len(obs)\\n        dp = [0] * 4\\n        for i in range(n - 2, 0, -1):\\n            if obs[i] == 0 or obs[i] == obs[i - 1]: continue    # this line can be ignored\\n            dp[obs[i]] = min(dp[j] for j in range(1, 4) if obs[i] != j and obs[i-1] != j) + 1\\n        return dp[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197001,
                "title": "c-memoization-on-recursion-simple-readable-code",
                "content": "```\\nIf you have any queries in this code, feel free to discuss. \\nThank you.\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &obstacles, int n, int currPos, int currLane, vector<vector<int>> &dp) {\\n        if(currPos==n)\\n            return(0);\\n        if(dp[currPos][currLane]!=-1)\\n            return(dp[currPos][currLane]);\\n        if(obstacles[currPos+1]!=currLane)\\n            return(dp[currPos][currLane]=solve(obstacles, n, currPos+1, currLane, dp));\\n        int mini=1e9;\\n        for(int i=1;i<=3;i++) {\\n            if(i!=currLane) {\\n                if(obstacles[currPos]!=i) {\\n                    mini=min(mini, 1+solve(obstacles, n, currPos, i, dp));\\n                }\\n            }\\n        }\\n        return(dp[currPos][currLane]=mini);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>> dp(n+5, vector<int>(4, -1));\\n        int ans=solve(obstacles, n, 0, 2, dp);\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nIf you have any queries in this code, feel free to discuss. \\nThank you.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &obstacles, int n, int currPos, int currLane, vector<vector<int>> &dp) {\\n        if(currPos==n)\\n            return(0);\\n        if(dp[currPos][currLane]!=-1)\\n            return(dp[currPos][currLane]);\\n        if(obstacles[currPos+1]!=currLane)\\n            return(dp[currPos][currLane]=solve(obstacles, n, currPos+1, currLane, dp));\\n        int mini=1e9;\\n        for(int i=1;i<=3;i++) {\\n            if(i!=currLane) {\\n                if(obstacles[currPos]!=i) {\\n                    mini=min(mini, 1+solve(obstacles, n, currPos, i, dp));\\n                }\\n            }\\n        }\\n        return(dp[currPos][currLane]=mini);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>> dp(n+5, vector<int>(4, -1));\\n        int ans=solve(obstacles, n, 0, 2, dp);\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160406,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master): It is more natural for me to switch the rows and columns, ie. let `dp[i][j]` denote the minimum side-steps performed to reach cell `i`,`j`.  The goal is to reach the `N`<sup>th</sup> row at minimum cost.  This bottom-up solution first attempts to perform optimal side-steps for the previous `i - 1`<sup>th</sup> row by optimally side-stepping from each column `j` to each column `k` (an astute observer will notice when `j == k`, this minimum operation is a no-op, since `min(x, x) == x`).  Then use those optimal solutions of the previous `i - 1`<sup>th</sup> row to formulate the optimal solutions of the current `i`<sup>th</sup> row until the `N`<sup>th</sup> row is reached.  Then we return the minimal value of the `N - 1`<sup>th</sup> row as the best answer.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var dp = Array(N){ IntArray(3){ INF } }                                 // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                            // \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                                     // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                                     // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j])                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n        }\\n        return dp[N - 1].min()!!                                                // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var pre = arrayOf(1, 0, 1)                            // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                              // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                  // cur obstacle \\uD83C\\uDF4F at cur row i\\n            var cur = arrayOf(INF, INF, INF)\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                   // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        pre[j] = Math.min(pre[j], 1 + pre[k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                   // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = Math.min(cur[j], pre[j])         // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n            pre = cur.copyOf()                                // \\uD83E\\uDD14 memo\\n        }\\n        return pre.min()!!                                    // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(3).fill(Infinity));                // \\uD83E\\uDD14 memo\\n    dp[0][1] = 0;                                                            // \\uD83D\\uDED1 base case\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n    }\\n    return Math.min(...dp[N - 1]);                                           // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let pre = [1, 0, 1];                                     // \\uD83E\\uDD14 memo\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        let cur = [Infinity, Infinity, Infinity];\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    pre[j] = Math.min(pre[j], 1 + pre[k]);   // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                cur[j] = Math.min(cur[j], pre[j]);           // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n        pre = [...cur];                                      // \\uD83E\\uDD14 memo\\n    }\\n    return Math.min(...pre);                                 // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(N)]                        # \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                       # \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                                               # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                                   # cur obstacle \\uD83C\\uDF4F at cur row i\\n            # best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            for j in range(3):\\n                if j != x:                                                 # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                                                 # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])                 # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        return min(dp[N - 1])                                              # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        pre = [1, 0, 1]                                  # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                             # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                 # cur obstacle \\uD83C\\uDF4F at cur row i\\n            cur = [INF, INF, INF]\\n            for j in range(3):\\n                if j != x:                               # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        pre[j] = min(pre[j], 1 + pre[k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                               # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j])         # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            pre = cur.copy()                             # \\uD83E\\uDD14 memo\\n        return min(pre)                                  # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N, VI(3, INF));                                              // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0;                                                       // \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                                          // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                                              // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                                                 // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                                                 // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);                 // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n        }\\n        return *min_element(dp[N - 1].begin(), dp[N - 1].end());            // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VI pre{ 1, 0, 1 };                                // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                        // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                            // cur obstacle \\uD83C\\uDF4F at cur row i\\n            VI cur{ INF, INF, INF };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                               // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        pre[j] = min(pre[j], 1 + pre[k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                               // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j]);         // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n            pre.swap(cur);                                // \\uD83E\\uDD14 memo\\n        }\\n        return *min_element(pre.begin(), pre.end());      // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var dp = Array(N){ IntArray(3){ INF } }                                 // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                            // \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                                     // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                                     // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j])                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n        }\\n        return dp[N - 1].min()!!                                                // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var pre = arrayOf(1, 0, 1)                            // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                              // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                  // cur obstacle \\uD83C\\uDF4F at cur row i\\n            var cur = arrayOf(INF, INF, INF)\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                   // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        pre[j] = Math.min(pre[j], 1 + pre[k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                   // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = Math.min(cur[j], pre[j])         // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n            pre = cur.copyOf()                                // \\uD83E\\uDD14 memo\\n        }\\n        return pre.min()!!                                    // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(3).fill(Infinity));                // \\uD83E\\uDD14 memo\\n    dp[0][1] = 0;                                                            // \\uD83D\\uDED1 base case\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n    }\\n    return Math.min(...dp[N - 1]);                                           // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let pre = [1, 0, 1];                                     // \\uD83E\\uDD14 memo\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        let cur = [Infinity, Infinity, Infinity];\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    pre[j] = Math.min(pre[j], 1 + pre[k]);   // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                cur[j] = Math.min(cur[j], pre[j]);           // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n        pre = [...cur];                                      // \\uD83E\\uDD14 memo\\n    }\\n    return Math.min(...pre);                                 // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(N)]                        # \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                       # \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                                               # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                                   # cur obstacle \\uD83C\\uDF4F at cur row i\\n            # best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            for j in range(3):\\n                if j != x:                                                 # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                                                 # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])                 # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        return min(dp[N - 1])                                              # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        pre = [1, 0, 1]                                  # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                             # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                 # cur obstacle \\uD83C\\uDF4F at cur row i\\n            cur = [INF, INF, INF]\\n            for j in range(3):\\n                if j != x:                               # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        pre[j] = min(pre[j], 1 + pre[k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                               # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j])         # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            pre = cur.copy()                             # \\uD83E\\uDD14 memo\\n        return min(pre)                                  # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N, VI(3, INF));                                              // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0;                                                       // \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                                          // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                                              // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                                                 // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                                                 // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);                 // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n        }\\n        return *min_element(dp[N - 1].begin(), dp[N - 1].end());            // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VI pre{ 1, 0, 1 };                                // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                        // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                            // cur obstacle \\uD83C\\uDF4F at cur row i\\n            VI cur{ INF, INF, INF };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                               // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        pre[j] = min(pre[j], 1 + pre[k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                               // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j]);         // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n            pre.swap(cur);                                // \\uD83E\\uDD14 memo\\n        }\\n        return *min_element(pre.begin(), pre.end());      // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155406,
                "title": "java-dp-o-n-o-1",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for(int i=1; i<obstacles.length; i++){\\n            switch(obstacles[i]){\\n                case 0:\\n                    dp[0] = min(dp[0], dp[1]+1, dp[2]+1);\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1);\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2]);\\n                    break;\\n                case 1:\\n                    dp[0] = Integer.MAX_VALUE;\\n                    dp[1] = min(dp[1], dp[2]+1);\\n                    dp[2] = min(dp[1]+1, dp[2]);\\n                    break;\\n                case 2:\\n                    dp[0] = min(dp[0], dp[2]+1);\\n                    dp[1] = Integer.MAX_VALUE;\\n                    dp[2] = min(dp[0]+1, dp[2]);\\n                    break;\\n                case 3:\\n                    dp[0] = min(dp[0], dp[1]+1);\\n                    dp[1] = min(dp[0]+1, dp[1]);\\n                    dp[2] = Integer.MAX_VALUE;\\n                    break;\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    int min(int... vals){\\n        int min = Integer.MAX_VALUE;\\n        for(int val: vals){\\n            if(val>=0) min = Math.min(min, val);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for(int i=1; i<obstacles.length; i++){\\n            switch(obstacles[i]){\\n                case 0:\\n                    dp[0] = min(dp[0], dp[1]+1, dp[2]+1);\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1);\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2]);\\n                    break;\\n                case 1:\\n                    dp[0] = Integer.MAX_VALUE;\\n                    dp[1] = min(dp[1], dp[2]+1);\\n                    dp[2] = min(dp[1]+1, dp[2]);\\n                    break;\\n                case 2:\\n                    dp[0] = min(dp[0], dp[2]+1);\\n                    dp[1] = Integer.MAX_VALUE;\\n                    dp[2] = min(dp[0]+1, dp[2]);\\n                    break;\\n                case 3:\\n                    dp[0] = min(dp[0], dp[1]+1);\\n                    dp[1] = min(dp[0]+1, dp[1]);\\n                    dp[2] = Integer.MAX_VALUE;\\n                    break;\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    int min(int... vals){\\n        int min = Integer.MAX_VALUE;\\n        for(int val: vals){\\n            if(val>=0) min = Math.min(min, val);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153580,
                "title": "c-solution-based-on-bfs",
                "content": "Apply the standard BFS algorithm, but with some modifications.\\nIf there is no obstacles on current line -> just move forward (it will be most optimal solution).\\nIf there is an obstacle consider both of two other lines.\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        using ip = pair<int, pair<int, int>>;\\n        int size = obstacles.size();\\n        queue<ip> q;\\n        vector<vector<bool>> vis(4, vector<bool>(size, false));\\n        int sidej = INT_MAX;\\n        q.push({0, {2, 0}});\\n        vis[2][0] = true;\\n        while (!q.empty()) {\\n            auto p = q.front(); q.pop();\\n            int point = p.second.second;\\n            int line = p.second.first;\\n            int jumps = p.first;\\n            if (point >= size) return jumps;\\n            if (obstacles[point + 1] != line) {\\n                q.push({jumps, {line, point + 1}});\\n                vis[line][point + 1] = true;\\n            } else {\\n                for (int i = 1; i <= 3; i++) {\\n                    if (i != line && obstacles[point] != i) {\\n                        if (!vis[i][point]) {\\n                            q.push({jumps + 1, {i, point}});\\n                            vis[i][point] = true;\\n                        }\\n                    }\\n                }   \\n            }\\n        }\\n        return sidej;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        using ip = pair<int, pair<int, int>>;\\n        int size = obstacles.size();\\n        queue<ip> q;\\n        vector<vector<bool>> vis(4, vector<bool>(size, false));\\n        int sidej = INT_MAX;\\n        q.push({0, {2, 0}});\\n        vis[2][0] = true;\\n        while (!q.empty()) {\\n            auto p = q.front(); q.pop();\\n            int point = p.second.second;\\n            int line = p.second.first;\\n            int jumps = p.first;\\n            if (point >= size) return jumps;\\n            if (obstacles[point + 1] != line) {\\n                q.push({jumps, {line, point + 1}});\\n                vis[line][point + 1] = true;\\n            } else {\\n                for (int i = 1; i <= 3; i++) {\\n                    if (i != line && obstacles[point] != i) {\\n                        if (!vis[i][point]) {\\n                            q.push({jumps + 1, {i, point}});\\n                            vis[i][point] = true;\\n                        }\\n                    }\\n                }   \\n            }\\n        }\\n        return sidej;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153503,
                "title": "java-dp-recursive-code-with-matrix-to-memorize",
                "content": "my lane values will be 0,1,2\\nto switch between the lanes i have subtracted -1 from the array given\\nso to switch i can easily add +1 and +2 to the currentlane and do % with 3 to find the available option\\nex- current lane=1 so to switch between lanes, available options are 0 and 2\\nto get that 1+1%3=2 and 1+2%3=0\\nsimilarly for current lane=0 so to switch between lanes, options available are 1 and 2\\nto get that 0+1%3=1 and 0+2%3=2\\nand  for current lane=2 so to switch between lanes options available are 0 and 1\\nto get that 2+1%3=0 and 2+2%3=1\\n\\nRecursive Trree will be \\ncureentlane !=obstracle[i+1] in that case just move forward no need to jump\\nor\\nin this find the min between (switch lane option)\\nMy code\\n~~~\\nclass Solution {\\n    int[][] t=new int[3][500001];\\n    public int minSideJumps(int[] obstacles) {\\n        int index=0;\\n        int laneno=1;\\n        for(int i=0;i<obstacles.length;i++){\\n            obstacles[i]=obstacles[i]-1;\\n        }\\n       \\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<500001;j++){\\n                t[i][j]=-1;\\n            }\\n        }\\n        return minJump(index,laneno,obstacles);\\n    }\\n\\n    public int minJump(int index,int currLane,int[] obstacles){\\n        \\n        if(index>=obstacles.length-1){\\n            return 0;\\n        }\\n        \\n        if(t[currLane][index]!=-1){\\n            return t[currLane][index];\\n        }\\n\\n        if(currLane!=obstacles[index+1]){\\n            t[currLane][index]= 0+minJump(index+1,currLane,obstacles);\\n        }else {\\n            int a=500001;\\n            int b=500001;\\n            \\n            if(obstacles[index]!=(currLane+1)%3){\\n                a= minJump(index,(currLane+1)%3,obstacles);\\n            }\\n\\n            if(obstacles[index]!=(currLane+2)%3){\\n                b=minJump(index,(currLane+2)%3,obstacles);\\n            }\\n\\n            t[currLane][index] = 1+Math.min(a,b);\\n        }\\n      return t[currLane][index];      \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[][] t=new int[3][500001];\\n    public int minSideJumps(int[] obstacles) {\\n        int index=0;\\n        int laneno=1;\\n        for(int i=0;i<obstacles.length;i++){\\n            obstacles[i]=obstacles[i]-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1152790,
                "title": "java-bfs-solution-o-n",
                "content": "```\\nclass State{\\n    int jumps;\\n    int index;\\n    int lane;\\n    State(){\\n        this.lane = 2;\\n    }\\n    State(int j, int i, int l){\\n        this.jumps = j;\\n        this.index = i;\\n        this.lane = l;\\n    }\\n}\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        Queue<State> q = new LinkedList<State>();\\n        boolean[][] vis = new boolean[4][obstacles.length];\\n        q.offer(new State(0,0,2));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                //Get current state\\n                State front = q.poll();\\n                \\n                //Check if we are at the end of the road\\n                if(front.index == obstacles.length-1){\\n                    return front.jumps;\\n                }\\n                \\n                //Check if we are obstructed or check if this is visited already\\n                if(obstacles[front.index] == front.lane || vis[front.lane][front.index]){\\n                    continue;\\n                }\\n                \\n                //Visit current lane by marking it visited\\n                vis[front.lane][front.index] = true;\\n                \\n                \\n                //Add all other options from this state to next state\\n                for(int i=1;i<=3;i++){\\n                    \\n                    //Moving/Hopping to next index in same lane\\n                    if(i == front.lane){\\n                        q.offer(new State(front.jumps, front.index+1, i));\\n                    }\\n                    //Exploring sideways jumps also\\n                    else{\\n                        q.offer(new State(front.jumps+1, front.index, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //No route till end of the road, Not possible in this question I guess\\n        return -1;\\n    }\\n}\\n```\\n**Time Complexity:** We are visiting every possible position on the road for the frog, \\n\\t\\t\\t\\t\\t\\t\\tO(No. of lanes * length of the lane(obstacles)) = O(3 * N)\\n**Space Complexity:** O(4 * N), for keeping track whether each position is visited or not,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tusing 4 instead of 3 as the rows of vis[][] is 4, to handle 1-indexed\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlanes.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State{\\n    int jumps;\\n    int index;\\n    int lane;\\n    State(){\\n        this.lane = 2;\\n    }\\n    State(int j, int i, int l){\\n        this.jumps = j;\\n        this.index = i;\\n        this.lane = l;\\n    }\\n}\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        Queue<State> q = new LinkedList<State>();\\n        boolean[][] vis = new boolean[4][obstacles.length];\\n        q.offer(new State(0,0,2));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                //Get current state\\n                State front = q.poll();\\n                \\n                //Check if we are at the end of the road\\n                if(front.index == obstacles.length-1){\\n                    return front.jumps;\\n                }\\n                \\n                //Check if we are obstructed or check if this is visited already\\n                if(obstacles[front.index] == front.lane || vis[front.lane][front.index]){\\n                    continue;\\n                }\\n                \\n                //Visit current lane by marking it visited\\n                vis[front.lane][front.index] = true;\\n                \\n                \\n                //Add all other options from this state to next state\\n                for(int i=1;i<=3;i++){\\n                    \\n                    //Moving/Hopping to next index in same lane\\n                    if(i == front.lane){\\n                        q.offer(new State(front.jumps, front.index+1, i));\\n                    }\\n                    //Exploring sideways jumps also\\n                    else{\\n                        q.offer(new State(front.jumps+1, front.index, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //No route till end of the road, Not possible in this question I guess\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152687,
                "title": "simple-c-o-n-time-complexity-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n      \\n        int l[] = {0,0,0,0};\\n        \\n        for(int i=obstacles.size()-2; i>0 ; i--){\\n            \\n            int nl[] = {0,0,0,0};\\n            \\n            l[obstacles[i+1]] = 500001;\\n            l[obstacles[i]] = 500001;          \\n            \\n            nl[1] = min(l[1], min(l[2]+1, l[3]+1));\\n            nl[2] = min(l[2], min(l[1]+1, l[3]+1));\\n            nl[3] = min(l[3], min(l[2]+1, l[1]+1));           \\n            \\n            \\n            copy(begin(nl),end(nl),begin(l));\\n            \\n        }\\n        \\n        return min(l[2], min(l[1]+1, l[3]+1));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n      \\n        int l[] = {0,0,0,0};\\n        \\n        for(int i=obstacles.size()-2; i>0 ; i--){\\n            \\n            int nl[] = {0,0,0,0};\\n            \\n            l[obstacles[i+1]] = 500001;\\n            l[obstacles[i]] = 500001;          \\n            \\n            nl[1] = min(l[1], min(l[2]+1, l[3]+1));\\n            nl[2] = min(l[2], min(l[1]+1, l[3]+1));\\n            nl[3] = min(l[3], min(l[2]+1, l[1]+1));           \\n            \\n            \\n            copy(begin(nl),end(nl),begin(l));\\n            \\n        }\\n        \\n        return min(l[2], min(l[1]+1, l[3]+1));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152680,
                "title": "python-3-clear-easy",
                "content": "Calculating optimal no of steps required for travelling from particular position to end (each line)\\nfrom the end\\n##### Example\\n\\t\\t       0       1      2      3      0\\n\\t\\t\\t   ---------------------------------\\n\\t\\t x    inf    inf      1      0      0\\n\\t     y     2     2       inf     0      0  \\n\\t\\t z     1     1        1      i      0\\n\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        x,y,z=0,0,0\\n        px,py,pz=0,0,0\\n\\n        for o in obstacles[::-1][1:]:\\n            \\n            if o==1:\\n                x = float(\"inf\")\\n                y = min(py, pz+1)\\n                z = min(pz, py+1)\\n            elif o==2:\\n                y = float(\"inf\")\\n                x = min(px, pz+1)\\n                z = min(pz, px+1)\\n            elif o==3:\\n                z = float(\"inf\")\\n                y = min(py, px+1)\\n                x = min(px, py+1)\\n            else:\\n                y = min(py, px+1, pz+1)\\n                x = min(px, py+1, pz+1)\\n                z = min(pz, px+1, py+1)\\n            px,py,pz=x,y,z                \\n\\n        return y\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        x,y,z=0,0,0\\n        px,py,pz=0,0,0\\n\\n        for o in obstacles[::-1][1:]:\\n            \\n            if o==1:\\n                x = float(\"inf\")\\n                y = min(py, pz+1)\\n                z = min(pz, py+1)\\n            elif o==2:\\n                y = float(\"inf\")\\n                x = min(px, pz+1)\\n                z = min(pz, px+1)\\n            elif o==3:\\n                z = float(\"inf\")\\n                y = min(py, px+1)\\n                x = min(px, py+1)\\n            else:\\n                y = min(py, px+1, pz+1)\\n                x = min(px, py+1, pz+1)\\n                z = min(pz, px+1, py+1)\\n            px,py,pz=x,y,z                \\n\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253238,
                "title": "simple-memoized-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->]\\nhere  at each step if the current lane does not have any obstacle in the next point then move in the current lane .otherwise need to use sideways jumps\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int help(int point,int lane,vector<int>&obstacles,vector<vector<int>>&dp){\\n\\n\\n        if(point>=obstacles.size()-1){\\n            return dp[point][lane]=0;\\n            //this is the base case\\n        }\\n\\n        if(dp[point][lane]!=-1){\\n            return dp[point][lane];\\n        }\\n\\n\\n\\n        if(obstacles[point+1]==0||obstacles[point+1]!=lane){\\n            //current lane me hi i will move one step formward for the most optimal answer \\n            //as i need to optimse the n umber of side jumps overall\\n             dp[point][lane]=help(point+1,lane,obstacles,dp);\\n        }else{\\n\\n            int c=obstacles[point+1];\\n            int mn=INT_MAX;\\n            if(c!=1 && obstacles[point]!=1){\\n                mn=min(mn,help(point+1,1,obstacles,dp)+1);\\n\\n            }\\n            if(c!=2 && obstacles[point]!=2){\\n                mn=min(mn,help(point+1,2,obstacles,dp)+1);\\n\\n            }\\n            if(c!=3 && obstacles[point]!=3){\\n                mn=min(mn,help(point+1,3,obstacles,dp)+1);\\n            }\\n             dp[point][lane]=mn;\\n        }\\n        return dp[point][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        //note you should first read the question carefully \\n\\n        if(obstacles.size()<=1){\\n            return 0;\\n        }\\n        //when ever he makes a sideway jump he makes it to a diff lane on the same point\\n        int n=obstacles.size();\\n        //now we willl optimse it \\n        //see which all variables are changing in the current recursiuve \\n        //logic building and implementation both somewhat diff\\n        vector<vector<int>>dp(n+2,vector<int>(4,-1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-min number of side way jumps to reach the last points\\n\\n\\n        return help(0,2,obstacles,dp);\\n\\n        //there are no obstacles on point 0 to n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int help(int point,int lane,vector<int>&obstacles,vector<vector<int>>&dp){\\n\\n\\n        if(point>=obstacles.size()-1){\\n            return dp[point][lane]=0;\\n            //this is the base case\\n        }\\n\\n        if(dp[point][lane]!=-1){\\n            return dp[point][lane];\\n        }\\n\\n\\n\\n        if(obstacles[point+1]==0||obstacles[point+1]!=lane){\\n            //current lane me hi i will move one step formward for the most optimal answer \\n            //as i need to optimse the n umber of side jumps overall\\n             dp[point][lane]=help(point+1,lane,obstacles,dp);\\n        }else{\\n\\n            int c=obstacles[point+1];\\n            int mn=INT_MAX;\\n            if(c!=1 && obstacles[point]!=1){\\n                mn=min(mn,help(point+1,1,obstacles,dp)+1);\\n\\n            }\\n            if(c!=2 && obstacles[point]!=2){\\n                mn=min(mn,help(point+1,2,obstacles,dp)+1);\\n\\n            }\\n            if(c!=3 && obstacles[point]!=3){\\n                mn=min(mn,help(point+1,3,obstacles,dp)+1);\\n            }\\n             dp[point][lane]=mn;\\n        }\\n        return dp[point][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        //note you should first read the question carefully \\n\\n        if(obstacles.size()<=1){\\n            return 0;\\n        }\\n        //when ever he makes a sideway jump he makes it to a diff lane on the same point\\n        int n=obstacles.size();\\n        //now we willl optimse it \\n        //see which all variables are changing in the current recursiuve \\n        //logic building and implementation both somewhat diff\\n        vector<vector<int>>dp(n+2,vector<int>(4,-1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-min number of side way jumps to reach the last points\\n\\n\\n        return help(0,2,obstacles,dp);\\n\\n        //there are no obstacles on point 0 to n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935585,
                "title": "easy-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602192,
                "title": "c-recursion-tle-memoization-top-down-bottom-up",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n**There are 3 approaches :**\\n* Recursion **(TLE)**\\n* Recursion + (DP) **Memoization** (Top down approach ) \\n* Dp with Bottom up approach **Will upload code tomarrow **\\n\\n\\n\\n***1st Approach : Recursion (TLE) NOT ACCEPTED*** \\n```\\nint solve(vector<int>& obstacles, int pos,int currlane){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i));\\n            }\\n            return ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        return solve(obstacles,0,2);\\n        \\n    }\\n```\\n\\n***2nd Approach : Recursion + Memoization (TOP Down approach )***\\n```\\nint solve(vector<int>& obstacles, int pos,int currlane,vector<vector<int>>& dp){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(dp[currlane][pos]!=-1) return dp[currlane][pos];\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane,dp);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i,dp));\\n            }\\n            return dp[currlane][pos]=ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,0,2,dp);\\n        \\n    }\\n```\\n***3rd Approach : dp (Bottom up  approach )***\\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int> > dp(4,vector<int>(obstacles.size(),1e9));\\n        \\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n        for(int currpos=n-1;currpos>=0;currpos--){\\n            for(int currlane=1;currlane<=3;currlane++){\\n                if(currlane!=obstacles[currpos+1]){\\n                    dp[currlane][currpos]=dp[currlane][currpos+1];\\n                }else{\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(currlane!=i && obstacles[currpos]!=i)\\n                         ans=min(ans,1+dp[i][currpos+1]);\\n                    }\\n                    dp[currlane][currpos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int>& obstacles, int pos,int currlane){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i));\\n            }\\n            return ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        return solve(obstacles,0,2);\\n        \\n    }\\n```\n```\\nint solve(vector<int>& obstacles, int pos,int currlane,vector<vector<int>>& dp){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(dp[currlane][pos]!=-1) return dp[currlane][pos];\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane,dp);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i,dp));\\n            }\\n            return dp[currlane][pos]=ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,0,2,dp);\\n        \\n    }\\n```\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int> > dp(4,vector<int>(obstacles.size(),1e9));\\n        \\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n        for(int currpos=n-1;currpos>=0;currpos--){\\n            for(int currlane=1;currlane<=3;currlane++){\\n                if(currlane!=obstacles[currpos+1]){\\n                    dp[currlane][currpos]=dp[currlane][currpos+1];\\n                }else{\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(currlane!=i && obstacles[currpos]!=i)\\n                         ans=min(ans,1+dp[i][currpos+1]);\\n                    }\\n                    dp[currlane][currpos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258473,
                "title": "c-dp-tabulation-time-complexity-o-n",
                "content": "```\\n int minSideJumps(vector<int>& obstacles) {\\n        \\n        int i,j,n=obstacles.size();\\n        int dp[n][4],mini=INT_MAX;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = 0;\\n        dp[0][3] = INT_MIN;\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=1;j<=3;j++)\\n            {\\n                if(j==obstacles[i])\\n                {\\n                    dp[i][j] = INT_MIN;\\n                    continue;\\n                }\\n                dp[i][j] = INT_MAX;\\n                if(j==1)\\n                {\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][1]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==2)\\n                {\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][2]);\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==3)\\n                {\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][3]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                \\n                \\n            }\\n        }\\n        for(i=1;i<=3;i++)\\n        {\\n            if(dp[n-1][i]>=0)\\n            {\\n                mini = min(mini,dp[n-1][i]);\\n            }\\n        }\\n      \\n        return mini;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int minSideJumps(vector<int>& obstacles) {\\n        \\n        int i,j,n=obstacles.size();\\n        int dp[n][4],mini=INT_MAX;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = 0;\\n        dp[0][3] = INT_MIN;\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=1;j<=3;j++)\\n            {\\n                if(j==obstacles[i])\\n                {\\n                    dp[i][j] = INT_MIN;\\n                    continue;\\n                }\\n                dp[i][j] = INT_MAX;\\n                if(j==1)\\n                {\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][1]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==2)\\n                {\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][2]);\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==3)\\n                {\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][3]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                \\n                \\n            }\\n        }\\n        for(i=1;i<=3;i++)\\n        {\\n            if(dp[n-1][i]>=0)\\n            {\\n                mini = min(mini,dp[n-1][i]);\\n            }\\n        }\\n      \\n        return mini;",
                "codeTag": "Unknown"
            },
            {
                "id": 2096522,
                "title": "python-100-speed-simplest-dp",
                "content": "The key idea is to remember the last lanes we can stay, remove the facing obstacle, and jump to the avaliable lanes with added steps (Ok, maybe rename it with jump would be a little better) when no more past lanes. \\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # solution 1\\n        n = len(obstacles)\\n        step = 0\\n        lanes = {2}\\n        pre_lanes = {i: {not_i for not_i in range(1,4) if not_i != i} for i in range(1, 4)}\\n        for i in range(1, n):\\n            lanes -= {obstacles[i]}\\n            if not len(lanes):\\n                step += 1\\n                lanes = pre_lanes[obstacles[i]] - {obstacles[i-1]}\\n        return step\\n                \\n```\\n![image](https://assets.leetcode.com/users/images/4ccde6a8-00e4-4fd2-a4fa-bc0cf9eab17f_1654055140.292658.png)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # solution 1\\n        n = len(obstacles)\\n        step = 0\\n        lanes = {2}\\n        pre_lanes = {i: {not_i for not_i in range(1,4) if not_i != i} for i in range(1, 4)}\\n        for i in range(1, n):\\n            lanes -= {obstacles[i]}\\n            if not len(lanes):\\n                step += 1\\n                lanes = pre_lanes[obstacles[i]] - {obstacles[i-1]}\\n        return step\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069904,
                "title": "c-greedy-bit-manipulation-creative-time-o-n-space-o-1-90-81-86-88",
                "content": "### Why greedy method works?\\nLook at example 3:\\nAt index 0, frog can **side jump** to lane 1 or lane 3. \\nFor the case **side jump**  to lane 1, frog  need to go back to lane 3 at index 1 because of  obstacles[2].\\n\\nWe can find that **two cases have *the same status* at index 1**, but the case side jump to lane 1 costs **two** side jump.\\nSo, we can claim the case jump to lane 1 **will never be better than** another case, in any situation.\\n![image](https://assets.leetcode.com/users/images/2184a8a0-3bcd-479c-bb7e-9588e60368c6_1653395982.937031.png)\\n\\n\\n\\n### But ... How to keep track of two cases? \\n### The answer is Quantum Frogs!!\\n\\n1. When frog side jump, frog **split**.\\n2. We can use **3 bits** ( lane1 to lane3 ) to record if the quantum frog alive in that lane.\\n3. When quantum frog meet obstacles, it dies.\\n4. When all quantum frogs die, means a side jump. \\nAnd quantum frogs appear in other two lanes, excepting obstacle exist at this index.\\n![image](https://assets.leetcode.com/users/images/1020876b-366b-4543-a9cd-d755ec4757b6_1653399540.528078.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int cnt = 0;\\n        // 3 bits status\\n        // 000\\n        // 001\\n        // 010\\n        // 011\\n        // 100\\n        // 101\\n        // 110\\n        // 111\\n        // turn left 90\\'\\n        int status = 2;\\n        for(int i = 0; i < obstacles.size()-1; i++){\\n            if(obstacles[i+1] == 2 && (status & (1<<1)) ){\\n                status -= 2;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 5;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 3 && (status & (1<<2)) ){\\n                status -= 4;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 3;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 1 && (status & 1) ){\\n                status -= 1;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 6;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n```\\nRuntime: 327 ms, faster than 90.81% of C++ online submissions for Minimum Sideway Jumps.\\nMemory Usage: 188 MB, less than 86.88% of C++ online submissions for Minimum Sideway Jumps.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int cnt = 0;\\n        // 3 bits status\\n        // 000\\n        // 001\\n        // 010\\n        // 011\\n        // 100\\n        // 101\\n        // 110\\n        // 111\\n        // turn left 90\\'\\n        int status = 2;\\n        for(int i = 0; i < obstacles.size()-1; i++){\\n            if(obstacles[i+1] == 2 && (status & (1<<1)) ){\\n                status -= 2;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 5;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 3 && (status & (1<<2)) ){\\n                status -= 4;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 3;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 1 && (status & 1) ){\\n                status -= 1;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 6;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nRuntime: 327 ms, faster than 90.81% of C++ online submissions for Minimum Sideway Jumps.\\nMemory Usage: 188 MB, less than 86.88% of C++ online submissions for Minimum Sideway Jumps.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584262,
                "title": "java-clean-and-concise-dp-tabulation-solution-o-3-n",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][n];\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j <= 3; j++){\\n                dp[j][i] = dp[j][i+1];\\n                if(obstacles[i] == j)\\n                    dp[j][i] = Integer.MAX_VALUE;\\n            }\\n            int j = obstacles[i+1];\\n            dp[j][i] = Math.min(dp[1][i], Math.min(dp[2][i], dp[3][i])) + 1;\\n        }\\n        \\n        return dp[2][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][n];\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j <= 3; j++){\\n                dp[j][i] = dp[j][i+1];\\n                if(obstacles[i] == j)\\n                    dp[j][i] = Integer.MAX_VALUE;\\n            }\\n            int j = obstacles[i+1];\\n            dp[j][i] = Math.min(dp[1][i], Math.min(dp[2][i], dp[3][i])) + 1;\\n        }\\n        \\n        return dp[2][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449150,
                "title": "c-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<int> dp = {INT_MAX,1,0,1};\\n        for(int ob : obstacles) {\\n            dp[ob] = INT_MAX;\\n            int minJumps = *min_element(dp.begin(), dp.end());\\n            for(int i = 1; i < 4; ++i) {\\n                if(ob == i) continue;\\n                dp[i] = min(minJumps+1, dp[i]);\\n            }\\n        }\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<int> dp = {INT_MAX,1,0,1};\\n        for(int ob : obstacles) {\\n            dp[ob] = INT_MAX;\\n            int minJumps = *min_element(dp.begin(), dp.end());\\n            for(int i = 1; i < 4; ++i) {\\n                if(ob == i) continue;\\n                dp[i] = min(minJumps+1, dp[i]);\\n            }\\n        }\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355888,
                "title": "c-short-and-crisp-explanation-similar-to-frog-jump-1",
                "content": "-------1--------\\nf  --2---------2--\\n   ------3---------\\n   \\n   Frog is intially in second lane so just keep in mind that we have to go from point 0 to point N and whenever we see an obstacle at current position so we change our lane where there is no obstacle at current point.\\n   \\n  So here only two states are changing --> position of the frog and Lane of the frog\\n  These states becomes our dp states which makes this problem exactly similar to Frog jump1\\n  \\n  ```\\n  class Solution {\\npublic:\\n    vector<int>lanes={1,2,3};\\n    \\n    int last_pos;\\n    vector<vector<int>>dp;\\n    int rec(int pos, int lane,vector<int>&obstacles){\\n        if(pos==last_pos) return 0;\\n        if(dp[pos][lane]!=-1) return dp[pos][lane];\\n        if(obstacles[pos]==lane){\\n            return INT_MAX;\\n        }\\n        \\n        if(obstacles[pos+1]!=lane){\\n            dp[pos][lane]=rec(pos+1,lane,obstacles);\\n        }\\n        else{\\n           int ans=INT_MAX;\\n            for(int i=0;i<=2;i++){\\n                if(lane!=lanes[i]){\\n                    ans=min(rec(pos,lanes[i],obstacles),ans);\\n                }\\n            }\\n          dp[pos][lane]=1+ans;  \\n        }\\n           \\n          \\n        \\n        \\n        return dp[pos][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        last_pos=obstacles.size()-1;\\n        dp.resize(obstacles.size(),vector<int>(4,-1));\\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\npublic:\\n    vector<int>lanes={1,2,3};\\n    \\n    int last_pos;\\n    vector<vector<int>>dp;\\n    int rec(int pos, int lane,vector<int>&obstacles){\\n        if(pos==last_pos) return 0;\\n        if(dp[pos][lane]!=-1) return dp[pos][lane];\\n        if(obstacles[pos]==lane){\\n            return INT_MAX;\\n        }\\n        \\n        if(obstacles[pos+1]!=lane){\\n            dp[pos][lane]=rec(pos+1,lane,obstacles);\\n        }\\n        else{\\n           int ans=INT_MAX;\\n            for(int i=0;i<=2;i++){\\n                if(lane!=lanes[i]){\\n                    ans=min(rec(pos,lanes[i],obstacles),ans);\\n                }\\n            }\\n          dp[pos][lane]=1+ans;  \\n        }\\n           \\n          \\n        \\n        \\n        return dp[pos][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        last_pos=obstacles.size()-1;\\n        dp.resize(obstacles.size(),vector<int>(4,-1));\\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242581,
                "title": "c-dp-solution-explained-most-efficient",
                "content": "We Initialize the DP with INFINITY.\\nIf there is obstackle on previous index or there is obstacle on current index , thn we cannot reach that index so we will assign INFINITY to it,\\notherwise we will assignt the mininum value from (considering that lane to reach the end, changing the lane)\\n\\n```\\nclass Solution {\\npublic:\\n     int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp (n, vector<int>(3, 99999999));\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int k = 0; k < 3; k++) {\\n                if (obstacles[i - 1] == (k + 1) || obstacles[i] == (k + 1)) {\\n                    dp[i][k] = 99999999;\\n                } else {\\n                    int a_lane = (k + 1) % 3;\\n                    int b_lane = (k + 2) % 3;\\n                    dp[i][k] = min(dp[i - 1][k], min(dp[i - 1][a_lane], dp[i - 1][b_lane]) + 1);\\n                }\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```\\n\\nDo Upvote!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp (n, vector<int>(3, 99999999));\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int k = 0; k < 3; k++) {\\n                if (obstacles[i - 1] == (k + 1) || obstacles[i] == (k + 1)) {\\n                    dp[i][k] = 99999999;\\n                } else {\\n                    int a_lane = (k + 1) % 3;\\n                    int b_lane = (k + 2) % 3;\\n                    dp[i][k] = min(dp[i - 1][k], min(dp[i - 1][a_lane], dp[i - 1][b_lane]) + 1);\\n                }\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193555,
                "title": "python-dp-solution",
                "content": "The idea is quite simple. Given initial position, we update each column of the dp with the shortest path, which is either shortest path from the same column +1 or from the previous position. The stones are weighted with a barrier, big number, which indicates that it needs inf many steps to get into that position.\\n\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        barrier = float(\\'inf\\')\\n        \\n        dp = [[0]*len(obstacles) for i in range(3)]\\n        \\n        if len(obstacles) < 3:\\n            return 0\\n        \\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        \\n        for i in range(1,len(obstacles)):\\n            if obstacles[i]>0:\\n                dp[obstacles[i]-1][i] = barrier \\n\\n            dp[0][i] = max(dp[0][i], min(dp[0][i-1], max(dp[1][i],dp[1][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[1][i] = max(dp[1][i], min(dp[1][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[2][i] = max(dp[2][i], min(dp[2][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[1][i],dp[1][i-1]+1)))\\n\\n                    \\n        return min([dp[i][-1] for i in range(3)])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        barrier = float(\\'inf\\')\\n        \\n        dp = [[0]*len(obstacles) for i in range(3)]\\n        \\n        if len(obstacles) < 3:\\n            return 0\\n        \\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        \\n        for i in range(1,len(obstacles)):\\n            if obstacles[i]>0:\\n                dp[obstacles[i]-1][i] = barrier \\n\\n            dp[0][i] = max(dp[0][i], min(dp[0][i-1], max(dp[1][i],dp[1][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[1][i] = max(dp[1][i], min(dp[1][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[2][i] = max(dp[2][i], min(dp[2][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[1][i],dp[1][i-1]+1)))\\n\\n                    \\n        return min([dp[i][-1] for i in range(3)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153526,
                "title": "c-memoization-faster-than-100",
                "content": "```\\nclass Solution {\\n    int dp[4][500001];\\npublic:\\n   int solve(vector<int>& obs,int currLane,int i){\\n        if(i==obs.size()-1) return 0;\\n        if(currLane == obs[i]) return 1e6;\\n        if(dp[currLane][i]!=-1) return dp[currLane][i];\\n       \\n        if(obs[i+1] == currLane)\\n             return dp[currLane][i]= 1+min(solve(obs,((currLane+1)%3 == 0)?3:(currLane+1)%3,i),solve(obs,((currLane+2)%3 == 0)?3:(currLane+2)%3,i));\\n        else \\n            return dp[currLane][i]=solve(obs,currLane,i+1);\\n             \\n    }\\n    \\n    int minSideJumps(vector<int>& obs) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obs,2,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[4][500001];\\npublic:\\n   int solve(vector<int>& obs,int currLane,int i){\\n        if(i==obs.size()-1) return 0;\\n        if(currLane == obs[i]) return 1e6;\\n        if(dp[currLane][i]!=-1) return dp[currLane][i];\\n       \\n        if(obs[i+1] == currLane)\\n             return dp[currLane][i]= 1+min(solve(obs,((currLane+1)%3 == 0)?3:(currLane+1)%3,i),solve(obs,((currLane+2)%3 == 0)?3:(currLane+2)%3,i));\\n        else \\n            return dp[currLane][i]=solve(obs,currLane,i+1);\\n             \\n    }\\n    \\n    int minSideJumps(vector<int>& obs) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obs,2,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152647,
                "title": "clean-java-solution-recursion-with-caching",
                "content": "```\\nInteger[][] cache;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        cache = new Integer[4][obstacles.length+1];\\n        return recurs(2, obstacles, 0);\\n    }\\n    \\n     private int recurs(int lane, int[] obs, int i) {\\n\\t        \\n        if(i+1 == obs.length-1) return 0;\\n\\n        if(cache[lane][i] != null) return cache[lane][i];\\n\\n        int val1 = Integer.MAX_VALUE, val2 = Integer.MAX_VALUE, val3 = Integer.MAX_VALUE, val4 = Integer.MAX_VALUE;\\n\\n        if(i+1 < obs.length && obs[i+1] == lane) {\\n\\n            if(lane-1 > 0 && obs[i] != lane-1) val1 = recurs(lane-1, obs, i+1);\\n            if(lane-2 > 0 && obs[i] != lane-2) val2 = recurs(lane-2, obs, i+1);\\n            if(lane+1 <= 3 && obs[i] != lane+1) val3 = recurs(lane+1, obs, i+1);\\n            if(lane+2 <= 3 && obs[i] != lane+2) val4 = recurs(lane+2, obs, i+1);\\n\\n            cache[lane][i] = 1 + Math.min(Math.min(Math.min(val1, val2), val3), val4);\\n\\n        } else {\\n\\n            cache[lane][i] = recurs(lane, obs, i+1);\\n\\n        }\\n         \\n        return cache[lane][i];\\n\\t        \\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nInteger[][] cache;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        cache = new Integer[4][obstacles.length+1];\\n        return recurs(2, obstacles, 0);\\n    }\\n    \\n     private int recurs(int lane, int[] obs, int i) {\\n\\t        \\n        if(i+1 == obs.length-1) return 0;\\n\\n        if(cache[lane][i] != null) return cache[lane][i];\\n\\n        int val1 = Integer.MAX_VALUE, val2 = Integer.MAX_VALUE, val3 = Integer.MAX_VALUE, val4 = Integer.MAX_VALUE;\\n\\n        if(i+1 < obs.length && obs[i+1] == lane) {\\n\\n            if(lane-1 > 0 && obs[i] != lane-1) val1 = recurs(lane-1, obs, i+1);\\n            if(lane-2 > 0 && obs[i] != lane-2) val2 = recurs(lane-2, obs, i+1);\\n            if(lane+1 <= 3 && obs[i] != lane+1) val3 = recurs(lane+1, obs, i+1);\\n            if(lane+2 <= 3 && obs[i] != lane+2) val4 = recurs(lane+2, obs, i+1);\\n\\n            cache[lane][i] = 1 + Math.min(Math.min(Math.min(val1, val2), val3), val4);\\n\\n        } else {\\n\\n            cache[lane][i] = recurs(lane, obs, i+1);\\n\\n        }\\n         \\n        return cache[lane][i];\\n\\t        \\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1152603,
                "title": "java-bfs-solution",
                "content": "The time complexity should be O(N). Correct me if I\\'m wrong.\\n```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int j;\\n        int step;\\n        \\n        public Node(int i, int j, int step) {\\n            this.i = i;\\n            this.j = j;\\n            this.step = step;\\n        }\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        boolean visited[][] = new boolean[3][N];\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1, 0, 0));\\n        visited[1][0] = true;\\n        \\n        while(!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            if(curr.j == N - 1) {\\n                return curr.step;\\n            }\\n            \\n            if(curr.i != obstacles[curr.j + 1] - 1 && !visited[curr.i][curr.j + 1]) {\\n                // jump forward\\n                visited[curr.i][curr.j + 1] = true;\\n                queue.add(new Node(curr.i, curr.j+1, curr.step));\\n            }\\n            \\n            int rowAfterJump = (curr.i + 1) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n            \\n            rowAfterJump = (curr.i + 2) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n        }\\n        \\n         return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int j;\\n        int step;\\n        \\n        public Node(int i, int j, int step) {\\n            this.i = i;\\n            this.j = j;\\n            this.step = step;\\n        }\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        boolean visited[][] = new boolean[3][N];\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1, 0, 0));\\n        visited[1][0] = true;\\n        \\n        while(!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            if(curr.j == N - 1) {\\n                return curr.step;\\n            }\\n            \\n            if(curr.i != obstacles[curr.j + 1] - 1 && !visited[curr.i][curr.j + 1]) {\\n                // jump forward\\n                visited[curr.i][curr.j + 1] = true;\\n                queue.add(new Node(curr.i, curr.j+1, curr.step));\\n            }\\n            \\n            int rowAfterJump = (curr.i + 1) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n            \\n            rowAfterJump = (curr.i + 2) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n        }\\n        \\n         return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152546,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        ans = [0]*3 \\n        for i in reversed(range(len(obstacles) - 1)): \\n            tmp = [inf]*3\\n            for k in range(3):\\n                if obstacles[i]-1 != k: \\n                    tmp[k] = ans[k]\\n                    if obstacles[i]-1 != (k+1)%3: tmp[k] = min(tmp[k], 1 + ans[(k+1)%3])\\n                    if obstacles[i]-1 != (k+2)%3: tmp[k] = min(tmp[k], 1 + ans[(k+2)%3])\\n            ans = tmp\\n        return ans[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        ans = [0]*3 \\n        for i in reversed(range(len(obstacles) - 1)): \\n            tmp = [inf]*3\\n            for k in range(3):\\n                if obstacles[i]-1 != k: \\n                    tmp[k] = ans[k]\\n                    if obstacles[i]-1 != (k+1)%3: tmp[k] = min(tmp[k], 1 + ans[(k+1)%3])\\n                    if obstacles[i]-1 != (k+2)%3: tmp[k] = min(tmp[k], 1 + ans[(k+2)%3])\\n            ans = tmp\\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152512,
                "title": "c-o-n-space-time-dynamic-programming",
                "content": "In this approach we will solve this problem by dynamic programming\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,int pos,int i,int n,vector<int>&arr){\\n        if(arr[i]==pos)return INT_MAX;\\n        \\n        //when we reach finale position then we return 0 value\\n        if(i+1==n)return 0;\\n        if(dp[pos][i]!=1e6)return dp[pos][i];\\n        \\n        //if in next index there is a obstacles on current position then we will change our direction\\n        if(pos==arr[i+1]){\\n            int x=(pos+1)%3;\\n            int y=(pos+2)%3;\\n            if(x==0)x=3;\\n            if(y==0)y=3;\\n            //we will check in both position for getting minimum side jump\\n            dp[pos][i]= 1+min(f(dp,x,i,n,arr),f(dp,y,i,n,arr));\\n        }\\n        else dp[pos][i]=f(dp,pos,i+1,n,arr); //if there is no obstacles then we will go further\\n        return dp[pos][i];\\n    }\\n    int minSideJumps(vector<int>& arr) {\\n        vector<vector<int>>dp(4,vector<int>(arr.size()+2,1e6));\\n        return f(dp,2,0,arr.size(),arr);\\n    }\\n};\\n```\\nIf you like this solution then pls upvote :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,int pos,int i,int n,vector<int>&arr){\\n        if(arr[i]==pos)return INT_MAX;\\n        \\n        //when we reach finale position then we return 0 value\\n        if(i+1==n)return 0;\\n        if(dp[pos][i]!=1e6)return dp[pos][i];\\n        \\n        //if in next index there is a obstacles on current position then we will change our direction\\n        if(pos==arr[i+1]){\\n            int x=(pos+1)%3;\\n            int y=(pos+2)%3;\\n            if(x==0)x=3;\\n            if(y==0)y=3;\\n            //we will check in both position for getting minimum side jump\\n            dp[pos][i]= 1+min(f(dp,x,i,n,arr),f(dp,y,i,n,arr));\\n        }\\n        else dp[pos][i]=f(dp,pos,i+1,n,arr); //if there is no obstacles then we will go further\\n        return dp[pos][i];\\n    }\\n    int minSideJumps(vector<int>& arr) {\\n        vector<vector<int>>dp(4,vector<int>(arr.size()+2,1e6));\\n        return f(dp,2,0,arr.size(),arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152448,
                "title": "java-simple-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int res = 0;\\n        int n = obstacles.length - 1;\\n        int curLane = 2;\\n        \\n       Map<String, Integer> map = new HashMap<>();\\n        return findMinDistance(0, 2, obstacles, n, map);\\n    }\\n    \\n    private int findMinDistance(int pos, int curLane, int[] obstacles, int n, Map<String, Integer> map) {\\n        \\n        if(map.containsKey(pos + \"_\" + curLane)) {\\n            return map.get(pos + \"_\" + curLane);\\n        }\\n        int curPos = pos;\\n        while(pos < n && obstacles[pos+1] != curLane) {\\n            pos++;\\n        }\\n        \\n        if(pos == n) {\\n            return 0;\\n        }\\n        \\n        if(obstacles[pos] == 0) {\\n\\t\\t// multiple options available : choose min of both possible lanes where we can choose to go\\n            if(curLane == 1) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 2, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 2) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 2, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 1) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 2) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 3) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"shouldn\\'t have reached here!!\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int res = 0;\\n        int n = obstacles.length - 1;\\n        int curLane = 2;\\n        \\n       Map<String, Integer> map = new HashMap<>();\\n        return findMinDistance(0, 2, obstacles, n, map);\\n    }\\n    \\n    private int findMinDistance(int pos, int curLane, int[] obstacles, int n, Map<String, Integer> map) {\\n        \\n        if(map.containsKey(pos + \"_\" + curLane)) {\\n            return map.get(pos + \"_\" + curLane);\\n        }\\n        int curPos = pos;\\n        while(pos < n && obstacles[pos+1] != curLane) {\\n            pos++;\\n        }\\n        \\n        if(pos == n) {\\n            return 0;\\n        }\\n        \\n        if(obstacles[pos] == 0) {\\n\\t\\t// multiple options available : choose min of both possible lanes where we can choose to go\\n            if(curLane == 1) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 2, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 2) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 2, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 1) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 2) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 3) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"shouldn\\'t have reached here!!\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152414,
                "title": "js-easy-o-n-time-o-1-space-dp-solution-with-explanations",
                "content": "We look at the previous point (or column/index) and determine what our current point\\'s best solution is. At any lane, if no obstacle, we can go either up, down, or forward.\\n\\nSo if previous point has obstacle at `current lane 1`, we know it\\'s **impossible** to go from `previous lane 1` to any of the current lanes because we cannot go up/down/forward from an obstacle. Therefore, `current lane 1` will be impossible to reach. The only reachable points would be `lane2` and `lane3`.\\nSame goes for obstacles at 2 or 3. But if there is no obstacle at previous point, we can then update all three current lanes based on three previous lane\\n\\n```\\nvar minSideJumps = function(obstacles) {\\n    let m1 = 1;\\n    let m2 = 0;\\n    let m3 = 1;\\n    for (let i = 1; i < obstacles.length; i++) {\\n        const mm1 = m1;\\n        const mm2 = m2;\\n        const mm3 = m3;\\n        if (obstacles[i-1] == 1) {\\n            m1 = Infinity;\\n            m2 = Math.min(mm2, mm3+1);\\n            m3 = Math.min(mm3, mm2+1);\\n        } else if (obstacles[i-1] == 2) {\\n            m1 = Math.min(mm1, mm3+1);\\n            m2 = Infinity\\n            m3 = Math.min(mm3, mm1+1);\\n        } else if (obstacles[i-1] == 3) {\\n            m1 = Math.min(mm1, mm2+1);\\n            m2 = Math.min(mm2, mm1+1);\\n            m3 = Infinity\\n        } else {\\n            m1 = Math.min(mm1, mm2+1, mm3+1);\\n            m2 = Math.min(mm2, mm1+1, mm3+1);\\n            m3 = Math.min(mm3, mm1+1, mm2+1);\\n        }\\n    }\\n    return Math.min(m1,m2,m3);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minSideJumps = function(obstacles) {\\n    let m1 = 1;\\n    let m2 = 0;\\n    let m3 = 1;\\n    for (let i = 1; i < obstacles.length; i++) {\\n        const mm1 = m1;\\n        const mm2 = m2;\\n        const mm3 = m3;\\n        if (obstacles[i-1] == 1) {\\n            m1 = Infinity;\\n            m2 = Math.min(mm2, mm3+1);\\n            m3 = Math.min(mm3, mm2+1);\\n        } else if (obstacles[i-1] == 2) {\\n            m1 = Math.min(mm1, mm3+1);\\n            m2 = Infinity\\n            m3 = Math.min(mm3, mm1+1);\\n        } else if (obstacles[i-1] == 3) {\\n            m1 = Math.min(mm1, mm2+1);\\n            m2 = Math.min(mm2, mm1+1);\\n            m3 = Infinity\\n        } else {\\n            m1 = Math.min(mm1, mm2+1, mm3+1);\\n            m2 = Math.min(mm2, mm1+1, mm3+1);\\n            m3 = Math.min(mm3, mm1+1, mm2+1);\\n        }\\n    }\\n    return Math.min(m1,m2,m3);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877702,
                "title": "short-easy-and-clean-c-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int>dp1(n,n), dp2(n,n), dp3(n,n);\\n        dp1[0] = 1; dp2[0] = 0; dp3[0] = 1;\\n\\n        for(int i=1; i<n; i++){\\n            if(arr[i-1] != 1 && arr[i] != 1) dp1[i] = dp1[i-1];\\n            if(arr[i-1] != 2 && arr[i] != 2) dp2[i] = dp2[i-1];\\n            if(arr[i-1] != 3 && arr[i] != 3) dp3[i] = dp3[i-1];\\n\\n            dp1[i] = min({dp1[i], 1 + dp2[i], 1 + dp3[i]});\\n            dp2[i] = min({1 + dp1[i], dp2[i], 1 + dp3[i]});\\n            dp3[i] = min({1 + dp1[i], 1 + dp2[i], dp3[i]});\\n        }\\n\\n        return min({dp1[n-1],dp2[n-1],dp3[n-1]});\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int>dp1(n,n), dp2(n,n), dp3(n,n);\\n        dp1[0] = 1; dp2[0] = 0; dp3[0] = 1;\\n\\n        for(int i=1; i<n; i++){\\n            if(arr[i-1] != 1 && arr[i] != 1) dp1[i] = dp1[i-1];\\n            if(arr[i-1] != 2 && arr[i] != 2) dp2[i] = dp2[i-1];\\n            if(arr[i-1] != 3 && arr[i] != 3) dp3[i] = dp3[i-1];\\n\\n            dp1[i] = min({dp1[i], 1 + dp2[i], 1 + dp3[i]});\\n            dp2[i] = min({1 + dp1[i], dp2[i], 1 + dp3[i]});\\n            dp3[i] = min({1 + dp1[i], 1 + dp2[i], dp3[i]});\\n        }\\n\\n        return min({dp1[n-1],dp2[n-1],dp3[n-1]});\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476984,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        // now there will be repeated calls so we will use dp , and for dp we have to figure\\n        // out no of unique calls ; so in this quesiton unique calls will be ; \\n        // no of Lane(3) * obstacles.length ; \\n\\n        int dp[][] = new int[4][obstacles.length+1] ; \\n\\n        for( int i = 0 ; i < dp.length ; i++)\\n        {\\n            for( int j = 0 ; j < dp[0].length ; j++)\\n            {\\n                dp[i][j] = -1 ; \\n            }\\n        }\\n        return answer(2 , 0 , obstacles , dp ) ;\\n    }\\n    public int answer ( int currentLane , int index , int obstacles[], int dp[][])\\n    {\\n        if( index == obstacles.length-1)\\n        {\\n            return 0 ;  // because no side jump required ; \\n        }\\n\\n        if( dp[currentLane][index] != -1 )\\n        return dp[currentLane][index] ;\\n\\n           \\n           int count = 0 ; \\n        if( obstacles[index+1] == currentLane) // toh side jum karna padhega ; \\n        {\\n            \\n             if( currentLane == 1)\\n             { \\n                  \\n\\n                 int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles ,dp ) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n\\n\\n             }\\n             else if( currentLane == 2)\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option1 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n             else\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option2 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n        }\\n        else\\n        {\\n            dp[currentLane][index] = answer(currentLane , index+1 , obstacles , dp) ;\\n             return dp[currentLane][index] ; \\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        // now there will be repeated calls so we will use dp , and for dp we have to figure\\n        // out no of unique calls ; so in this quesiton unique calls will be ; \\n        // no of Lane(3) * obstacles.length ; \\n\\n        int dp[][] = new int[4][obstacles.length+1] ; \\n\\n        for( int i = 0 ; i < dp.length ; i++)\\n        {\\n            for( int j = 0 ; j < dp[0].length ; j++)\\n            {\\n                dp[i][j] = -1 ; \\n            }\\n        }\\n        return answer(2 , 0 , obstacles , dp ) ;\\n    }\\n    public int answer ( int currentLane , int index , int obstacles[], int dp[][])\\n    {\\n        if( index == obstacles.length-1)\\n        {\\n            return 0 ;  // because no side jump required ; \\n        }\\n\\n        if( dp[currentLane][index] != -1 )\\n        return dp[currentLane][index] ;\\n\\n           \\n           int count = 0 ; \\n        if( obstacles[index+1] == currentLane) // toh side jum karna padhega ; \\n        {\\n            \\n             if( currentLane == 1)\\n             { \\n                  \\n\\n                 int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles ,dp ) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n\\n\\n             }\\n             else if( currentLane == 2)\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option1 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n             else\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option2 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n        }\\n        else\\n        {\\n            dp[currentLane][index] = answer(currentLane , index+1 , obstacles , dp) ;\\n             return dp[currentLane][index] ; \\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358523,
                "title": "memoized-dp-solution-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<int> &obs, vector<vector<int>> &dp) {\\n        if(i == n - 1) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(obs[i + 1] != j) return dp[i][j] = dfs(i + 1, j, n, obs, dp);\\n        int up = 1e9, down = 1e9;\\n        for(int c=1; c<=2; c++) {\\n            up = min(up, (int)(j + c <= 3 && obs[i] != j + c ? 1 + dfs(i, j + c, n, obs, dp) : 1e9));\\n            down = min(down, (int)(j - c >= 1 && obs[i] != j - c ? 1 + dfs(i, j - c, n, obs, dp) : 1e9));\\n        }\\n        return dp[i][j] = min(up, down);\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int>(4, -1));\\n        return dfs(0, 2, n, obstacles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<int> &obs, vector<vector<int>> &dp) {\\n        if(i == n - 1) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(obs[i + 1] != j) return dp[i][j] = dfs(i + 1, j, n, obs, dp);\\n        int up = 1e9, down = 1e9;\\n        for(int c=1; c<=2; c++) {\\n            up = min(up, (int)(j + c <= 3 && obs[i] != j + c ? 1 + dfs(i, j + c, n, obs, dp) : 1e9));\\n            down = min(down, (int)(j - c >= 1 && obs[i] != j - c ? 1 + dfs(i, j - c, n, obs, dp) : 1e9));\\n        }\\n        return dp[i][j] = min(up, down);\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int>(4, -1));\\n        return dfs(0, 2, n, obstacles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300296,
                "title": "c-solution-recursion-memorization-tabulation-dp-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(4*n);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int>&obstacles,int lane,int pos,vector<vector<int>>&dp)\\n    {\\n        if(pos == n-1)\\n        return 0;\\n\\n        if(dp[lane][pos]!= -1)\\n            return dp[lane][pos];\\n\\n        if(obstacles[pos+1]!= lane)\\n            return solve(n,obstacles,lane,pos+1,dp);\\n        \\n        int ans =1e9;\\n\\n            for(int k = 1;k<=3;k++)\\n            {\\n                if(lane != k && obstacles[pos]!=k)\\n                {\\n                    ans = min(ans,1+solve(n,obstacles,k,pos,dp));\\n                }   \\n            }\\n            dp[lane][pos] = ans;\\n            return ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n    vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solve(n,obstacles,2,0,dp);\\n    }\\n};\\n```\\n\\n** Tabulation + Space Optimization ** \\n\\n**Time Complexity -> O(n)\\nSpace compllexity -> O(1)**\\n\\n\\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        // vector<vector<int>>dp(4,vector<int>(n,1e9));\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0] = 0;\\n        next[1] = 0;\\n        next[2] = 0;\\n        next[3] = 0;\\n\\n        for(int pos = n-2;pos>=0;pos--)\\n        {\\n            for(int lane=1;lane<=3;lane++)\\n            {\\n                if(obstacles[pos+1]!= lane)\\n                    curr[lane] =  next[lane];\\n                else{\\n                    int ans =1e9;\\n                    for(int k = 1;k<=3;k++)\\n                    {\\n                        if(lane != k && obstacles[pos]!=k)\\n                        {\\n                            ans = min(ans,1+next[k]);\\n                        }   \\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return min(curr[2],min(curr[1]+1,curr[3]+1));\\n    }\\n\\n```\\n\\n\\n\\n**Please vote me if you like the complete methods of dp**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int>&obstacles,int lane,int pos,vector<vector<int>>&dp)\\n    {\\n        if(pos == n-1)\\n        return 0;\\n\\n        if(dp[lane][pos]!= -1)\\n            return dp[lane][pos];\\n\\n        if(obstacles[pos+1]!= lane)\\n            return solve(n,obstacles,lane,pos+1,dp);\\n        \\n        int ans =1e9;\\n\\n            for(int k = 1;k<=3;k++)\\n            {\\n                if(lane != k && obstacles[pos]!=k)\\n                {\\n                    ans = min(ans,1+solve(n,obstacles,k,pos,dp));\\n                }   \\n            }\\n            dp[lane][pos] = ans;\\n            return ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n    vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solve(n,obstacles,2,0,dp);\\n    }\\n};\\n```\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        // vector<vector<int>>dp(4,vector<int>(n,1e9));\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0] = 0;\\n        next[1] = 0;\\n        next[2] = 0;\\n        next[3] = 0;\\n\\n        for(int pos = n-2;pos>=0;pos--)\\n        {\\n            for(int lane=1;lane<=3;lane++)\\n            {\\n                if(obstacles[pos+1]!= lane)\\n                    curr[lane] =  next[lane];\\n                else{\\n                    int ans =1e9;\\n                    for(int k = 1;k<=3;k++)\\n                    {\\n                        if(lane != k && obstacles[pos]!=k)\\n                        {\\n                            ans = min(ans,1+next[k]);\\n                        }   \\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return min(curr[2],min(curr[1]+1,curr[3]+1));\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313557,
                "title": "recursive-approach-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int idx, int lane, int n, vector<int>& obstacles, vector<vector<int>>& dp){\\n        \\n        if(idx == n-1) return 0;\\n        \\n        if(obstacles[idx] == lane) return 1e6;\\n        \\n        if(dp[idx][lane] != -1) return dp[idx][lane];\\n        \\n        int ans = 1e6;\\n        \\n        if(idx+1 < n && obstacles[idx+1] == lane){\\n            \\n            if(lane == 1){\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }\\n            else if(lane == 2){\\n                ans = min(ans, 1 + f(idx, 1, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }\\n            else{\\n                ans = min(ans, 1 + f(idx, 1, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n            }\\n            \\n        }\\n        else if(idx + 1 < n && (obstacles[idx+1] != lane || obstacles[idx+1] == 0)){\\n            \\n            ans = min(ans, f(idx+1, lane, n, obstacles, dp));\\n            \\n        }\\n        \\n        \\n        return dp[idx][lane] = ans;\\n        \\n    }\\n    \\n    \\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        \\n        return f(0, 2, n, obstacles, dp);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int idx, int lane, int n, vector<int>& obstacles, vector<vector<int>>& dp){\\n        \\n        if(idx == n-1) return 0;\\n        \\n        if(obstacles[idx] == lane) return 1e6;\\n        \\n        if(dp[idx][lane] != -1) return dp[idx][lane];\\n        \\n        int ans = 1e6;\\n        \\n        if(idx+1 < n && obstacles[idx+1] == lane){\\n            \\n            if(lane == 1){\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2303223,
                "title": "java-memorization-easy-dp",
                "content": "```\\nclass Solution {\\n    int n;\\n    int dp[][];\\n    public int minSideJumps(int[] o) {\\n        n = o.length;\\n        dp = new int[4][n];\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return f(2 , 0 , o);\\n    }\\n    int f(int lane , int idx , int o[]){\\n        if(idx == n - 1){\\n            return 0;\\n        }\\n        if(dp[lane][idx] != -1) return dp[lane][idx];\\n        int fj = 1000000;\\n        int sj = 1000000;\\n        if(o[idx + 1] != lane){\\n            fj = f(lane , idx + 1 , o);\\n        }\\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(lane == i || o[idx] == i) continue;\\n                sj = Math.min(sj , f(i , idx , o) + 1);\\n            }\\n        }\\n        return dp[lane][idx] = Math.min(sj , fj);\\n    }\\n}",
                "solutionTags": [
                    "Brainteaser"
                ],
                "code": "class Solution {\\n    int n;\\n    int dp[][];\\n    public int minSideJumps(int[] o) {\\n        n = o.length;\\n        dp = new int[4][n];\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2260213,
                "title": "c-dp-bottom-up",
                "content": "DP bottom-up approach.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> D(3, vector<int>(n, 0));\\n        for(int i=n-2; i>=0; --i)\\n        {\\n            if(obstacles[i]==0)\\n            {\\n                D[0][i]=min(D[0][i+1], min(D[1][i+1], D[2][i+1])+1); \\n                D[1][i]=min(D[1][i+1], min(D[0][i+1], D[2][i+1])+1); \\n                D[2][i]=min(D[2][i+1], min(D[0][i+1], D[1][i+1])+1);\\n            }\\n            else if(obstacles[i]==1)\\n            {\\n                D[0][i]=n;\\n                D[1][i] = min(D[1][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[1][i+1]+1);\\n            }\\n            else if(obstacles[i]==2)\\n            {\\n                D[1][i]=n;\\n                D[0][i] = min(D[0][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[0][i+1]+1);\\n            }\\n            else if(obstacles[i]==3)\\n            {\\n                D[2][i]=n;\\n                D[0][i] = min(D[0][i+1], D[1][i+1]+1);\\n                D[1][i] = min(D[1][i+1], D[0][i+1]+1);\\n            }\\n        }\\n        return D[1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> D(3, vector<int>(n, 0));\\n        for(int i=n-2; i>=0; --i)\\n        {\\n            if(obstacles[i]==0)\\n            {\\n                D[0][i]=min(D[0][i+1], min(D[1][i+1], D[2][i+1])+1); \\n                D[1][i]=min(D[1][i+1], min(D[0][i+1], D[2][i+1])+1); \\n                D[2][i]=min(D[2][i+1], min(D[0][i+1], D[1][i+1])+1);\\n            }\\n            else if(obstacles[i]==1)\\n            {\\n                D[0][i]=n;\\n                D[1][i] = min(D[1][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[1][i+1]+1);\\n            }\\n            else if(obstacles[i]==2)\\n            {\\n                D[1][i]=n;\\n                D[0][i] = min(D[0][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[0][i+1]+1);\\n            }\\n            else if(obstacles[i]==3)\\n            {\\n                D[2][i]=n;\\n                D[0][i] = min(D[0][i+1], D[1][i+1]+1);\\n                D[1][i] = min(D[1][i+1], D[0][i+1]+1);\\n            }\\n        }\\n        return D[1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171795,
                "title": "c-easy-dp-memoization-beats-90",
                "content": "![image](https://assets.leetcode.com/users/images/d39d86ba-24d8-4ea5-a43b-58ebdb1d815c_1655666311.2374113.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[500001][3];\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(obstacles, 0, 1);\\n    }\\n    int rec(vector<int>& obstacles, int i, int j){\\n        if(j<0||j>2||obstacles[i]-1==j)//reject impossible cases\\n            return INT_MAX;\\n        if(i>=obstacles.size()-1)//reached end\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(obstacles[i+1]-1!=j)//subtract 1 since lane is indexed 1\\n            return dp[i][j]=rec(obstacles, i+1, j);\\n        return dp[i][j]=1+min(rec(obstacles, i, j+1), min(rec(obstacles, i, j+2), min(rec(obstacles, i, j-1), rec(obstacles, i, j-2))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500001][3];\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(obstacles, 0, 1);\\n    }\\n    int rec(vector<int>& obstacles, int i, int j){\\n        if(j<0||j>2||obstacles[i]-1==j)//reject impossible cases\\n            return INT_MAX;\\n        if(i>=obstacles.size()-1)//reached end\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(obstacles[i+1]-1!=j)//subtract 1 since lane is indexed 1\\n            return dp[i][j]=rec(obstacles, i+1, j);\\n        return dp[i][j]=1+min(rec(obstacles, i, j+1), min(rec(obstacles, i, j+2), min(rec(obstacles, i, j-1), rec(obstacles, i, j-2))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088982,
                "title": "c-dp-tabulation-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        int dp[n][4];\\n        dp[0][1]=1;\\n        dp[0][2]=0;\\n        dp[0][3]=1;\\n        for(int i=1; i<n-1; i++) {\\n             if(obstacles[i] == 1)\\n             {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][3] + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][2] + 1 : dp[i-1][3];\\n                 dp[i][1] = INT_MAX;\\n             } else if(obstacles[i] == 2) {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][3] + 1 : dp[i-1][1];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][1] + 1 : dp[i-1][3];\\n                 dp[i][2] = INT_MAX;\\n             } else if(obstacles[i] == 3) {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][1] + 1 : dp[i-1][2];\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][2] + 1 : dp[i-1][1];\\n                 dp[i][3] = INT_MAX;\\n             } else {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? min(dp[i-1][2], dp[i-1][3]) + 1 : dp[i-1][1];\\n                 dp[i][2] = (obstacles[i-1] == 2) ? min(dp[i-1][3], dp[i-1][1]) + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? min(dp[i-1][2], dp[i-1][1]) + 1 : dp[i-1][3];   \\n             }\\n        }\\n        // for(int i=1; i<n-1; i++) {\\n        //     for(int j = 1; j<=3; j++)\\n        //         cout<<dp[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(dp[n-2][1], min(dp[n-2][2], dp[n-2][3]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        int dp[n][4];\\n        dp[0][1]=1;\\n        dp[0][2]=0;\\n        dp[0][3]=1;\\n        for(int i=1; i<n-1; i++) {\\n             if(obstacles[i] == 1)\\n             {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][3] + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][2] + 1 : dp[i-1][3];\\n                 dp[i][1] = INT_MAX;\\n             } else if(obstacles[i] == 2) {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][3] + 1 : dp[i-1][1];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][1] + 1 : dp[i-1][3];\\n                 dp[i][2] = INT_MAX;\\n             } else if(obstacles[i] == 3) {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][1] + 1 : dp[i-1][2];\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][2] + 1 : dp[i-1][1];\\n                 dp[i][3] = INT_MAX;\\n             } else {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? min(dp[i-1][2], dp[i-1][3]) + 1 : dp[i-1][1];\\n                 dp[i][2] = (obstacles[i-1] == 2) ? min(dp[i-1][3], dp[i-1][1]) + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? min(dp[i-1][2], dp[i-1][1]) + 1 : dp[i-1][3];   \\n             }\\n        }\\n        // for(int i=1; i<n-1; i++) {\\n        //     for(int j = 1; j<=3; j++)\\n        //         cout<<dp[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(dp[n-2][1], min(dp[n-2][2], dp[n-2][3]));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2072806,
                "title": "python-simple-fast-intuitive",
                "content": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # inits\\n        cur_lane, side_steps, len_obs = 2, 0, len(obstacles)\\n        \\n        # O(1) lookup to obtain most empty other lane\\n        other_lanes = [{2:3, 3:2}, {1:3, 3:1}, {1:2, 2:1}]\\n        \\n        \\n        for i in range(len_obs):\\n            # Go until next obstacle and increment side steps\\n            if obstacles[i] == cur_lane:\\n                side_steps += 1\\n                \\n                # Search for obstacles in other lanes\\n                for j in range(i-1, len_obs):\\n                    if obstacles[j] in other_lanes[cur_lane-1]:\\n                        \\n                        # Next lane is the one that doesn\\'t have the next obstacle\\n                        cur_lane = other_lanes[cur_lane-1][obstacles[j]]\\n                        break\\n                        \\n                # We are at the end\\n                if j == len_obs-1:\\n                    break\\n                    \\n        return side_steps\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fc5bb4c5-b276-4fa8-b03b-aea7584ffad7_1653484220.7957945.png)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # inits\\n        cur_lane, side_steps, len_obs = 2, 0, len(obstacles)\\n        \\n        # O(1) lookup to obtain most empty other lane\\n        other_lanes = [{2:3, 3:2}, {1:3, 3:1}, {1:2, 2:1}]\\n        \\n        \\n        for i in range(len_obs):\\n            # Go until next obstacle and increment side steps\\n            if obstacles[i] == cur_lane:\\n                side_steps += 1\\n                \\n                # Search for obstacles in other lanes\\n                for j in range(i-1, len_obs):\\n                    if obstacles[j] in other_lanes[cur_lane-1]:\\n                        \\n                        # Next lane is the one that doesn\\'t have the next obstacle\\n                        cur_lane = other_lanes[cur_lane-1][obstacles[j]]\\n                        break\\n                        \\n                # We are at the end\\n                if j == len_obs-1:\\n                    break\\n                    \\n        return side_steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060692,
                "title": "c-easy-memoization",
                "content": "the basic concept which the solutions works is when there is no obstacle aahead let the frog move in the same lane and as an obstacle arrive check for options where the frog can change lanes andafter changing it has to take minimum side jump. :)\\n```\\nclass Solution {\\npublic:\\n    int dp[500005][3];\\n    int solve(vector<int>& arr, int i, int l) {\\n        int n = arr.size();\\n        if(i == n-1) {\\n            return 0;\\n        }\\n        if(arr[i] == l+1) {\\n            return 1e9;\\n        }\\n        if(dp[i][l] != -1) {\\n            return dp[i][l];\\n        }\\n        if(arr[i+1] != l+1) {\\n\\t\\t//move in same lane\\n         dp[i][l] = solve(arr, i+1, l);\\n        } else {\\n\\t\\t//change lane and check for min\\n         dp[i][l] = 1 + min(solve(arr, i, (l+1)%3), solve(arr, i, (l+2)%3));\\n        }\\n        return dp[i][l];\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(obstacles, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500005][3];\\n    int solve(vector<int>& arr, int i, int l) {\\n        int n = arr.size();\\n        if(i == n-1) {\\n            return 0;\\n        }\\n        if(arr[i] == l+1) {\\n            return 1e9;\\n        }\\n        if(dp[i][l] != -1) {\\n            return dp[i][l];\\n        }\\n        if(arr[i+1] != l+1) {\\n\\t\\t//move in same lane\\n         dp[i][l] = solve(arr, i+1, l);\\n        } else {\\n\\t\\t//change lane and check for min\\n         dp[i][l] = 1 + min(solve(arr, i, (l+1)%3), solve(arr, i, (l+2)%3));\\n        }\\n        return dp[i][l];\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(obstacles, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002779,
                "title": "python-top-down-dp-easy-to-understand",
                "content": "**Explanation:**\\n1. There are two options at each step: jump or not jump.\\n2. We follow the greedy idea that we only jump when there\\'s a stone at the nearest next position.\\n3. If there\\'s a stone at the next position, we try to jump to other lanes.\\n4. Otherwise, we keep moving to the next position.\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        \\n        choices = {1,2,3}\\n        memo = {}\\n        \\n        # need to use memo, lru_cache leads to runtime error\\n\\t\\t# state means the current lane state, it can take value 1 or 2 or 3; idx is the index of the obstacles array\\n        def dfs(state, idx):\\n            if idx == len(obstacles):\\n                return 0\\n            if (state, idx) in memo:\\n                return memo[(state, idx)]\\n            \\n            res = float(\"inf\")\\n\\t\\t\\t# if there\\'s a stone at the next position, try to jump to other lanes\\n            if idx + 1 < len(obstacles) and state == obstacles[idx + 1]:\\n                for choice in choices:\\n\\t\\t\\t\\t\\t# check the available choices, the choice should be a different lane from the current lane and there\\'s no stone on that chosen lane\\n                    if state != choice and obstacles[idx] != choice:\\n                        res = min(res, 1 + dfs(choice, idx + 1))\\n            \\n\\t\\t\\t#  if there\\'s no stone at the next position, continue moving\\n            else:\\n                res = dfs(state, idx + 1)\\n            \\n            memo[(state, idx)] = res\\n            return res\\n        \\n        return dfs(2, 0)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        \\n        choices = {1,2,3}",
                "codeTag": "Java"
            },
            {
                "id": 1926187,
                "title": "java-simple-solution",
                "content": "\\n\\n        \\n        int dp[][]=new int[4][obstacles.length];\\n        for(int i=obstacles.length-2;i>=0;i--)\\n        {\\n            for(int j=1;j<=3;j++)\\n            {\\n                dp[j][i]=dp[j][i+1];\\n                if(obstacles[i]==j)\\n                    dp[j][i]=Integer.MAX_VALUE;\\n            }\\n            int j=obstacles[i+1];\\n            if(j!=0)\\n            {\\n                int min=Integer.MAX_VALUE;\\n                for(int k=1;k<=3;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        min=Math.min(min,dp[k][i]);\\n                    }\\n                }\\n                dp[j][i]=min+1;\\n            }\\n        }\\n        \\n        return dp[2][0];\\n            \\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n        \\n        int dp[][]=new int[4][obstacles.length];\\n        for(int i=obstacles.length-2;i>=0;i--)\\n        {\\n            for(int j=1;j<=3;j++)\\n            {\\n                dp[j][i]=dp[j][i+1];\\n                if(obstacles[i]==j)\\n                    dp[j][i]=Integer.MAX_VALUE;\\n            }\\n            int j=obstacles[i+1];\\n            if(j!=0)\\n            {\\n                int min=Integer.MAX_VALUE;\\n                for(int k=1;k<=3;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        min=Math.min(min,dp[k][i]);\\n                    }\\n                }\\n                dp[j][i]=min+1;\\n            }\\n        }\\n        \\n        return dp[2][0];\\n            \\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1915016,
                "title": "schr-dinger-s-frog-o-n-o-1-python-fast",
                "content": "av_lanes represents the lanes we could potentially be travelling on, we start of with {2} because we know that we start on lane 2. however when we need to switch lanes, we remove the current lane we are travelling on and add the other two potential lanes to the set. This means if the other two lanes are available then we are travelling on both of them at the same time untill we hit an obstacle, then our quantum state collapses and we only have one lane we can travel on untill we hit an obstacle and have to jump. hope you enjoy this little joke.\\n\\n```\\nclass Solution:\\n   \\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        jumps=0\\n        av_lanes={2}\\n        for idx,v in enumerate(obstacles):\\n            if v in av_lanes and len(av_lanes)<2:\\n                jumps+=1\\n                av_lanes={1,2,3}-{av_lanes.pop(),obstacles[idx-1]}\\n            elif v in av_lanes:\\n                av_lanes.remove(v)\\n        return jumps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n   \\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        jumps=0\\n        av_lanes={2}\\n        for idx,v in enumerate(obstacles):\\n            if v in av_lanes and len(av_lanes)<2:\\n                jumps+=1\\n                av_lanes={1,2,3}-{av_lanes.pop(),obstacles[idx-1]}\\n            elif v in av_lanes:\\n                av_lanes.remove(v)\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894720,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>memo;\\n    int findAns(vector<int>&obs,int index,int lane){\\n        int n=obs.size()-1;\\n        if(index==n){\\n            return 0;\\n        } else if(memo[index][lane]!=-1){\\n            return memo[index][lane];\\n        } else {\\n            if(obs[index+1]!=lane){\\n                return memo[index][lane]=findAns(obs,index+1,lane);\\n            } else {\\n                int ans=INT_MAX;\\n                for(int l=1;l<=3;l++){\\n                    if(l!=lane and obs[index]!=l){\\n                        ans=min(ans,findAns(obs,index,l));\\n                    }\\n                }\\n                return memo[index][lane]=ans+1;\\n            }\\n        }\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        memo=vector<vector<int>>(n,vector<int>(4,-1));\\n        return findAns(obs,0,2);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>memo;\\n    int findAns(vector<int>&obs,int index,int lane){\\n        int n=obs.size()-1;\\n        if(index==n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1856595,
                "title": "java-solution-no-recursion-no-dp-runtime-faster-than-99-52-memory-usage-less-than-88-41",
                "content": "```\\npublic int minSideJumps(int[] obstacles) {\\n        int sideJumps = 0;  // track side jumps\\n        int currLane = 2;   // track lane that the frog is currently in\\n        for (int i = 0; i < obstacles.length - 1; i++) {\\n            if (obstacles[i+1] == currLane) {   // check if there is a obstacle right in front of the frog\\n                if (obstacles[i] != 0) {    // check if there is an obstacle in any of the lanes at the current point that the frog is in\\n                    currLane = getNextLane(obstacles[i], obstacles[i+1]);   // if so, only one lane for the frog to move to, update current lane frog is in\\n                } else {    // if there are no obstacles at the current point, we have 2 lanes we could jump to, so we need to choose the right one\\n                    // the right lane to jump to is the one that does not hit an obstacle first\\n                    int j = i + 2;  // j will act as a running pointer to find the next obstacle in a different lane\\n                    while (j < obstacles.length && (obstacles[j] == 0 || obstacles[j] == obstacles[i+1])) {     // we do not count points where there are no obstacles or if the next obstacle is in the same lane as the first obstacle we ran into\\n                        j++;\\n                    }\\n                    if (j < obstacles.length) { // if this condition is met, that means we found a obstacle in another lane before getting to the end\\n                        currLane = getNextLane(obstacles[i+1], obstacles[j]);   // update current lane frog is in\\n                    } else {    // if this else statement is hit, that means that we reached the end of the list without hitting anymore obstacles\\n                        i = obstacles.length - 1;   // update i in order to break out of the loop\\n                    }\\n                }\\n                sideJumps++;    // frog side jumps to get past the obstacle in front of it\\n            }\\n        }\\n        return sideJumps;\\n    }\\n    \\n    /* given 2 lanes with obstacles, function returns the open lane */\\n    public int getNextLane(int nextObstacle, int nextNextObstacle) {\\n        if ((nextObstacle == 2 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 2)) {\\n            return 1;\\n        }\\n        if ((nextObstacle == 1 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 1)) {\\n            return 2;\\n        }\\n        else {\\n\\t\\t\\treturn 3;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minSideJumps(int[] obstacles) {\\n        int sideJumps = 0;  // track side jumps\\n        int currLane = 2;   // track lane that the frog is currently in\\n        for (int i = 0; i < obstacles.length - 1; i++) {\\n            if (obstacles[i+1] == currLane) {   // check if there is a obstacle right in front of the frog\\n                if (obstacles[i] != 0) {    // check if there is an obstacle in any of the lanes at the current point that the frog is in\\n                    currLane = getNextLane(obstacles[i], obstacles[i+1]);   // if so, only one lane for the frog to move to, update current lane frog is in\\n                } else {    // if there are no obstacles at the current point, we have 2 lanes we could jump to, so we need to choose the right one\\n                    // the right lane to jump to is the one that does not hit an obstacle first\\n                    int j = i + 2;  // j will act as a running pointer to find the next obstacle in a different lane\\n                    while (j < obstacles.length && (obstacles[j] == 0 || obstacles[j] == obstacles[i+1])) {     // we do not count points where there are no obstacles or if the next obstacle is in the same lane as the first obstacle we ran into\\n                        j++;\\n                    }\\n                    if (j < obstacles.length) { // if this condition is met, that means we found a obstacle in another lane before getting to the end\\n                        currLane = getNextLane(obstacles[i+1], obstacles[j]);   // update current lane frog is in\\n                    } else {    // if this else statement is hit, that means that we reached the end of the list without hitting anymore obstacles\\n                        i = obstacles.length - 1;   // update i in order to break out of the loop\\n                    }\\n                }\\n                sideJumps++;    // frog side jumps to get past the obstacle in front of it\\n            }\\n        }\\n        return sideJumps;\\n    }\\n    \\n    /* given 2 lanes with obstacles, function returns the open lane */\\n    public int getNextLane(int nextObstacle, int nextNextObstacle) {\\n        if ((nextObstacle == 2 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 2)) {\\n            return 1;\\n        }\\n        if ((nextObstacle == 1 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 1)) {\\n            return 2;\\n        }\\n        else {\\n\\t\\t\\treturn 3;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1672997,
                "title": "java-easy-dp-memoization-solution-intuitive-soln",
                "content": "```\\nclass Solution {\\n    private int solve(int i,int lane,int n,int[] obstacles,int[][] dp){\\n        if((i<n-1 && obstacles[i]==lane) || (i>0 && obstacles[i-1]==lane))\\n            return 1000000;\\n        if(i==n-1)\\n            return 0;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        int a=solve(i+1,lane,n,obstacles,dp);\\n        int b=0,c=0;\\n        if(lane==1){\\n            b=1+solve(i+1,2,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else if(lane==2){\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else{\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,2,n,obstacles,dp);\\n        }\\n        return dp[i][lane]=Math.min(a,Math.min(b,c));\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[n+1][4];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,2,n,obstacles,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int solve(int i,int lane,int n,int[] obstacles,int[][] dp){\\n        if((i<n-1 && obstacles[i]==lane) || (i>0 && obstacles[i-1]==lane))\\n            return 1000000;\\n        if(i==n-1)\\n            return 0;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        int a=solve(i+1,lane,n,obstacles,dp);\\n        int b=0,c=0;\\n        if(lane==1){\\n            b=1+solve(i+1,2,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else if(lane==2){\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else{\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,2,n,obstacles,dp);\\n        }\\n        return dp[i][lane]=Math.min(a,Math.min(b,c));\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[n+1][4];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,2,n,obstacles,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665751,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[600000][5];\\n    int find(vector<int>&nums,int index,int line)\\n    {\\n        if(index==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        if(nums[index]==line)\\n        {\\n            return INT_MAX;\\n        }\\n        if(dp[index][line]!=-1)\\n        {\\n            return dp[index][line];\\n        }\\n        if(nums[index+1]!=line)\\n        {\\n            return find(nums,index+1,line);\\n        }\\n        else\\n        {\\n            int val=0;\\n            if(line==1)\\n            {\\n                val=1+min(find(nums,index,2),find(nums,index,3));\\n            }\\n            else if(line==2)\\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,3));\\n            }\\n            else \\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,2));\\n            }\\n            return dp[index][line]=val;\\n        }\\n    }\\n    int minSideJumps(vector<int>&nums)\\n    {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[600000][5];\\n    int find(vector<int>&nums,int index,int line)\\n    {\\n        if(index==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        if(nums[index]==line)\\n        {\\n            return INT_MAX;\\n        }\\n        if(dp[index][line]!=-1)\\n        {\\n            return dp[index][line];\\n        }\\n        if(nums[index+1]!=line)\\n        {\\n            return find(nums,index+1,line);\\n        }\\n        else\\n        {\\n            int val=0;\\n            if(line==1)\\n            {\\n                val=1+min(find(nums,index,2),find(nums,index,3));\\n            }\\n            else if(line==2)\\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,3));\\n            }\\n            else \\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,2));\\n            }\\n            return dp[index][line]=val;\\n        }\\n    }\\n    int minSideJumps(vector<int>&nums)\\n    {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488014,
                "title": "simple-concept-beats-90-by-both-space-and-time",
                "content": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        int count = 0;\\n        int row = 2; \\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            while(i < n && obstacles[i] != row){\\n                i++;\\n            }\\n            \\n            if(i < n && obstacles[i] == row){\\n                \\n                i--;\\n                \\n                if(i < n && obstacles[i] != 0){\\n                    count ++;\\n                    row = 6 - row - obstacles[i];\\n                }\\n                \\n                else{\\n                    count++;\\n                    int go1 = (row + 1) > 3 ? (row + 1 - 3) : (row + 1);\\n                    int go2 = (row + 2) > 3 ? (row + 2 - 3) : (row + 2);\\n                    \\n                    while(i < n && obstacles[i] != go1 && obstacles[i] != go2){\\n                        i++;\\n                    }\\n                    \\n                    if(i < n && obstacles[i] == go1){\\n                         row = go2;\\n                         i--;\\n                    }\\n                    \\n                    if(i < n && obstacles[i] == go2){\\n                         row = go1;\\n                        i--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        int count = 0;\\n        int row = 2; \\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            while(i < n && obstacles[i] != row){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1419305,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int>(3,1e6));\\n        dp[0][1]=0;\\n        for (int idx=0;idx<n;idx++){\\n            for (int i=0;i<3;i++){\\n                if (i!=(obstacles[idx]-1)){\\n                    int Min=INT_MAX;\\n                    for (int j=0;j<3;j++){\\n                        Min=min(Min,(i!=j)?dp[idx][j]+1:dp[idx][i]);\\n                    }\\n                    dp[idx][i]=Min;\\n                    if (idx+1<n &&  i!=obstacles[idx+1]-1) dp[idx+1][i]=dp[idx][i];\\n                }\\n            }\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int>(3,1e6));\\n        dp[0][1]=0;\\n        for (int idx=0;idx<n;idx++){\\n            for (int i=0;i<3;i++){\\n                if (i!=(obstacles[idx]-1)){\\n                    int Min=INT_MAX;\\n                    for (int j=0;j<3;j++){\\n                        Min=min(Min,(i!=j)?dp[idx][j]+1:dp[idx][i]);\\n                    }\\n                    dp[idx][i]=Min;\\n                    if (idx+1<n &&  i!=obstacles[idx+1]-1) dp[idx+1][i]=dp[idx][i];\\n                }\\n            }\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382260,
                "title": "bfs-c-solution-based-on-bfs",
                "content": "**LOGIC-Apply BFS and check if x+1 is obstacle in same lane then add other lanes with jumps+1 to the queue else moving one step ahead in the same lane will be optimal.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) \\n    {\\n        \\n       int n=obstacles.size(); \\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{2,0},0});\\n      set<pair<int,int>>vis;\\n      while(q.size()>0)\\n      {\\n          pair<pair<int,int>,int>d=q.front();\\n          q.pop();\\n          if(vis.find(d.first)!=vis.end())continue;\\n          vis.insert(d.first);\\n          int lane=d.first.first;\\n          int x=d.first.second;\\n          int jumps=d.second;\\n          if(x==n-1)return jumps;\\n          if(obstacles[x+1]!=lane)\\n          {\\n              q.push({{lane,x+1},jumps});                 //No obstacle so move forward\\n          }\\n          else \\n          {\\n              for(int i=1;i<=3;i++)\\n              {\\n                  if(i!=lane && obstacles[x]!=i)\\n                  {\\n                    q.push({{i,x},jumps+1});   //Obstacle ahead in the current lane so jump to other\\n                  }\\n              }\\n          }\\n      }\\n        \\n       return -1;   \\n         }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) \\n    {\\n        \\n       int n=obstacles.size(); \\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{2,0},0});\\n      set<pair<int,int>>vis;\\n      while(q.size()>0)\\n      {\\n          pair<pair<int,int>,int>d=q.front();\\n          q.pop();\\n          if(vis.find(d.first)!=vis.end())continue;\\n          vis.insert(d.first);\\n          int lane=d.first.first;\\n          int x=d.first.second;\\n          int jumps=d.second;\\n          if(x==n-1)return jumps;\\n          if(obstacles[x+1]!=lane)\\n          {\\n              q.push({{lane,x+1},jumps});                 //No obstacle so move forward\\n          }\\n          else \\n          {\\n              for(int i=1;i<=3;i++)\\n              {\\n                  if(i!=lane && obstacles[x]!=i)\\n                  {\\n                    q.push({{i,x},jumps+1});   //Obstacle ahead in the current lane so jump to other\\n                  }\\n              }\\n          }\\n      }\\n        \\n       return -1;   \\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376221,
                "title": "top-down-solution-dp-java",
                "content": "`dp[idx][currLane]` represents the min jumps to reach `idx` on lane `currLane`\\n\\n```\\n\\n\\nclass Solution {\\n  int[] lanes = new int[]{1,2,3};\\n  public int minSideJumps(int[] obstacles) {\\n    int n = obstacles.length;\\n    Integer[][] dp = new Integer[n][4];\\n    return jump(n, obstacles, dp, 2, 0);\\n  }\\n  \\n  public int jump(int n, int[] obstacles, Integer[][] dp, int currLane, int idx) {\\n    if(idx >= n-1) return 0;\\n    if(dp[idx][currLane] != null) return dp[idx][currLane];\\n    int rockLocation = obstacles[idx+1];\\n    int min = n; \\n    \\n    if(currLane == rockLocation) {\\n      for(int lane: lanes) {\\n        if(lane == currLane) continue;\\n        if(obstacles[idx] == lane) continue;\\n        int res = jump(n, obstacles, dp, lane, idx);    \\n        min = Math.min(min, res);\\n      }\\n      dp[idx][currLane] = 1+min;\\n      return 1 + min;\\n    }\\n    min = jump(n, obstacles, dp, currLane, idx+1);\\n    dp[idx][currLane] = min;\\n    return min;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n  int[] lanes = new int[]{1,2,3};\\n  public int minSideJumps(int[] obstacles) {\\n    int n = obstacles.length;\\n    Integer[][] dp = new Integer[n][4];\\n    return jump(n, obstacles, dp, 2, 0);\\n  }\\n  \\n  public int jump(int n, int[] obstacles, Integer[][] dp, int currLane, int idx) {\\n    if(idx >= n-1) return 0;\\n    if(dp[idx][currLane] != null) return dp[idx][currLane];\\n    int rockLocation = obstacles[idx+1];\\n    int min = n; \\n    \\n    if(currLane == rockLocation) {\\n      for(int lane: lanes) {\\n        if(lane == currLane) continue;\\n        if(obstacles[idx] == lane) continue;\\n        int res = jump(n, obstacles, dp, lane, idx);    \\n        min = Math.min(min, res);\\n      }\\n      dp[idx][currLane] = 1+min;\\n      return 1 + min;\\n    }\\n    min = jump(n, obstacles, dp, currLane, idx+1);\\n    dp[idx][currLane] = min;\\n    return min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324513,
                "title": "optimal-greedy-solution",
                "content": "```\\ndef greedy(k,a):\\n    \\n    def do_stuff(x,y,i,j,l):\\n        if a[j]==x: #check previous obstacle and change lane\\n            return y\\n        elif a[j]==y:\\n            return x\\n        else:\\n            while i<n and (a[i+1]==0 or a[i+1]==l):#to avoid 0s and same lane duplicates\\n                i+=1\\n            if i==n:\\n                return -1\\n            if a[i+1]==x: #check the next coming obstacle\\n                return y\\n            elif a[i+1]==y:\\n                return x\\n    n=k-1\\n    ans=0\\n    \\n    l=2 #current lane\\n    \\n    i=0\\n    while i<n:\\n        if l==a[i+1]: #when we encounter next obstacle\\n            j=i #stored for checking before obstacle\\n            while i<n and l==a[i+1]: #avoiding same lane duplicates\\n                i+=1\\n            ans+=1\\n            if i==n:\\n                break\\n\\n            if l==2: #deciding which lane to shift next\\n                l = do_stuff(1,3,i,j,l)\\n            elif l==1:\\n                l = do_stuff(2,3,i,j,l)\\n            else:\\n                l= do_stuff(1,2,i,j,l)\\n            \\n            if l==-1: #case when i==n hits\\n                    break\\n                \\n            if i>0: #edge case\\n                i-=1\\n        i+=1\\n    return ans\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        return greedy(len(obstacles),obstacles)\\n```\\n\\nSimple greedy approach by checking previous obstacle and the immediate next obstacle approriately.[](http://)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef greedy(k,a):\\n    \\n    def do_stuff(x,y,i,j,l):\\n        if a[j]==x: #check previous obstacle and change lane\\n            return y\\n        elif a[j]==y:\\n            return x\\n        else:\\n            while i<n and (a[i+1]==0 or a[i+1]==l):#to avoid 0s and same lane duplicates\\n                i+=1\\n            if i==n:\\n                return -1\\n            if a[i+1]==x: #check the next coming obstacle\\n                return y\\n            elif a[i+1]==y:\\n                return x\\n    n=k-1\\n    ans=0\\n    \\n    l=2 #current lane\\n    \\n    i=0\\n    while i<n:\\n        if l==a[i+1]: #when we encounter next obstacle\\n            j=i #stored for checking before obstacle\\n            while i<n and l==a[i+1]: #avoiding same lane duplicates\\n                i+=1\\n            ans+=1\\n            if i==n:\\n                break\\n\\n            if l==2: #deciding which lane to shift next\\n                l = do_stuff(1,3,i,j,l)\\n            elif l==1:\\n                l = do_stuff(2,3,i,j,l)\\n            else:\\n                l= do_stuff(1,2,i,j,l)\\n            \\n            if l==-1: #case when i==n hits\\n                    break\\n                \\n            if i>0: #edge case\\n                i-=1\\n        i+=1\\n    return ans\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        return greedy(len(obstacles),obstacles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310227,
                "title": "java-dp-solution-with-explanation-time-o-n-space-o-1",
                "content": "```\\n// DP Solution\\n// 1. dp[j] is the min jump to reach lane j\\n// 2. If there is a stone at lane j, set dp[j] to infinity.\\n// 3. Jump: lane 0 -> 1 or 2, lane 1 -> 0 or 2, lane 2 -> 0 or 1. \\n//    So it\\'s lane j -> (j+1) % 3 or (j+2) % 3.\\n// 4. The final result is the min in dp.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        if (obstacles == null || obstacles.length <= 1) return 0;\\n        final int N = obstacles.length - 1, INF = N * 2;\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int i = 1; i <= N; i++) {\\n            int ob = obstacles[i];\\n            if (ob != 0) {\\n                dp[ob - 1] = INF;\\n            }\\n            for (int j = 0; j < 3; j++) {\\n                if (ob != j + 1) {\\n                    dp[j] = min(dp[j], dp[(j+1) % 3] + 1, dp[(j+2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(a, Math.min(b, c));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// DP Solution\\n// 1. dp[j] is the min jump to reach lane j\\n// 2. If there is a stone at lane j, set dp[j] to infinity.\\n// 3. Jump: lane 0 -> 1 or 2, lane 1 -> 0 or 2, lane 2 -> 0 or 1. \\n//    So it\\'s lane j -> (j+1) % 3 or (j+2) % 3.\\n// 4. The final result is the min in dp.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        if (obstacles == null || obstacles.length <= 1) return 0;\\n        final int N = obstacles.length - 1, INF = N * 2;\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int i = 1; i <= N; i++) {\\n            int ob = obstacles[i];\\n            if (ob != 0) {\\n                dp[ob - 1] = INF;\\n            }\\n            for (int j = 0; j < 3; j++) {\\n                if (ob != j + 1) {\\n                    dp[j] = min(dp[j], dp[(j+1) % 3] + 1, dp[(j+2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(a, Math.min(b, c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254622,
                "title": "java-simple-dp-o-n-and-o-1-solution",
                "content": "```\\nclass Solution {\\n       public int minSideJumps(int[] obstacles) {\\n        int[] prev = new int[3];\\n        prev[0] = 1;\\n        prev[1] = 0;\\n        prev[2] = 1;\\n\\n        for (int i = 0; i < obstacles.length; ++i) {\\n            int[] curr = new int[3];\\n            int obsIndex = obstacles[i] -1;\\n            if (obsIndex >= 0)\\n                curr[obsIndex] = Integer.MAX_VALUE;\\n\\n            // move forward\\n            for (int j = 0; j < 3; j++) {\\n                if (curr[j] != Integer.MAX_VALUE && prev[j] != Integer.MAX_VALUE)\\n                    curr[j] = prev[j];\\n            }\\n            // move sideways - meanigful only for cell just after the obstacle.\\n            for (int j = 0; j < 3; ++j) {\\n                if (prev[j] == Integer.MAX_VALUE && curr[j] != Integer.MAX_VALUE) {\\n                    curr[j] = Math.min(curr[(j+1) % 3], curr[(j+2)%3]) + 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return Math.min(prev[0], Math.min(prev[1], prev[2]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public int minSideJumps(int[] obstacles) {\\n        int[] prev = new int[3];\\n        prev[0] = 1;\\n        prev[1] = 0;\\n        prev[2] = 1;\\n\\n        for (int i = 0; i < obstacles.length; ++i) {\\n            int[] curr = new int[3];\\n            int obsIndex = obstacles[i] -1;\\n            if (obsIndex >= 0)\\n                curr[obsIndex] = Integer.MAX_VALUE;\\n\\n            // move forward\\n            for (int j = 0; j < 3; j++) {\\n                if (curr[j] != Integer.MAX_VALUE && prev[j] != Integer.MAX_VALUE)\\n                    curr[j] = prev[j];\\n            }\\n            // move sideways - meanigful only for cell just after the obstacle.\\n            for (int j = 0; j < 3; ++j) {\\n                if (prev[j] == Integer.MAX_VALUE && curr[j] != Integer.MAX_VALUE) {\\n                    curr[j] = Math.min(curr[(j+1) % 3], curr[(j+2)%3]) + 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return Math.min(prev[0], Math.min(prev[1], prev[2]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250533,
                "title": "o-n-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,dp[500005][4];\\n    int find(vector<int>&v,int i,int k)\\n    {  \\n        if(i==n-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(v[i+1]==k)\\n        { \\n            int x=INT_MAX,y=INT_MAX;\\n            if(k==1)\\n            {   \\n                if(v[i]!=2)\\n                x=1+find(v,i+1,2);\\n                 if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n            }\\n           else if(k==2)\\n           {  \\n               if(v[i]!=1)\\n               x=1+find(v,i+1,1);\\n                if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n           }\\n          else\\n          { \\n              if(v[i]!=1)\\n              x=1+find(v,i+1,1);\\n             if(v[i]!=2)\\n                y=1+find(v,i+1,2);\\n          }\\n         return dp[i][k]=min(x,y);\\n        }\\n        else\\n        return dp[i][k]=find(v,i+1,k);\\n        \\n    }\\n    int minSideJumps(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(v,0,2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,dp[500005][4];\\n    int find(vector<int>&v,int i,int k)\\n    {  \\n        if(i==n-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(v[i+1]==k)\\n        { \\n            int x=INT_MAX,y=INT_MAX;\\n            if(k==1)\\n            {   \\n                if(v[i]!=2)\\n                x=1+find(v,i+1,2);\\n                 if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n            }\\n           else if(k==2)\\n           {  \\n               if(v[i]!=1)\\n               x=1+find(v,i+1,1);\\n                if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n           }\\n          else\\n          { \\n              if(v[i]!=1)\\n              x=1+find(v,i+1,1);\\n             if(v[i]!=2)\\n                y=1+find(v,i+1,2);\\n          }\\n         return dp[i][k]=min(x,y);\\n        }\\n        else\\n        return dp[i][k]=find(v,i+1,k);\\n        \\n    }\\n    int minSideJumps(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(v,0,2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238483,
                "title": "python-recursive-bottom-up",
                "content": "Top down idea:\\n- Memory limit exceeds :0\\n- More intuitive to come up with thou\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n                                \\n        @functools.lru_cache(None)\\n        def recurse(idx, lane):                    \\n            if idx >= len(obstacles): return 0            \\n            if obstacles[idx] == lane: return float(\\'inf\\')            \\n            return min([\\n                (1 if l != lane else 0) + recurse(idx+1, l)\\n                for l in range(1, 4)\\n                if l != obstacles[idx]\\n            ])\\n        \\n        return recurse(0, 2)\\n```\\n\\nBottom up!\\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n                        \\n\\t\\t# Because we also \"look ahead\", we want to shorten the DP array\\n        N = len(A) - 1\\n            \\n        dp = [\\n            [float(\\'inf\\')] * 3\\n            for _ in range(N)\\n        ]\\n        \\n\\t\\t# Initial state\\n        dp[0] = [1, 0, 1]\\n        \\n        for i in range(1, N):\\n            for j in range(3):\\n            \\n                \"\"\"\\n\\t\\t\\t\\tThis line here is the tricky one.\\n\\t\\t\\t\\tThink about this: if we can jump to a space but the immediate next space is a rock,\\n\\t\\t\\t\\tcan will we succeed? NO. We don\\'t! So we must consider this\\n\\t\\t\\t\\t\"\"\"\\n                if A[i] == j+1 or A[i+1] == j+1:\\n                    dp[i][j] = float(\\'inf\\')\\n                else:\\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tOther people use the modulo \"%\" to be a bit more clean,\\n\\t\\t\\t\\t\\tbut to me, this is the easiest to read :)\\n\\t\\t\\t\\t\\t\"\"\"\\n                    dp[i][j] = min([\\n                        dp[i-1][0] + (1 if j != 0 else 0),\\n                        dp[i-1][1] + (1 if j != 1 else 0),\\n                        dp[i-1][2] + (1 if j != 2 else 0),\\n                    ])\\n                    \\n        return min(dp[-1])\\n```\\n\\nWe don\\'t really need to use the extra space however, so we can simply do:\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        \\n        # 1\\n        N = len(A) - 1        \\n        dp = [1, 0, 1]\\n        \\n        # 2\\n        for i in range(1, N):\\n            for j in range(3):\\n                \\n                # 3\\n                if j+1 == A[i]:\\n                    dp[j] = float(\\'inf\\')\\n                else:\\n                    dp[j] = min(\\n                        dp[0] + (1 if j != 0 else 0) + (float(\\'inf\\') if A[i] == 1 else 0),\\n                        dp[1] + (1 if j != 1 else 0) + (float(\\'inf\\') if A[i] == 2 else 0),\\n                        dp[2] + (1 if j != 2 else 0) + (float(\\'inf\\') if A[i] == 3 else 0),\\n                    )\\n                    \\n        # 4\\n        return min(dp)\\n```\\n\\nAlso, I refactored the area in `#3` to only check for the current rock, and thus added the extra `(float(\\'inf\\') if A[i] == 1 else 0)` etc, etc.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n                                \\n        @functools.lru_cache(None)\\n        def recurse(idx, lane):                    \\n            if idx >= len(obstacles): return 0            \\n            if obstacles[idx] == lane: return float(\\'inf\\')            \\n            return min([\\n                (1 if l != lane else 0) + recurse(idx+1, l)\\n                for l in range(1, 4)\\n                if l != obstacles[idx]\\n            ])\\n        \\n        return recurse(0, 2)\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n                        \\n\\t\\t# Because we also \"look ahead\", we want to shorten the DP array\\n        N = len(A) - 1\\n            \\n        dp = [\\n            [float(\\'inf\\')] * 3\\n            for _ in range(N)\\n        ]\\n        \\n\\t\\t# Initial state\\n        dp[0] = [1, 0, 1]\\n        \\n        for i in range(1, N):\\n            for j in range(3):\\n            \\n                \"\"\"\\n\\t\\t\\t\\tThis line here is the tricky one.\\n\\t\\t\\t\\tThink about this: if we can jump to a space but the immediate next space is a rock,\\n\\t\\t\\t\\tcan will we succeed? NO. We don\\'t! So we must consider this\\n\\t\\t\\t\\t\"\"\"\\n                if A[i] == j+1 or A[i+1] == j+1:\\n                    dp[i][j] = float(\\'inf\\')\\n                else:\\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tOther people use the modulo \"%\" to be a bit more clean,\\n\\t\\t\\t\\t\\tbut to me, this is the easiest to read :)\\n\\t\\t\\t\\t\\t\"\"\"\\n                    dp[i][j] = min([\\n                        dp[i-1][0] + (1 if j != 0 else 0),\\n                        dp[i-1][1] + (1 if j != 1 else 0),\\n                        dp[i-1][2] + (1 if j != 2 else 0),\\n                    ])\\n                    \\n        return min(dp[-1])\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        \\n        # 1\\n        N = len(A) - 1        \\n        dp = [1, 0, 1]\\n        \\n        # 2\\n        for i in range(1, N):\\n            for j in range(3):\\n                \\n                # 3\\n                if j+1 == A[i]:\\n                    dp[j] = float(\\'inf\\')\\n                else:\\n                    dp[j] = min(\\n                        dp[0] + (1 if j != 0 else 0) + (float(\\'inf\\') if A[i] == 1 else 0),\\n                        dp[1] + (1 if j != 1 else 0) + (float(\\'inf\\') if A[i] == 2 else 0),\\n                        dp[2] + (1 if j != 2 else 0) + (float(\\'inf\\') if A[i] == 3 else 0),\\n                    )\\n                    \\n        # 4\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233835,
                "title": "c-easy-recursion-and-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[4][500002];\\n    \\n    int recurs(int lane,int i,vector<int>& obstacles)\\n    {\\n        if(i+1>=obstacles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[lane][i]!=-1)\\n        {\\n            return dp[lane][i];\\n        }\\n        \\n        \\n        int ans=INT_MAX;\\n        \\n        if(obstacles[i+1]==lane)\\n        {\\n            if(obstacles[i]!=0)\\n            {\\n                   for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i]&&i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n            }\\n                                  \\n            else\\n            {\\n                     for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n\\n            }\\n        }\\n         else\\n         {\\n              ans=min(ans,recurs(lane,i+1,obstacles));\\n         }\\n            \\n            \\n                return dp[lane][i]=ans;\\n            \\n        }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        \\n        for(int i=0;i<=3;i++)\\n        {\\n            for(int j=0;j<=obstacles.size();j++)\\n                dp[i][j]=-1;\\n        }\\n        \\n        \\n        \\n        return recurs(2,0,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[4][500002];\\n    \\n    int recurs(int lane,int i,vector<int>& obstacles)\\n    {\\n        if(i+1>=obstacles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[lane][i]!=-1)\\n        {\\n            return dp[lane][i];\\n        }\\n        \\n        \\n        int ans=INT_MAX;\\n        \\n        if(obstacles[i+1]==lane)\\n        {\\n            if(obstacles[i]!=0)\\n            {\\n                   for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i]&&i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n            }\\n                                  \\n            else\\n            {\\n                     for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n\\n            }\\n        }\\n         else\\n         {\\n              ans=min(ans,recurs(lane,i+1,obstacles));\\n         }\\n            \\n            \\n                return dp[lane][i]=ans;\\n            \\n        }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        \\n        for(int i=0;i<=3;i++)\\n        {\\n            for(int j=0;j<=obstacles.size();j++)\\n                dp[i][j]=-1;\\n        }\\n        \\n        \\n        \\n        return recurs(2,0,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220290,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    \\n    int dp[][] = new int[500009][4];\\n    \\n    public int minSideJumps(int[] nums) {\\n        int len = nums.length;\\n        return solve(nums , 0 , 2);\\n    }\\n    \\n    public int solve(int nums[] , int index , int currPos) {\\n        if(index == nums.length - 1) return 0;\\n        \\n        if(dp[index][currPos] != 0) return dp[index][currPos];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1 ; i <= 3 ; i++) {\\n            if(nums[index + 1] != i && nums[index] != i) {\\n                if(i == currPos)\\n                  ans = Math.min(ans , solve(nums , index + 1 , i));\\n                else \\n                  ans = Math.min(ans , 1 + solve(nums , index + 1 , i));\\n            }\\n        }\\n        return dp[index][currPos] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dp[][] = new int[500009][4];\\n    \\n    public int minSideJumps(int[] nums) {\\n        int len = nums.length;\\n        return solve(nums , 0 , 2);\\n    }\\n    \\n    public int solve(int nums[] , int index , int currPos) {\\n        if(index == nums.length - 1) return 0;\\n        \\n        if(dp[index][currPos] != 0) return dp[index][currPos];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1 ; i <= 3 ; i++) {\\n            if(nums[index + 1] != i && nums[index] != i) {\\n                if(i == currPos)\\n                  ans = Math.min(ans , solve(nums , index + 1 , i));\\n                else \\n                  ans = Math.min(ans , 1 + solve(nums , index + 1 , i));\\n            }\\n        }\\n        return dp[index][currPos] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180693,
                "title": "javascript-o-n-solution-not-recursive-although-can-be-implemented-recursivly",
                "content": "So the idea is to keep note of the current position and jump every time there is a brick directly in front of the frog\\nIf there is also a brick above or below that means there is only 1 jump possible so the frog jumps to the lane with no brick\\nIf multiple jumps possible then frog jumps to the lane where the brick is further away since u dont want to hit the brick with the frog\\n```\\nfunction minSideJumps(obstacles) {\\n  const n = obstacles.length - 1\\n  let jumps = 0\\n  let cur = 2\\n  for (let i = 1; i < n; i++) {\\n    if (obstacles[i] != cur) continue\\n    jumps++ /* JUMPS ++ */\\n    if (obstacles[i - 1]) {\\n      cur = 3 - ((obstacles[i - 1] + cur) % 3) /* MAKE A JUMP IF ONLY 1 AVALIABLE */\\n      continue\\n    }\\n    while (i < n) {\\n      let rock = obstacles[i]\\n      if (rock != 0 && rock != cur) {\\n        cur = 3 - ((rock + cur) % 3) /* CHOOSE LONGEST BRICK-FREE LANE*/\\n        break\\n      }\\n      i++\\n    }\\n  }\\n  return jumps\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction minSideJumps(obstacles) {\\n  const n = obstacles.length - 1\\n  let jumps = 0\\n  let cur = 2\\n  for (let i = 1; i < n; i++) {\\n    if (obstacles[i] != cur) continue\\n    jumps++ /* JUMPS ++ */\\n    if (obstacles[i - 1]) {\\n      cur = 3 - ((obstacles[i - 1] + cur) % 3) /* MAKE A JUMP IF ONLY 1 AVALIABLE */\\n      continue\\n    }\\n    while (i < n) {\\n      let rock = obstacles[i]\\n      if (rock != 0 && rock != cur) {\\n        cur = 3 - ((rock + cur) % 3) /* CHOOSE LONGEST BRICK-FREE LANE*/\\n        break\\n      }\\n      i++\\n    }\\n  }\\n  return jumps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1177860,
                "title": "java-recursion-memoization",
                "content": "\\n```\\n public int minSideJumps(int[] obstacles) {\\n        int dp[][]=new int[obstacles.length][4];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(obstacles,obstacles.length,0,2,dp);\\n    }\\n    \\n    private int helper(int obstacles[],int length,int start,int lane,int [][]dp){\\n        /* if the last element is reached return*/\\n        if(start==length-1){\\n            return 0;\\n        }\\n        \\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        \\n        /*if the next element in the current lane doesnot have a obstacle\\n        continue in the same lane*/\\n        if(lane!=obstacles[start+1]){ \\n            return dp[start][lane]= helper(obstacles,length,start+1,lane,dp);\\n        }\\n        /*if the lane is 1 and the 2 and 3 doesnot contain obstacle then\\n        traverse those path and return the minimum value similarly for all other*/\\n        else{\\n            int jump1=0;\\n            int jump2=0;\\n             if(lane==1){\\n                 if(obstacles[start]!=2){\\n                     jump1=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]= min(jump1,jump2);\\n             }\\n            else if(lane==2){\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            else{\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=2){\\n                     jump2=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            \\n        }\\n                \\n    }\\n    \\n    private int min(int jump1,int jump2){\\n        \\n        if(jump1==0 && jump2==0){\\n            return 0;\\n        }\\n        else if(jump1==0){\\n            return jump2;\\n        }\\n        else if(jump2==0){\\n            return jump1;\\n        }\\n        else{\\n            return Math.min(jump1,jump2);\\n        }\\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\n```\\n public int minSideJumps(int[] obstacles) {\\n        int dp[][]=new int[obstacles.length][4];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(obstacles,obstacles.length,0,2,dp);\\n    }\\n    \\n    private int helper(int obstacles[],int length,int start,int lane,int [][]dp){\\n        /* if the last element is reached return*/\\n        if(start==length-1){\\n            return 0;\\n        }\\n        \\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        \\n        /*if the next element in the current lane doesnot have a obstacle\\n        continue in the same lane*/\\n        if(lane!=obstacles[start+1]){ \\n            return dp[start][lane]= helper(obstacles,length,start+1,lane,dp);\\n        }\\n        /*if the lane is 1 and the 2 and 3 doesnot contain obstacle then\\n        traverse those path and return the minimum value similarly for all other*/\\n        else{\\n            int jump1=0;\\n            int jump2=0;\\n             if(lane==1){\\n                 if(obstacles[start]!=2){\\n                     jump1=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]= min(jump1,jump2);\\n             }\\n            else if(lane==2){\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            else{\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=2){\\n                     jump2=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            \\n        }\\n                \\n    }\\n    \\n    private int min(int jump1,int jump2){\\n        \\n        if(jump1==0 && jump2==0){\\n            return 0;\\n        }\\n        else if(jump1==0){\\n            return jump2;\\n        }\\n        else if(jump2==0){\\n            return jump1;\\n        }\\n        else{\\n            return Math.min(jump1,jump2);\\n        }\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1173870,
                "title": "python-o-n-dp",
                "content": "```\\nclass Solution(object):\\n\\n    def minSideJumps(self, obs) :\\n        dp = [1,0,1]\\n        for i in range(1,len(obs)-1):\\n            if obs[i] != 0:\\n                dp[obs[i]-1] = 1000000         \\n            if obs[i]-1 != 0:\\n                if dp[0]!= 1000000:\\n                    dp[0] = min(dp[0],dp[1]+1,dp[2]+1)\\n                else:\\n                    dp[0] = min(dp[1]+1,dp[2]+1)\\n            if obs[i]-1 != 1:\\n                if dp[1]!= 1000000:\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1)\\n                else:\\n                    dp[1] = min(dp[0]+1, dp[2]+1)\\n            if obs[i]-1 != 2: \\n                if dp[2]!= 1000000:\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2])\\n                else:\\n                    dp[2] = min(dp[0]+1, dp[1]+1)\\n            \\n        return min(dp)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    def minSideJumps(self, obs) :\\n        dp = [1,0,1]\\n        for i in range(1,len(obs)-1):\\n            if obs[i] != 0:\\n                dp[obs[i]-1] = 1000000         \\n            if obs[i]-1 != 0:\\n                if dp[0]!= 1000000:\\n                    dp[0] = min(dp[0],dp[1]+1,dp[2]+1)\\n                else:\\n                    dp[0] = min(dp[1]+1,dp[2]+1)\\n            if obs[i]-1 != 1:\\n                if dp[1]!= 1000000:\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1)\\n                else:\\n                    dp[1] = min(dp[0]+1, dp[2]+1)\\n            if obs[i]-1 != 2: \\n                if dp[2]!= 1000000:\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2])\\n                else:\\n                    dp[2] = min(dp[0]+1, dp[1]+1)\\n            \\n        return min(dp)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165485,
                "title": "c-memoization-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500001][4];\\n    \\n    int go(int pos,int lane,vector<int>& A){\\n        if(pos>=A.size())return 0;\\n        if(A[pos]==lane)return 1e8;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        long long int ans=go(pos+1,lane,A);\\n        for(int pos_lane=1;pos_lane<=3;pos_lane++){\\n            if(lane==pos_lane){\\n                continue;\\n            }\\n            else if(A[pos]!=pos_lane){\\n                ans=min(ans,(long long int)(1ll+(long long int)go(pos+1,pos_lane,A)));\\n            }\\n        }\\n        \\n        return dp[pos][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500001][4];\\n    \\n    int go(int pos,int lane,vector<int>& A){\\n        if(pos>=A.size())return 0;\\n        if(A[pos]==lane)return 1e8;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        long long int ans=go(pos+1,lane,A);\\n        for(int pos_lane=1;pos_lane<=3;pos_lane++){\\n            if(lane==pos_lane){\\n                continue;\\n            }\\n            else if(A[pos]!=pos_lane){\\n                ans=min(ans,(long long int)(1ll+(long long int)go(pos+1,pos_lane,A)));\\n            }\\n        }\\n        \\n        return dp[pos][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161090,
                "title": "python-solution-minimum-sideway-jumps",
                "content": "\\nTo represent stones we put \\'inf\\'.\\nRepresenting the min jumps required at each lane using variables : lane1,lane2,lane3.\\n\\nEg :[0,1,2,3,0]\\nstep 1:  at i=0 ,Minimum no.of jumps required to reach lane 1 or lane 3 will be 1 since we start from lane 2.\\nlane1 = |1|\\nlane2 = |0|\\nlane3 = |1|\\nstep 2: now at i=1, lane 1 has obstacle so we assign value infinity to it .and now we dont want to consider lane 1 so we make lane1_yes = False. \\nwe keep lane2 and lane3s value same .\\nlane 1 =| 1 | inf|\\nlane2 = | 0 | 0  |\\nlane3 = | 1 | 1  |\\nNow we need to find minimum no.of jumps to reach lane 2 and lane 3.\\nto reach lane 2 we can either come from same row or we can make a jump from lane 1 to lane 2 or make a  jump from lane 3 to lane 2 .\\nhence *lane2 = min(lane2,min(lane1+1,lane3+1))*.similarly for lane3.\\nfinally \\nlane 1 =| 1 | inf|\\nlane2 = | 0 | 0  |\\nlane3 = | 1 | 1  |\\n\\ni=3 \\nlane 1 =| 1 | inf|inf|     \\nlane2 = | 0 | 0  |inf|\\nlane3 = | 1 | 1  |1|\\n\\nnow finding minimum at i=3\\nlane 1 =| 1 | inf| 2 |     \\nlane2 = | 0 | 0  |inf|\\nlane3 = | 1 | 1  | 1 |.\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:    \\n            \\n        n = len(obstacles)\\n        inf = sys.maxsize\\n        \\n        lane1,lane2,lane3 = 1,0,1\\n        \\n        for indx in range(1,n):\\n            lane1_yes,lane2_yes,lane3_yes = True,True,True\\n            if obstacles[indx] == 1:\\n                lane1 = inf\\n                lane1_yes = False\\n            elif obstacles[indx] == 2:\\n                lane2 = inf\\n                lane2_yes = False\\n            elif obstacles[indx] == 3:\\n                lane3 = inf\\n                lane3_yes = False\\n            \\n            \\n            if lane1_yes:\\n                lane1 = min(lane1,min(lane2+1,lane3+1))\\n            if lane2_yes:\\n                lane2 = min(lane2,min(lane1+1,lane3+1))\\n            if lane3_yes:\\n                lane3 = min(lane3,min(lane1+1,lane2+1))\\n        return min(lane3,min(lane1,lane2))\\n            \\n        \\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:    \\n            \\n        n = len(obstacles)\\n        inf = sys.maxsize\\n        \\n        lane1,lane2,lane3 = 1,0,1\\n        \\n        for indx in range(1,n):\\n            lane1_yes,lane2_yes,lane3_yes = True,True,True\\n            if obstacles[indx] == 1:\\n                lane1 = inf\\n                lane1_yes = False\\n            elif obstacles[indx] == 2:\\n                lane2 = inf\\n                lane2_yes = False\\n            elif obstacles[indx] == 3:\\n                lane3 = inf\\n                lane3_yes = False\\n            \\n            \\n            if lane1_yes:\\n                lane1 = min(lane1,min(lane2+1,lane3+1))\\n            if lane2_yes:\\n                lane2 = min(lane2,min(lane1+1,lane3+1))\\n            if lane3_yes:\\n                lane3 = min(lane3,min(lane1+1,lane2+1))\\n        return min(lane3,min(lane1,lane2))\\n            \\n        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157132,
                "title": "simple-solution-in-python-with-some-comments",
                "content": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # so let me try to explain\\n        # scan over the obstacles and keep track when the point is reached when you\\'ve  \\n        # encountered at least one boulder in each unique lane (multiple boulders in the same lane don\\'t count)\\n        # this means you need to sidejump at one place to get beyond this point\\n        # start again from this point onwards\\n        # keep doing this until you\\'re at the finish\\n        \\n        O = obstacles\\n        N = len(O)\\n\\n        # this means one boulder encountered in lane 1 and lane 3\\n        # this is a special starting condition to account for the requirement you start in lane 2\\n        L = [True, False, True]\\n        i = 0 # point 0\\n        s = 0 # amount of sidejumps\\n        \\n        while i < N: # while not at end\\n            if O[i] == 0: # no boulder means do nothing just move on\\n                i += 1\\n                continue\\n                \\n            L[O[i] - 1] = True # boulder encountered and take note\\n\\n            # if you\\'ve encountered three boulders\\n            if all(L):\\n                i -= 1         # start again one place before the third boulder\\n                L  = [False, False, False] # reinitialize array L so no boulders accounted for at this point\\n                s += 1         # one jump needed\\n                continue\\n                \\n            i += 1 # next\\n            \\n        return s # return sidejumps needed\\n```\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # so let me try to explain\\n        # scan over the obstacles and keep track when the point is reached when you\\'ve  \\n        # encountered at least one boulder in each unique lane (multiple boulders in the same lane don\\'t count)\\n        # this means you need to sidejump at one place to get beyond this point\\n        # start again from this point onwards\\n        # keep doing this until you\\'re at the finish\\n        \\n        O = obstacles\\n        N = len(O)\\n\\n        # this means one boulder encountered in lane 1 and lane 3\\n        # this is a special starting condition to account for the requirement you start in lane 2\\n        L = [True, False, True]\\n        i = 0 # point 0\\n        s = 0 # amount of sidejumps\\n        \\n        while i < N: # while not at end\\n            if O[i] == 0: # no boulder means do nothing just move on\\n                i += 1\\n                continue\\n                \\n            L[O[i] - 1] = True # boulder encountered and take note\\n\\n            # if you\\'ve encountered three boulders\\n            if all(L):\\n                i -= 1         # start again one place before the third boulder\\n                L  = [False, False, False] # reinitialize array L so no boulders accounted for at this point\\n                s += 1         # one jump needed\\n                continue\\n                \\n            i += 1 # next\\n            \\n        return s # return sidejumps needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155503,
                "title": "c-avoiding-stackoverflow-runtime-error-recursive-dp-o-n",
                "content": "You might be having some difficulty in avoiding the runtime error, so here\\'s the solution. What I have done here basically is ran the loop backwards and called the function *f* this ensured that there are not many states in the stack at a time, hence controlling the expansion of the implicit stack. Slowly, the *dp* values in the memoized container built up, thus controlling the expansion in the futher calls.\\n\\nIf you have any difficulty in understanding the code, please let me know I\\'ll try to get back as soon as I can.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3));\\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]==0) continue;\\n            grid[i][obstacles[i]-1]=1;\\n        }\\n        int inf = 1e9;\\n        \\n        vector<vector<int>> dp(n,vector<int>(3,-1));\\n        \\n        std::function<int(int,int)> f = [&](int i, int lane){\\n            if(dp[i][lane]!=-1) return dp[i][lane];\\n            if(i+1<n){\\n                int l1,l2;\\n                if(lane==0){\\n                    l1=1;\\n                    l2=2;\\n                }\\n                else if(lane==1){\\n                    l1=0;\\n                    l2=2;\\n                }\\n                else if(lane==2){\\n                    l1=0;\\n                    l2=1;\\n                }\\n                return dp[i][lane] = min({\\n                    grid[i+1][lane]==0?f(i+1,lane):inf,\\n                    (grid[i][l1]==0 && grid[i+1][l1]==0)?1+f(i+1,l1):inf,\\n                    (grid[i][l2]==0 && grid[i+1][l2]==0)?1+f(i+1,l2):inf\\n                });\\n            }\\n            else return dp[i][lane] = 0;\\n        };\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=2;j++){\\n                if(grid[i][j]==0){\\n                    f(i,j);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3));\\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]==0) continue;\\n            grid[i][obstacles[i]-1]=1;\\n        }\\n        int inf = 1e9;\\n        \\n        vector<vector<int>> dp(n,vector<int>(3,-1));\\n        \\n        std::function<int(int,int)> f = [&](int i, int lane){\\n            if(dp[i][lane]!=-1) return dp[i][lane];\\n            if(i+1<n){\\n                int l1,l2;\\n                if(lane==0){\\n                    l1=1;\\n                    l2=2;\\n                }\\n                else if(lane==1){\\n                    l1=0;\\n                    l2=2;\\n                }\\n                else if(lane==2){\\n                    l1=0;\\n                    l2=1;\\n                }\\n                return dp[i][lane] = min({\\n                    grid[i+1][lane]==0?f(i+1,lane):inf,\\n                    (grid[i][l1]==0 && grid[i+1][l1]==0)?1+f(i+1,l1):inf,\\n                    (grid[i][l2]==0 && grid[i+1][l2]==0)?1+f(i+1,l2):inf\\n                });\\n            }\\n            else return dp[i][lane] = 0;\\n        };\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=2;j++){\\n                if(grid[i][j]==0){\\n                    f(i,j);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154884,
                "title": "simple-dp-tabulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obst) {\\n        int dp[500005][4];\\n        memset(dp , 0 , sizeof(dp));\\n        \\n        int n = obst.size();\\n        dp[n-1][1] = dp[n-1][2] = dp[n-1][3] = 0;\\n        \\n        dp[n-1][obst[n-1]] = INT_MAX;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            dp[i][obst[i]] = INT_MAX;\\n            \\n            if(dp[i][1] != INT_MAX )   dp[i][1] = dp[i+1][1] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][1];\\n            if(dp[i][2] != INT_MAX )   dp[i][2] = dp[i+1][2] == INT_MAX ? min(max(dp[i][1],dp[i+1][1]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][2];\\n            if(dp[i][3] != INT_MAX )   dp[i][3] = dp[i+1][3] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][1] , dp[i+1][1])) + 1 : dp[i+1][3];\\n            \\n        }   \\n        return dp[0][2];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obst) {\\n        int dp[500005][4];\\n        memset(dp , 0 , sizeof(dp));\\n        \\n        int n = obst.size();\\n        dp[n-1][1] = dp[n-1][2] = dp[n-1][3] = 0;\\n        \\n        dp[n-1][obst[n-1]] = INT_MAX;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            dp[i][obst[i]] = INT_MAX;\\n            \\n            if(dp[i][1] != INT_MAX )   dp[i][1] = dp[i+1][1] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][1];\\n            if(dp[i][2] != INT_MAX )   dp[i][2] = dp[i+1][2] == INT_MAX ? min(max(dp[i][1],dp[i+1][1]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][2];\\n            if(dp[i][3] != INT_MAX )   dp[i][3] = dp[i+1][3] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][1] , dp[i+1][1])) + 1 : dp[i+1][3];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1154639,
                "title": "simple-dp-top-down-approach-well-explained-naive-approach",
                "content": "EXPLANATION:\\nsuppose you are in any lane l and index i the simplest move is to move to index i+1 of lane l without taking any jumps but this is possible only if the the next index in the current lane is not an obstacle. \\nin the absence of an obstacle we move to lane,index+1\\nOtherwise we have two possible option \\njump to one of the two remaining lanes but for this we first check if there is n obstacle or not \\nie: if you are at index i and lane 2 we can jump to index i lane 1 (if there is no obstacle at this place ) or we can jump at index i lane 3 again considering that there should not be an obstacle. \\nincase both these lanes dont have an obstacle we take the minimum fo the two result:)\\n```class Solution {\\npublic: \\n    int helper(vector<int>&ob,int lane,int index,vector<vector<int>>&dp)\\n    {   if(dp[index][lane]!=1000000007)\\n          return dp[index][lane];\\n        if(index>=ob.size()-1)\\n          return dp[index][lane]=0;\\n        if(ob[index+1]!=lane)\\n          dp[index][lane]=helper(ob,lane,index+1,dp);\\n        else\\n        {   if(lane==1 && ob[index]!=2)                  //currently in lane 1\\n            dp[index][1]=min(dp[index][1],helper(ob,2,index,dp)+1);\\n            if(lane==1 && ob[index]!=3)\\n            dp[index][1]=min(dp[index][1],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==2 && ob[index]!=1)                  //currently in lane 2\\n            dp[index][2]=min(dp[index][2],helper(ob,1,index,dp)+1);\\n            if(lane==2 && ob[index]!=3)\\n            dp[index][2]=min(dp[index][2],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==3 && ob[index]!=1)                 //currently in lane 3\\n            dp[index][3]=min(dp[index][3],helper(ob,1,index,dp)+1);\\n            if(lane==3 && ob[index]!=2)\\n            dp[index][3]=min(dp[index][3],helper(ob,2,index,dp)+1);\\n                   \\n        }\\n        return dp[index][lane];\\n    }\\n    int minSideJumps(vector<int>& ob) {\\n         int n=ob.size();\\n         vector<vector<int>>dp(n,vector<int>(4,1000000007));\\n         int result=helper(ob,2,0,dp);         \\n         return result;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic: \\n    int helper(vector<int>&ob,int lane,int index,vector<vector<int>>&dp)\\n    {   if(dp[index][lane]!=1000000007)\\n          return dp[index][lane];\\n        if(index>=ob.size()-1)\\n          return dp[index][lane]=0;\\n        if(ob[index+1]!=lane)\\n          dp[index][lane]=helper(ob,lane,index+1,dp);\\n        else\\n        {   if(lane==1 && ob[index]!=2)                  //currently in lane 1\\n            dp[index][1]=min(dp[index][1],helper(ob,2,index,dp)+1);\\n            if(lane==1 && ob[index]!=3)\\n            dp[index][1]=min(dp[index][1],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==2 && ob[index]!=1)                  //currently in lane 2\\n            dp[index][2]=min(dp[index][2],helper(ob,1,index,dp)+1);\\n            if(lane==2 && ob[index]!=3)\\n            dp[index][2]=min(dp[index][2],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==3 && ob[index]!=1)                 //currently in lane 3\\n            dp[index][3]=min(dp[index][3],helper(ob,1,index,dp)+1);\\n            if(lane==3 && ob[index]!=2)\\n            dp[index][3]=min(dp[index][3],helper(ob,2,index,dp)+1);\\n                   \\n        }\\n        return dp[index][lane];\\n    }\\n    int minSideJumps(vector<int>& ob) {\\n         int n=ob.size();\\n         vector<vector<int>>dp(n,vector<int>(4,1000000007));\\n         int result=helper(ob,2,0,dp);         \\n         return result;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1154531,
                "title": "solved-using-dfs-and-memoiziation-java",
                "content": "```\\nclass Solution {\\n    //All possible directions to go up and down. Some could become invalid which we will check\\n    int[] directions = new int[]{1, 2, -1, -2};\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        //We will this array to eleminate solving sub problems repetedly\\n        int[][] memo = new int[obstacles.length][4];\\n        //-1 represents no value found\\n        for(int[] m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        //let\\'s solve by dfs\\n        return dfs(obstacles, 0, 2, memo);\\n    }\\n    \\n    private int dfs(int[] obstacles, int curPoint, int lane, int[][] memo) {\\n        //we are one point behind n and there wont be any obstacles in n as problem defins. So we can stop here\\n        if(curPoint+1 == obstacles.length) {\\n            return 0;\\n        }\\n        \\n        //We already calculatted this, so just return\\n        if(memo[curPoint][lane] > -1) {\\n            return memo[curPoint][lane];\\n        }\\n        \\n        int result;\\n        if(obstacles[curPoint+1] != lane) { //We can move to next point since there is no blocker\\n            result = dfs(obstacles, curPoint+1, lane, memo);//Moved to next point in same lane\\n        } else {\\n            //There is blocker so we need to go to other lane in same point\\n            result = Integer.MAX_VALUE;\\n            for(int jumpDir : directions) {\\n                int newLane = lane + jumpDir;\\n                //Check if it is within lane 1-3 and that has no blocker\\n                if(1 <= newLane && newLane <= 3 && obstacles[curPoint] != newLane) {\\n                    result = Math.min(result, 1+dfs(obstacles, curPoint, newLane, memo)); //jumped to different lane in same point\\n                }\\n            }\\n        }\\n        \\n        //Remeber this best decession for the given point and lane\\n        memo[curPoint][lane] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //All possible directions to go up and down. Some could become invalid which we will check\\n    int[] directions = new int[]{1, 2, -1, -2};\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        //We will this array to eleminate solving sub problems repetedly\\n        int[][] memo = new int[obstacles.length][4];\\n        //-1 represents no value found\\n        for(int[] m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        //let\\'s solve by dfs\\n        return dfs(obstacles, 0, 2, memo);\\n    }\\n    \\n    private int dfs(int[] obstacles, int curPoint, int lane, int[][] memo) {\\n        //we are one point behind n and there wont be any obstacles in n as problem defins. So we can stop here\\n        if(curPoint+1 == obstacles.length) {\\n            return 0;\\n        }\\n        \\n        //We already calculatted this, so just return\\n        if(memo[curPoint][lane] > -1) {\\n            return memo[curPoint][lane];\\n        }\\n        \\n        int result;\\n        if(obstacles[curPoint+1] != lane) { //We can move to next point since there is no blocker\\n            result = dfs(obstacles, curPoint+1, lane, memo);//Moved to next point in same lane\\n        } else {\\n            //There is blocker so we need to go to other lane in same point\\n            result = Integer.MAX_VALUE;\\n            for(int jumpDir : directions) {\\n                int newLane = lane + jumpDir;\\n                //Check if it is within lane 1-3 and that has no blocker\\n                if(1 <= newLane && newLane <= 3 && obstacles[curPoint] != newLane) {\\n                    result = Math.min(result, 1+dfs(obstacles, curPoint, newLane, memo)); //jumped to different lane in same point\\n                }\\n            }\\n        }\\n        \\n        //Remeber this best decession for the given point and lane\\n        memo[curPoint][lane] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154248,
                "title": "python3-dp-o-n-time-o-1-space-no-modulo",
                "content": "```\\n        N = len(obstacles)\\n        dp = [float(\\'inf\\')] * 3\\n        dp[1] = 0\\n        for obs in obstacles:\\n            if obs:\\n                dp[obs - 1] = float(\\'inf\\')\\n            cur = min(dp)\\n            for i in range(3):\\n                if i != (obs - 1):\\n                    dp[i] = min(dp[i], cur + 1)\\n        return min(dp)\\n```",
                "solutionTags": [],
                "code": "```\\n        N = len(obstacles)\\n        dp = [float(\\'inf\\')] * 3\\n        dp[1] = 0\\n        for obs in obstacles:\\n            if obs:\\n                dp[obs - 1] = float(\\'inf\\')\\n            cur = min(dp)\\n            for i in range(3):\\n                if i != (obs - 1):\\n                    dp[i] = min(dp[i], cur + 1)\\n        return min(dp)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153984,
                "title": "javascript-bottom-up-dp-tabulation-100-100",
                "content": "## Understanding the logic\\n\\nThe idea is to create a table storing the minimum side jumps required to reach a particular lane of a particular index.\\n\\nSuppose index is denoted by i (0 <= i < obstacle.length) and lane is denoted by j (1, 2, 3).\\ndp[i][j] denotes the minimum side jumps to reach index i and lane j\\nTo find the value of dp[i][j] there are 3 different paths from the previous index(i-1) to reach [i][j].\\n**dp[i][j] = Math.min(path1, path2, path3)**\\n\\nInitially I am assigning **dp[i][j] = Infinity**; when there is an obstacle present at index i, lane j. To preserve the obstacle data I am simply adding dp[i][j] with itself.**Hence, dp[i][j] = dp[i][j] + Math.min(path1, path2, path3)**\\n\\n**Example: say, i = 3; j = 1\\nthen path1 = dp[i-1][1] + 0 side jump (since we are not changing lanes)\\npath2 =  dp[i-1][2] + 1 side jump (if there is no obstacle at [i][2]); else + 2 side jumps\\npath3 = dp[i-1][3] + 1 side jump (if there is no obstacle at [i][3]); else + 2 side jumps**\\n\\n\\n## Code\\n```\\nlet minSideJumps = function (obstacle){\\n\\tlet dp = new Array (obstacle.length);\\n\\tfor(let i = 0; i < obstacle.length; i++){\\n\\t\\tdp[i] = new Array(4).fill(0);\\n\\t\\tdp[i][obstacle[i]] = Infinity;\\n\\t}\\n\\t// Initial State\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 0;\\n\\tdp[0][3] = 1;\\n\\tfor(let i = 1; i < dp.length; i++){\\n\\t\\tfor(let j = 1; j < 4; j++){\\n\\t\\t\\tvalue1 = j === 1 ? dp[i-1][1] : (obstacle[i] === 1 ? dp[i-1][1]+2 : dp[i-1][1]+1)\\n\\t\\t\\tvalue2 = j === 2 ? dp[i-1][2] : (obstacle[i] === 2 ? dp[i-1][2]+2 : dp[i-1][2]+1)\\n\\t\\t\\tvalue3 = j === 3 ? dp[i-1][3] : (obstacle[i] === 3 ? dp[i-1][3]+2 : dp[i-1][3]+1)\\n\\t\\t\\tdp[i][j] += Math.min(value3, value2, value1);\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(...dp[dp.length-1]);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nlet minSideJumps = function (obstacle){\\n\\tlet dp = new Array (obstacle.length);\\n\\tfor(let i = 0; i < obstacle.length; i++){\\n\\t\\tdp[i] = new Array(4).fill(0);\\n\\t\\tdp[i][obstacle[i]] = Infinity;\\n\\t}\\n\\t// Initial State\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 0;\\n\\tdp[0][3] = 1;\\n\\tfor(let i = 1; i < dp.length; i++){\\n\\t\\tfor(let j = 1; j < 4; j++){\\n\\t\\t\\tvalue1 = j === 1 ? dp[i-1][1] : (obstacle[i] === 1 ? dp[i-1][1]+2 : dp[i-1][1]+1)\\n\\t\\t\\tvalue2 = j === 2 ? dp[i-1][2] : (obstacle[i] === 2 ? dp[i-1][2]+2 : dp[i-1][2]+1)\\n\\t\\t\\tvalue3 = j === 3 ? dp[i-1][3] : (obstacle[i] === 3 ? dp[i-1][3]+2 : dp[i-1][3]+1)\\n\\t\\t\\tdp[i][j] += Math.min(value3, value2, value1);\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(...dp[dp.length-1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153722,
                "title": "javascript-dp",
                "content": "Not a whole lot of things to consider here, just need to understand the problem and figure out how to deal\\nwith the few conditions it presents.\\n1. We start from lane 2, so set the starting cost for lanes 1 and 3 to ```MAX``` so we\\'re forced to jump from lane 2 if we want to use them.\\n2. At each turn, find the minimum cost for each lane to either stay in the same lane, or jump from one of the other two lanes.\\n    - If the current lane is an obstacle, the cost should be ```MAX``` because we can\\'t reach it\\n    - If the current lane was the last obstacle, and the lane we\\'re trying to get to it from is the current obstacle, we have to jump in a zigzag pattern to get to it, which requires an extra jump, \\n        ```\\n\\t    // to get from lane 1 to lane 2, we have to jump to lane 3, then lane 2\\n\\t    [-, x, -]\\n\\t    [x, -, -]\\n\\t    ```\\n3. Normal DP things like we don\\'t need an entire table for this, just the last two rows. Really only need variables, but maybe it\\'s a little cleaner with arrays.\\n```\\nvar minSideJumps = function (obstacles) {\\n  // pretty unnecessary, but use a MAX number <= 2 ** 31 and array literals to get packed SMIs\\n  const MAX = 10 ** 6;\\n  let current = [MAX, 0, MAX];\\n  let next = [0, 0, 0];\\n  let lastLaneBlocked = -1;\\n\\n  for (let i = 1; i < obstacles.length; i += 1) {\\n    // could just increase the size of current / next by one\\n    const laneBlocked = obstacles[i] - 1;\\n    for (let currentLane = 0; currentLane < 3; currentLane += 1) {\\n      next[currentLane] = MAX;\\n      if (laneBlocked === currentLane) continue;\\n\\n      for (let previousLane = 0; previousLane < 3; previousLane += 1) {\\n        const jumpCost = currentLane === previousLane ? 0 : 1;\\n\\t\\t// if this lane was blocked last time, they couldn\\'t jump to it to switch\\n\\t\\t// last turn, so would require an extra jump to get here\\n        const extraJump = lastLaneBlocked === currentLane && laneBlocked === previousLane ? 1 : 0;\\n        next[currentLane] = Math.min(\\n          next[currentLane],\\n          current[previousLane] + jumpCost + extraJump,\\n        );\\n      }\\n    }\\n\\n    lastLaneBlocked = laneBlocked;\\n    [current, next] = [next, current];\\n  }\\n\\n  return Math.min(...current);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```MAX```\n```MAX```\n```\\n\\t    // to get from lane 1 to lane 2, we have to jump to lane 3, then lane 2\\n\\t    [-, x, -]\\n\\t    [x, -, -]\\n\\t    ```\n```\\nvar minSideJumps = function (obstacles) {\\n  // pretty unnecessary, but use a MAX number <= 2 ** 31 and array literals to get packed SMIs\\n  const MAX = 10 ** 6;\\n  let current = [MAX, 0, MAX];\\n  let next = [0, 0, 0];\\n  let lastLaneBlocked = -1;\\n\\n  for (let i = 1; i < obstacles.length; i += 1) {\\n    // could just increase the size of current / next by one\\n    const laneBlocked = obstacles[i] - 1;\\n    for (let currentLane = 0; currentLane < 3; currentLane += 1) {\\n      next[currentLane] = MAX;\\n      if (laneBlocked === currentLane) continue;\\n\\n      for (let previousLane = 0; previousLane < 3; previousLane += 1) {\\n        const jumpCost = currentLane === previousLane ? 0 : 1;\\n\\t\\t// if this lane was blocked last time, they couldn\\'t jump to it to switch\\n\\t\\t// last turn, so would require an extra jump to get here\\n        const extraJump = lastLaneBlocked === currentLane && laneBlocked === previousLane ? 1 : 0;\\n        next[currentLane] = Math.min(\\n          next[currentLane],\\n          current[previousLane] + jumpCost + extraJump,\\n        );\\n      }\\n    }\\n\\n    lastLaneBlocked = laneBlocked;\\n    [current, next] = [next, current];\\n  }\\n\\n  return Math.min(...current);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153673,
                "title": "java-recursion-and-memo",
                "content": "Consider all possible paths.\\n```\\n// i -> 0 indexed x coordinate\\n// j -> 0 indexed y coordinate\\n// arr[i] = j   ==>  There is an obstacle at point (i,j)\\n// arr[i] = -1  ==>  There is no obstacle at x = i\\nclass Solution\\n{\\n    int[][] minJumps;  // Memo to store min jumps required from (i,j)\\n    int[] arr;         // Input\\n    int n;             // length of arr\\n    int solve(int i, int j)\\n    {\\n\\t    if(i>=n-1)    // If i>=n-1, you have reached or crossed the last point (here n is taken as length of the array).\\n        {\\n            return 0;\\n        }\\n        if(i<0 || j<0 || j>2 || arr[i]==j)  // base cases, out of bounds or land on obstacle (so not a valid path and hence return max_value).\\n            return 1000000;\\n        if(minJumps[i][j]!=1000000)   // If min jumps from (i,j) already known simply return it.\\n            return minJumps[i][j];\\n\\t\\t// Moving towards +ve x\\n        if(i+1<n && arr[i+1]!=j)      // Moving right possible if one to the right of current point is not an obstacle.\\n            minJumps[i][j] = Math.min(minJumps[i][j], solve(i+1,j));\\n        // Below are different cases of moving up and down on the same x coordinate by 1 or 2 units based on only condition that do not land on obstacle.\\n        if(j==0)    // point has y coordinate = 0\\n        {\\n            if(arr[i]!=1)   // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=2)   // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n\\t\\telse if(j==1)  // point has y coordinate = 1\\n        {\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n            if(arr[i]!=2)  // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n        else if(j==2)   // point has y coordinate = 2\\n        {\\n            if(arr[i]!=1)  // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n        }\\n        return minJumps[i][j];  // Return answer stored as minimum of all possible cases.\\n    }\\n    public int minSideJumps(int[] arr)\\n    {\\n        this.n = arr.length;\\n        this.arr = arr;\\n        this.minJumps = new int[n][3];\\n        for(int i=0; i<n; i++)\\n        {\\n            this.arr[i] -= 1;\\n            this.minJumps[i][0] = 1000000;\\n            this.minJumps[i][1] = 1000000;\\n            this.minJumps[i][2] = 1000000;\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// i -> 0 indexed x coordinate\\n// j -> 0 indexed y coordinate\\n// arr[i] = j   ==>  There is an obstacle at point (i,j)\\n// arr[i] = -1  ==>  There is no obstacle at x = i\\nclass Solution\\n{\\n    int[][] minJumps;  // Memo to store min jumps required from (i,j)\\n    int[] arr;         // Input\\n    int n;             // length of arr\\n    int solve(int i, int j)\\n    {\\n\\t    if(i>=n-1)    // If i>=n-1, you have reached or crossed the last point (here n is taken as length of the array).\\n        {\\n            return 0;\\n        }\\n        if(i<0 || j<0 || j>2 || arr[i]==j)  // base cases, out of bounds or land on obstacle (so not a valid path and hence return max_value).\\n            return 1000000;\\n        if(minJumps[i][j]!=1000000)   // If min jumps from (i,j) already known simply return it.\\n            return minJumps[i][j];\\n\\t\\t// Moving towards +ve x\\n        if(i+1<n && arr[i+1]!=j)      // Moving right possible if one to the right of current point is not an obstacle.\\n            minJumps[i][j] = Math.min(minJumps[i][j], solve(i+1,j));\\n        // Below are different cases of moving up and down on the same x coordinate by 1 or 2 units based on only condition that do not land on obstacle.\\n        if(j==0)    // point has y coordinate = 0\\n        {\\n            if(arr[i]!=1)   // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=2)   // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n\\t\\telse if(j==1)  // point has y coordinate = 1\\n        {\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n            if(arr[i]!=2)  // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n        else if(j==2)   // point has y coordinate = 2\\n        {\\n            if(arr[i]!=1)  // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n        }\\n        return minJumps[i][j];  // Return answer stored as minimum of all possible cases.\\n    }\\n    public int minSideJumps(int[] arr)\\n    {\\n        this.n = arr.length;\\n        this.arr = arr;\\n        this.minJumps = new int[n][3];\\n        for(int i=0; i<n; i++)\\n        {\\n            this.arr[i] -= 1;\\n            this.minJumps[i][0] = 1000000;\\n            this.minJumps[i][1] = 1000000;\\n            this.minJumps[i][2] = 1000000;\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153029,
                "title": "100-faster-0-n-bottom-up-dp-solution",
                "content": "This can be a very ideal problem for those we are newly learning dp(like me), first try to find recursion and the try to memoize it.  Find inline comments. \\nThis can be done is greedy as well, but here i tried to implement dp.\\nhere 0(n) time as the table is 4\\\\*0(n) we need to basically fill the table\\nand space complexity is also 4*0(n) i.e. 0(n)\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)-1\\n        mem = [[-1]*(4) for i in range(n+1)]\\n        def jumps(pos, lane):\\n            # if we reached the last position return 0\\n\\t\\t\\tif pos == n:  \\n                return 0\\n            # first we check in memoization table, if already present return that\\n\\t\\t\\tif mem[pos][lane]!=-1: \\n                return mem[pos][lane]\\n\\t\\t\\t#if either we dont have any obstacle in next pos or the obstacle in not in our lane, then \\n\\t\\t\\t# recur for the next position but in the same lane\\n            if obstacles[pos+1] == 0 or obstacles[pos+1]!=lane: \\n                mem[pos][lane] =  jumps(pos+1, lane)\\n                return mem[pos][lane]\\n\\t\\t\\t# if obstacle is in our lane then we need to jump to sideways\\n            if obstacles[pos+1] == lane:\\n                first, second = sys.maxsize, sys.maxsize\\n\\t\\t\\t\\t# we can check for all the lanes, if currently in lane 1, then check for lane 2 and 3\\n                if lane == 1:\\n\\t\\t\\t\\t\\t#if we have a obstacle in 2, then we cant jump there.\\n\\t\\t\\t\\t\\t#else we can jump so add 1 to the ans and recur for next position\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=3:\\n                        second =1+ jumps(pos+1, 3)\\n                if lane == 2:\\n                    if obstacles[pos]!=1:\\n                        first = 1+ jumps(pos+1, 1)\\n                    if obstacles[pos]!=3:\\n                        second = 1+ jumps(pos+1, 3)\\n                if lane == 3:\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=1:\\n                        second = 1+ jumps(pos+1, 1)\\n\\t\\t\\t\\t#after calculation of first and second path, take the minimum\\n                mem[pos][lane] =  min(first, second)\\n                return mem[pos][lane]\\n        return jumps(0, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)-1\\n        mem = [[-1]*(4) for i in range(n+1)]\\n        def jumps(pos, lane):\\n            # if we reached the last position return 0\\n\\t\\t\\tif pos == n:  \\n                return 0\\n            # first we check in memoization table, if already present return that\\n\\t\\t\\tif mem[pos][lane]!=-1: \\n                return mem[pos][lane]\\n\\t\\t\\t#if either we dont have any obstacle in next pos or the obstacle in not in our lane, then \\n\\t\\t\\t# recur for the next position but in the same lane\\n            if obstacles[pos+1] == 0 or obstacles[pos+1]!=lane: \\n                mem[pos][lane] =  jumps(pos+1, lane)\\n                return mem[pos][lane]\\n\\t\\t\\t# if obstacle is in our lane then we need to jump to sideways\\n            if obstacles[pos+1] == lane:\\n                first, second = sys.maxsize, sys.maxsize\\n\\t\\t\\t\\t# we can check for all the lanes, if currently in lane 1, then check for lane 2 and 3\\n                if lane == 1:\\n\\t\\t\\t\\t\\t#if we have a obstacle in 2, then we cant jump there.\\n\\t\\t\\t\\t\\t#else we can jump so add 1 to the ans and recur for next position\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=3:\\n                        second =1+ jumps(pos+1, 3)\\n                if lane == 2:\\n                    if obstacles[pos]!=1:\\n                        first = 1+ jumps(pos+1, 1)\\n                    if obstacles[pos]!=3:\\n                        second = 1+ jumps(pos+1, 3)\\n                if lane == 3:\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=1:\\n                        second = 1+ jumps(pos+1, 1)\\n\\t\\t\\t\\t#after calculation of first and second path, take the minimum\\n                mem[pos][lane] =  min(first, second)\\n                return mem[pos][lane]\\n        return jumps(0, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153013,
                "title": "c-greedy-272ms-time-100",
                "content": "we will continue to travel in the current lane until we find the stone\\nwhen we find a stone we will calculate the distance of the next stone in the other 2 lanes from the current point \\nwe will shift to the lane that have the stone at the greater distance from the current point;\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>>lane(3,vector<int>(n+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(obs[i]==0)\\n                continue;\\n            lane[obs[i]-1][i]=1;\\n        }\\n        int p=0;\\n        int ans=0;\\n        int l=1;\\n        int s;\\n        while(p<n)\\n        {\\n            while(p<n&&lane[l][p]==0)\\n            {\\n                p++;\\n            }\\n            if(p==n)\\n                return ans;\\n            p--;\\n            cout<<p<<\" \";\\n            int c1=0;\\n            int c2=0;\\n            int a=(l+1)%3;\\n            int b=(l+2)%3;\\n            s=p;\\n            while(s<n&&lane[a][s]==0)\\n            {\\n                s++;\\n                c1++;\\n            }\\n            s=p;\\n            while(s<n&&lane[b][s]==0)\\n            {\\n                s++;\\n                c2++;\\n            }\\n            if(c1>c2)\\n            {\\n              l=a;\\n                p=p+c1-1;\\n                ans++;\\n            }\\n            else\\n            {\\n                l=b;\\n                p=p+c2-1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>>lane(3,vector<int>(n+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(obs[i]==0)\\n                continue;\\n            lane[obs[i]-1][i]=1;\\n        }\\n        int p=0;\\n        int ans=0;\\n        int l=1;\\n        int s;\\n        while(p<n)\\n        {\\n            while(p<n&&lane[l][p]==0)\\n            {\\n                p++;\\n            }\\n            if(p==n)\\n                return ans;\\n            p--;\\n            cout<<p<<\" \";\\n            int c1=0;\\n            int c2=0;\\n            int a=(l+1)%3;\\n            int b=(l+2)%3;\\n            s=p;\\n            while(s<n&&lane[a][s]==0)\\n            {\\n                s++;\\n                c1++;\\n            }\\n            s=p;\\n            while(s<n&&lane[b][s]==0)\\n            {\\n                s++;\\n                c2++;\\n            }\\n            if(c1>c2)\\n            {\\n              l=a;\\n                p=p+c1-1;\\n                ans++;\\n            }\\n            else\\n            {\\n                l=b;\\n                p=p+c2-1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1152948,
                "title": "dp-backtracking-java-codes-heavily-commented-go-recursion",
                "content": "```\\n//Note: Frog jumps to another lane one and only when no forward movement is possible in the same lane.\\nclass Solution {\\n    boolean [][] matrix;\\n    int n;\\n    int [][] dp;\\n    public int minSideJumps(int[] obstacles) {\\n        n=obstacles.length;\\n        matrix=new boolean[3][n];\\n        \\n        dp=new int [3][n];\\n        for(int [] arr:dp)Arrays.fill(arr,-1);\\n        \\n\\t\\t//I used a matrix of 3*n dimension for my exploration\\n        for(int i=0;i<n;i++){\\n            int val = obstacles[i];\\n            if(val!=0)matrix[val-1][i]=true; //mark obstacled position\\n        }\\n        return helper(1,0,new boolean [3][n]); //lane is counted on 0-indexed basis\\n    }\\n    private int helper(int lane, int i, boolean [][]visited){\\n        if(i==n-2)return 0; //no further jump/movement required, because if u reached (n-2)th position, u can always reach to (n-1)position\\n        if(visited[lane][i])return 1000000; //if this path is already visited\\n        \\n        //store\\n        if(dp[lane][i]!=-1)return dp[lane][i];\\n        \\n        //mark visited\\n        visited[lane][i]=true;\\n        \\n        //move forward when no obstacle in the same lane\\n        if(!matrix[lane][i+1]){\\n            int forward = Integer.MAX_VALUE;\\n            forward = helper(lane,i+1,visited);\\n            \\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i]=forward;\\n        }\\n        // else jump\\n        else{\\n            //move downward : two possible jumps\\n            int down=Integer.MAX_VALUE;\\n            int ans1 = Integer.MAX_VALUE;\\n            if(lane+1<=2 && !matrix[lane+1][i]){\\n                ans1 = 1+helper(lane+1,i,visited);\\n            }\\n            int ans2 = Integer.MAX_VALUE;\\n            if(lane+2<=2 && !matrix[lane+2][i]){\\n                ans2 = 1+helper(lane+2,i,visited);\\n            }\\n\\n            down = Math.min(ans1,ans2);\\n\\n            //up move : two possible jumps\\n            int up = Integer.MAX_VALUE;\\n            int ans3 = Integer.MAX_VALUE;\\n            if(lane-1>=0 && !matrix[lane-1][i]){\\n                ans3 = 1+helper(lane-1,i,visited);\\n            }\\n            int ans4 = Integer.MAX_VALUE;\\n            if(lane-2>=0 && !matrix[lane-2][i]){\\n                ans4 = 1+helper(lane-2,i,visited);\\n            }\\n\\n            up = Math.min(ans3,ans4);\\n\\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i] = Math.min(down,up);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Note: Frog jumps to another lane one and only when no forward movement is possible in the same lane.\\nclass Solution {\\n    boolean [][] matrix;\\n    int n;\\n    int [][] dp;\\n    public int minSideJumps(int[] obstacles) {\\n        n=obstacles.length;\\n        matrix=new boolean[3][n];\\n        \\n        dp=new int [3][n];\\n        for(int [] arr:dp)Arrays.fill(arr,-1);\\n        \\n\\t\\t//I used a matrix of 3*n dimension for my exploration\\n        for(int i=0;i<n;i++){\\n            int val = obstacles[i];\\n            if(val!=0)matrix[val-1][i]=true; //mark obstacled position\\n        }\\n        return helper(1,0,new boolean [3][n]); //lane is counted on 0-indexed basis\\n    }\\n    private int helper(int lane, int i, boolean [][]visited){\\n        if(i==n-2)return 0; //no further jump/movement required, because if u reached (n-2)th position, u can always reach to (n-1)position\\n        if(visited[lane][i])return 1000000; //if this path is already visited\\n        \\n        //store\\n        if(dp[lane][i]!=-1)return dp[lane][i];\\n        \\n        //mark visited\\n        visited[lane][i]=true;\\n        \\n        //move forward when no obstacle in the same lane\\n        if(!matrix[lane][i+1]){\\n            int forward = Integer.MAX_VALUE;\\n            forward = helper(lane,i+1,visited);\\n            \\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i]=forward;\\n        }\\n        // else jump\\n        else{\\n            //move downward : two possible jumps\\n            int down=Integer.MAX_VALUE;\\n            int ans1 = Integer.MAX_VALUE;\\n            if(lane+1<=2 && !matrix[lane+1][i]){\\n                ans1 = 1+helper(lane+1,i,visited);\\n            }\\n            int ans2 = Integer.MAX_VALUE;\\n            if(lane+2<=2 && !matrix[lane+2][i]){\\n                ans2 = 1+helper(lane+2,i,visited);\\n            }\\n\\n            down = Math.min(ans1,ans2);\\n\\n            //up move : two possible jumps\\n            int up = Integer.MAX_VALUE;\\n            int ans3 = Integer.MAX_VALUE;\\n            if(lane-1>=0 && !matrix[lane-1][i]){\\n                ans3 = 1+helper(lane-1,i,visited);\\n            }\\n            int ans4 = Integer.MAX_VALUE;\\n            if(lane-2>=0 && !matrix[lane-2][i]){\\n                ans4 = 1+helper(lane-2,i,visited);\\n            }\\n\\n            up = Math.min(ans3,ans4);\\n\\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i] = Math.min(down,up);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152942,
                "title": "python-c-easy-recursive-dp-solution",
                "content": "# Python\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        dp =  [[-1 for _ in range(4)] for j in range(len(obstacles) + 1)]\\n        def go(i,lane):\\n            if i == len(obstacles): return 0\\n            if obstacles[i] == lane: return float(\"inf\")\\n            if dp[i][lane] != -1: return dp[i][lane] \\n            res = go(i + 1, lane)\\n            for j in range(1,4):\\n                if lane == j or obstacles[i] == j: continue\\n                res = min(res , go(i+1,j) + 1)\\n            dp[i][lane] = res\\n            return dp[i][lane]\\n        return go(0,2)\\n```\\n# C++\\n```python\\nclass Solution {\\npublic:\\n    int dp[500005][4];\\n    int solve(vector<int>& obstacles , int i , int lane){\\n        if(i == obstacles.size()) return 0;\\n        if(obstacles[i] == lane) return 1000000000;\\n        if(dp[i][lane] != -1) return dp[i][lane];\\n        int res = solve(obstacles , i + 1, lane);\\n        for(int j = 1 ; j <= 3 ; j++){\\n            if(lane == j or obstacles[i] == j) continue;\\n            res = min(res , solve(obstacles,i+1,j) + 1);            \\n        }\\n        return dp[i][lane] = res;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacles,0,2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        dp =  [[-1 for _ in range(4)] for j in range(len(obstacles) + 1)]\\n        def go(i,lane):\\n            if i == len(obstacles): return 0\\n            if obstacles[i] == lane: return float(\"inf\")\\n            if dp[i][lane] != -1: return dp[i][lane] \\n            res = go(i + 1, lane)\\n            for j in range(1,4):\\n                if lane == j or obstacles[i] == j: continue\\n                res = min(res , go(i+1,j) + 1)\\n            dp[i][lane] = res\\n            return dp[i][lane]\\n        return go(0,2)\\n```\n```python\\nclass Solution {\\npublic:\\n    int dp[500005][4];\\n    int solve(vector<int>& obstacles , int i , int lane){\\n        if(i == obstacles.size()) return 0;\\n        if(obstacles[i] == lane) return 1000000000;\\n        if(dp[i][lane] != -1) return dp[i][lane];\\n        int res = solve(obstacles , i + 1, lane);\\n        for(int j = 1 ; j <= 3 ; j++){\\n            if(lane == j or obstacles[i] == j) continue;\\n            res = min(res , solve(obstacles,i+1,j) + 1);            \\n        }\\n        return dp[i][lane] = res;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacles,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152882,
                "title": "c-simple-recursion-with-memoization",
                "content": "At each obstacle we have can choose to change the lane depending on the conditions.\\n<b>if obstacles[i+1]!==k  and obstacles[i]!=k:</b>\\nExplanation of the above condition:\\nif obstacles is not present in the kth lane at \"i+1\" th position we can jump to that lane (kth lane) but since we making a change in the lane at point i so we have to make sure that  no obstacles is present at the  \"i\" th position in the same lane (kth -> the same lane in which we are planing to jump). <br>\\nIf the kth lane in which are making jump is same as the current lane so no jump is required but if it is different then 1 is added as we made a jump to different lane.\\n\\nRest all  code is simple recursion with memoization of states.\\n\\n// zero based indexing\\nrec(0,2,obstacles); // staring at point 0 in the lane 2 \\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[510000][4];\\n \\n    \\n    int rec(int i,int lane,vector<int>&obstacles)\\n    {\\n     \\n        if(i==obstacles.size()-1)\\n            return 0;\\n        \\n        int &ans=dp[i][lane];\\n        if(ans!=-1)\\n            return ans;\\n       \\n        int temp=INT_MAX;\\n       \\n        for(int k=1;k<=3;k++)\\n        {\\n            if(obstacles[i+1]!=k && obstacles[i]!=k)\\n            {\\n                if(lane==k)\\n                {\\n                    temp=min(temp,rec(i+1,k,obstacles));\\n                }\\n                else\\n                {\\n                    temp=min(temp,1+rec(i+1,k,obstacles));\\n                }\\n            }\\n        }\\n        \\n        ans=temp;\\n        return ans;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=3;j++)\\n            {\\n                \\n                dp[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[510000][4];\\n \\n    \\n    int rec(int i,int lane,vector<int>&obstacles)\\n    {\\n     \\n        if(i==obstacles.size()-1)\\n            return 0;\\n        \\n        int &ans=dp[i][lane];\\n        if(ans!=-1)\\n            return ans;\\n       \\n        int temp=INT_MAX;\\n       \\n        for(int k=1;k<=3;k++)\\n        {\\n            if(obstacles[i+1]!=k && obstacles[i]!=k)\\n            {\\n                if(lane==k)\\n                {\\n                    temp=min(temp,rec(i+1,k,obstacles));\\n                }\\n                else\\n                {\\n                    temp=min(temp,1+rec(i+1,k,obstacles));\\n                }\\n            }\\n        }\\n        \\n        ans=temp;\\n        return ans;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=3;j++)\\n            {\\n                \\n                dp[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152802,
                "title": "c-dp-solution-with-explanation",
                "content": "*First, let us discuss the recursive formula:*\\nLet us assume that we are on point i and currently in lane \"curr\".Let the function be f\\n**Base Case:**\\nif i==obstacles.size()-1\\n\\t we simply return 0 since it is given that last point has no obstacles.\\n**Now,**\\n*if (i+1)th point in the curr lane is safe, we will simply move ahead*\\n     thus, we return f(i+1,curr)\\nelse\\n   we have two options( the adjacent lanes).\\n   lets denote answer to be res. lets set res=INT_MAX.\\n   we will check if we can make a side jump to these lanes now ( i.e we look if they are obstacle free at point i). If we are able to perform side jump, we make res=min(res,1+f(i+1,safe adj lane)\\n   So we explore both adjacent lanes and return res.\\n   \\n**Memoization**\\nNow if we draw a computation tree( we can see overlapping subproblems), try it out on paper. Thus, we use memoization.\\n\\n**Time Complexity**\\n\\tO(N * 3) ~ O(N)\\n\\t**Space Complexity**\\n\\tO(N * 3) ~ O(N) ( Not factoring recursion call stack, but that can be worked upon by converting top down code to bottom up code!!)\\n\\n**Code**\\n```\\n\\nint help(int i,int curr,vector<int>&o,vector<vector<int>>&dp)\\n {\\n        if(i==o.size()-1)\\n            return 0;\\n        if(dp[i][curr]!=-1)\\n            return dp[i][curr];\\n        if(o[i+1]!=curr)\\n            return dp[i][curr]=help(i+1,curr,o,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            if(curr!=1 && o[i]!=1)\\n            {\\n                ans=min(ans,1+help(i+1,1,o,dp));\\n            }\\n            if(curr!=2 && o[i]!=2)\\n            {\\n                ans=min(ans,1+help(i+1,2,o,dp));\\n            }\\n            if(curr!=3 && o[i]!=3)\\n            {\\n                ans=min(ans,1+help(i+1,3,o,dp));\\n            }\\n            return dp[i][curr]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return help(0,2,obstacles,dp);\\n    }\\n\\t\\n\\n\\t\\n \\n  \\n\\n\\t\\n",
                "solutionTags": [],
                "code": "*First, let us discuss the recursive formula:*\\nLet us assume that we are on point i and currently in lane \"curr\".Let the function be f\\n**Base Case:**\\nif i==obstacles.size()-1\\n\\t we simply return 0 since it is given that last point has no obstacles.\\n**Now,**\\n*if (i+1)th point in the curr lane is safe, we will simply move ahead*\\n     thus, we return f(i+1,curr)\\nelse\\n   we have two options( the adjacent lanes).\\n   lets denote answer to be res. lets set res=INT_MAX.\\n   we will check if we can make a side jump to these lanes now ( i.e we look if they are obstacle free at point i). If we are able to perform side jump, we make res=min(res,1+f(i+1,safe adj lane)\\n   So we explore both adjacent lanes and return res.\\n   \\n**Memoization**\\nNow if we draw a computation tree( we can see overlapping subproblems), try it out on paper. Thus, we use memoization.\\n\\n**Time Complexity**\\n\\tO(N * 3) ~ O(N)\\n\\t**Space Complexity**\\n\\tO(N * 3) ~ O(N) ( Not factoring recursion call stack, but that can be worked upon by converting top down code to bottom up code!!)\\n\\n**Code**\\n```\\n\\nint help(int i,int curr,vector<int>&o,vector<vector<int>>&dp)\\n {\\n        if(i==o.size()-1)\\n            return 0;\\n        if(dp[i][curr]!=-1)\\n            return dp[i][curr];\\n        if(o[i+1]!=curr)\\n            return dp[i][curr]=help(i+1,curr,o,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            if(curr!=1 && o[i]!=1)\\n            {\\n                ans=min(ans,1+help(i+1,1,o,dp));\\n            }\\n            if(curr!=2 && o[i]!=2)\\n            {\\n                ans=min(ans,1+help(i+1,2,o,dp));\\n            }\\n            if(curr!=3 && o[i]!=3)\\n            {\\n                ans=min(ans,1+help(i+1,3,o,dp));\\n            }\\n            return dp[i][curr]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return help(0,2,obstacles,dp);\\n    }\\n\\t\\n\\n\\t\\n \\n  \\n\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1152798,
                "title": "optimal-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int x=3,n=obs.size(),ans=0;\\n        int arr[4]={1,2,3,5};\\n        for(int i=1;i<n;i++){\\n            if(x%arr[obs[i]]==0){\\n                if(x==arr[obs[i]]){\\n                    ans++;\\n                    x=30/(arr[obs[i]]*arr[obs[i-1]]);\\n                }else\\n                    x/=arr[obs[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int x=3,n=obs.size(),ans=0;\\n        int arr[4]={1,2,3,5};\\n        for(int i=1;i<n;i++){\\n            if(x%arr[obs[i]]==0){\\n                if(x==arr[obs[i]]){\\n                    ans++;\\n                    x=30/(arr[obs[i]]*arr[obs[i-1]]);\\n                }else\\n                    x/=arr[obs[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152735,
                "title": "java-very-easy-to-understand-recursion-memoisation-comments-added",
                "content": "This problem can be easily solved by simple recursion\\n\\nEvery time the frog has 2 options :\\n1. move ahead with current lane if no obstacles\\n       for this no side jump is required.\\n\\n2. jump to one of the other lane (if no obstacles in the jumping lane)\\n        for this 1 side jump is required.\\n\\nJust add memoisation to improve on time complexity\\nthat is save the min side jump if from already visited the index, and reuse the min side jump, if frog gets to revisit same index\\n```\\nclass Solution {\\n\\n        public int minSideJumps(int[] obstacle) {\\n            int n = obstacle.length;\\n            memory = new Integer[n][4];\\n            // start with lane = 2, as given in question\\n            return minSideJumps(obstacle, 0, 2);\\n        }\\n\\n        Integer memory[][];\\n\\n        // return the minimum side jump required to reach enc\\n        int minSideJumps(int[] obstacle, int i, int curr_lane) {\\n            //base case: if reached the end position than return 0 (as 0 steps required to reach end)\\n            if (i == obstacle.length - 1) {\\n                return 0;\\n            }\\n\\n            // if we already have calculated min ans for this position, return simply return ans\\n            if (memory[i][curr_lane] != null)\\n                return memory[i][curr_lane];\\n\\n            // initialise with max value\\n            int min = 100000000;\\n            // loop for all the possible lanes to jump(here lane can be: 1, 2, or 3)\\n            for (int lane = 1; lane <= 3; lane++) {\\n\\n                // if frog is already in the current lane, and their is no obstacle move ahead( 0 jumps required here)\\n                if (curr_lane == lane && obstacle[i + 1] != curr_lane) {\\n                    min = Math.min(minSideJumps(obstacle, i + 1, curr_lane), min);\\n                }\\n                // if frog is at different lane, and their is no obstacle in this lane, then jump to this lane(1 jump required here)\\n                else if (obstacle[i] != lane && obstacle[i + 1] != lane) {\\n                    min = Math.min(1 + minSideJumps(obstacle, i + 1, lane), min);\\n                }\\n            }\\n\\n            // save the result for this index in memory\\n            memory[i][curr_lane] = min;\\n\\n            // return the minium jumps required from this index = i to reach end\\n            return min;\\n\\n        }\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n        public int minSideJumps(int[] obstacle) {\\n            int n = obstacle.length;\\n            memory = new Integer[n][4];\\n            // start with lane = 2, as given in question\\n            return minSideJumps(obstacle, 0, 2);\\n        }\\n\\n        Integer memory[][];\\n\\n        // return the minimum side jump required to reach enc\\n        int minSideJumps(int[] obstacle, int i, int curr_lane) {\\n            //base case: if reached the end position than return 0 (as 0 steps required to reach end)\\n            if (i == obstacle.length - 1) {\\n                return 0;\\n            }\\n\\n            // if we already have calculated min ans for this position, return simply return ans\\n            if (memory[i][curr_lane] != null)\\n                return memory[i][curr_lane];\\n\\n            // initialise with max value\\n            int min = 100000000;\\n            // loop for all the possible lanes to jump(here lane can be: 1, 2, or 3)\\n            for (int lane = 1; lane <= 3; lane++) {\\n\\n                // if frog is already in the current lane, and their is no obstacle move ahead( 0 jumps required here)\\n                if (curr_lane == lane && obstacle[i + 1] != curr_lane) {\\n                    min = Math.min(minSideJumps(obstacle, i + 1, curr_lane), min);\\n                }\\n                // if frog is at different lane, and their is no obstacle in this lane, then jump to this lane(1 jump required here)\\n                else if (obstacle[i] != lane && obstacle[i + 1] != lane) {\\n                    min = Math.min(1 + minSideJumps(obstacle, i + 1, lane), min);\\n                }\\n            }\\n\\n            // save the result for this index in memory\\n            memory[i][curr_lane] = min;\\n\\n            // return the minium jumps required from this index = i to reach end\\n            return min;\\n\\n        }\\n\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152728,
                "title": "java-dp-easy-to-understand",
                "content": "`dp[i][j]`  How many sideway jumps at point i and lane j\\n1. If `obstacle[i] == j + 1` means we have obstacle in point i and lane j. We cannot jump to this point, so `dp[i][j] = Integer.MAX_VALUE`\\n2. Else we can reach this point i and lane j.\\n- From the same lane, `dp[i][j] = dp[i - 1][j]` no need for jump\\n- From the other two lanes, `obstacles[i] != (j + 1) % 3 + 1` is to make sure, the obstacle is not front of point i - 1 and lane `(j + 1) % 3`(different from current line). \\nFor example, if we current in point 1 and lane 1, if obstacle is in point 1 and lane 2, we cannot jump directly from point 0 lane 2 to point 1 lane1. We have to route to the other lane 3 to see if it can reach lane 1 or not.\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[n][3];\\n        for (int[] d : dp) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        dp[0][1] = 0;\\n        dp[0][0] = 1;\\n        dp[0][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (obstacles[i] == j + 1) { // cannot reach\\n                    continue;\\n                }\\n                if (dp[i - 1][j] != Integer.MAX_VALUE) { // same lane\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\\n                }\\n\\t\\t\\t\\t// from other lanes, make sure the point i and lane k, h does not have obstacle\\n                if (dp[i - 1][(j + 1) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 1) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 1) % 3] + 1);\\n                }\\n                if (dp[i - 1][(j + 2) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 2) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return Math.min(dp[n - 1][2], Math.min(dp[n - 1][1], dp[n - 1][0]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[n][3];\\n        for (int[] d : dp) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        dp[0][1] = 0;\\n        dp[0][0] = 1;\\n        dp[0][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (obstacles[i] == j + 1) { // cannot reach\\n                    continue;\\n                }\\n                if (dp[i - 1][j] != Integer.MAX_VALUE) { // same lane\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\\n                }\\n\\t\\t\\t\\t// from other lanes, make sure the point i and lane k, h does not have obstacle\\n                if (dp[i - 1][(j + 1) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 1) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 1) % 3] + 1);\\n                }\\n                if (dp[i - 1][(j + 2) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 2) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return Math.min(dp[n - 1][2], Math.min(dp[n - 1][1], dp[n - 1][0]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152650,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    private int[][] memo;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        memo = new int[N][4];\\n        for (int i=0;i<N;i++)\\n        {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return dfs(obstacles, 2, 0);\\n    }\\n    \\n\\t/*\\n\\t* currIdx = current position in obstacles array\\n\\t* currRow = rowNum i.e 1,2,3\\n\\t*/\\n    private int dfs(int[] obstacles, int currRow, int currIdx)\\n    {\\n        if (memo[currIdx][currRow] != -1)\\n        {\\n            return memo[currIdx][currRow];\\n        }\\n\\n        if (currIdx == obstacles.length - 1)\\n        {\\n            return memo[currIdx][currRow] = 0;\\n        }\\n        \\n        int nextIdx = currIdx + 1;\\n        int minSwaps = Integer.MAX_VALUE;\\n        if (obstacles[nextIdx] == currRow)//obstacle in curr row, cant move further\\n        {\\n            //side swap\\n            for (int row = 1; row <= 3; row++)\\n            {\\n                //there should not be obstacle in other row where jumping\\n                if (row != currRow && obstacles[currIdx] != row)\\n                {\\n                    //stay at same idx but move sideways\\n                   minSwaps = Math.min(minSwaps, 1 + dfs(obstacles, row, currIdx));\\n                }\\n            }\\n        }\\n        else//no obstacle in nextIdx, move ahead in same row\\n        {\\n            minSwaps = dfs(obstacles, currRow, currIdx + 1);\\n        }\\n\\n        return memo[currIdx][currRow] = minSwaps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] memo;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        memo = new int[N][4];\\n        for (int i=0;i<N;i++)\\n        {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return dfs(obstacles, 2, 0);\\n    }\\n    \\n\\t/*\\n\\t* currIdx = current position in obstacles array\\n\\t* currRow = rowNum i.e 1,2,3\\n\\t*/\\n    private int dfs(int[] obstacles, int currRow, int currIdx)\\n    {\\n        if (memo[currIdx][currRow] != -1)\\n        {\\n            return memo[currIdx][currRow];\\n        }\\n\\n        if (currIdx == obstacles.length - 1)\\n        {\\n            return memo[currIdx][currRow] = 0;\\n        }\\n        \\n        int nextIdx = currIdx + 1;\\n        int minSwaps = Integer.MAX_VALUE;\\n        if (obstacles[nextIdx] == currRow)//obstacle in curr row, cant move further\\n        {\\n            //side swap\\n            for (int row = 1; row <= 3; row++)\\n            {\\n                //there should not be obstacle in other row where jumping\\n                if (row != currRow && obstacles[currIdx] != row)\\n                {\\n                    //stay at same idx but move sideways\\n                   minSwaps = Math.min(minSwaps, 1 + dfs(obstacles, row, currIdx));\\n                }\\n            }\\n        }\\n        else//no obstacle in nextIdx, move ahead in same row\\n        {\\n            minSwaps = dfs(obstacles, currRow, currIdx + 1);\\n        }\\n\\n        return memo[currIdx][currRow] = minSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152612,
                "title": "from-bt-to-dp-solution",
                "content": "## BT solution\\n\\nFrom frist glance, this issue can be easy solved by BT , the steps can be :\\n- start from lan 2, keep moving until see the block in lan 2\\n- once facing block,  we have 2 choices, jumping to the next 2 lans\\n- start the same process, until reach the end\\n\\ncode  (timeout for some test case):\\n```\\n    public int minSideJumps(int[] obstacles) {\\n        //looks like using BT way to double check\\n        int curLan = 2;\\n        int ret = 0;\\n        int len = obstacles.length;\\n        \\n        return getMinJumps(obstacles, curLan, 0, 0);\\n    }\\n    \\n    \\n\\n    //curLan : 1, 2, 3\\n    //ob[i + 1] : 0, 1, 2, 3\\n    //curIdx : 0 - len - 1\\n    //curJump:\\n    private int getMinJumps(int[] ob, int curLan, int curIdx, int curJump {\\n        int len = ob.length;\\n        if (curIdx == len - 1 || isReachingEnd(ob, curLan, curIdx)) {\\n            return curJump;\\n        }\\n        \\n        int ret = 0;\\n        \\n        if (ob[curIdx + 1] == curLan) {\\n            //need to jump\\n            int nextLan1 = (curLan - 1) % 3 + 2;\\n            int nextLan2 = (curLan - 1) % 3 + 3;\\n            \\n            nextLan1 = nextLan1 > 3 ? nextLan1 % 3 : nextLan1;\\n            nextLan2 = nextLan2 > 3 ? nextLan2 % 3 : nextLan2;\\n            \\n            ret =  Math.min(ob[curIdx] == nextLan1 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan1, curIdx, 1 + curJump),\\n                            ob[curIdx] == nextLan2 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan2, curIdx, 1 + curJump));\\n        } else {\\n            ret = getMinJumps(ob, curLan, curIdx + 1, curJump);\\n        }\\n\\n        return ret;\\n    }\\n    \\n    private boolean isReachingEnd(int[] ob, int curLan, int curIdx) {\\n        int len = ob.length;\\n        for (int i = curIdx; i < len; i++) {\\n            if (ob[i] == curLan) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n\\n\\nThe above solution is much easy to get , normally when we hit Timeout, that means we are repeating the same calculations, so we can use array to save the status, like `int[lan_number][obstacles.length]`, however i cannot get the correct reason due to some reason, so I came to the DP solution:\\n\\n\\n## DP solution\\n\\nThe idea here is using backward method, (lan is 0 based , means 0 -> 1, 1 -> 2, 2-> 3)\\n- dp[0][len - 1] =  dp[1][len - 1] =  dp[1][len - 1] = 0\\n- if the ` obstacles[curIdx]` is the `curLan`, that means this point is not usable, so set the value to `Integer.MAX_VALUE`\\n-  however, if the ` obstacles[curIdx]` is not equals `curLan`, we have 2 choices, either to get the value from the prev step : `dp[curLan][curIdx + 1]` or the other 2 lans. \\n\\t-  the only reason why we need to retrive the current value `dp[curLan][curIdx]` from the other 2 lans is that the prev idx is not usable (`means dp[curLan][curIdx + 1] == MAX_INTEGER`)\\n\\n\\nBe careful about the little trick here:\\n```\\nYou can only get the correct number for dp[curLan][curIdx]  when dp[curLan][curIdx + 1] == MAX_INTEGER \\nafter the other 2 lan\\'s value are determinated, or you will already get 0 (which is the default value of the arry)\\n```\\n\\n\\n```\\n    public int minSideJumps(int[] obstacles) {\\n        int len = obstacles.length;\\n        int[][] dp = new int[3][len];\\n    \\n        for (int i = len - 2; i >= 0; i--) {\\n            int backup = -1;\\n            for (int j = 0; j < 3; j++) {\\n                dp[j][i] = (obstacles[i] == j + 1)\\n                    ? Integer.MAX_VALUE \\n                    : (dp[j][i + 1] == Integer.MAX_VALUE ? -1 : dp[j][i + 1]);\\n                \\n                if (dp[j][i] == -1) {\\n                    backup = j;\\n                }\\n            }\\n            \\n\\t\\t\\t//check back only after the other 2 lan has determinated\\n            if (backup > -1) {\\n                dp[backup][i] = (Math.min(dp[(backup + 1) % 3][i], dp[(backup + 2) % 3][i]) + 1);\\n            }\\n            \\n        }\\n        \\n        return dp[1][0];\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int minSideJumps(int[] obstacles) {\\n        //looks like using BT way to double check\\n        int curLan = 2;\\n        int ret = 0;\\n        int len = obstacles.length;\\n        \\n        return getMinJumps(obstacles, curLan, 0, 0);\\n    }\\n    \\n    \\n\\n    //curLan : 1, 2, 3\\n    //ob[i + 1] : 0, 1, 2, 3\\n    //curIdx : 0 - len - 1\\n    //curJump:\\n    private int getMinJumps(int[] ob, int curLan, int curIdx, int curJump {\\n        int len = ob.length;\\n        if (curIdx == len - 1 || isReachingEnd(ob, curLan, curIdx)) {\\n            return curJump;\\n        }\\n        \\n        int ret = 0;\\n        \\n        if (ob[curIdx + 1] == curLan) {\\n            //need to jump\\n            int nextLan1 = (curLan - 1) % 3 + 2;\\n            int nextLan2 = (curLan - 1) % 3 + 3;\\n            \\n            nextLan1 = nextLan1 > 3 ? nextLan1 % 3 : nextLan1;\\n            nextLan2 = nextLan2 > 3 ? nextLan2 % 3 : nextLan2;\\n            \\n            ret =  Math.min(ob[curIdx] == nextLan1 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan1, curIdx, 1 + curJump),\\n                            ob[curIdx] == nextLan2 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan2, curIdx, 1 + curJump));\\n        } else {\\n            ret = getMinJumps(ob, curLan, curIdx + 1, curJump);\\n        }\\n\\n        return ret;\\n    }\\n    \\n    private boolean isReachingEnd(int[] ob, int curLan, int curIdx) {\\n        int len = ob.length;\\n        for (int i = curIdx; i < len; i++) {\\n            if (ob[i] == curLan) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\nYou can only get the correct number for dp[curLan][curIdx]  when dp[curLan][curIdx + 1] == MAX_INTEGER \\nafter the other 2 lan\\'s value are determinated, or you will already get 0 (which is the default value of the arry)\\n```\n```\\n    public int minSideJumps(int[] obstacles) {\\n        int len = obstacles.length;\\n        int[][] dp = new int[3][len];\\n    \\n        for (int i = len - 2; i >= 0; i--) {\\n            int backup = -1;\\n            for (int j = 0; j < 3; j++) {\\n                dp[j][i] = (obstacles[i] == j + 1)\\n                    ? Integer.MAX_VALUE \\n                    : (dp[j][i + 1] == Integer.MAX_VALUE ? -1 : dp[j][i + 1]);\\n                \\n                if (dp[j][i] == -1) {\\n                    backup = j;\\n                }\\n            }\\n            \\n\\t\\t\\t//check back only after the other 2 lan has determinated\\n            if (backup > -1) {\\n                dp[backup][i] = (Math.min(dp[(backup + 1) % 3][i], dp[(backup + 2) % 3][i]) + 1);\\n            }\\n            \\n        }\\n        \\n        return dp[1][0];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152592,
                "title": "java-easy-soln-using-memoization",
                "content": "```\\npublic int memo(int[][] dp,int ci,int cl,int[] obstacles,boolean[][] vst){\\n        int n=dp[0].length; \\n        if(ci==(n-1)){\\n            return 0;\\n        }\\n        \\n        if(vst[cl][ci]){return dp[cl][ci];}\\n        int min=Integer.MAX_VALUE;\\n        \\n        int ocl=cl,oci=ci;\\n        vst[cl][ci]=true;\\n        \\n        if(obstacles[ci+1]!=cl){  //move\\n           min=memo(dp,ci+1,cl,obstacles,vst);\\n        }else{\\n            int ct=0;\\n            \\n           while(ct<2){\\n            cl=(cl+1)%4;\\n            if(cl==0){cl=1;}\\n            if(dp[cl][ci]!=-100){  //jump\\n                int ft=(memo(dp,ci,cl,obstacles,vst)); ft+=1;\\n               min=Math.min(min, ft);\\n            }\\n            ct++;\\n            } \\n        }\\n        \\n        cl=ocl;  ci=oci;\\n        dp[cl][ci]=min;\\n        return dp[cl][ci];\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[4][n];\\n        boolean[][] vst=new boolean[4][n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]>0){\\n                dp[ obstacles[i] ][i]=-100;\\n            }\\n        }\\n        \\n        return memo(dp,0,2,obstacles,vst);\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int memo(int[][] dp,int ci,int cl,int[] obstacles,boolean[][] vst){\\n        int n=dp[0].length; \\n        if(ci==(n-1)){\\n            return 0;\\n        }\\n        \\n        if(vst[cl][ci]){return dp[cl][ci];}\\n        int min=Integer.MAX_VALUE;\\n        \\n        int ocl=cl,oci=ci;\\n        vst[cl][ci]=true;\\n        \\n        if(obstacles[ci+1]!=cl){  //move\\n           min=memo(dp,ci+1,cl,obstacles,vst);\\n        }else{\\n            int ct=0;\\n            \\n           while(ct<2){\\n            cl=(cl+1)%4;\\n            if(cl==0){cl=1;}\\n            if(dp[cl][ci]!=-100){  //jump\\n                int ft=(memo(dp,ci,cl,obstacles,vst)); ft+=1;\\n               min=Math.min(min, ft);\\n            }\\n            ct++;\\n            } \\n        }\\n        \\n        cl=ocl;  ci=oci;\\n        dp[cl][ci]=min;\\n        return dp[cl][ci];\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[4][n];\\n        boolean[][] vst=new boolean[4][n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]>0){\\n                dp[ obstacles[i] ][i]=-100;\\n            }\\n        }\\n        \\n        return memo(dp,0,2,obstacles,vst);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152583,
                "title": "python-3-solution-by-greedy-choose",
                "content": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        pos = defaultdict(list)\\n        for i, o in enumerate(obstacles):\\n            if o!=0:\\n                pos[o].append(i)\\n        res = 0\\n        while pos[1] and pos[2] and pos[3]:\\n            temp = min(pos[1][-1], pos[2][-1], pos[3][-1])\\n            while pos[1] and pos[1][-1]>temp+1:\\n                pos[1].pop()\\n            while pos[2] and pos[2][-1]>temp+1:\\n                pos[2].pop()\\n            while pos[3] and pos[3][-1]>temp+1:\\n                pos[3].pop()\\n            res += 1\\n        return res if not pos[2] else res+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        pos = defaultdict(list)\\n        for i, o in enumerate(obstacles):\\n            if o!=0:\\n                pos[o].append(i)\\n        res = 0\\n        while pos[1] and pos[2] and pos[3]:\\n            temp = min(pos[1][-1], pos[2][-1], pos[3][-1])\\n            while pos[1] and pos[1][-1]>temp+1:\\n                pos[1].pop()\\n            while pos[2] and pos[2][-1]>temp+1:\\n                pos[2].pop()\\n            while pos[3] and pos[3][-1]>temp+1:\\n                pos[3].pop()\\n            res += 1\\n        return res if not pos[2] else res+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152568,
                "title": "i-m-getting-a-weird-recursion-limit-for-an-optimized-top-down-dp-solution",
                "content": "Hey guys, I coded this up in like 10 minutes. It passed all the unit tests, but it looks like it has a recursion limit. Which is weird since top down recursion limits have passed before for similar questions. I spend a whole hour debugging it which pissed me off :(\\n\\nAnyone have any input on what went wrong here? It passes 38 tests cases before failing on an input at 500001 test values. The exit conditions are all correct.\\n\\n```\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        minimum= float(\\'inf\\')\\n        \\n        @lru_cache(None)\\n        def minimum_jumps(obstacle_index, current_position):\\n            if obstacles[obstacle_index] == current_position or obstacle_index == len(obstacles): return float(\\'inf\\')\\n            if obstacle_index == len(obstacles)-1: return 0\\n\\n            counts = [float(\\'inf\\'), float(\\'inf\\'),float(\\'inf\\')]\\n            \\n            for i in range(1, 4):\\n                if obstacles[obstacle_index] == i: continue\\n                count = minimum_jumps(obstacle_index+1, i)\\n                if not i == current_position: \\n                    count+=1\\n                counts[i-1] = count\\n            \\n            return min(counts)\\n        \\n        minimum = minimum_jumps(0, 2)\\n        \\n        return minimum",
                "solutionTags": [],
                "code": "Hey guys, I coded this up in like 10 minutes. It passed all the unit tests, but it looks like it has a recursion limit. Which is weird since top down recursion limits have passed before for similar questions. I spend a whole hour debugging it which pissed me off :(\\n\\nAnyone have any input on what went wrong here? It passes 38 tests cases before failing on an input at 500001 test values. The exit conditions are all correct.\\n\\n```\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        minimum= float(\\'inf\\')\\n        \\n        @lru_cache(None)\\n        def minimum_jumps(obstacle_index, current_position):\\n            if obstacles[obstacle_index] == current_position or obstacle_index == len(obstacles): return float(\\'inf\\')\\n            if obstacle_index == len(obstacles)-1: return 0\\n\\n            counts = [float(\\'inf\\'), float(\\'inf\\'),float(\\'inf\\')]\\n            \\n            for i in range(1, 4):\\n                if obstacles[obstacle_index] == i: continue\\n                count = minimum_jumps(obstacle_index+1, i)\\n                if not i == current_position: \\n                    count+=1\\n                counts[i-1] = count\\n            \\n            return min(counts)\\n        \\n        minimum = minimum_jumps(0, 2)\\n        \\n        return minimum",
                "codeTag": "Java"
            },
            {
                "id": 1152560,
                "title": "4-lines-python-o-n-dynamic-programming-with-detailed-explanation-and-readable-code",
                "content": "`dp[i][l]` means from l line of i-th position to the end, how many side jump needed\\ninitialize with all \"inf\"\\n\\n`dp[-1][1 to 3] = 0`\\n\\n**If there\\'s no obstacle at l line of next position, no extra side jump is needed:**\\n    `dp[i][l] = dp[i + 1][l]`\\n\\n**Otherwise we need to select the best side jump target line.**\\n   ` dp[i][l] = min(1 + dp[i + 1][nl] for nl in line 1 to 3 except the cur line and the line with obstacle)`\\n    \\n**Two steps:**\\n        1. from line \\'l\\' at i side jump to line \\'nl\\' at i    **-> +1 side jump**\\n        2. from line \\'nl\\' at i direct jump to line \\'nl\\' at i + 1   **-> +0 side jump**\\n\\nSince only one line has the obstacle at each position, if the cur line at the cur position facing obstacle, then all the other lines could pass directly\\n\\t\\n\\t\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: list[int]) -> int:\\n        n = len(obstacles)\\n \\xA0 \\xA0 \\xA0 \\xA0dp = [[float(\"inf\")] * 4 for _ in range(n - 1)] + [[0] * 4]\\n\\n        for i in range(n - 2, -1, -1):\\n            for l in {1, 2, 3} - {obstacles[i]}:\\n                if obstacles[i + 1] != l:\\n                    dp[i][l] = dp[i + 1][l]\\n                else:\\n                    for nl in {1, 2, 3} - {obstacles[i], l}:\\n                        dp[i][l] = min(dp[i][l], 1 + dp[i + 1][nl])\\n\\n        return dp[0][2]\\n```\\n\\t\\n**Time Complexity:** O(3N) = O(N)\\n**Space complexity:** O(4N) = O(N)\\n\\nReduce space complexity to **O(1)**:\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: list[int]) -> int:\\n        dp = [0] * 4\\n\\n        for i in range(len(obs) - 2, -1, -1):\\n            # for l in {1, 2, 3} - {obs[i], obs[i + 1]}:\\n            #     if obs[i + 1] == l:\\n            #          dp[l] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], l})\\n            dp[obs[i + 1]] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], obs[i + 1]})\\n\\n        return dp[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: list[int]) -> int:\\n        n = len(obstacles)\\n \\xA0 \\xA0 \\xA0 \\xA0dp = [[float(\"inf\")] * 4 for _ in range(n - 1)] + [[0] * 4]\\n\\n        for i in range(n - 2, -1, -1):\\n            for l in {1, 2, 3} - {obstacles[i]}:\\n                if obstacles[i + 1] != l:\\n                    dp[i][l] = dp[i + 1][l]\\n                else:\\n                    for nl in {1, 2, 3} - {obstacles[i], l}:\\n                        dp[i][l] = min(dp[i][l], 1 + dp[i + 1][nl])\\n\\n        return dp[0][2]\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: list[int]) -> int:\\n        dp = [0] * 4\\n\\n        for i in range(len(obs) - 2, -1, -1):\\n            # for l in {1, 2, 3} - {obs[i], obs[i + 1]}:\\n            #     if obs[i + 1] == l:\\n            #          dp[l] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], l})\\n            dp[obs[i + 1]] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], obs[i + 1]})\\n\\n        return dp[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152547,
                "title": "python-o-n-straightforward-open-list-with-explanation",
                "content": "* loop once and use openList hash set to keep track of available lanes/options\\n* check next step and remove available options from open list\\n    * if open list is empty increment count and set new openList\\n\\nto set new open list\\n```\\nopenList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n```\\n> all options: set([1, 2, 3])\\n> not available: set([obstacles[i], obstacles[i+1]])\\n> & set([1, 2, 3]: to filter out 0\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # init with start lane 2\\n        openList = set([2])\\n        count = 0\\n\\n        for i in range(len(obstacles)-1):\\n            # check next step\\n            if obstacles[i+1] in openList:\\n                openList.remove(obstacles[i+1])\\n                # reset openlist and count\\n                if not openList:\\n                    openList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n                    count += 1\\n\\n        return count\\n```\\n\\n> Time: O(n)\\n> Space: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nopenList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # init with start lane 2\\n        openList = set([2])\\n        count = 0\\n\\n        for i in range(len(obstacles)-1):\\n            # check next step\\n            if obstacles[i+1] in openList:\\n                openList.remove(obstacles[i+1])\\n                # reset openlist and count\\n                if not openList:\\n                    openList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n                    count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152507,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n      int arr[4];\\n       arr[1]=arr[3]=0;\\n        arr[2]=1;\\n        int ans=0;\\n        int l=0;\\n        int sz=obs.size();\\n        while(l<sz)\\n        {\\n           if(l+1<sz and obs[l+1]>0)\\n           {\\n               int t=obs[l+1];\\n               if(t==1)\\n               {\\n                   if(arr[1])\\n                   {\\n                       if(arr[2] or arr[3])\\n                       {\\n                           arr[1]=0;\\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           if(obs[l]!=3)\\n                            arr[3]=1;\\n                           arr[1]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n               else if(t==2)\\n               {\\n                  if(arr[2])\\n                  {\\n                      if(arr[1] or arr[3])\\n                      {\\n                         arr[2]=0; \\n                      }else\\n                      {\\n                          arr[2]=0;\\n                          if(obs[l]!=1)\\n                            arr[1]=1;\\n                          if(obs[l]!=3)\\n                            arr[3]=1;\\n                          ans++;\\n                      }\\n                  }\\n               }\\n               else\\n               {\\n                   if(arr[3])\\n                   {\\n                       if(arr[2] or arr[1])\\n                       {\\n                         arr[3]=0;  \\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=1)\\n                              arr[1]=1;\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           arr[3]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n           }\\n            l++;\\n               \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n      int arr[4];\\n       arr[1]=arr[3]=0;\\n        arr[2]=1;\\n        int ans=0;\\n        int l=0;\\n        int sz=obs.size();\\n        while(l<sz)\\n        {\\n           if(l+1<sz and obs[l+1]>0)\\n           {\\n               int t=obs[l+1];\\n               if(t==1)\\n               {\\n                   if(arr[1])\\n                   {\\n                       if(arr[2] or arr[3])\\n                       {\\n                           arr[1]=0;\\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           if(obs[l]!=3)\\n                            arr[3]=1;\\n                           arr[1]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n               else if(t==2)\\n               {\\n                  if(arr[2])\\n                  {\\n                      if(arr[1] or arr[3])\\n                      {\\n                         arr[2]=0; \\n                      }else\\n                      {\\n                          arr[2]=0;\\n                          if(obs[l]!=1)\\n                            arr[1]=1;\\n                          if(obs[l]!=3)\\n                            arr[3]=1;\\n                          ans++;\\n                      }\\n                  }\\n               }\\n               else\\n               {\\n                   if(arr[3])\\n                   {\\n                       if(arr[2] or arr[1])\\n                       {\\n                         arr[3]=0;  \\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=1)\\n                              arr[1]=1;\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           arr[3]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n           }\\n            l++;\\n               \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152428,
                "title": "javascript-tabulation-dp-solution",
                "content": "```javascript\\nvar minSideJumps = function(obstacles) {\\n    // create a dp cache for tabulation\\n    const dp = [...obstacles].map(() => new Array(4).fill(Infinity));\\n    \\n    // initialize the first positions\\n    dp[0][2] = 0;\\n    for (const lane of [1,3]) {\\n        if (obstacles[0] === lane) continue;\\n        dp[0][lane] = 1;\\n    }\\n\\n    // for every index we will do the following\\n    for (let i = 1; i < obstacles.length; i++) {\\n        \\n        // first we find the best way to get to this position from the previous index\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            if (obstacles[i] === nextLane) continue;\\n            dp[i][nextLane] = dp[i - 1][nextLane]\\n        }\\n        \\n        // then we find the best way to get to this position from the current index;\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            for (let prevLane = 1; prevLane <= 3; prevLane++) {\\n                if (prevLane === nextLane) continue;\\n                if (obstacles[i] === nextLane) continue;\\n                dp[i][nextLane] = Math.min(dp[i][nextLane], dp[i][prevLane] + 1)\\n            }\\n        }\\n    }\\n\\n    // return the best result after reaching the end\\n    return Math.min(...dp[dp.length - 1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar minSideJumps = function(obstacles) {\\n    // create a dp cache for tabulation\\n    const dp = [...obstacles].map(() => new Array(4).fill(Infinity));\\n    \\n    // initialize the first positions\\n    dp[0][2] = 0;\\n    for (const lane of [1,3]) {\\n        if (obstacles[0] === lane) continue;\\n        dp[0][lane] = 1;\\n    }\\n\\n    // for every index we will do the following\\n    for (let i = 1; i < obstacles.length; i++) {\\n        \\n        // first we find the best way to get to this position from the previous index\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            if (obstacles[i] === nextLane) continue;\\n            dp[i][nextLane] = dp[i - 1][nextLane]\\n        }\\n        \\n        // then we find the best way to get to this position from the current index;\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            for (let prevLane = 1; prevLane <= 3; prevLane++) {\\n                if (prevLane === nextLane) continue;\\n                if (obstacles[i] === nextLane) continue;\\n                dp[i][nextLane] = Math.min(dp[i][nextLane], dp[i][prevLane] + 1)\\n            }\\n        }\\n    }\\n\\n    // return the best result after reaching the end\\n    return Math.min(...dp[dp.length - 1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152426,
                "title": "python-dp-with-3-variables",
                "content": "This is a DP problem that can be solved with constant memory (only 3 variables). Here `x, y, z` represent the minimum cost of reaching lanes 1, 2, and 3 respectively. At the end of the DP, `min(x, y, z)` is the answer.\\n\\nFrom `x, y, z` we create the next step costs as `xy, yn, zn`. If there is an obstacle in the current step, the corresponding cost is simply `inf`. Otherwise we first find the minimum of the three, and then calculate the costs to other two based on this minimum value. While doing so we check if there is an obstacle as if this is the case the cost should remain `inf`.\\n\\nTime: `O(N)`\\nSpace: `O(1)`\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles):\\n        n = len(obstacles)\\n     \\t#DP variables, one for each lane\\n        x, y, z = 1, 0, 1\\n        #Bottom-up DP\\n        for i in range(1, n):\\n            #next step\\n            xn, yn, zn = x, y, z\\n            #check obstacles\\n            if obstacles[i] == 1: \\n                xn = math.inf\\n            if obstacles[i] == 2: \\n                yn = math.inf\\n            if obstacles[i] == 3: \\n                zn = math.inf\\n            #update min costs\\n            if xn == min(xn, yn, zn):\\n                if obstacles[i] != 2: yn = min(yn, xn + 1)\\n                if obstacles[i] != 3: zn = min(zn, xn + 1)\\n            elif yn == min(xn, yn, zn):\\n                if obstacles[i] != 1: xn = min(xn, yn + 1)\\n                if obstacles[i] != 3: zn = min(zn, yn + 1)\\n            else:\\n                if obstacles[i] != 1: xn = min(xn, zn + 1)\\n                if obstacles[i] != 2: yn = min(yn, zn + 1)\\n            #update original variables\\n            x, y, z = xn, yn, zn\\n        return min(x, y, z)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles):\\n        n = len(obstacles)\\n     \\t#DP variables, one for each lane\\n        x, y, z = 1, 0, 1\\n        #Bottom-up DP\\n        for i in range(1, n):\\n            #next step\\n            xn, yn, zn = x, y, z\\n            #check obstacles\\n            if obstacles[i] == 1: \\n                xn = math.inf\\n            if obstacles[i] == 2: \\n                yn = math.inf\\n            if obstacles[i] == 3: \\n                zn = math.inf\\n            #update min costs\\n            if xn == min(xn, yn, zn):\\n                if obstacles[i] != 2: yn = min(yn, xn + 1)\\n                if obstacles[i] != 3: zn = min(zn, xn + 1)\\n            elif yn == min(xn, yn, zn):\\n                if obstacles[i] != 1: xn = min(xn, yn + 1)\\n                if obstacles[i] != 3: zn = min(zn, yn + 1)\\n            else:\\n                if obstacles[i] != 1: xn = min(xn, zn + 1)\\n                if obstacles[i] != 2: yn = min(yn, zn + 1)\\n            #update original variables\\n            x, y, z = xn, yn, zn\\n        return min(x, y, z)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152421,
                "title": "clean-python-3-bottom-up-dp",
                "content": "Construct path backwards.\\nIf we found there is an obstacle in front of the frog, update side jump from same position.\\nOtherwise the side jump is the same as the next position\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles) - 1\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(n)]\\n        dp.append([0, 0, 0])\\n        for i in reversed(range(n)):\\n            ob_lane = None\\n            for lane in range(3):\\n                if obstacles[i] == lane + 1: continue\\n                if dp[i+1][lane] == float(\\'inf\\'):\\n                    ob_lane = lane\\n                else:\\n                    dp[i][lane] = dp[i+1][lane]\\n            if ob_lane is not None: dp[i][ob_lane] = min(dp[i]) + 1\\n        return dp[0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles) - 1\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(n)]\\n        dp.append([0, 0, 0])\\n        for i in reversed(range(n)):\\n            ob_lane = None\\n            for lane in range(3):\\n                if obstacles[i] == lane + 1: continue\\n                if dp[i+1][lane] == float(\\'inf\\'):\\n                    ob_lane = lane\\n                else:\\n                    dp[i][lane] = dp[i+1][lane]\\n            if ob_lane is not None: dp[i][ob_lane] = min(dp[i]) + 1\\n        return dp[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070318,
                "title": "rust-dynamic-programming-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```rust\\nconst WIDTH: usize = 3;\\n\\nimpl Solution {\\n    pub fn min_side_jumps(vec: Vec<i32>) -> i32 {\\n        let vec = vec.into_iter()\\n            .rev()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        \\n        let mut dp = [Some(usize::MIN); WIDTH];\\n        for obstacle in vec {\\n            let obstacle = obstacle as usize;\\n            if obstacle > 0 {\\n                dp[obstacle - 1] = None; // not possible\\n            }\\n\\n            for ptr in usize::MIN..WIDTH {\\n                if ptr + 1 == obstacle {\\n                    continue;\\n                }\\n\\n                for ptr_next in usize::MIN..WIDTH {\\n                    if let Some(count_next) = dp[ptr_next] {\\n                        dp[ptr] = Some(\\n                            dp[ptr]\\n                                .unwrap_or(usize::MAX)\\n                                .min(count_next + 1)\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[1].unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nconst WIDTH: usize = 3;\\n\\nimpl Solution {\\n    pub fn min_side_jumps(vec: Vec<i32>) -> i32 {\\n        let vec = vec.into_iter()\\n            .rev()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        \\n        let mut dp = [Some(usize::MIN); WIDTH];\\n        for obstacle in vec {\\n            let obstacle = obstacle as usize;\\n            if obstacle > 0 {\\n                dp[obstacle - 1] = None; // not possible\\n            }\\n\\n            for ptr in usize::MIN..WIDTH {\\n                if ptr + 1 == obstacle {\\n                    continue;\\n                }\\n\\n                for ptr_next in usize::MIN..WIDTH {\\n                    if let Some(count_next) = dp[ptr_next] {\\n                        dp[ptr] = Some(\\n                            dp[ptr]\\n                                .unwrap_or(usize::MAX)\\n                                .min(count_next + 1)\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[1].unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050793,
                "title": "javascript-solution",
                "content": "# Intuition\\nWe can use the dp to solve this question\\n\\n# Approach\\nIncreasing the position by checking the obstacles and keeping the minimum from all the possible path\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} obstacles\\n * @return {number}\\n */\\n// var solve = function(obstacles, lane, pos, dp) {\\n//     if (pos === obstacles.length - 1) {\\n//         return 0;\\n//     }\\n//     // Obstacle on next straight position\\n//     if (dp[lane][pos] !== -1) {\\n//         return dp[lane][pos];\\n//     }\\n//     if (obstacles[pos + 1] !== lane) {\\n//         return solve(obstacles, lane, pos + 1, dp);\\n//     } else {\\n//         let ans = Number.MAX_SAFE_INTEGER;\\n//         for (let i = 1; i <= 3; i++) {\\n//             if (i !== lane && obstacles[pos] !== i) {\\n//                 ans = Math.min(ans, 1 + solve(obstacles, i, pos + 1, dp)); // Updated pos here\\n//             }\\n//         }\\n//         dp[lane][pos] = ans;\\n//         return ans;\\n//     }\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let dp = Array.from({ length: 4 }, () => Array(obstacles.length).fill(-1));\\n//     return solve(obstacles, 2, 0, dp);\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let n = obstacles.length;\\n//     let dp = Array.from({ length: 4 }, () => Array(n).fill(Number.MAX_SAFE_INTEGER));\\n    \\n//     // Initialize the last column of dp to 0\\n//     dp[0][n - 1] = 0;\\n//     dp[1][n - 1] = 0;\\n//     dp[2][n - 1] = 0;\\n//     dp[3][n - 1] = 0;\\n\\n//     for (let pos = n - 2; pos >= 0; pos--) {\\n//         for (let lane = 1; lane <= 3; lane++) {\\n//             if (obstacles[pos + 1] !== lane) {\\n//                 dp[lane][pos] = dp[lane][pos + 1];\\n//             } else {\\n//                 let ans = Number.MAX_SAFE_INTEGER;\\n//                 for (let i = 1; i <= 3; i++) {\\n//                     if (i !== lane && obstacles[pos] !== i) {\\n//                         ans = Math.min(ans, 1 + dp[i][pos + 1]);\\n//                     }\\n//                 }\\n//                 dp[lane][pos] = ans;\\n//             }\\n//         }\\n//     }\\n    \\n//     // Fix the return statement\\n//     return Math.min(dp[2][0], Math.min(1 + dp[1][0], 1 + dp[3][0]));\\n// };\\n\\nvar minSideJumps = function(obstacles) { \\nlet n = obstacles.length;\\n    let curr = Array(4).fill(Number.MAX_SAFE_INTEGER)\\n    let next = Array(4).fill(0)\\n\\n    for (let pos = n - 2; pos >= 0; pos--) {\\n        for (let lane = 1; lane <= 3; lane++) {\\n            if (obstacles[pos + 1] !== lane) {\\n                curr[lane] = next[lane]\\n            } else {\\n                let ans = Number.MAX_SAFE_INTEGER;\\n                for (let i = 1; i <= 3; i++) {\\n                    if (i !== lane && obstacles[pos] !== i) {\\n                        ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                }\\n                curr[lane] = ans;\\n                next = curr\\n            }\\n        }\\n    }\\n    return Math.min(next[2], Math.min(1 + next[1], 1 + next[0]));\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} obstacles\\n * @return {number}\\n */\\n// var solve = function(obstacles, lane, pos, dp) {\\n//     if (pos === obstacles.length - 1) {\\n//         return 0;\\n//     }\\n//     // Obstacle on next straight position\\n//     if (dp[lane][pos] !== -1) {\\n//         return dp[lane][pos];\\n//     }\\n//     if (obstacles[pos + 1] !== lane) {\\n//         return solve(obstacles, lane, pos + 1, dp);\\n//     } else {\\n//         let ans = Number.MAX_SAFE_INTEGER;\\n//         for (let i = 1; i <= 3; i++) {\\n//             if (i !== lane && obstacles[pos] !== i) {\\n//                 ans = Math.min(ans, 1 + solve(obstacles, i, pos + 1, dp)); // Updated pos here\\n//             }\\n//         }\\n//         dp[lane][pos] = ans;\\n//         return ans;\\n//     }\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let dp = Array.from({ length: 4 }, () => Array(obstacles.length).fill(-1));\\n//     return solve(obstacles, 2, 0, dp);\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let n = obstacles.length;\\n//     let dp = Array.from({ length: 4 }, () => Array(n).fill(Number.MAX_SAFE_INTEGER));\\n    \\n//     // Initialize the last column of dp to 0\\n//     dp[0][n - 1] = 0;\\n//     dp[1][n - 1] = 0;\\n//     dp[2][n - 1] = 0;\\n//     dp[3][n - 1] = 0;\\n\\n//     for (let pos = n - 2; pos >= 0; pos--) {\\n//         for (let lane = 1; lane <= 3; lane++) {\\n//             if (obstacles[pos + 1] !== lane) {\\n//                 dp[lane][pos] = dp[lane][pos + 1];\\n//             } else {\\n//                 let ans = Number.MAX_SAFE_INTEGER;\\n//                 for (let i = 1; i <= 3; i++) {\\n//                     if (i !== lane && obstacles[pos] !== i) {\\n//                         ans = Math.min(ans, 1 + dp[i][pos + 1]);\\n//                     }\\n//                 }\\n//                 dp[lane][pos] = ans;\\n//             }\\n//         }\\n//     }\\n    \\n//     // Fix the return statement\\n//     return Math.min(dp[2][0], Math.min(1 + dp[1][0], 1 + dp[3][0]));\\n// };\\n\\nvar minSideJumps = function(obstacles) { \\nlet n = obstacles.length;\\n    let curr = Array(4).fill(Number.MAX_SAFE_INTEGER)\\n    let next = Array(4).fill(0)\\n\\n    for (let pos = n - 2; pos >= 0; pos--) {\\n        for (let lane = 1; lane <= 3; lane++) {\\n            if (obstacles[pos + 1] !== lane) {\\n                curr[lane] = next[lane]\\n            } else {\\n                let ans = Number.MAX_SAFE_INTEGER;\\n                for (let i = 1; i <= 3; i++) {\\n                    if (i !== lane && obstacles[pos] !== i) {\\n                        ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                }\\n                curr[lane] = ans;\\n                next = curr\\n            }\\n        }\\n    }\\n    return Math.min(next[2], Math.min(1 + next[1], 1 + next[0]));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050559,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minSideJumps(vector<int>& obstacles) {\\n    constexpr int kInf = 1e6;\\n\\n    // dp[i] := min jump to reach lane i\\n    vector<int> dp{kInf, 1, 0, 1};\\n\\n    for (const int obstacle : obstacles) {\\n      if (obstacle > 0)\\n        dp[obstacle] = kInf;\\n      for (int i = 1; i <= 3; ++i)  // Current\\n        if (i != obstacle)\\n          for (int j = 1; j <= 3; ++j)  // Prev\\n            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});\\n    }\\n\\n    return *min_element(dp.begin(), dp.end());\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minSideJumps(vector<int>& obstacles) {\\n    constexpr int kInf = 1e6;\\n\\n    // dp[i] := min jump to reach lane i\\n    vector<int> dp{kInf, 1, 0, 1};\\n\\n    for (const int obstacle : obstacles) {\\n      if (obstacle > 0)\\n        dp[obstacle] = kInf;\\n      for (int i = 1; i <= 3; ++i)  // Current\\n        if (i != obstacle)\\n          for (int j = 1; j <= 3; ++j)  // Prev\\n            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});\\n    }\\n\\n    return *min_element(dp.begin(), dp.end());\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043831,
                "title": "python-simple-solution-beats-97-in-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe keep track of all possible lanes one can be in, then prune away the lanes that are blocked when obstacles appear. This allows us to avoid having to predict which is the best lane to take.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncurr stores all possible lanes we can take. If we see an obstacle block some option in curr, just remove that from curr.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        curr = {2}\\n        i = 0; n = len(obstacles); ret = 0\\n        while i < n:\\n            obs = {obstacles[i]}\\n            curr = curr.difference(obs)\\n            #No more lanes that aren\\'t blocked\\n            if curr == set():\\n                #Find possible lanes we can take\\n                blockade = {obstacles[i-1], obstacles[i]}\\n                curr = {1,2,3}.difference(blockade)\\n                ret += 1\\n            i += 1\\n        return ret\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        curr = {2}\\n        i = 0; n = len(obstacles); ret = 0\\n        while i < n:\\n            obs = {obstacles[i]}\\n            curr = curr.difference(obs)\\n            #No more lanes that aren\\'t blocked\\n            if curr == set():\\n                #Find possible lanes we can take\\n                blockade = {obstacles[i-1], obstacles[i]}\\n                curr = {1,2,3}.difference(blockade)\\n                ret += 1\\n            i += 1\\n        return ret\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040345,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&obstacles,int currlane ,int currpos, vector<vector<int>>&dp)\\n    {\\n        //base case \\n        int n=obstacles.size()-1;\\n        if(currpos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1)\\n        {\\n            return dp[currlane][currpos];\\n        }\\n\\n\\n        if(obstacles[currpos+1]!=currlane)\\n\\n        {\\n            return solve(obstacles,currlane,currpos+1,dp);\\n        }\\n        else\\n        {\\n            //sideways\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++)\\n            {   \\n                if(currlane!= i && obstacles[currpos]!=i)\\n                ans=min(ans,1+solve(obstacles,i,currpos,dp));\\n            }\\n            dp[currlane][currpos]=ans;\\n            return dp[currlane][currpos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n         \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n         return solve(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&obstacles,int currlane ,int currpos, vector<vector<int>>&dp)\\n    {\\n        //base case \\n        int n=obstacles.size()-1;\\n        if(currpos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1)\\n        {\\n            return dp[currlane][currpos];\\n        }\\n\\n\\n        if(obstacles[currpos+1]!=currlane)\\n\\n        {\\n            return solve(obstacles,currlane,currpos+1,dp);\\n        }\\n        else\\n        {\\n            //sideways\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++)\\n            {   \\n                if(currlane!= i && obstacles[currpos]!=i)\\n                ans=min(ans,1+solve(obstacles,i,currpos,dp));\\n            }\\n            dp[currlane][currpos]=ans;\\n            return dp[currlane][currpos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n         \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n         return solve(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028462,
                "title": "dp-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSideJumps(self, s: List[int]) -> int:\\n        f = float(\\'inf\\')\\n        dp = [[f for i in range(len(s))] for j in range(3)]\\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        n = len(s)\\n        p =1\\n        for i in range(1,n):\\n            t = [1,2,3]\\n            if(s[i] != 0):\\n                t.pop(s[i]-1) \\n            for j in range(3): dp[j][i] = dp[j][i-1] if s[i] != j+1 else f\\n            for j in range(len(t)):\\n                dp[t[j]-1][i] = min(dp[t[j]-1][i], 1+dp[t[j-1]-1][i], 1+dp[t[j-2]-1][i])\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, s: List[int]) -> int:\\n        f = float(\\'inf\\')\\n        dp = [[f for i in range(len(s))] for j in range(3)]\\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        n = len(s)\\n        p =1\\n        for i in range(1,n):\\n            t = [1,2,3]\\n            if(s[i] != 0):\\n                t.pop(s[i]-1) \\n            for j in range(3): dp[j][i] = dp[j][i-1] if s[i] != j+1 else f\\n            for j in range(len(t)):\\n                dp[t[j]-1][i] = min(dp[t[j]-1][i], 1+dp[t[j-1]-1][i], 1+dp[t[j-2]-1][i])\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027212,
                "title": "runtime-error-can-someone-please-point-out-what-am-i-doing-wrong",
                "content": "```\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==23==ERROR: AddressSanitizer: stack-overflow on address 0x7ffc4321efc0 (pc 0x000000357172 bp 0x7ffc4321f0b0 sp 0x7ffc4321efc0 T0)\\n==23==ABORTING\\n\\nCan someone please point out what am i doing wrong? Getting runtime error at testcase 38th!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static const int inf = 1e9;\\n\\n    int n;\\n\\n    vector<set<int>> v;\\n\\n    pair<int,int> check(int lane) {\\n\\n        pair<int,int> ans;\\n\\n        if(lane == 1) {\\n\\n            ans.first = 1;\\n\\n            ans.second = 2;\\n\\n        } else if(lane == 2) {\\n\\n            ans.first = -1;\\n\\n            ans.second = 1;\\n\\n        } else if(lane == 3) {\\n\\n            ans.first = -1;\\n\\n            ans.second = -2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int rec(vector<vector<int>>& dp, vector<int>& o, int lane, int level) {\\n\\n        \\n        if(level == n-1)\\n            return 0;\\n\\n        if(dp[lane][level] != -1)\\n            return dp[lane][level];\\n\\n\\n        int ans = inf;\\n\\n        if(!v[lane].count(level+1))\\n            ans = min(ans, rec(dp, o, lane, level+1));\\n\\n        else {\\n\\n            pair<int,int> temp = check(lane);\\n\\n            // cout << \"lane: \" << lane << endl;\\n\\n            // cout << \"Side lane: \" << lane+temp.first << endl;\\n\\n            // cout << \"Side lane: \" << lane+temp.second << endl;\\n\\n            if(!v[lane+temp.first].count(level))\\n                ans = min(ans, 1 + rec(dp, o, lane+temp.first, level));\\n\\n            if(!v[lane+temp.second].count(level))\\n                ans = min(ans, 1 + rec(dp, o, lane+temp.second, level));\\n        }\\n\\n        return dp[lane][level] = ans;\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n\\n        n = (int)o.size();\\n\\n        v.resize(4);\\n\\n        // cout << \"n: \" << n << endl;\\n        \\n        for(int i = 0; i < n; ++i) {\\n\\n            if(o[i])\\n                v[o[i]].insert(i);\\n        }\\n\\n        // for(int i = 1; i < 4; ++i) {\\n\\n        //     cout << i << \": \";\\n\\n        //     for(auto el: v[i])\\n        //         cout << el << \" \";\\n\\n        //     cout << endl;\\n        // }\\n\\n        vector<vector<int>> dp(4, vector<int>(n+1, -1));\\n\\n        return rec(dp, o, 2, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==23==ERROR: AddressSanitizer: stack-overflow on address 0x7ffc4321efc0 (pc 0x000000357172 bp 0x7ffc4321f0b0 sp 0x7ffc4321efc0 T0)\\n==23==ABORTING\\n\\nCan someone please point out what am i doing wrong? Getting runtime error at testcase 38th!\\n\\n# Code\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015823,
                "title": "greedy-search",
                "content": "# Intuition\\nLooking into examples, you can notice that if previous step had an obstacle, there is 1 and only 1 allowed step. \\n\\n\\n# Approach\\nMove forward and if there is an obstacle in front and there are more than 1 allowed step, keep moving forward and select the line that allowed to travel the longest distance.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nfunc minSideJumps(obstacles []int) int {\\n\\t// The frog starts in lane 2 at position 0\\n\\tcurr := 2\\n\\tjumps := 0\\n\\n\\tvar search bool\\n\\n\\tfor i := 0; i < len(obstacles); i++ {\\n\\t\\tif !search {\\n\\t\\t\\tif curr == obstacles[i] {\\n\\t\\t\\t\\tjumps++\\n\\t\\t\\t\\tif obstacles[i-1] != 0 {\\n\\t\\t\\t\\t\\tcurr = 6 - obstacles[i-1] - curr // we know the line\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// look for the best line\\n\\t\\t\\t\\t\\tsearch = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif obstacles[i] != 0 && obstacles[i] != curr {\\n\\t\\t\\t\\tcurr = 6 - obstacles[i] - curr\\n\\t\\t\\t\\tsearch = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn jumps\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc minSideJumps(obstacles []int) int {\\n\\t// The frog starts in lane 2 at position 0\\n\\tcurr := 2\\n\\tjumps := 0\\n\\n\\tvar search bool\\n\\n\\tfor i := 0; i < len(obstacles); i++ {\\n\\t\\tif !search {\\n\\t\\t\\tif curr == obstacles[i] {\\n\\t\\t\\t\\tjumps++\\n\\t\\t\\t\\tif obstacles[i-1] != 0 {\\n\\t\\t\\t\\t\\tcurr = 6 - obstacles[i-1] - curr // we know the line\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// look for the best line\\n\\t\\t\\t\\t\\tsearch = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif obstacles[i] != 0 && obstacles[i] != curr {\\n\\t\\t\\t\\tcurr = 6 - obstacles[i] - curr\\n\\t\\t\\t\\tsearch = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn jumps\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012055,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles,int i,int lane,vector<vector<int>>&dp){\\n        if(i >= obstacles.size()-1)\\n            return 0;\\n        if(dp[i][lane] != -1)\\n            return dp[i][lane];\\n        if(obstacles[i+1] != lane)\\n            return solve(obstacles,i+1,lane,dp);\\n        int ans = INT_MAX;\\n        for(int j = 1;j <= 3;j++)\\n            if(j != lane && obstacles[i] != j)\\n                ans = min(ans,1 + solve(obstacles,i,j,dp));\\n        return dp[i][lane] = ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return solve(obstacles,0,2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles,int i,int lane,vector<vector<int>>&dp){\\n        if(i >= obstacles.size()-1)\\n            return 0;\\n        if(dp[i][lane] != -1)\\n            return dp[i][lane];\\n        if(obstacles[i+1] != lane)\\n            return solve(obstacles,i+1,lane,dp);\\n        int ans = INT_MAX;\\n        for(int j = 1;j <= 3;j++)\\n            if(j != lane && obstacles[i] != j)\\n                ans = min(ans,1 + solve(obstacles,i,j,dp));\\n        return dp[i][lane] = ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return solve(obstacles,0,2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008437,
                "title": "every-step-explain-with-commented-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<int>& obstacles, int currPos, int currLane,vector<vector<int>>&dp) {\\n        // Base case\\n        int n = obstacles.size() - 1;\\n        if (currPos == n) {\\n            return 0;\\n        }\\n\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n\\n        // If there\\'s no obstacle in the next position,\\n        // no need to change lanes\\n        if (obstacles[currPos + 1] != currLane) {\\n            return fun(obstacles, currPos + 1, currLane,dp);\\n        } else {\\n            int ans = INT_MAX;\\n            for (int i = 1; i <= 3; i++) {\\n                // Check if it\\'s possible to jump to lane i and\\n                // it\\'s not the current lane\\n                if (obstacles[currPos] != i && currLane != i) {\\n                    int jumps = 1 + fun(obstacles, currPos, i,dp);\\n                    // Jump to lane i\\n                    ans = min(ans, jumps);\\n                }\\n            }\\n            dp[currLane][currPos]=ans;\\n            return dp[currLane][currPos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return fun(obstacles, 0, 2,dp); \\n        // Start in the middle lane (lane 2)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<int>& obstacles, int currPos, int currLane,vector<vector<int>>&dp) {\\n        // Base case\\n        int n = obstacles.size() - 1;\\n        if (currPos == n) {\\n            return 0;\\n        }\\n\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n\\n        // If there\\'s no obstacle in the next position,\\n        // no need to change lanes\\n        if (obstacles[currPos + 1] != currLane) {\\n            return fun(obstacles, currPos + 1, currLane,dp);\\n        } else {\\n            int ans = INT_MAX;\\n            for (int i = 1; i <= 3; i++) {\\n                // Check if it\\'s possible to jump to lane i and\\n                // it\\'s not the current lane\\n                if (obstacles[currPos] != i && currLane != i) {\\n                    int jumps = 1 + fun(obstacles, currPos, i,dp);\\n                    // Jump to lane i\\n                    ans = min(ans, jumps);\\n                }\\n            }\\n            dp[currLane][currPos]=ans;\\n            return dp[currLane][currPos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return fun(obstacles, 0, 2,dp); \\n        // Start in the middle lane (lane 2)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974549,
                "title": "easy-java-solution-easy-to-understand-memorization-java",
                "content": "The solve function:\\n\\nThis function is a recursive helper function that aims to find the minimum number of side jumps required for the frog to reach the endpoint.\\nIt takes four parameters:\\npos: The current position of the frog on the road.\\ncurr_lane: The current lane of the frog.\\nobstacles: An array representing the obstacles on each lane at different points.\\nmemo: A memoization array used to store already computed solutions to avoid redundant calculations.\\nThe base case is when the frog has reached or passed the endpoint (pos >= obstacles.length or pos == obstacles.length - 1), in which case the function returns 0.\\nBefore performing any calculations, the function checks if the result for the current position and lane is already computed and stored in the memoization array. If it is, the stored result is returned to avoid recomputation.\\nIf the frog can directly jump to the next point without encountering an obstacle in the current lane, the function calculates the result for the next point and returns 0.\\nIf there\\'s an obstacle in the current lane at the next point, the function calculates the minimum number of side jumps needed to traverse the obstacle.\\nFor each possible lane to jump to (different from the current lane) and without any obstacles, the function recursively calculates the number of side jumps needed to reach the same point in the new lane and adds 1 to it (since a side jump is performed).\\nThe minimum of these values is taken as the result for the current position and lane.\\nThe minSideJumps function:\\n\\nThis function serves as the entry point to the solution.\\nIt initializes the current lane to 2 and the starting position to 0.\\nIt also initializes a memoization array with dimensions [obstacles.length][4] (representing the positions and the 3 possible lanes).\\nIt calls the solve function with these initial parameters and returns the computed result.\\n\\n```\\nclass Solution {\\n    public int solve(int pos , int curr_lane,int obstacles[], Integer memo[][]) {\\n        if(pos>=obstacles.length || pos==obstacles.length-1) {\\n            return 0 ;\\n        }\\n        if(memo[pos][curr_lane]!=null) {\\n            return memo[pos][curr_lane] ;\\n        }\\n       int ans = Integer.MAX_VALUE; \\n        if(obstacles[pos+1]!=curr_lane) {\\n            return 0+solve(pos+1,curr_lane,obstacles,memo) ;\\n        }\\n        else {\\n             if(curr_lane==2) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n                \\n            }\\n            if(curr_lane==1) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=2) {\\n                    ans1 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n            if(curr_lane==3) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=2) {\\n                    ans2 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n        }\\n        memo[pos][curr_lane] = ans ;\\n        return ans ;\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int curr_lane = 2 ;\\n        int pos = 0; \\n        Integer memo[][] = new Integer[obstacles.length][4] ;\\n        \\n       return solve(pos,curr_lane,obstacles,memo) ;\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int pos , int curr_lane,int obstacles[], Integer memo[][]) {\\n        if(pos>=obstacles.length || pos==obstacles.length-1) {\\n            return 0 ;\\n        }\\n        if(memo[pos][curr_lane]!=null) {\\n            return memo[pos][curr_lane] ;\\n        }\\n       int ans = Integer.MAX_VALUE; \\n        if(obstacles[pos+1]!=curr_lane) {\\n            return 0+solve(pos+1,curr_lane,obstacles,memo) ;\\n        }\\n        else {\\n             if(curr_lane==2) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n                \\n            }\\n            if(curr_lane==1) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=2) {\\n                    ans1 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n            if(curr_lane==3) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=2) {\\n                    ans2 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n        }\\n        memo[pos][curr_lane] = ans ;\\n        return ans ;\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int curr_lane = 2 ;\\n        int pos = 0; \\n        Integer memo[][] = new Integer[obstacles.length][4] ;\\n        \\n       return solve(pos,curr_lane,obstacles,memo) ;\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969280,
                "title": "easy-to-understand-recusion-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2*n)+O(3*n) = recursion*computation + grid making\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3*n)+O(2*n) = grid + stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int dp[5*100000+5][3];\\n    int n;\\n    int jumps(int index, int lane,vector<vector<int>>&grid){\\n        if(index==n) return 0;\\n        if(dp[index][lane]!=-1) return dp[index][lane];\\n        int ans = 0;\\n        if(grid[index+1][lane]==0){\\n            ans+=jumps(index+1,lane,grid);\\n        } \\n        if(grid[index+1][lane]!=0){\\n                /*\\n                _R_\\n                _F_\\n                */\\n                if(lane == 1){\\n                 if(grid[index][lane-1]==0 && grid[index][lane+1]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane-1,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane-1,grid);\\n                 else if(grid[index][lane-1]!=0) cnt++, ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n                else if(lane==2){\\n                 if(grid[index][lane-1]==0 && grid[index][lane-2]==0) ans+=min(jumps(index+1,lane-1,grid)+1,jumps(index+1,lane-2,grid)+1);\\n                 else if(grid[index][lane-1]!=0) ans+=1+jumps(index+1,lane-2,grid);\\n                 else if(grid[index][lane-2]!=0) cnt++, ans+=1+jumps(index+1,lane-1,grid); \\n\\n                }\\n                else if(lane == 0){\\n                 if(grid[index][lane+1]==0 && grid[index][lane+2]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane+2,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane+2,grid);\\n                 else if(grid[index][lane+2]!=0) ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n        }\\n        return dp[index][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3,0));\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0; i<n; i++){\\n            if(obstacles[i]!=0){\\n                grid[i][obstacles[i]-1] = 1;\\n            }\\n        }\\n\\n        //  for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<3; j++){\\n        //         cout << grid[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        n--;\\n\\n        \\n        return jumps(0,1,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int dp[5*100000+5][3];\\n    int n;\\n    int jumps(int index, int lane,vector<vector<int>>&grid){\\n        if(index==n) return 0;\\n        if(dp[index][lane]!=-1) return dp[index][lane];\\n        int ans = 0;\\n        if(grid[index+1][lane]==0){\\n            ans+=jumps(index+1,lane,grid);\\n        } \\n        if(grid[index+1][lane]!=0){\\n                /*\\n                _R_\\n                _F_\\n                */\\n                if(lane == 1){\\n                 if(grid[index][lane-1]==0 && grid[index][lane+1]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane-1,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane-1,grid);\\n                 else if(grid[index][lane-1]!=0) cnt++, ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n                else if(lane==2){\\n                 if(grid[index][lane-1]==0 && grid[index][lane-2]==0) ans+=min(jumps(index+1,lane-1,grid)+1,jumps(index+1,lane-2,grid)+1);\\n                 else if(grid[index][lane-1]!=0) ans+=1+jumps(index+1,lane-2,grid);\\n                 else if(grid[index][lane-2]!=0) cnt++, ans+=1+jumps(index+1,lane-1,grid); \\n\\n                }\\n                else if(lane == 0){\\n                 if(grid[index][lane+1]==0 && grid[index][lane+2]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane+2,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane+2,grid);\\n                 else if(grid[index][lane+2]!=0) ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n        }\\n        return dp[index][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3,0));\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0; i<n; i++){\\n            if(obstacles[i]!=0){\\n                grid[i][obstacles[i]-1] = 1;\\n            }\\n        }\\n\\n        //  for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<3; j++){\\n        //         cout << grid[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        n--;\\n\\n        \\n        return jumps(0,1,grid);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3959568,
                "title": "use-dynamic-programming",
                "content": "\\n# CPP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obstacles,int currlan ,int currpos){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\n if(obstacles[currpos+1]!=currlan){\\n     return solve(obstacles,currlan,currpos+1);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solve(obstacles,i,currpos+1));\\n} \\nreturn ans;\\n}\\n\\n}\\nint solveMem(vector<int>&obstacles,int currlan ,int currpos,vector<vector<int>>dp){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\nif(dp[currlan][currpos]!=-1)\\nreturn dp[currlan][currpos];\\n if(obstacles[currpos+1]!=currlan){\\n     return solveMem(obstacles,currlan,currpos+1,dp);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solveMem(obstacles,i,currpos+1,dp));\\n} \\ndp[currlan][currpos]=ans;\\n\\nreturn dp[currlan][currpos];\\n}\\n\\n}\\n\\nint solveTab(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\ndp[0][n]=0;\\ndp[1][n]=0;\\ndp[2][n]=0;\\ndp[3][n]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      dp[currlan][currpos]=dp[currlan][currpos+1];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+dp[i][currpos+1]);\\n          }\\n          dp[currlan][currpos]=ans;\\n      }\\n}\\n}\\nreturn min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n\\n}\\nint solveSO(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\nvector<int>curr(4,INT_MAX);\\nvector<int>next(4,INT_MAX);\\nnext[0]=0;\\nnext[1]=0;\\nnext[2]=0;\\nnext[3]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      curr[currlan]=next[currlan];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+next[i]);\\n          }\\n          curr[currlan]=ans;\\n      }\\n}\\nnext=curr;\\n}\\nreturn min(next[2],min(1+next[1],1+next[3]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n       // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n    // return solveMem(obstacles,2,0,dp);\\n    //  return solveTab(obstacles);\\n     return solveSO(obstacles);\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obstacles,int currlan ,int currpos){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\n if(obstacles[currpos+1]!=currlan){\\n     return solve(obstacles,currlan,currpos+1);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solve(obstacles,i,currpos+1));\\n} \\nreturn ans;\\n}\\n\\n}\\nint solveMem(vector<int>&obstacles,int currlan ,int currpos,vector<vector<int>>dp){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\nif(dp[currlan][currpos]!=-1)\\nreturn dp[currlan][currpos];\\n if(obstacles[currpos+1]!=currlan){\\n     return solveMem(obstacles,currlan,currpos+1,dp);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solveMem(obstacles,i,currpos+1,dp));\\n} \\ndp[currlan][currpos]=ans;\\n\\nreturn dp[currlan][currpos];\\n}\\n\\n}\\n\\nint solveTab(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\ndp[0][n]=0;\\ndp[1][n]=0;\\ndp[2][n]=0;\\ndp[3][n]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      dp[currlan][currpos]=dp[currlan][currpos+1];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+dp[i][currpos+1]);\\n          }\\n          dp[currlan][currpos]=ans;\\n      }\\n}\\n}\\nreturn min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n\\n}\\nint solveSO(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\nvector<int>curr(4,INT_MAX);\\nvector<int>next(4,INT_MAX);\\nnext[0]=0;\\nnext[1]=0;\\nnext[2]=0;\\nnext[3]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      curr[currlan]=next[currlan];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+next[i]);\\n          }\\n          curr[currlan]=ans;\\n      }\\n}\\nnext=curr;\\n}\\nreturn min(next[2],min(1+next[1],1+next[3]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n       // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n    // return solveMem(obstacles,2,0,dp);\\n    //  return solveTab(obstacles);\\n     return solveSO(obstacles);\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944941,
                "title": "easy-c-code-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obs,int currl,int currp ,vector<vector<int>>&dp){\\n  int n = obs.size()-1;\\n  if(n==currp) return 0;\\n  if(dp[currl][currp] != -1) return dp[currl][currp];\\n  if(obs[currp+1]!=currl){\\n      return solve(obs,currl,currp+1,dp);\\n  }else{\\n      int ans = INT_MAX;\\n      for(int i=1;i<=3;i++){\\n          if(currl !=i && obs[currp] !=i){\\n              ans = min(ans,1+solve(obs,i,currp,dp));\\n          }\\n      }\\n      dp[currl][currp] = ans;\\n      return dp[currl][currp];\\n  }\\n}\\n    int minSideJumps(vector<int>& obs) {\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        return solve(obs,2,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obs,int currl,int currp ,vector<vector<int>>&dp){\\n  int n = obs.size()-1;\\n  if(n==currp) return 0;\\n  if(dp[currl][currp] != -1) return dp[currl][currp];\\n  if(obs[currp+1]!=currl){\\n      return solve(obs,currl,currp+1,dp);\\n  }else{\\n      int ans = INT_MAX;\\n      for(int i=1;i<=3;i++){\\n          if(currl !=i && obs[currp] !=i){\\n              ans = min(ans,1+solve(obs,i,currp,dp));\\n          }\\n      }\\n      dp[currl][currp] = ans;\\n      return dp[currl][currp];\\n  }\\n}\\n    int minSideJumps(vector<int>& obs) {\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        return solve(obs,2,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913985,
                "title": "can-someone-guide-why-i-am-getting-runtime-error-on-test-case-38",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp(int dist, int lane, vector<vector<int>> &r, vector<vector<int>> &mem){\\n        if(dist == r[0].size()-1)return 0;\\n        if(r[lane][dist+1] == 0){\\n            return dp(dist+1, lane, r, mem);\\n        }\\n\\n        // shift to other lanes\\n\\n        if(mem[lane][dist] != -1)return mem[lane][dist];\\n\\n        // lane 1\\n        int lane1 = (r[0][dist] == 0 && lane != 0) ? (dp(dist, 0, r, mem) + 1) : 1e9;\\n        // lane 2\\n        int lane2 = (r[1][dist] == 0 && lane != 1)  ? (dp(dist, 1, r, mem) + 1) : 1e9;\\n        // lane 3\\n        int lane3 = (r[2][dist] == 0 && lane != 2)  ? (dp(dist, 2, r, mem) + 1): 1e9;\\n\\n        return mem[lane][dist] = min({lane1, lane2, lane3});\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n        int n = o.size();\\n        vector<vector<int>> r(3, vector<int> (n, 0));\\n        vector<vector<int>> mem(3, vector<int> (n, -1));\\n        for(int i=0; i<n; i++){\\n            if(o[i] == 0)continue;\\n            else r[o[i]-1][i] = 1;\\n        }\\n\\n        return dp(0,1,r, mem);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp(int dist, int lane, vector<vector<int>> &r, vector<vector<int>> &mem){\\n        if(dist == r[0].size()-1)return 0;\\n        if(r[lane][dist+1] == 0){\\n            return dp(dist+1, lane, r, mem);\\n        }\\n\\n        // shift to other lanes\\n\\n        if(mem[lane][dist] != -1)return mem[lane][dist];\\n\\n        // lane 1\\n        int lane1 = (r[0][dist] == 0 && lane != 0) ? (dp(dist, 0, r, mem) + 1) : 1e9;\\n        // lane 2\\n        int lane2 = (r[1][dist] == 0 && lane != 1)  ? (dp(dist, 1, r, mem) + 1) : 1e9;\\n        // lane 3\\n        int lane3 = (r[2][dist] == 0 && lane != 2)  ? (dp(dist, 2, r, mem) + 1): 1e9;\\n\\n        return mem[lane][dist] = min({lane1, lane2, lane3});\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n        int n = o.size();\\n        vector<vector<int>> r(3, vector<int> (n, 0));\\n        vector<vector<int>> mem(3, vector<int> (n, -1));\\n        for(int i=0; i<n; i++){\\n            if(o[i] == 0)continue;\\n            else r[o[i]-1][i] = 1;\\n        }\\n\\n        return dp(0,1,r, mem);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913024,
                "title": "c-space-optimized-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to reach the end of the lane by minizing side jumps. Hence at each i keep track of number of jumps required to reach lane 1, 2, 3. Note difference between no of jumps between any 2 nodes cannot exceed 1.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI kept 3 variables to keep track of jumps. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& o) {\\n        int n=o.size();\\n        int a=1, b=0, c=1, ta, tb, tc, inf=5*1e5;\\n        if(o[0]==1){\\n            a=inf;\\n        }\\n        if(o[0]==3){\\n            c=inf;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(o[i]==1){\\n                ta=inf;\\n                tb=min(b, c+1);\\n                tc=min(c, b+1);\\n            }else if(o[i]==2){\\n                ta=min(a, c+1);\\n                tb=inf;\\n                tc=min(c, a+1);\\n            }else if(o[i]==3){\\n                ta=min(a, b+1);\\n                tb=min(b, a+1);\\n                tc=inf;\\n            }else{\\n                ta=min(a, min(b+1, c+1));\\n                tb=min(b, min(a+1, c+1));\\n                tc=min(c, min(a+1, b+1));\\n            }\\n            a=ta;b=tb;c=tc;\\n        }\\n        return min(a, min(b, c));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& o) {\\n        int n=o.size();\\n        int a=1, b=0, c=1, ta, tb, tc, inf=5*1e5;\\n        if(o[0]==1){\\n            a=inf;\\n        }\\n        if(o[0]==3){\\n            c=inf;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(o[i]==1){\\n                ta=inf;\\n                tb=min(b, c+1);\\n                tc=min(c, b+1);\\n            }else if(o[i]==2){\\n                ta=min(a, c+1);\\n                tb=inf;\\n                tc=min(c, a+1);\\n            }else if(o[i]==3){\\n                ta=min(a, b+1);\\n                tb=min(b, a+1);\\n                tc=inf;\\n            }else{\\n                ta=min(a, min(b+1, c+1));\\n                tb=min(b, min(a+1, c+1));\\n                tc=min(c, min(a+1, b+1));\\n            }\\n            a=ta;b=tb;c=tc;\\n        }\\n        return min(a, min(b, c));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897223,
                "title": "memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solvemem(vector<int>& obstacles,vector<vector<int>>&dp,int lane,int pos){\\n        //base case\\n        if(pos==obstacles.size()-1)return 0;\\n        if(dp[lane][pos]!=-1)return dp[lane][pos];\\n        //if no obstacle go forward\\n        if(obstacles[pos+1]!=lane)return solvemem(obstacles,dp,lane,pos+1);\\n        //if obstacle present\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++){\\n                if(lane!=i && obstacles[pos]!=i){\\n                    ans=min(ans,1+solvemem(obstacles,dp,i,pos+1));\\n                }\\n            }\\n        \\n        return dp[lane][pos]=ans;\\n\\n    }\\n   \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solvemem(obstacles,dp,2,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solvemem(vector<int>& obstacles,vector<vector<int>>&dp,int lane,int pos){\\n        //base case\\n        if(pos==obstacles.size()-1)return 0;\\n        if(dp[lane][pos]!=-1)return dp[lane][pos];\\n        //if no obstacle go forward\\n        if(obstacles[pos+1]!=lane)return solvemem(obstacles,dp,lane,pos+1);\\n        //if obstacle present\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++){\\n                if(lane!=i && obstacles[pos]!=i){\\n                    ans=min(ans,1+solvemem(obstacles,dp,i,pos+1));\\n                }\\n            }\\n        \\n        return dp[lane][pos]=ans;\\n\\n    }\\n   \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solvemem(obstacles,dp,2,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873909,
                "title": "i-have-no-fuckin-idea-what-i-have-done",
                "content": "# Intuition\\n- Fuck intuition\\n\\n# Approach\\n- Infinite monkey theorem (Slam you head into the keyboard until the solution is written randomly)\\n\\n# Complexity\\n- Time complexity: The same amount I take to cum\\n\\n- Space complexity: The same size as your mom\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int jumps = 0;\\n        int lane = 2;\\n        int location = 0;\\n        while(location < obstacles.size() - 1){\\n            if(obstacles[location+1] != lane){\\n                location += 1;\\n                continue;\\n            }\\n            if((obstacles[location] == lane+1 || obstacles[location] == lane -1)\\n            && obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location +=1;\\n                continue;\\n            }\\n            if(obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location += 1;\\n                continue;\\n            }\\n            else{\\n                jumps += 1;\\n                int i = location+1;\\n                while(true){\\n                    if(i > obstacles.size() - 1){\\n                        lane = (lane == 3 || lane == 1) ? 2 : 3;\\n                        break;\\n                    }\\n                    if(obstacles[i] != 0 && obstacles[i] != lane){\\n                        lane = 6  - lane - obstacles[i];\\n                        break; \\n                    }\\n                \\n                    i += 1;\\n                }\\n                location += 1;\\n            }\\n        \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int jumps = 0;\\n        int lane = 2;\\n        int location = 0;\\n        while(location < obstacles.size() - 1){\\n            if(obstacles[location+1] != lane){\\n                location += 1;\\n                continue;\\n            }\\n            if((obstacles[location] == lane+1 || obstacles[location] == lane -1)\\n            && obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location +=1;\\n                continue;\\n            }\\n            if(obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location += 1;\\n                continue;\\n            }\\n            else{\\n                jumps += 1;\\n                int i = location+1;\\n                while(true){\\n                    if(i > obstacles.size() - 1){\\n                        lane = (lane == 3 || lane == 1) ? 2 : 3;\\n                        break;\\n                    }\\n                    if(obstacles[i] != 0 && obstacles[i] != lane){\\n                        lane = 6  - lane - obstacles[i];\\n                        break; \\n                    }\\n                \\n                    i += 1;\\n                }\\n                location += 1;\\n            }\\n        \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832352,
                "title": "eazy-c-dp-4-methods-recursion-recursion-memoisation-tabulation-space-optimization",
                "content": "# Intuition\\nJust start your solution using thinking of iterative approach until you reach to comparing answer to adjacent lanes for the smaller output .Here recursion kicks in.\\nThen just basic algorithms of Dynamic programming , keep it rolling.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\nFor Best Case (SO) \\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obs,int currpos,int currLane){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n        int jump=0;\\n        if(obs[currpos+1]!=currLane)\\n        return solve(obs,currpos+1,currLane);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solve(obs,currpos,i));\\n                }   \\n            }\\n            return ans;\\n        }\\n    }\\n    int solveMem(vector<int>& obs,int currpos,int currLane,vector<vector<int>>&dp){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n        if(dp[currLane][currpos]!=-1)\\n        return dp[currLane][currpos];\\n\\n        if(obs[currpos+1]!=currLane)\\n        return solveMem(obs,currpos+1,currLane,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solveMem(obs,currpos,i,dp));\\n                }  \\n\\n            }\\n            dp[currLane][currpos]=ans;\\n            return dp[currLane][currpos];\\n        }\\n    }\\n\\n    int solveTab(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),1e9));\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                dp[lane][pos]=dp[lane][pos+1];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+dp[i][pos+1]);\\n                        }\\n                    }\\n                    dp[lane][pos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(dp[1][0]+1,dp[3][0]+1));\\n    }\\n\\n    int solveSO(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0]=0;\\n        next[1]=0;\\n        next[2]=0;\\n        next[3]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                curr[lane]=next[lane];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+next[i]);\\n                        }\\n                    }\\n                    curr[lane]=ans;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return min(next[2],min(next[1]+1,next[3]+1));\\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        //////Recursion\\n        // return solve(obs,0,2);\\n\\n        //////Memoization\\n        // vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        // return solveMem(obs,0,2,dp);\\n\\n        //////Tabulation\\n        // return solveTab(obs);\\n\\n        //////Space Optimization\\n         return solveSO(obs);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obs,int currpos,int currLane){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n        int jump=0;\\n        if(obs[currpos+1]!=currLane)\\n        return solve(obs,currpos+1,currLane);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solve(obs,currpos,i));\\n                }   \\n            }\\n            return ans;\\n        }\\n    }\\n    int solveMem(vector<int>& obs,int currpos,int currLane,vector<vector<int>>&dp){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n        if(dp[currLane][currpos]!=-1)\\n        return dp[currLane][currpos];\\n\\n        if(obs[currpos+1]!=currLane)\\n        return solveMem(obs,currpos+1,currLane,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solveMem(obs,currpos,i,dp));\\n                }  \\n\\n            }\\n            dp[currLane][currpos]=ans;\\n            return dp[currLane][currpos];\\n        }\\n    }\\n\\n    int solveTab(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),1e9));\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                dp[lane][pos]=dp[lane][pos+1];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+dp[i][pos+1]);\\n                        }\\n                    }\\n                    dp[lane][pos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(dp[1][0]+1,dp[3][0]+1));\\n    }\\n\\n    int solveSO(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0]=0;\\n        next[1]=0;\\n        next[2]=0;\\n        next[3]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                curr[lane]=next[lane];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+next[i]);\\n                        }\\n                    }\\n                    curr[lane]=ans;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return min(next[2],min(next[1]+1,next[3]+1));\\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        //////Recursion\\n        // return solve(obs,0,2);\\n\\n        //////Memoization\\n        // vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        // return solveMem(obs,0,2,dp);\\n\\n        //////Tabulation\\n        // return solveTab(obs);\\n\\n        //////Space Optimization\\n         return solveSO(obs);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824541,
                "title": "c-memorization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& obstacles, int currlane, int currpos,  vector<vector<int>> &dp){\\n        int n=obstacles.size()-1;\\n        if(currpos==n){\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1){\\n            return dp[currlane][currpos];\\n        }\\n        if(obstacles[currpos+1]!=currlane){\\n            return solve(obstacles, currlane,currpos+1,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            for(int i=1; i<4; i++){\\n            if(currlane!=i && obstacles[currpos]!=i){\\n                ans=min(ans, 1+ solve(obstacles, i, currpos,dp));\\n            }\\n        }\\n        dp[currlane][currpos]=ans;\\n        return  dp[currlane][currpos];\\n\\n        }\\n\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n       int ans= solve(obstacles, 2, 0, dp);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& obstacles, int currlane, int currpos,  vector<vector<int>> &dp){\\n        int n=obstacles.size()-1;\\n        if(currpos==n){\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1){\\n            return dp[currlane][currpos];\\n        }\\n        if(obstacles[currpos+1]!=currlane){\\n            return solve(obstacles, currlane,currpos+1,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            for(int i=1; i<4; i++){\\n            if(currlane!=i && obstacles[currpos]!=i){\\n                ans=min(ans, 1+ solve(obstacles, i, currpos,dp));\\n            }\\n        }\\n        dp[currlane][currpos]=ans;\\n        return  dp[currlane][currpos];\\n\\n        }\\n\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n       int ans= solve(obstacles, 2, 0, dp);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817719,
                "title": "minimum-sideway-jupm-param-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> tabulation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// int solve(vector<int>& obstacles,int currlane,int currpos){\\n//     int n=obstacles.size()-1;\\n//     if(currpos==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[currpos+1]!=currlane){\\n//         return solve(obstacles,currlane,currpos+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=1;i<=3;i++){\\n//             if(currlane!=i&&obstacles[currpos]!=i){\\n//                 ans=min(ans,1+solve(obstacles,i,currpos));\\n//             }\\n//         }return ans;\\n//     }\\n// }\\n// int param(vector<int>&obstacles,int cl,int cp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return param(obstacles,cl,cp+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+param(obstacles,i,cp));\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n// int paramM(vector<int>&obstacles,int cl,int cp,vector<vector<int>>&dp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(dp[cl][cp]!=-1){\\n//         return dp[cl][cp];\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return paramM(obstacles,cl,cp+1,dp);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+paramM(obstacles,i,cp,dp));\\n//             }\\n            \\n//         }\\n//         dp[cl][cp]=ans;\\n//         return dp[cl][cp];\\n//     }\\n// }\\nint paramT(vector<int>&obstacles){\\n     int n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),1e9));\\n    dp[0][n]=0;\\n    dp[1][n]=0;\\n    dp[2][n]=0;\\n    dp[3][n]=0;\\n    for(int cp=n-1;cp>=0;cp--){\\n        for(int cl=1;cl<=3;cl++){\\n            if(obstacles[cp+1]!=cl){\\n                dp[cl][cp]=dp[cl][cp+1];\\n        // return param(obstacles,cl,cp+1);\\n    }else{\\n        int ans=INT_MAX;\\n        for(int i=0;i<=3;i++){\\n            if(cl!=i&&obstacles[cp]!=i){\\n                ans=min(ans,1+dp[i][cp+1]);\\n            }\\n        }dp[cl][cp]=ans;\\n        } }}\\n    \\n    return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        // return paramM(obstacles,2,0,dp);\\n        return paramT(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// int solve(vector<int>& obstacles,int currlane,int currpos){\\n//     int n=obstacles.size()-1;\\n//     if(currpos==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[currpos+1]!=currlane){\\n//         return solve(obstacles,currlane,currpos+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=1;i<=3;i++){\\n//             if(currlane!=i&&obstacles[currpos]!=i){\\n//                 ans=min(ans,1+solve(obstacles,i,currpos));\\n//             }\\n//         }return ans;\\n//     }\\n// }\\n// int param(vector<int>&obstacles,int cl,int cp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return param(obstacles,cl,cp+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+param(obstacles,i,cp));\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n// int paramM(vector<int>&obstacles,int cl,int cp,vector<vector<int>>&dp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(dp[cl][cp]!=-1){\\n//         return dp[cl][cp];\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return paramM(obstacles,cl,cp+1,dp);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+paramM(obstacles,i,cp,dp));\\n//             }\\n            \\n//         }\\n//         dp[cl][cp]=ans;\\n//         return dp[cl][cp];\\n//     }\\n// }\\nint paramT(vector<int>&obstacles){\\n     int n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),1e9));\\n    dp[0][n]=0;\\n    dp[1][n]=0;\\n    dp[2][n]=0;\\n    dp[3][n]=0;\\n    for(int cp=n-1;cp>=0;cp--){\\n        for(int cl=1;cl<=3;cl++){\\n            if(obstacles[cp+1]!=cl){\\n                dp[cl][cp]=dp[cl][cp+1];\\n        // return param(obstacles,cl,cp+1);\\n    }else{\\n        int ans=INT_MAX;\\n        for(int i=0;i<=3;i++){\\n            if(cl!=i&&obstacles[cp]!=i){\\n                ans=min(ans,1+dp[i][cp+1]);\\n            }\\n        }dp[cl][cp]=ans;\\n        } }}\\n    \\n    return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        // return paramM(obstacles,2,0,dp);\\n        return paramT(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810008,
                "title": "simple-cpp-solution-using-recursion-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& obstacles,int lane,int i,vector<vector<int>>& dp){\\n  int n=obstacles.size();\\n  if(i==n-1 && obstacles[i]!=lane){\\n    return 0;\\n  }\\n  int x=INT_MAX;\\n  if(dp[lane][i]!=-1){\\n    return dp[lane][i];\\n  }\\n  if(obstacles[i+1]!=lane){\\n  return solve(obstacles,lane,i+1,dp);\\n  }\\n  else{\\n    for(int j=1;j<=3;j++){\\n      if(j!=lane && obstacles[i]!=j){\\n       int ans=1+solve(obstacles,j,i,dp);\\n       x=min(ans,x);\\n      }\\n    }\\n    \\n  }\\n  return dp[lane][i]=x;\\n  \\n\\n  \\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n      int n=obstacles.size();\\n      int lane=2;\\n      int i=0;\\n      vector<vector<int>> dp(4,vector<int>(n+1,-1));\\n\\n      return solve(obstacles,lane,i,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& obstacles,int lane,int i,vector<vector<int>>& dp){\\n  int n=obstacles.size();\\n  if(i==n-1 && obstacles[i]!=lane){\\n    return 0;\\n  }\\n  int x=INT_MAX;\\n  if(dp[lane][i]!=-1){\\n    return dp[lane][i];\\n  }\\n  if(obstacles[i+1]!=lane){\\n  return solve(obstacles,lane,i+1,dp);\\n  }\\n  else{\\n    for(int j=1;j<=3;j++){\\n      if(j!=lane && obstacles[i]!=j){\\n       int ans=1+solve(obstacles,j,i,dp);\\n       x=min(ans,x);\\n      }\\n    }\\n    \\n  }\\n  return dp[lane][i]=x;\\n  \\n\\n  \\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n      int n=obstacles.size();\\n      int lane=2;\\n      int i=0;\\n      vector<vector<int>> dp(4,vector<int>(n+1,-1));\\n\\n      return solve(obstacles,lane,i,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799724,
                "title": "c-ease",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[(int)5e5 + 5][4];\\n    int f(vector<int>&o,int pos,int currlane){\\n        if(pos>=o.size())return 0;\\n        if(dp[pos][currlane]!=-1)return dp[pos][currlane];\\n        \\n        if(o[pos]==currlane)return dp[pos][currlane]=(int)1e9;\\n        \\n        int o1=f(o,pos+1,currlane);\\n        \\n        for(int i=1;i<=3;i++){ \\n            if(o[pos]!=i)\\n            o1=min(o1 , f(o,pos+1,i) + (i != currlane) );            \\n        }\\n        return dp[pos][currlane]=o1;\\n    }\\n    \\n    int minSideJumps(vector<int>& o) {\\n        memset(dp,-1,sizeof dp);\\n        return f(o,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[(int)5e5 + 5][4];\\n    int f(vector<int>&o,int pos,int currlane){\\n        if(pos>=o.size())return 0;\\n        if(dp[pos][currlane]!=-1)return dp[pos][currlane];\\n        \\n        if(o[pos]==currlane)return dp[pos][currlane]=(int)1e9;\\n        \\n        int o1=f(o,pos+1,currlane);\\n        \\n        for(int i=1;i<=3;i++){ \\n            if(o[pos]!=i)\\n            o1=min(o1 , f(o,pos+1,i) + (i != currlane) );            \\n        }\\n        return dp[pos][currlane]=o1;\\n    }\\n    \\n    int minSideJumps(vector<int>& o) {\\n        memset(dp,-1,sizeof dp);\\n        return f(o,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773110,
                "title": "easiest-and-the-most-beginner-friendly-code-neatly-written",
                "content": "# Complexity\\n- Time complexity:\\n- o(n*3)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& obstacles, int row, int col) {\\n        int obstaclePosition = obstacles[col];\\n        if (obstaclePosition == row) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(vector<int>& obstacles, int row, int col, vector<vector<int>>& dp) {\\n        if (col == obstacles.size()-1) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        int val = 1e9;\\n        if (isPossible(obstacles, row, col + 1)) {\\n            int moveAhead = solve(obstacles, row, col + 1, dp);    \\n            val = min(val, moveAhead);\\n        } \\n        else {\\n            for (int i = 1; i <= 3; i++) {\\n                if (isPossible(obstacles, i, col) && i != row) {\\n                    int adjJump = 1 + solve(obstacles, i, col, dp);\\n                    val = min(val, adjJump);\\n                }\\n            }\\n        }\\n        return dp[row][col] =val;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(obstacles.size() + 5, -1));\\n        return solve(obstacles, 2, 0, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& obstacles, int row, int col) {\\n        int obstaclePosition = obstacles[col];\\n        if (obstaclePosition == row) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(vector<int>& obstacles, int row, int col, vector<vector<int>>& dp) {\\n        if (col == obstacles.size()-1) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        int val = 1e9;\\n        if (isPossible(obstacles, row, col + 1)) {\\n            int moveAhead = solve(obstacles, row, col + 1, dp);    \\n            val = min(val, moveAhead);\\n        } \\n        else {\\n            for (int i = 1; i <= 3; i++) {\\n                if (isPossible(obstacles, i, col) && i != row) {\\n                    int adjJump = 1 + solve(obstacles, i, col, dp);\\n                    val = min(val, adjJump);\\n                }\\n            }\\n        }\\n        return dp[row][col] =val;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(obstacles.size() + 5, -1));\\n        return solve(obstacles, 2, 0, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753762,
                "title": "easily-understandable-all-approaches-rec-mem-tab-space-optimization-in-java",
                "content": "# Intuition\\nRecursion, then memoization, then tabulation and at last space optimization \\n\\n# Approach\\nDifferent from normal DP problems, there is a slight catch in bottom up approach where we added +1 in curr pos to make sure, we access previous value, not the max value of same pos which is not yet updated.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)** // for best case else O(4*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n       // return solve(obstacles, 2, 0);\\n        /*int[][] dp=new int[4][obstacles.length];\\n        for(int i=0;i<=3;i++){\\n            for(int j=0;j<obstacles.length;j++){\\n                //dp[i][j]=-1;\\n                dp[i][j]=Integer.MAX_VALUE;\\n            }\\n        }*/\\n        //return solvemem(obstacles, 2, 0, dp);\\n        //return solvetab(obstacles, dp);\\n        return solvetabSO(obstacles);\\n    }\\n    public static int solve(int[] obstacles, int curr, int pos){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solve(obstacles, curr, pos+1);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solve(obstacles, i, pos));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int solvemem(int[] obstacles, int curr, int pos, int[][] dp){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[curr][pos]!=-1){\\n            return dp[curr][pos];\\n        }\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solvemem(obstacles, curr, pos+1, dp);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solvemem(obstacles, i, pos, dp));\\n                }\\n            }\\n        }\\n        dp[curr][pos]=ans;\\n        return dp[curr][pos];\\n    }\\n    public static int solvetab(int[] obstacles, int[][] dp){\\n       int n=obstacles.length;\\n\\n       dp[0][n-1]=0;\\n       dp[1][n-1]=0;\\n       dp[2][n-1]=0;\\n       dp[3][n-1]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int curr=1;curr<=3;curr++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n                 dp[curr][pos]= dp[curr][pos+1];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(curr!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+dp[i][pos+1]);\\n                    }\\n                }\\n                dp[curr][pos]=ans;\\n           }            \\n       }\\n   } \\n   return Math.min(dp[2][0], Math.min(1+dp[1][0], 1+dp[3][0]));\\n}  \\npublic static int solvetabSO(int[] obstacles){\\n       int n=obstacles.length;\\n       int curr[]=new int[4];\\n       int next[]=new int[4];\\n       Arrays.fill(curr, Integer.MAX_VALUE);\\n       Arrays.fill(next, Integer.MAX_VALUE);\\n       next[0]=0;\\n       next[1]=0;\\n       next[2]=0;\\n       next[3]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int k=1;k<=3;k++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=k){\\n                 curr[k]= next[k];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(k!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+next[i]);\\n                    }\\n                }\\n                curr[k]=ans;\\n           }           \\n       }\\n       next=curr; \\n   } \\n   return Math.min(next[2], Math.min(1+next[1], 1+next[3]));\\n}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n       // return solve(obstacles, 2, 0);\\n        /*int[][] dp=new int[4][obstacles.length];\\n        for(int i=0;i<=3;i++){\\n            for(int j=0;j<obstacles.length;j++){\\n                //dp[i][j]=-1;\\n                dp[i][j]=Integer.MAX_VALUE;\\n            }\\n        }*/\\n        //return solvemem(obstacles, 2, 0, dp);\\n        //return solvetab(obstacles, dp);\\n        return solvetabSO(obstacles);\\n    }\\n    public static int solve(int[] obstacles, int curr, int pos){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solve(obstacles, curr, pos+1);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solve(obstacles, i, pos));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int solvemem(int[] obstacles, int curr, int pos, int[][] dp){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[curr][pos]!=-1){\\n            return dp[curr][pos];\\n        }\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solvemem(obstacles, curr, pos+1, dp);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solvemem(obstacles, i, pos, dp));\\n                }\\n            }\\n        }\\n        dp[curr][pos]=ans;\\n        return dp[curr][pos];\\n    }\\n    public static int solvetab(int[] obstacles, int[][] dp){\\n       int n=obstacles.length;\\n\\n       dp[0][n-1]=0;\\n       dp[1][n-1]=0;\\n       dp[2][n-1]=0;\\n       dp[3][n-1]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int curr=1;curr<=3;curr++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n                 dp[curr][pos]= dp[curr][pos+1];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(curr!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+dp[i][pos+1]);\\n                    }\\n                }\\n                dp[curr][pos]=ans;\\n           }            \\n       }\\n   } \\n   return Math.min(dp[2][0], Math.min(1+dp[1][0], 1+dp[3][0]));\\n}  \\npublic static int solvetabSO(int[] obstacles){\\n       int n=obstacles.length;\\n       int curr[]=new int[4];\\n       int next[]=new int[4];\\n       Arrays.fill(curr, Integer.MAX_VALUE);\\n       Arrays.fill(next, Integer.MAX_VALUE);\\n       next[0]=0;\\n       next[1]=0;\\n       next[2]=0;\\n       next[3]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int k=1;k<=3;k++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=k){\\n                 curr[k]= next[k];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(k!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+next[i]);\\n                    }\\n                }\\n                curr[k]=ans;\\n           }           \\n       }\\n       next=curr; \\n   } \\n   return Math.min(next[2], Math.min(1+next[1], 1+next[3]));\\n}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749460,
                "title": "best-solution-of-minimum-sideways-jump",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    memoization\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  2-D DP\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  o(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  o(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(vector<int>& obstacles,int currlane,int currpos){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solve(obstacles,currlane,currpos);\\n     }\\n     else\\n     {\\n        int ans = 1;\\n     for(int i =1;i<=3;i++){\\n\\n         ans = min(ans,1+solve(obstacles,currlane,currpos+1));\\n     }\\n     return ans;\\n     }\\n }\\n  int solvemem(vector<int>& obstacles,int currlane,int currpos,vector<vector<int>>&dp){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(dp[currlane][currpos]!=-1){\\n         return dp[currlane][currpos];\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solvemem(obstacles,currlane,currpos+1,dp);\\n     }\\n     else\\n     {\\n        int ans = INT_MAX;\\n     for(int i =1;i<=3;i++){\\n         if(currlane!=i && obstacles[currpos]!=i)\\n         ans = min(ans,1+solvemem(obstacles,i,currpos,dp));\\n         \\n     }\\n      dp[currlane][currpos]=ans;\\n     return dp[currlane][currpos];\\n     }\\n }\\n      \\n      \\n \\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solvemem(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(vector<int>& obstacles,int currlane,int currpos){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solve(obstacles,currlane,currpos);\\n     }\\n     else\\n     {\\n        int ans = 1;\\n     for(int i =1;i<=3;i++){\\n\\n         ans = min(ans,1+solve(obstacles,currlane,currpos+1));\\n     }\\n     return ans;\\n     }\\n }\\n  int solvemem(vector<int>& obstacles,int currlane,int currpos,vector<vector<int>>&dp){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(dp[currlane][currpos]!=-1){\\n         return dp[currlane][currpos];\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solvemem(obstacles,currlane,currpos+1,dp);\\n     }\\n     else\\n     {\\n        int ans = INT_MAX;\\n     for(int i =1;i<=3;i++){\\n         if(currlane!=i && obstacles[currpos]!=i)\\n         ans = min(ans,1+solvemem(obstacles,i,currpos,dp));\\n         \\n     }\\n      dp[currlane][currpos]=ans;\\n     return dp[currlane][currpos];\\n     }\\n }\\n      \\n      \\n \\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solvemem(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740477,
                "title": "easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- dp[i] memorizes the number of mininum side jumps to the cuurent point\\n- dp[i]==INT_MAX if there is a stone (1,2,3)\\n- update the blocked value if  there is no stone (0)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& v) {\\n        vector<int> dp{1,0,1};\\n        int last=0;\\n        for(auto n:v){\\n            if(n==0) {\\n                if(last==0) continue;\\n                dp[(last+2)%3]=1+min(dp[(last+3)%3],dp[(last+4)%3]);\\n                last=0;continue;\\n            }\\n            vector<int> ndp(3);\\n            int i=(n+2)%3, j=(n+3)%3, k=(n+4)%3;\\n            ndp[i]=INT_MAX;\\n            ndp[j]=min(dp[j],dp[k]==INT_MAX?INT_MAX:dp[k]+1);\\n            ndp[k]=min(dp[k],dp[j]==INT_MAX?INT_MAX:dp[j]+1);           \\n            dp=ndp;\\n            last=n;\\n        }\\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& v) {\\n        vector<int> dp{1,0,1};\\n        int last=0;\\n        for(auto n:v){\\n            if(n==0) {\\n                if(last==0) continue;\\n                dp[(last+2)%3]=1+min(dp[(last+3)%3],dp[(last+4)%3]);\\n                last=0;continue;\\n            }\\n            vector<int> ndp(3);\\n            int i=(n+2)%3, j=(n+3)%3, k=(n+4)%3;\\n            ndp[i]=INT_MAX;\\n            ndp[j]=min(dp[j],dp[k]==INT_MAX?INT_MAX:dp[k]+1);\\n            ndp[k]=min(dp[k],dp[j]==INT_MAX?INT_MAX:dp[j]+1);           \\n            dp=ndp;\\n            last=n;\\n        }\\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734836,
                "title": "all-type-of-complexity-sol-in-c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n    int solveTab(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<vector<int>> dp(4, vector<int>(n+1, 1e9));\\n\\n        dp[0][n] = 0;\\n        dp[1][n] = 0;\\n        dp[2][n] = 0;\\n        dp[3][n] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    dp[lane][index] = dp[lane][index+1];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+dp[i][index+1]);\\n                        }\\n                    }\\n                    dp[lane][index] = ans ;\\n                }\\n            }\\n        }\\n        return min(dp[2][0], min(1+dp[1][0], 1+dp[3][0]) );\\n    }\\n\\n    int solveTabOpt(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<int> curr(4, 1e9);\\n        vector<int> prev(4, 1e9);\\n        prev[0] = 0;\\n        prev[1] = 0;\\n        prev[2] = 0;\\n        prev[3] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    curr[lane] = prev[lane];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+prev[i]);\\n                        }\\n                    }\\n                    curr[lane] = ans ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return min(prev[2], min(1+prev[1], 1+prev[3]) );\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n        return solveTabOpt(obstacles);\\n        return solveTab(obstacles);\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n    int solveTab(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<vector<int>> dp(4, vector<int>(n+1, 1e9));\\n\\n        dp[0][n] = 0;\\n        dp[1][n] = 0;\\n        dp[2][n] = 0;\\n        dp[3][n] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    dp[lane][index] = dp[lane][index+1];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+dp[i][index+1]);\\n                        }\\n                    }\\n                    dp[lane][index] = ans ;\\n                }\\n            }\\n        }\\n        return min(dp[2][0], min(1+dp[1][0], 1+dp[3][0]) );\\n    }\\n\\n    int solveTabOpt(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<int> curr(4, 1e9);\\n        vector<int> prev(4, 1e9);\\n        prev[0] = 0;\\n        prev[1] = 0;\\n        prev[2] = 0;\\n        prev[3] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    curr[lane] = prev[lane];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+prev[i]);\\n                        }\\n                    }\\n                    curr[lane] = ans ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return min(prev[2], min(1+prev[1], 1+prev[3]) );\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n        return solveTabOpt(obstacles);\\n        return solveTab(obstacles);\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731948,
                "title": "sol-in-c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720810,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &obs, int currpos, int currlane, vector<vector<int>> &dp){\\n        if(currpos == obs.size()-1)\\n        return 0;\\n\\n        if(dp[currpos][currlane] != -1)\\n        return dp[currpos][currlane] ;\\n        \\n        int ans = INT_MAX;\\n        if(obs[currpos+1] != currlane)\\n         return dp[currpos][currlane] = solve(obs, currpos+1, currlane, dp);\\n        \\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(i != currlane && obs[currpos] != i)\\n                ans = min(ans, 1 + solve(obs, currpos, i, dp));\\n            }\\n        }\\n        return dp[currpos][currlane] = ans;\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int currpos = 0;\\n        int currlane = 2;\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        return solve(obstacles, currpos, currlane, dp);\\n        // return solveTab(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &obs, int currpos, int currlane, vector<vector<int>> &dp){\\n        if(currpos == obs.size()-1)\\n        return 0;\\n\\n        if(dp[currpos][currlane] != -1)\\n        return dp[currpos][currlane] ;\\n        \\n        int ans = INT_MAX;\\n        if(obs[currpos+1] != currlane)\\n         return dp[currpos][currlane] = solve(obs, currpos+1, currlane, dp);\\n        \\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(i != currlane && obs[currpos] != i)\\n                ans = min(ans, 1 + solve(obs, currpos, i, dp));\\n            }\\n        }\\n        return dp[currpos][currlane] = ans;\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int currpos = 0;\\n        int currlane = 2;\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        return solve(obstacles, currpos, currlane, dp);\\n        // return solveTab(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718080,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,2,0,dp);\\n        \\n    }\\n\\n\\n    int solve(vector<int>& obstacles, int currlane,int currpos,vector<vector<int>>& dp)\\n    {\\n        //bc\\n        int n = obstacles.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n    if(dp[currlane][currpos]!=-1)\\n    return dp[currlane][currpos];\\n\\n\\n    if(obstacles[currpos+1]!=currlane)\\n    return solve(obstacles,currlane,currpos+1,dp);\\n\\n    else\\n    {\\n        int ans =INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currlane !=i && obstacles[currpos]!=i)\\n            ans= min(ans,1+solve(obstacles,i,currpos,dp));\\n        }\\n        dp[currlane][currpos]=ans;\\n        return dp[currlane][currpos];\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,2,0,dp);\\n        \\n    }\\n\\n\\n    int solve(vector<int>& obstacles, int currlane,int currpos,vector<vector<int>>& dp)\\n    {\\n        //bc\\n        int n = obstacles.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n    if(dp[currlane][currpos]!=-1)\\n    return dp[currlane][currpos];\\n\\n\\n    if(obstacles[currpos+1]!=currlane)\\n    return solve(obstacles,currlane,currpos+1,dp);\\n\\n    else\\n    {\\n        int ans =INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currlane !=i && obstacles[currpos]!=i)\\n            ans= min(ans,1+solve(obstacles,i,currpos,dp));\\n        }\\n        dp[currlane][currpos]=ans;\\n        return dp[currlane][currpos];\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717733,
                "title": "c-o-n-time-complexity-o-1-space-complexity-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic programming can be used to solve the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have provided three solutions of o(n) complexity in which the approach is that we are calculating minimum number of jumps required from 3 lanes by jumping one by one and then storing the minimum value.\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //Recursion + memoization \\n    int solve(vector<int>& obstacles, int currLane, int currPos,int n,vector<vector<int>>&dp)\\n    {\\n        if(currPos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n        if(obstacles[currPos+1] !=currLane)\\n        {\\n            return solve(obstacles,currLane,currPos+1,n,dp);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currLane!=i && obstacles[currPos]!=i)\\n            {\\n                int mini=solve(obstacles,i,currPos,n,dp);\\n                ans=min(1+mini,ans);\\n            }\\n        }\\n        dp[currLane][currPos]=ans;\\n\\n        return dp[currLane][currPos];\\n    }\\n\\n    //Tabluation solution\\n    int solveTab(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>>dp(4, vector<int>(n+1,1e9));\\n\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    dp[currLane][currPos]=dp[currLane][currPos+1];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+dp[i][currPos+1]);\\n                    }\\n                }\\n                dp[currLane][currPos]=ans;\\n                }        \\n            }\\n        }\\n    return min(dp[2][0],min(1+dp[1][0], 1+dp[3][0]));\\n    }\\n\\n    //0(1) space complexity solution\\n    int spaceOP(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<int>curr(4,0);\\n        vector<int>next(4,0);\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    curr[currLane]=next[currLane];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+next[i]);\\n                    }\\n                }\\n                curr[currLane]=ans;\\n                }        \\n            }\\n            next=curr;\\n        }\\n    return min(curr[2],min(1+curr[1], 1+curr[3]));\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles)\\n    {\\n        // int n=obstacles.size()-1;\\n        //  vector<vector<int>>dp(4, vector<int>(n+1,-1));\\n        // int ans=solve(obstacles,2,0,n,dp);\\n        // return ans;\\n\\n        return spaceOP(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Recursion + memoization \\n    int solve(vector<int>& obstacles, int currLane, int currPos,int n,vector<vector<int>>&dp)\\n    {\\n        if(currPos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n        if(obstacles[currPos+1] !=currLane)\\n        {\\n            return solve(obstacles,currLane,currPos+1,n,dp);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currLane!=i && obstacles[currPos]!=i)\\n            {\\n                int mini=solve(obstacles,i,currPos,n,dp);\\n                ans=min(1+mini,ans);\\n            }\\n        }\\n        dp[currLane][currPos]=ans;\\n\\n        return dp[currLane][currPos];\\n    }\\n\\n    //Tabluation solution\\n    int solveTab(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>>dp(4, vector<int>(n+1,1e9));\\n\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    dp[currLane][currPos]=dp[currLane][currPos+1];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+dp[i][currPos+1]);\\n                    }\\n                }\\n                dp[currLane][currPos]=ans;\\n                }        \\n            }\\n        }\\n    return min(dp[2][0],min(1+dp[1][0], 1+dp[3][0]));\\n    }\\n\\n    //0(1) space complexity solution\\n    int spaceOP(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<int>curr(4,0);\\n        vector<int>next(4,0);\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    curr[currLane]=next[currLane];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+next[i]);\\n                    }\\n                }\\n                curr[currLane]=ans;\\n                }        \\n            }\\n            next=curr;\\n        }\\n    return min(curr[2],min(1+curr[1], 1+curr[3]));\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles)\\n    {\\n        // int n=obstacles.size()-1;\\n        //  vector<vector<int>>dp(4, vector<int>(n+1,-1));\\n        // int ans=solve(obstacles,2,0,n,dp);\\n        // return ans;\\n\\n        return spaceOP(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706844,
                "title": "recursion-and-memorization-using-dp-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[n]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[n*4]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minSideJumpsHelper(int i,vector<int>& obstacles,int lane){\\n        if(i>=obstacles.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][lane]!=-1){\\n            return dp[i][lane];\\n        }\\n        int stoneLane=obstacles[i+1];\\n        int currStone=obstacles[i];\\n        int ansSidelane1=INT_MAX-1,ansSidelane2=INT_MAX-1,ansSamelane=INT_MAX-1;\\n        if(stoneLane==lane){\\n            if(lane==1){\\n                // jump to lane 2 and 3\\n                if(lane+1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n                if(lane+2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+2);\\n                }\\n            }\\n            else if(lane==2){\\n                // jump to lane 1 and 3\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane+1!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n            }\\n            else{\\n                // jump tolane 1 and 2\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane-2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane-2);\\n                }\\n            }\\n        }\\n        else{\\n            ansSamelane=minSideJumpsHelper(i+1,obstacles,lane);\\n        }\\n        int ansJumplane=INT_MAX-1;\\n        if(ansSidelane1==INT_MAX-1 && ansSidelane2==INT_MAX-1){\\n            ansJumplane=INT_MAX-1;\\n        }\\n        else{\\n            ansJumplane=1+min(ansSidelane1,ansSidelane2);\\n        }\\n        return dp[i][lane]=min(ansSamelane,ansJumplane);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        dp=vector<vector<int>> (obstacles.size(), vector<int> (4,-1));\\n        int ans=minSideJumpsHelper(0,obstacles,2);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minSideJumpsHelper(int i,vector<int>& obstacles,int lane){\\n        if(i>=obstacles.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][lane]!=-1){\\n            return dp[i][lane];\\n        }\\n        int stoneLane=obstacles[i+1];\\n        int currStone=obstacles[i];\\n        int ansSidelane1=INT_MAX-1,ansSidelane2=INT_MAX-1,ansSamelane=INT_MAX-1;\\n        if(stoneLane==lane){\\n            if(lane==1){\\n                // jump to lane 2 and 3\\n                if(lane+1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n                if(lane+2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+2);\\n                }\\n            }\\n            else if(lane==2){\\n                // jump to lane 1 and 3\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane+1!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n            }\\n            else{\\n                // jump tolane 1 and 2\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane-2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane-2);\\n                }\\n            }\\n        }\\n        else{\\n            ansSamelane=minSideJumpsHelper(i+1,obstacles,lane);\\n        }\\n        int ansJumplane=INT_MAX-1;\\n        if(ansSidelane1==INT_MAX-1 && ansSidelane2==INT_MAX-1){\\n            ansJumplane=INT_MAX-1;\\n        }\\n        else{\\n            ansJumplane=1+min(ansSidelane1,ansSidelane2);\\n        }\\n        return dp[i][lane]=min(ansSamelane,ansJumplane);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        dp=vector<vector<int>> (obstacles.size(), vector<int> (4,-1));\\n        int ans=minSideJumpsHelper(0,obstacles,2);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705404,
                "title": "easiest-c-memoization-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRead my code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead my code \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    Thoughts\\n    1)We need to find the min no of sideways jumps needed for point just before n point\\n    2)In base case if you are at the destination already then return 0 as no side jumps needed\\n    3)How to perform a small calculation?\\n    ->we need to perform some calculation over obstacles\\n    ->We need to keep track of current lane\\n    ->side jumps are possible only when the lane we are switching to are different from same lane and the lane at that point having stone\\n    ->We have some ways to jump over which we can call recurance and min the answer\\n    ->there can be no case in which we can not take any lane\\n    ->after every side jump perform a +1\\n    */\\n    int solve(vector<int>& obstacles,int i,int walkinglane,vector<vector<int>>& strg){\\n        //If we are at i==n then please tell that we need now 0 side jumps!\\n        if(i==obstacles.size()-1) return 0; \\n        if(strg[i][walkinglane]!=-1) return strg[i][walkinglane];\\n        //If we remain in same lane we need 0 side jumps additionally\\n        int remainInSameLane=(obstacles[i]!=walkinglane)?solve(obstacles,i+1,walkinglane,strg) : INT_MAX;\\n        //We can go to another lane if that lane is not having stones or is our current lane\\n        int goToAnotherLane=INT_MAX;\\n        for(int lane=1;lane<=3;lane++){\\n            if(lane!=obstacles[i-1] && lane!=walkinglane && lane!=obstacles[i]){\\n                goToAnotherLane=min(goToAnotherLane,1+solve(obstacles,i+1,lane,strg));\\n            }\\n        }\\n        int sideJumps=min(remainInSameLane,goToAnotherLane);\\n        return strg[i][walkinglane] = sideJumps;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> strg(obstacles.size()+1,vector<int>(4,-1));\\n        //Keep track of point and the lane\\n        return solve(obstacles,1,2,strg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Thoughts\\n    1)We need to find the min no of sideways jumps needed for point just before n point\\n    2)In base case if you are at the destination already then return 0 as no side jumps needed\\n    3)How to perform a small calculation?\\n    ->we need to perform some calculation over obstacles\\n    ->We need to keep track of current lane\\n    ->side jumps are possible only when the lane we are switching to are different from same lane and the lane at that point having stone\\n    ->We have some ways to jump over which we can call recurance and min the answer\\n    ->there can be no case in which we can not take any lane\\n    ->after every side jump perform a +1\\n    */\\n    int solve(vector<int>& obstacles,int i,int walkinglane,vector<vector<int>>& strg){\\n        //If we are at i==n then please tell that we need now 0 side jumps!\\n        if(i==obstacles.size()-1) return 0; \\n        if(strg[i][walkinglane]!=-1) return strg[i][walkinglane];\\n        //If we remain in same lane we need 0 side jumps additionally\\n        int remainInSameLane=(obstacles[i]!=walkinglane)?solve(obstacles,i+1,walkinglane,strg) : INT_MAX;\\n        //We can go to another lane if that lane is not having stones or is our current lane\\n        int goToAnotherLane=INT_MAX;\\n        for(int lane=1;lane<=3;lane++){\\n            if(lane!=obstacles[i-1] && lane!=walkinglane && lane!=obstacles[i]){\\n                goToAnotherLane=min(goToAnotherLane,1+solve(obstacles,i+1,lane,strg));\\n            }\\n        }\\n        int sideJumps=min(remainInSameLane,goToAnotherLane);\\n        return strg[i][walkinglane] = sideJumps;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> strg(obstacles.size()+1,vector<int>(4,-1));\\n        //Keep track of point and the lane\\n        return solve(obstacles,1,2,strg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686603,
                "title": "simple-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(vector<int>& obstacles,int i,int j,int n,vector<vector<int>>& dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        if(obstacles[i+1]==0 || obstacles[i+1]!=j){\\n            ans=0+solve(obstacles,i+1,j,n,dp);\\n        }\\n        else if(obstacles[i+1]==j){\\n            if(j==2){\\n              if(obstacles[i]==1) ans+=1+solve(obstacles,i,j+1,n,dp);\\n              else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j-1,n,dp);\\n              else ans+=min(1+solve(obstacles,i,j+1,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n            else if(j==1){\\n                if(obstacles[i]==2) ans+=1+solve(obstacles,i,j+2,n,dp);\\n                else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j+1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j+2,n,dp),1+solve(obstacles,i,j+1,n,dp));\\n            }\\n            else if(j==3){\\n                 if(obstacles[i]==2) ans+=1+solve(obstacles,i,j-2,n,dp);\\n                else if(obstacles[i]==1) ans+=1+solve(obstacles,i,j-1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j-2,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int> (4,-1));\\n        int ans=solve(obstacles,0,2,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& obstacles,int i,int j,int n,vector<vector<int>>& dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        if(obstacles[i+1]==0 || obstacles[i+1]!=j){\\n            ans=0+solve(obstacles,i+1,j,n,dp);\\n        }\\n        else if(obstacles[i+1]==j){\\n            if(j==2){\\n              if(obstacles[i]==1) ans+=1+solve(obstacles,i,j+1,n,dp);\\n              else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j-1,n,dp);\\n              else ans+=min(1+solve(obstacles,i,j+1,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n            else if(j==1){\\n                if(obstacles[i]==2) ans+=1+solve(obstacles,i,j+2,n,dp);\\n                else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j+1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j+2,n,dp),1+solve(obstacles,i,j+1,n,dp));\\n            }\\n            else if(j==3){\\n                 if(obstacles[i]==2) ans+=1+solve(obstacles,i,j-2,n,dp);\\n                else if(obstacles[i]==1) ans+=1+solve(obstacles,i,j-1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j-2,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int> (4,-1));\\n        int ans=solve(obstacles,0,2,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679881,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int [][] path=new int[obstacles.length][4];\\n        for(int i=0;i<obstacles.length;i++){\\n            for(int j=0;j<4;j++){\\n                if(obstacles[i]!=0)\\n                {\\n                    path[i][obstacles[i]]=1;\\n                }\\n            }\\n        }\\n        int [][]dp=new int[obstacles.length][4];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<4;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(path,0,obstacles.length-1,2,dp);\\n    }\\n\\n    int solve(int [][]path,int start,int end,int lane,int [][]dp){\\n        if(start==end){\\n            return 0;\\n        }\\n        if(path[start+1][lane]==0){\\n            return solve(path,start+1,end,lane,dp);\\n        }\\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        else{\\n            if(lane==1){\\n                if(path[start][lane+1]==0 && path[start][lane+2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane+1,dp),1+solve(path,start,end,lane+2,dp));}\\n                else if(path[start][lane+1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+2,dp);\\n                }}\\n            else if(lane==2){\\n                if(path[start][lane-1]==0 && path[start][lane+1]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane+1,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }}\\n            else{\\n                if(path[start][lane-1]==0 && path[start][lane-2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane-2,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane-2,dp);\\n                }\\n    }}\\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int [][] path=new int[obstacles.length][4];\\n        for(int i=0;i<obstacles.length;i++){\\n            for(int j=0;j<4;j++){\\n                if(obstacles[i]!=0)\\n                {\\n                    path[i][obstacles[i]]=1;\\n                }\\n            }\\n        }\\n        int [][]dp=new int[obstacles.length][4];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<4;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(path,0,obstacles.length-1,2,dp);\\n    }\\n\\n    int solve(int [][]path,int start,int end,int lane,int [][]dp){\\n        if(start==end){\\n            return 0;\\n        }\\n        if(path[start+1][lane]==0){\\n            return solve(path,start+1,end,lane,dp);\\n        }\\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        else{\\n            if(lane==1){\\n                if(path[start][lane+1]==0 && path[start][lane+2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane+1,dp),1+solve(path,start,end,lane+2,dp));}\\n                else if(path[start][lane+1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+2,dp);\\n                }}\\n            else if(lane==2){\\n                if(path[start][lane-1]==0 && path[start][lane+1]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane+1,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }}\\n            else{\\n                if(path[start][lane-1]==0 && path[start][lane-2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane-2,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane-2,dp);\\n                }\\n    }}\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640186,
                "title": "dp-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,int l,int n,vector<vector<int>>&dp){\\n        if(i>=n-1)return 0;\\n        if(v[i]==l)return 1e8;\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        // when next point is clear\\n        if(v[i+1]!=l)\\n            return dp[i][l] = solve(v,i+1,l,n,dp);\\n\\n        // when next point has an obstacle\\n        if(l==2)\\n            return dp[i][l] = min(1+solve(v,i,3,n,dp),1+solve(v,i,1,n,dp));\\n        else if(l==1) return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,3,n,dp));\\n\\n        else return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,1,n,dp));\\n\\n    }\\n    int minSideJumps(vector<int>& v) {\\n        int n=v.size();\\n        int i=0,l=2;\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return solve(v,i,l,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,int l,int n,vector<vector<int>>&dp){\\n        if(i>=n-1)return 0;\\n        if(v[i]==l)return 1e8;\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        // when next point is clear\\n        if(v[i+1]!=l)\\n            return dp[i][l] = solve(v,i+1,l,n,dp);\\n\\n        // when next point has an obstacle\\n        if(l==2)\\n            return dp[i][l] = min(1+solve(v,i,3,n,dp),1+solve(v,i,1,n,dp));\\n        else if(l==1) return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,3,n,dp));\\n\\n        else return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,1,n,dp));\\n\\n    }\\n    int minSideJumps(vector<int>& v) {\\n        int n=v.size();\\n        int i=0,l=2;\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return solve(v,i,l,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637617,
                "title": "c-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,int last,int n,vector<int> &obs,vector<vector<int>> &dp ){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i][last]!=-1){\\n            return dp[i][last];\\n        }\\n        \\n        int ans=INT_MAX;\\n        if(obs[i]==0){\\n            ans=min(ans, find(i+1,last,n,obs,dp));\\n        }\\n        else if(obs[i]==last){\\n            for(int it=1;it<=3;it++){\\n                if(last!=it and obs[i-1]!=it){\\n                    ans=min(ans,1+find(i+1,it,n,obs,dp));\\n                }\\n            }\\n        }\\n        else{\\n            ans=min(ans,find(i+1,last,n,obs,dp));\\n        }\\n        return dp[i][last]=ans;\\n       \\n        \\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return find(1,2,n,obs,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,int last,int n,vector<int> &obs,vector<vector<int>> &dp ){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i][last]!=-1){\\n            return dp[i][last];\\n        }\\n        \\n        int ans=INT_MAX;\\n        if(obs[i]==0){\\n            ans=min(ans, find(i+1,last,n,obs,dp));\\n        }\\n        else if(obs[i]==last){\\n            for(int it=1;it<=3;it++){\\n                if(last!=it and obs[i-1]!=it){\\n                    ans=min(ans,1+find(i+1,it,n,obs,dp));\\n                }\\n            }\\n        }\\n        else{\\n            ans=min(ans,find(i+1,last,n,obs,dp));\\n        }\\n        return dp[i][last]=ans;\\n       \\n        \\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return find(1,2,n,obs,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629170,
                "title": "simple-solution-by-uisng-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int solve(vector<int>& obs, int pos, int currlane, vector<vector<int>> &dp){\\n        int n=obs.size()-1;\\n        //base case\\n        if(pos==n){\\n            return 0;\\n        }\\n        if(dp[pos][currlane]!=-1){\\n            return dp[pos][currlane];\\n        }\\n        if(obs[pos+1]!=currlane){\\n            return solve(obs, pos+1, currlane, dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            //sideways jump\\n            for(int i=1;i<=3; i++){\\n                if(currlane!=i && obs[pos]!=i){\\n                    ans=min(ans,1+solve(obs,pos,i, dp));\\n                }\\n                dp[pos][currlane]=ans;\\n            }\\n            return dp[pos][currlane];\\n        }\\n\\n\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(obstacles.size(), vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int solve(vector<int>& obs, int pos, int currlane, vector<vector<int>> &dp){\\n        int n=obs.size()-1;\\n        //base case\\n        if(pos==n){\\n            return 0;\\n        }\\n        if(dp[pos][currlane]!=-1){\\n            return dp[pos][currlane];\\n        }\\n        if(obs[pos+1]!=currlane){\\n            return solve(obs, pos+1, currlane, dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            //sideways jump\\n            for(int i=1;i<=3; i++){\\n                if(currlane!=i && obs[pos]!=i){\\n                    ans=min(ans,1+solve(obs,pos,i, dp));\\n                }\\n                dp[pos][currlane]=ans;\\n            }\\n            return dp[pos][currlane];\\n        }\\n\\n\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(obstacles.size(), vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575124,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1566660,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1977745,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1992530,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1964380,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1948538,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1945904,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1898467,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            }
        ]
    },
    {
        "title": "Finding MK Average",
        "question_content": "<p>You are given two integers, <code>m</code> and <code>k</code>, and a stream of integers. You are tasked to implement a data structure that calculates the <strong>MKAverage</strong> for the stream.</p>\n\n<p>The <strong>MKAverage</strong> can be calculated using these steps:</p>\n\n<ol>\n\t<li>If the number of the elements in the stream is less than <code>m</code> you should consider the <strong>MKAverage</strong> to be <code>-1</code>. Otherwise, copy the last <code>m</code> elements of the stream to a separate container.</li>\n\t<li>Remove the smallest <code>k</code> elements and the largest <code>k</code> elements from the container.</li>\n\t<li>Calculate the average value for the rest of the elements <strong>rounded down to the nearest integer</strong>.</li>\n</ol>\n\n<p>Implement the <code>MKAverage</code> class:</p>\n\n<ul>\n\t<li><code>MKAverage(int m, int k)</code> Initializes the <strong>MKAverage</strong> object with an empty stream and the two integers <code>m</code> and <code>k</code>.</li>\n\t<li><code>void addElement(int num)</code> Inserts a new element <code>num</code> into the stream.</li>\n\t<li><code>int calculateMKAverage()</code> Calculates and returns the <strong>MKAverage</strong> for the current stream <strong>rounded down to the nearest integer</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;addElement&quot;, &quot;calculateMKAverage&quot;]\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\n<strong>Output</strong>\n[null, null, null, -1, null, 3, null, null, null, 5]\n\n<strong>Explanation</strong>\n<code>MKAverage obj = new MKAverage(3, 1); \nobj.addElement(3);        // current elements are [3]\nobj.addElement(1);        // current elements are [3,1]\nobj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.\nobj.addElement(10);       // current elements are [3,1,10]\nobj.calculateMKAverage(); // The last 3 elements are [3,1,10].\n                          // After removing smallest and largest 1 element the container will be [3].\n                          // The average of [3] equals 3/1 = 3, return 3\nobj.addElement(5);        // current elements are [3,1,10,5]\nobj.addElement(5);        // current elements are [3,1,10,5,5]\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\n                          // After removing smallest and largest 1 element the container will be [5].\n                          // The average of [5] equals 5/1 = 5, return 5\n</code></pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k*2 &lt; m</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>addElement</code> and <code>calculateMKAverage</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152724,
                "title": "c-balance-3-multisets",
                "content": "A bit lengthy; the idea is to keep track of the `left`, `mid`, and `right` sets. When removing or adding numbers, we reballance these sets so that the size of `left` and `right` stays `k`.\\n\\nAlso, we keep track of `sum` for elements in `mid`. That way, the calculate function is O(1).\\n \\nFinally, to track the current `m` numbers, we use a circular array of size `m`.\\n\\n```cpp\\nint m = 0, k = 0, sz = 0, pos = 0;\\nlong sum = 0;\\nvector<int> v;\\nmultiset<int> left, mid, right;\\nvoid remove(int n) {\\n    if (n <= *rbegin(left))\\n        left.erase(left.find(n));\\n    else if (n <= *rbegin(mid)) {\\n       auto it = mid.find(n); \\n       sum -= *it;\\n       mid.erase(it);\\n    }\\n    else\\n        right.erase(right.find(n));\\n    if (left.size() < k) {\\n        left.insert(*begin(mid));\\n        sum -= *begin(mid);\\n        mid.erase(begin(mid));\\n    }\\n    if (mid.size() < sz) {\\n        mid.insert(*begin(right));\\n        sum += *begin(right);\\n        right.erase(begin(right));\\n    }\\n}\\nvoid add(int n) {\\n    left.insert(n);\\n    if (left.size() > k) {\\n        auto it = prev(end(left));\\n        mid.insert(*it);\\n        sum += *it;\\n        left.erase(it);\\n    }\\n    if (mid.size() > sz) {\\n        auto it = prev(end(mid));\\n        sum -= *it;\\n        right.insert(*it);\\n        mid.erase(it);\\n    }\\n}\\nMKAverage(int m, int k) : m(m), k(k), sz(m - 2 * k) {\\n    v = vector<int>(m);\\n}\\nvoid addElement(int num) {\\n    if (pos >= m)\\n        remove(v[pos % m]);\\n    add(num);\\n    v[pos++ % m] = num;\\n}\\nint calculateMKAverage() {\\n    if (pos < m)\\n        return -1;\\n    return sum / sz;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint m = 0, k = 0, sz = 0, pos = 0;\\nlong sum = 0;\\nvector<int> v;\\nmultiset<int> left, mid, right;\\nvoid remove(int n) {\\n    if (n <= *rbegin(left))\\n        left.erase(left.find(n));\\n    else if (n <= *rbegin(mid)) {\\n       auto it = mid.find(n); \\n       sum -= *it;\\n       mid.erase(it);\\n    }\\n    else\\n        right.erase(right.find(n));\\n    if (left.size() < k) {\\n        left.insert(*begin(mid));\\n        sum -= *begin(mid);\\n        mid.erase(begin(mid));\\n    }\\n    if (mid.size() < sz) {\\n        mid.insert(*begin(right));\\n        sum += *begin(right);\\n        right.erase(begin(right));\\n    }\\n}\\nvoid add(int n) {\\n    left.insert(n);\\n    if (left.size() > k) {\\n        auto it = prev(end(left));\\n        mid.insert(*it);\\n        sum += *it;\\n        left.erase(it);\\n    }\\n    if (mid.size() > sz) {\\n        auto it = prev(end(mid));\\n        sum -= *it;\\n        right.insert(*it);\\n        mid.erase(it);\\n    }\\n}\\nMKAverage(int m, int k) : m(m), k(k), sz(m - 2 * k) {\\n    v = vector<int>(m);\\n}\\nvoid addElement(int num) {\\n    if (pos >= m)\\n        remove(v[pos % m]);\\n    add(num);\\n    v[pos++ % m] = num;\\n}\\nint calculateMKAverage() {\\n    if (pos < m)\\n        return -1;\\n    return sum / sz;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152438,
                "title": "python3-fenwick-tree",
                "content": "\\n```\\nclass Fenwick: \\n\\n    def __init__(self, n: int):\\n        self.nums = [0]*(n+1)\\n\\n    def sum(self, k: int) -> int: \\n        k += 1\\n        ans = 0\\n        while k:\\n            ans += self.nums[k]\\n            k &= k-1 # unset last set bit \\n        return ans\\n\\n    def add(self, k: int, x: int) -> None: \\n        k += 1\\n        while k < len(self.nums): \\n            self.nums[k] += x\\n            k += k & -k \\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k \\n        self.data = deque()\\n        self.value = Fenwick(10**5+1)\\n        self.index = Fenwick(10**5+1)\\n\\n    def addElement(self, num: int) -> None:\\n        self.data.append(num)\\n        self.value.add(num, num)\\n        self.index.add(num, 1)\\n        if len(self.data) > self.m: \\n            num = self.data.popleft()\\n            self.value.add(num, -num)\\n            self.index.add(num, -1)\\n\\n    def _getindex(self, k): \\n        lo, hi = 0, 10**5 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if self.index.sum(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.data) < self.m: return -1 \\n        lo = self._getindex(self.k)\\n        hi = self._getindex(self.m-self.k)\\n        ans = self.value.sum(hi) - self.value.sum(lo)\\n        ans += (self.index.sum(lo) - self.k) * lo\\n        ans -= (self.index.sum(hi) - (self.m-self.k)) * hi\\n        return ans // (self.m - 2*self.k)\\n        \\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Fenwick: \\n\\n    def __init__(self, n: int):\\n        self.nums = [0]*(n+1)\\n\\n    def sum(self, k: int) -> int: \\n        k += 1\\n        ans = 0\\n        while k:\\n            ans += self.nums[k]\\n            k &= k-1 # unset last set bit \\n        return ans\\n\\n    def add(self, k: int, x: int) -> None: \\n        k += 1\\n        while k < len(self.nums): \\n            self.nums[k] += x\\n            k += k & -k \\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k \\n        self.data = deque()\\n        self.value = Fenwick(10**5+1)\\n        self.index = Fenwick(10**5+1)\\n\\n    def addElement(self, num: int) -> None:\\n        self.data.append(num)\\n        self.value.add(num, num)\\n        self.index.add(num, 1)\\n        if len(self.data) > self.m: \\n            num = self.data.popleft()\\n            self.value.add(num, -num)\\n            self.index.add(num, -1)\\n\\n    def _getindex(self, k): \\n        lo, hi = 0, 10**5 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if self.index.sum(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.data) < self.m: return -1 \\n        lo = self._getindex(self.k)\\n        hi = self._getindex(self.m-self.k)\\n        ans = self.value.sum(hi) - self.value.sum(lo)\\n        ans += (self.index.sum(lo) - self.k) * lo\\n        ans -= (self.index.sum(hi) - (self.m-self.k)) * hi\\n        return ans // (self.m - 2*self.k)\\n        \\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152742,
                "title": "clean-java-with-3-treemaps",
                "content": "Sadly, there isn\\'t a built-in multiset in Java, therefore we have to play around with treemap. \\n```\\nclass MKAverage {\\n    TreeMap<Integer, Integer> top = new TreeMap<>(), middle = new TreeMap<>(), bottom = new TreeMap<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    long middleSum;\\n    int m, k;\\n    int countTop, countBottom;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (q.size() == m) {\\n            int pop = q.poll();\\n            if (top.containsKey(pop)) { // delete item in top, if present\\n                remove(top, pop); \\n                countTop--;\\n            } else if (middle.containsKey(pop)) { // delete item in bottom, if present\\n                remove(middle, pop);\\n                middleSum -= pop;\\n            } else { // delete item in bottom, if present\\n                remove(bottom, pop); \\n                countBottom--;\\n            }\\n        } \\n        // insert to middle first\\n        add(middle, num);\\n        q.offer(num);\\n        middleSum += num;\\n        // move item from middle to top, to fill k slots\\n        while (countTop < k && !middle.isEmpty()) {\\n            countTop++;\\n            middleSum -= middle.lastKey();\\n            add(top, remove(middle, middle.lastKey()));\\n        }\\n        // rebalance middle and top\\n        while (!middle.isEmpty() && !top.isEmpty() && top.firstKey() < middle.lastKey()) {\\n            middleSum += top.firstKey();\\n            add(middle, remove(top, top.firstKey()));\\n            middleSum -= middle.lastKey();\\n            add(top, remove(middle, middle.lastKey()));\\n        }\\n        // move item from middle to bottom, to fill k slots\\n        while (countBottom < k && !middle.isEmpty()) {\\n            countBottom++;\\n            middleSum -= middle.firstKey();\\n            add(bottom, remove(middle, middle.firstKey()));\\n        }\\n        // rebalance middle and bottom\\n        while (!middle.isEmpty() && !bottom.isEmpty() && bottom.lastKey() > middle.firstKey()) {\\n            middleSum += bottom.lastKey();\\n            add(middle, remove(bottom, bottom.lastKey()));\\n            middleSum -= middle.firstKey();\\n            add(bottom, remove(middle, middle.firstKey()));\\n        }\\n    }\\n    \\n    \\n    private int remove(TreeMap<Integer, Integer> tm, int num) {\\n        tm.put(num, tm.get(num) - 1);\\n        if (tm.get(num) == 0) tm.remove(num); \\n        return num;\\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> tm, int num) {\\n        tm.put(num, tm.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return q.size() == m ? (int)(middleSum / (m - 2 * k)) : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    TreeMap<Integer, Integer> top = new TreeMap<>(), middle = new TreeMap<>(), bottom = new TreeMap<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    long middleSum;\\n    int m, k;\\n    int countTop, countBottom;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (q.size() == m) {\\n            int pop = q.poll();\\n            if (top.containsKey(pop)) { // delete item in top, if present\\n                remove(top, pop); \\n                countTop--;\\n            } else if (middle.containsKey(pop)) { // delete item in bottom, if present\\n                remove(middle, pop);\\n                middleSum -= pop;\\n            } else { // delete item in bottom, if present\\n                remove(bottom, pop); \\n                countBottom--;\\n            }\\n        } \\n        // insert to middle first\\n        add(middle, num);\\n        q.offer(num);\\n        middleSum += num;\\n        // move item from middle to top, to fill k slots\\n        while (countTop < k && !middle.isEmpty()) {\\n            countTop++;\\n            middleSum -= middle.lastKey();\\n            add(top, remove(middle, middle.lastKey()));\\n        }\\n        // rebalance middle and top\\n        while (!middle.isEmpty() && !top.isEmpty() && top.firstKey() < middle.lastKey()) {\\n            middleSum += top.firstKey();\\n            add(middle, remove(top, top.firstKey()));\\n            middleSum -= middle.lastKey();\\n            add(top, remove(middle, middle.lastKey()));\\n        }\\n        // move item from middle to bottom, to fill k slots\\n        while (countBottom < k && !middle.isEmpty()) {\\n            countBottom++;\\n            middleSum -= middle.firstKey();\\n            add(bottom, remove(middle, middle.firstKey()));\\n        }\\n        // rebalance middle and bottom\\n        while (!middle.isEmpty() && !bottom.isEmpty() && bottom.lastKey() > middle.firstKey()) {\\n            middleSum += bottom.lastKey();\\n            add(middle, remove(bottom, bottom.lastKey()));\\n            middleSum -= middle.firstKey();\\n            add(bottom, remove(middle, middle.firstKey()));\\n        }\\n    }\\n    \\n    \\n    private int remove(TreeMap<Integer, Integer> tm, int num) {\\n        tm.put(num, tm.get(num) - 1);\\n        if (tm.get(num) == 0) tm.remove(num); \\n        return num;\\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> tm, int num) {\\n        tm.put(num, tm.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return q.size() == m ? (int)(middleSum / (m - 2 * k)) : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152915,
                "title": "java-o-logn-o-1-time-beat-100-sortedlist-implementation",
                "content": "Java doesn\\'t has ```SortedList``` like python. So manually implemented one.\\nThe idea is to maintain 3 SortedList. Every time when add new element, remove old element, keep 3 ```SortedList``` size as required.\\nTotal size of ```l1```, ```l2```, ```l3``` is ```m```, ```l1```, ```l3``` has length of ```k```\\n```\\npublic class MKAverage {\\n\\n    int m, k;\\n    Deque<Integer> queue = new ArrayDeque();\\n    SortedList l1 = new SortedList();\\n    SortedList l2 = new SortedList();\\n    SortedList l3 = new SortedList();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n\\n    public void addElement(int num) {\\n        queue.addLast(num);\\n        // add in the proper place\\n        if (l1.isEmpty() || num <= l1.getLast()) {\\n            l1.add(num);\\n        } else if (l2.isEmpty() || num <= l2.getLast()) {\\n            l2.add(num);\\n        } else {\\n            l3.add(num);\\n        }\\n        if (queue.size() > m) {\\n            int removedElement = queue.removeFirst();\\n            // remove in the proper place\\n            if (l1.contains(removedElement)) {\\n                l1.remove(removedElement);\\n            } else if (l2.contains(removedElement)) {\\n                l2.remove(removedElement);\\n            } else {\\n                l3.remove(removedElement);\\n            }\\n        }\\n\\t\\t// adjust size of l1, l2, l3\\n        if (l1.size > k) {\\n            l2.add(l1.removeLast());\\n        } else if (l1.size < k && !l2.isEmpty()) {\\n            l1.add(l2.removeFirst());\\n        }\\n        if (l2.size > m - k - k) {\\n            l3.add(l2.removeLast());\\n        } else if (l2.size < m - k - k && !l3.isEmpty()) {\\n            l2.add(l3.removeFirst());\\n        }\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (l1.size + l2.size + l3.size < m) {\\n            return -1;\\n        }\\n        return (int)Math.floor((double)(l2.sum) / (l2.size));\\n    }\\n\\n    static class SortedList {\\n        long sum;\\n        int size;\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n\\n        public void add(int n) {\\n            tm.put(n, tm.getOrDefault(n, 0) + 1);\\n            sum += n;\\n            size++;\\n        }\\n\\n        public boolean isEmpty() {\\n            return size == 0;\\n        }\\n\\n        public boolean contains(int n) {\\n            return tm.containsKey(n);\\n        }\\n\\n        public void remove(int n) {\\n            if (!tm.containsKey(n)) {\\n                return;\\n            }\\n            int count = tm.get(n);\\n            sum -= n;\\n            size--;\\n            if (count == 1) {\\n                tm.remove(n);\\n            } else {\\n                tm.put(n, count - 1);\\n            }\\n        }\\n\\n        public int removeLast() {\\n            Map.Entry<Integer, Integer> lastEntry = tm.lastEntry();\\n            if (lastEntry.getValue() == 1) {\\n                tm.remove(lastEntry.getKey());\\n            } else {\\n                tm.put(lastEntry.getKey(), lastEntry.getValue() - 1);\\n            }\\n            sum -= lastEntry.getKey();\\n            size--;\\n            return lastEntry.getKey();\\n        }\\n\\n        public int removeFirst() {\\n            Map.Entry<Integer, Integer> firstEntry = tm.firstEntry();\\n            if (firstEntry.getValue() == 1) {\\n                tm.remove(firstEntry.getKey());\\n            } else {\\n                tm.put(firstEntry.getKey(), firstEntry.getValue() - 1);\\n            }\\n            sum -= firstEntry.getKey();\\n            size--;\\n            return firstEntry.getKey();\\n        }\\n\\n        public int getLast() {\\n            return tm.lastKey();\\n        }\\n\\n        public int getFirst() {\\n            return tm.firstKey();\\n        }\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```SortedList```\n```SortedList```\n```l1```\n```l2```\n```l3```\n```m```\n```l1```\n```l3```\n```k```\n```\\npublic class MKAverage {\\n\\n    int m, k;\\n    Deque<Integer> queue = new ArrayDeque();\\n    SortedList l1 = new SortedList();\\n    SortedList l2 = new SortedList();\\n    SortedList l3 = new SortedList();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n\\n    public void addElement(int num) {\\n        queue.addLast(num);\\n        // add in the proper place\\n        if (l1.isEmpty() || num <= l1.getLast()) {\\n            l1.add(num);\\n        } else if (l2.isEmpty() || num <= l2.getLast()) {\\n            l2.add(num);\\n        } else {\\n            l3.add(num);\\n        }\\n        if (queue.size() > m) {\\n            int removedElement = queue.removeFirst();\\n            // remove in the proper place\\n            if (l1.contains(removedElement)) {\\n                l1.remove(removedElement);\\n            } else if (l2.contains(removedElement)) {\\n                l2.remove(removedElement);\\n            } else {\\n                l3.remove(removedElement);\\n            }\\n        }\\n\\t\\t// adjust size of l1, l2, l3\\n        if (l1.size > k) {\\n            l2.add(l1.removeLast());\\n        } else if (l1.size < k && !l2.isEmpty()) {\\n            l1.add(l2.removeFirst());\\n        }\\n        if (l2.size > m - k - k) {\\n            l3.add(l2.removeLast());\\n        } else if (l2.size < m - k - k && !l3.isEmpty()) {\\n            l2.add(l3.removeFirst());\\n        }\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (l1.size + l2.size + l3.size < m) {\\n            return -1;\\n        }\\n        return (int)Math.floor((double)(l2.sum) / (l2.size));\\n    }\\n\\n    static class SortedList {\\n        long sum;\\n        int size;\\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\\n\\n        public void add(int n) {\\n            tm.put(n, tm.getOrDefault(n, 0) + 1);\\n            sum += n;\\n            size++;\\n        }\\n\\n        public boolean isEmpty() {\\n            return size == 0;\\n        }\\n\\n        public boolean contains(int n) {\\n            return tm.containsKey(n);\\n        }\\n\\n        public void remove(int n) {\\n            if (!tm.containsKey(n)) {\\n                return;\\n            }\\n            int count = tm.get(n);\\n            sum -= n;\\n            size--;\\n            if (count == 1) {\\n                tm.remove(n);\\n            } else {\\n                tm.put(n, count - 1);\\n            }\\n        }\\n\\n        public int removeLast() {\\n            Map.Entry<Integer, Integer> lastEntry = tm.lastEntry();\\n            if (lastEntry.getValue() == 1) {\\n                tm.remove(lastEntry.getKey());\\n            } else {\\n                tm.put(lastEntry.getKey(), lastEntry.getValue() - 1);\\n            }\\n            sum -= lastEntry.getKey();\\n            size--;\\n            return lastEntry.getKey();\\n        }\\n\\n        public int removeFirst() {\\n            Map.Entry<Integer, Integer> firstEntry = tm.firstEntry();\\n            if (firstEntry.getValue() == 1) {\\n                tm.remove(firstEntry.getKey());\\n            } else {\\n                tm.put(firstEntry.getKey(), firstEntry.getValue() - 1);\\n            }\\n            sum -= firstEntry.getKey();\\n            size--;\\n            return firstEntry.getKey();\\n        }\\n\\n        public int getLast() {\\n            return tm.lastKey();\\n        }\\n\\n        public int getFirst() {\\n            return tm.firstKey();\\n        }\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152629,
                "title": "python3-solution-w-sortedlist-o-logm-add-o-1-calculate",
                "content": "python3 doesn\\'t have a built-in [order statistic tree](https://en.wikipedia.org/wiki/Order_statistic_tree) or even a basic BST and that may be why `sortedcontainers` is one of the few third-party libraries allowed.\\n\\nAnyway, with a [SortedList](http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html) this solution is conceptually simple. I use both a deque and a SortedList to keep track of the last m numbers, FIFO. It\\'s trivial to maintain the total sum of them. To maintain the sum of the smallest/largest k numbers, we examine the index at which the new number will be inserted into the SortedList and the index at which the oldest number will be removed from the SortedList. If the new number to be inserted will become one of the smallest/largest k numbers, we add it to self.first_k/self.last_k and subtract out the current kth smallest/largest number. The operation for removing the oldest number is similar but the reverse. The only gotcha is the off-by-1 error.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m, k\\n        self.deque = collections.deque()\\n        self.sl = SortedList()\\n        self.total = self.first_k = self.last_k = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.total += num\\n        self.deque.append(num)\\n        index = self.sl.bisect_left(num)\\n        if index < self.k:\\n            self.first_k += num\\n            if len(self.sl) >= self.k:\\n                self.first_k -= self.sl[self.k - 1]\\n        if index >= len(self.sl) + 1 - self.k:\\n            self.last_k += num\\n            if len(self.sl) >= self.k:\\n                self.last_k -= self.sl[-self.k]\\n        self.sl.add(num)\\n        if len(self.deque) > self.m:\\n            num = self.deque.popleft()\\n            self.total -= num\\n            index = self.sl.index(num)\\n            if index < self.k:\\n                self.first_k -= num\\n                self.first_k += self.sl[self.k]\\n            elif index >= len(self.sl) - self.k:\\n                self.last_k -= num\\n                self.last_k += self.sl[-self.k - 1]\\n            self.sl.remove(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl) < self.m:\\n            return -1\\n        return (self.total - self.first_k - self.last_k) // (self.m - 2 * self.k)\\n```\\n\\nTime complexity: O(logM) add due to operations on the SortedList (essentially an [order statistic tree](https://en.wikipedia.org/wiki/Order_statistic_tree)). O(1) calculate is trivial.\\nSpace complexity: O(M) due to the deque and SortedList.",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m, k\\n        self.deque = collections.deque()\\n        self.sl = SortedList()\\n        self.total = self.first_k = self.last_k = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.total += num\\n        self.deque.append(num)\\n        index = self.sl.bisect_left(num)\\n        if index < self.k:\\n            self.first_k += num\\n            if len(self.sl) >= self.k:\\n                self.first_k -= self.sl[self.k - 1]\\n        if index >= len(self.sl) + 1 - self.k:\\n            self.last_k += num\\n            if len(self.sl) >= self.k:\\n                self.last_k -= self.sl[-self.k]\\n        self.sl.add(num)\\n        if len(self.deque) > self.m:\\n            num = self.deque.popleft()\\n            self.total -= num\\n            index = self.sl.index(num)\\n            if index < self.k:\\n                self.first_k -= num\\n                self.first_k += self.sl[self.k]\\n            elif index >= len(self.sl) - self.k:\\n                self.last_k -= num\\n                self.last_k += self.sl[-self.k - 1]\\n            self.sl.remove(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl) < self.m:\\n            return -1\\n        return (self.total - self.first_k - self.last_k) // (self.m - 2 * self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152418,
                "title": "c-3-multisets",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. 3 Multisets\\n\\n* Use 3 `multiset<int>` to track the top `k`, bottom `k` and middle elements.\\n* Use `queue<int> q` to track the current `m` numbers.\\n* Use `sum` to track the sum of numbers in `mid`.\\n\\nPlease see comments as explanations.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-236/problems/finding-mk-average/\\n// Author: github.com/lzl124631x\\n// Time: \\n//     MKAverage: O(1)\\n//     addElement: O(logM)\\n//     calculateMKAverage: O(1)\\n// Space: O(M)\\nclass MKAverage {\\n    multiset<int> top, bot, mid;\\n    queue<int> q;\\n    long sum = 0, m, k;\\npublic:\\n    MKAverage(int m, int k) : m(m), k(k) {}\\n    \\n    void addElement(int n) {\\n        if (q.size() < m) mid.insert(n); // when there are less than `m` numbers, always insert into `mid`.\\n        q.push(n);\\n        if (q.size() == m) {\\n            // when we reached exactly `m` numbers, we nudge numbers from `mid` to `top` and `bot`, and calculate `sum`.\\n            for (int i = 0; i < k; ++i) {\\n                bot.insert(*mid.begin());\\n                mid.erase(mid.begin());\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                top.insert(*mid.rbegin());\\n                mid.erase(prev(mid.end()));\\n            }\\n            for (int x : mid) sum += x;\\n        } else if (q.size() > m) {\\n            // when we\\'ve seen more than `m` numbers. We first add the new number `n` to where it should belong.\\n            // If we add `n` to `top` or `bot`, we balance them with `mid` to make sure `top` and `bot` have exactly `k` numbers\\n            if (n < *bot.rbegin()) {\\n                bot.insert(n);\\n                int x = *bot.rbegin();\\n                bot.erase(prev(bot.end()));\\n                mid.insert(x);\\n                sum += x; \\n            } else if (n > *top.begin()) {\\n                top.insert(n);\\n                int x = *top.begin();\\n                top.erase(top.begin());\\n                mid.insert(x);\\n                sum += x;\\n            } else {\\n                mid.insert(n);\\n                sum += n;\\n            }\\n            // Then we remove the number `rm` that is no longer one of the latest `m` numbers.\\n            int rm = q.front();\\n            q.pop();\\n            auto it = mid.find(rm);\\n            if (it != mid.end()) { // first try removing from `mid`, then `top` or `bot`.\\n                mid.erase(it);\\n                sum -= rm;\\n            } else {\\n                it = top.find(rm);\\n                if (it != top.end()) {\\n                    top.erase(it);\\n                } else {\\n                    bot.erase(bot.find(rm));\\n                }\\n            }\\n            // Lastly, balance `top` and `bot` if needed\\n            if (bot.size() < k) {\\n                int x = *mid.begin();\\n                bot.insert(x);\\n                mid.erase(mid.begin());\\n                sum -= x;\\n            } else if (top.size() < k) {\\n                int x = *mid.rbegin();\\n                top.insert(x);\\n                mid.erase(prev(mid.end()));\\n                sum -= x;\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        return q.size() == m ? (sum / (m - 2 * k)) : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-236/problems/finding-mk-average/\\n// Author: github.com/lzl124631x\\n// Time: \\n//     MKAverage: O(1)\\n//     addElement: O(logM)\\n//     calculateMKAverage: O(1)\\n// Space: O(M)\\nclass MKAverage {\\n    multiset<int> top, bot, mid;\\n    queue<int> q;\\n    long sum = 0, m, k;\\npublic:\\n    MKAverage(int m, int k) : m(m), k(k) {}\\n    \\n    void addElement(int n) {\\n        if (q.size() < m) mid.insert(n); // when there are less than `m` numbers, always insert into `mid`.\\n        q.push(n);\\n        if (q.size() == m) {\\n            // when we reached exactly `m` numbers, we nudge numbers from `mid` to `top` and `bot`, and calculate `sum`.\\n            for (int i = 0; i < k; ++i) {\\n                bot.insert(*mid.begin());\\n                mid.erase(mid.begin());\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                top.insert(*mid.rbegin());\\n                mid.erase(prev(mid.end()));\\n            }\\n            for (int x : mid) sum += x;\\n        } else if (q.size() > m) {\\n            // when we\\'ve seen more than `m` numbers. We first add the new number `n` to where it should belong.\\n            // If we add `n` to `top` or `bot`, we balance them with `mid` to make sure `top` and `bot` have exactly `k` numbers\\n            if (n < *bot.rbegin()) {\\n                bot.insert(n);\\n                int x = *bot.rbegin();\\n                bot.erase(prev(bot.end()));\\n                mid.insert(x);\\n                sum += x; \\n            } else if (n > *top.begin()) {\\n                top.insert(n);\\n                int x = *top.begin();\\n                top.erase(top.begin());\\n                mid.insert(x);\\n                sum += x;\\n            } else {\\n                mid.insert(n);\\n                sum += n;\\n            }\\n            // Then we remove the number `rm` that is no longer one of the latest `m` numbers.\\n            int rm = q.front();\\n            q.pop();\\n            auto it = mid.find(rm);\\n            if (it != mid.end()) { // first try removing from `mid`, then `top` or `bot`.\\n                mid.erase(it);\\n                sum -= rm;\\n            } else {\\n                it = top.find(rm);\\n                if (it != top.end()) {\\n                    top.erase(it);\\n                } else {\\n                    bot.erase(bot.find(rm));\\n                }\\n            }\\n            // Lastly, balance `top` and `bot` if needed\\n            if (bot.size() < k) {\\n                int x = *mid.begin();\\n                bot.insert(x);\\n                mid.erase(mid.begin());\\n                sum -= x;\\n            } else if (top.size() < k) {\\n                int x = *mid.rbegin();\\n                top.insert(x);\\n                mid.erase(prev(mid.end()));\\n                sum -= x;\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        return q.size() == m ? (sum / (m - 2 * k)) : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154068,
                "title": "python-4-heaps-one-list-o-n-log-n-explained",
                "content": "The idea is similar to problem **480. Sliding Window Median**, here we also have sliding window, but we need to find not median, but some other statistics: sum of some middle elements in sorted window. Imagine for the purpose of example that `m = 7` and `k = 2`. Then we have widow of size `7`: `a1 < a2 < a3 < a4 < a5 < a6 < a7` and we need to evaluate the sum of `3` numbers `a3 + a4 + a5`. Let us solve two problems: evaluate `a1 + a2 + a3 + a4 + a5` and then substitute `a1 + a2`. How we are going to evaluate sum `a1 + a2` for example?\\n\\nThe idea is to keep `2` heaps: one for smallest `2` numbers in sliding window and another is for the `5` biggest numbers. We do it in very similar way as problem **480**, however we need to also evaluate sums. The trick is to use lazy deletion from heap, that is sometimes it happen, that there are some old elements in our window we need to be deleted later. If you know what is lazy deletion from heap, I think you got the idea, if not, please google it. The difficult part is how to update sum in heap as well, we need to do it carefully, because we have lazy updates, we need to make sure when we add or delete element, that it is element which will not be lazy update.\\n\\nFinally, we need to solve two separate problems: one for parts with sizes `2 vs 5` and another with sizes `5 vs 2`. Also I use trick where I fill heap with zeroes at first, so no need to check case when we do not have enough elements it parts.\\n\\n#### Complexity\\nTime complexity is `O(n log n)`, where `n` is total number of calls of `addElement`. Space complexity is `O(n)`.\\n\\n```\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m, k\\n        self.arr = [0]*m\\n        self.lh1, self.rh1 = self.heap_init(m, k)\\n        self.lh2, self.rh2 = self.heap_init(m, m - k)\\n        self.score = 0\\n        \\n    def heap_init(self, p1, p2):\\n        h1 = [(0, i) for i in range(p1-p2, p1)]\\n        h2 = [(0, i) for i in range(p1-p2)]\\n        heapq.heapify(h1)\\n        heapq.heapify(h2)\\n        return (h1, h2)\\n        \\n    def update(self, lh, rh, m, k, num):\\n        score, T = 0, len(self.arr)\\n        if num > rh[0][0]:\\n            heappush(rh, (num, T))        \\n            if self.arr[T - m] <= rh[0][0]:\\n                if rh[0][1] >= T - m: score += rh[0][0]\\n                score -= self.arr[T - m]\\n                heappush(lh, (-rh[0][0], rh[0][1]))\\n                heappop(rh)\\n        else:\\n            heappush(lh, (-num, T))       \\n            score += num\\n            if self.arr[T - m] >= rh[0][0]: \\n                heappush(rh, (-lh[0][0], lh[0][1]))\\n                q = heappop(lh)\\n                score += q[0]\\n            else:\\n                score -= self.arr[T - m]\\n\\n        while lh and lh[0][1] <= T - m: heappop(lh)  # lazy-deletion\\n        while rh and rh[0][1] <= T - m: heappop(rh)  # lazy-deletion\\n        return score\\n        \\n    def addElement(self, num):\\n        t1 = self.update(self.lh1, self.rh1, self.m, self.k, num)\\n        t2 = self.update(self.lh2, self.rh2, self.m, self.m - self.k, num)\\n        self.arr.append(num)\\n        self.score += (t2 - t1)\\n    \\n    def calculateMKAverage(self):\\n        if len(self.arr) < 2*self.m: return -1\\n        return self.score//(self.m - 2*self.k)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m, k\\n        self.arr = [0]*m\\n        self.lh1, self.rh1 = self.heap_init(m, k)\\n        self.lh2, self.rh2 = self.heap_init(m, m - k)\\n        self.score = 0\\n        \\n    def heap_init(self, p1, p2):\\n        h1 = [(0, i) for i in range(p1-p2, p1)]\\n        h2 = [(0, i) for i in range(p1-p2)]\\n        heapq.heapify(h1)\\n        heapq.heapify(h2)\\n        return (h1, h2)\\n        \\n    def update(self, lh, rh, m, k, num):\\n        score, T = 0, len(self.arr)\\n        if num > rh[0][0]:\\n            heappush(rh, (num, T))        \\n            if self.arr[T - m] <= rh[0][0]:\\n                if rh[0][1] >= T - m: score += rh[0][0]\\n                score -= self.arr[T - m]\\n                heappush(lh, (-rh[0][0], rh[0][1]))\\n                heappop(rh)\\n        else:\\n            heappush(lh, (-num, T))       \\n            score += num\\n            if self.arr[T - m] >= rh[0][0]: \\n                heappush(rh, (-lh[0][0], lh[0][1]))\\n                q = heappop(lh)\\n                score += q[0]\\n            else:\\n                score -= self.arr[T - m]\\n\\n        while lh and lh[0][1] <= T - m: heappop(lh)  # lazy-deletion\\n        while rh and rh[0][1] <= T - m: heappop(rh)  # lazy-deletion\\n        return score\\n        \\n    def addElement(self, num):\\n        t1 = self.update(self.lh1, self.rh1, self.m, self.k, num)\\n        t2 = self.update(self.lh2, self.rh2, self.m, self.m - self.k, num)\\n        self.arr.append(num)\\n        self.score += (t2 - t1)\\n    \\n    def calculateMKAverage(self):\\n        if len(self.arr) < 2*self.m: return -1\\n        return self.score//(self.m - 2*self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152431,
                "title": "java-fenwick-tree-binarysearch",
                "content": "Idea : \\n1. We can have a queue to maintain m elements\\n2. Use two Fenwick tree, 1 for count and 1 for prefix sum\\n3. Do 2 times binary search for the first k elements and the last k elements by using the count from our first fenwick tree\\n4. We can get the sum by subtrating the sum of first k elements and sum of last k element by using our second fenwick tree\\n\\n```\\nclass MKAverage {\\n    Queue<Integer>q=new LinkedList<>();\\n    int m,k;\\n    FenWick fen1;\\n    FenWick fen2;\\n    int cnt[]=new int[100010];\\n    long sum=0;\\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n        long A[]=new long[100010];\\n        long B[]=new long[100010];\\n        fen1=new FenWick(A);\\n        fen2=new FenWick(B);\\n    }\\n    \\n    public void addElement(int num) {\\n        q.add(num);\\n        sum+=num;\\n        fen1.update(num,1);\\n        fen2.update(num,num);\\n        cnt[num]++;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(q.size()<m)return -1;\\n        while(q.size()>m){\\n            int peek=q.poll();\\n            cnt[peek]--;\\n            sum-=peek;\\n            fen1.update(peek,-1);\\n            fen2.update(peek,-peek);\\n        }\\n        \\n        \\n        \\n        int l=0,r=cnt.length-1;\\n        int pos1=-1,pos2=-1;\\n        while(l<=r){//binary search for the first k (there may be duplicated)\\n            int mid=l+(r-l)/2;\\n            long count=fen1.sumRange(0,mid);\\n            if(count>=k){\\n                pos1=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        \\n        \\n        l=0;r=cnt.length-1;\\n        while(l<=r){//binary search for the last k (there may be duplicated)\\n            int mid=l+(r-l)/2;\\n            long count=fen1.sumRange(mid,cnt.length-1);\\n            if(count>=k){\\n                pos2=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        \\n        \\n        long sum1=fen2.sumRange(0,pos1);\\n        long sum2=fen2.sumRange(pos2,cnt.length-1);\\n        long cnt1=fen1.sumRange(0,pos1);\\n        long cnt2=fen1.sumRange(pos2,cnt.length-1);\\n        \\n        if(cnt1>k){\\n            sum1-=(pos1*(cnt1-k));\\n        }\\n        if(cnt2>k){\\n            sum2-=(pos2*(cnt2-k));\\n        }\\n        long remain=sum-sum1-sum2;\\n        return (int)(remain/(m-2*k));\\n    }\\n}\\n\\nclass FenWick {\\n    long tree[];//1-index based\\n    long A[];\\n    long arr[];\\n    public FenWick(long[] A) {\\n        this.A=A;\\n        arr=new long[A.length];\\n        tree=new long[A.length+1];\\n    }\\n    \\n    public void update(int i, int val) {\\n        arr[i]+=val;\\n        i++;\\n        while(i<tree.length){\\n            tree[i]+=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    \\n    public long sumRange(int i, int j) {\\n        return pre(j+1)-pre(i);\\n    }\\n    \\n    public long pre(int i){\\n        long sum=0;\\n        while(i>0){\\n            sum+=tree[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n\\n/*\\n                             ;\\\\\\n                            |\\' \\\\\\n         _                  ; : ;\\n        / `-.              /: : |\\n       |  ,-.`-.          ,\\': : |\\n       \\\\  :  `. `.       ,\\'-. : |\\n        \\\\ ;    ;  `-.__,\\'    `-.|\\n         \\\\ ;   ;  :::  ,::\\'`:.  `.\\n          \\\\ `-. :  `    :.    `.  \\\\\\n           \\\\   \\\\    ,   ;   ,:    (\\\\\\n            \\\\   :., :.    ,\\'o)): ` `-.\\n           ,/,\\' ;\\' ,::\"\\'`.`---\\'   `.  `-._\\n         ,/  :  ; \\'\"      `;\\'          ,--`.\\n        ;/   :; ;             ,:\\'     (   ,:)\\n          ,.,:.    ; ,:.,  ,-._ `.     \\\\\"\"\\'/\\n          \\'::\\'     `:\\'`  ,\\'(  \\\\`._____.-\\'\"\\'\\n             ;,   ;  `.  `. `._`-.  \\\\\\\\\\n             ;:.  ;:       `-._`-.\\\\  \\\\`.\\n              \\'`:. :        |\\' `. `\\\\  ) \\\\\\n      -hrr-      ` ;:       |    `--\\\\__,\\'\\n                   \\'`      ,\\'\\n                        ,-\\'\\n\\n\\n                      free bug dog\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    Queue<Integer>q=new LinkedList<>();\\n    int m,k;\\n    FenWick fen1;\\n    FenWick fen2;\\n    int cnt[]=new int[100010];\\n    long sum=0;\\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n        long A[]=new long[100010];\\n        long B[]=new long[100010];\\n        fen1=new FenWick(A);\\n        fen2=new FenWick(B);\\n    }\\n    \\n    public void addElement(int num) {\\n        q.add(num);\\n        sum+=num;\\n        fen1.update(num,1);\\n        fen2.update(num,num);\\n        cnt[num]++;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(q.size()<m)return -1;\\n        while(q.size()>m){\\n            int peek=q.poll();\\n            cnt[peek]--;\\n            sum-=peek;\\n            fen1.update(peek,-1);\\n            fen2.update(peek,-peek);\\n        }\\n        \\n        \\n        \\n        int l=0,r=cnt.length-1;\\n        int pos1=-1,pos2=-1;\\n        while(l<=r){//binary search for the first k (there may be duplicated)\\n            int mid=l+(r-l)/2;\\n            long count=fen1.sumRange(0,mid);\\n            if(count>=k){\\n                pos1=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        \\n        \\n        l=0;r=cnt.length-1;\\n        while(l<=r){//binary search for the last k (there may be duplicated)\\n            int mid=l+(r-l)/2;\\n            long count=fen1.sumRange(mid,cnt.length-1);\\n            if(count>=k){\\n                pos2=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        \\n        \\n        long sum1=fen2.sumRange(0,pos1);\\n        long sum2=fen2.sumRange(pos2,cnt.length-1);\\n        long cnt1=fen1.sumRange(0,pos1);\\n        long cnt2=fen1.sumRange(pos2,cnt.length-1);\\n        \\n        if(cnt1>k){\\n            sum1-=(pos1*(cnt1-k));\\n        }\\n        if(cnt2>k){\\n            sum2-=(pos2*(cnt2-k));\\n        }\\n        long remain=sum-sum1-sum2;\\n        return (int)(remain/(m-2*k));\\n    }\\n}\\n\\nclass FenWick {\\n    long tree[];//1-index based\\n    long A[];\\n    long arr[];\\n    public FenWick(long[] A) {\\n        this.A=A;\\n        arr=new long[A.length];\\n        tree=new long[A.length+1];\\n    }\\n    \\n    public void update(int i, int val) {\\n        arr[i]+=val;\\n        i++;\\n        while(i<tree.length){\\n            tree[i]+=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    \\n    public long sumRange(int i, int j) {\\n        return pre(j+1)-pre(i);\\n    }\\n    \\n    public long pre(int i){\\n        long sum=0;\\n        while(i>0){\\n            sum+=tree[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n\\n/*\\n                             ;\\\\\\n                            |\\' \\\\\\n         _                  ; : ;\\n        / `-.              /: : |\\n       |  ,-.`-.          ,\\': : |\\n       \\\\  :  `. `.       ,\\'-. : |\\n        \\\\ ;    ;  `-.__,\\'    `-.|\\n         \\\\ ;   ;  :::  ,::\\'`:.  `.\\n          \\\\ `-. :  `    :.    `.  \\\\\\n           \\\\   \\\\    ,   ;   ,:    (\\\\\\n            \\\\   :., :.    ,\\'o)): ` `-.\\n           ,/,\\' ;\\' ,::\"\\'`.`---\\'   `.  `-._\\n         ,/  :  ; \\'\"      `;\\'          ,--`.\\n        ;/   :; ;             ,:\\'     (   ,:)\\n          ,.,:.    ; ,:.,  ,-._ `.     \\\\\"\"\\'/\\n          \\'::\\'     `:\\'`  ,\\'(  \\\\`._____.-\\'\"\\'\\n             ;,   ;  `.  `. `._`-.  \\\\\\\\\\n             ;:.  ;:       `-._`-.\\\\  \\\\`.\\n              \\'`:. :        |\\' `. `\\\\  ) \\\\\\n      -hrr-      ` ;:       |    `--\\\\__,\\'\\n                   \\'`      ,\\'\\n                        ,-\\'\\n\\n\\n                      free bug dog\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230771,
                "title": "python-sortedlist-solution",
                "content": "There is a `sortedcontainers` package for Python ([link](http://www.grantjenks.com/docs/sortedcontainers/index.html)), which I think is a good alternative for red-black tree or ordered map for python players.\\nUsing `SortedList`, it takes `~ O(logn)` time for both remove and insert. (Since `SortedList` is based on list of list, instead of tree structure, the time cost is not exactly `O(logn)`)\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    MAX_NUM = 10 ** 5\\n    def __init__(self, m: int, k: int):\\n        \\n        self.m = m\\n        self.k = k\\n        \\n        # sorted list\\n        self.sl = SortedList([0] * m)\\n\\t\\t# sum of k smallest elements\\n        self.sum_k = 0\\n\\t\\t# sum of m - k smallest elements\\n        self.sum_m_k = 0\\n        \\n        # queue for the last M elements if the stream\\n        self.q = deque([0] * m)\\n        \\n    def addElement(self, num: int) -> None:\\n        # Time: O(logm)\\n\\t\\t\\n        m, k, q, sl = self.m, self.k, self.q, self.sl            \\n            \\n        # update q\\n        q.append(num)\\n        old = q.popleft()\\n        \\n        # remove the old num\\n        r = sl.bisect_right(old)\\n\\t\\t# maintain sum_k\\n        if r <= k:\\n            self.sum_k -= old\\n            self.sum_k += sl[k]\\n\\t\\t# maintain sum_m_k\\n        if r <= m - k:\\n            self.sum_m_k -= old\\n            self.sum_m_k += sl[m-k]\\n        # remove the old num\\n        sl.remove(old)\\n        \\n        # add the new num\\n        r = sl.bisect_right(num)\\n        if r < k:\\n            self.sum_k -= sl[k-1]\\n            self.sum_k += num\\n        if r < m - k:\\n            self.sum_m_k -= sl[m - k - 1]\\n            self.sum_m_k += num\\n        \\n        sl.add(num)\\n            \\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n\\t\\t# Time: O(1)\\n        if self.sl[0] == 0:\\n            return -1\\n        return (self.sum_m_k - self.sum_k) // (self.m - self.k * 2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    MAX_NUM = 10 ** 5\\n    def __init__(self, m: int, k: int):\\n        \\n        self.m = m\\n        self.k = k\\n        \\n        # sorted list\\n        self.sl = SortedList([0] * m)\\n\\t\\t# sum of k smallest elements\\n        self.sum_k = 0\\n\\t\\t# sum of m - k smallest elements\\n        self.sum_m_k = 0\\n        \\n        # queue for the last M elements if the stream\\n        self.q = deque([0] * m)\\n        \\n    def addElement(self, num: int) -> None:\\n        # Time: O(logm)\\n\\t\\t\\n        m, k, q, sl = self.m, self.k, self.q, self.sl            \\n            \\n        # update q\\n        q.append(num)\\n        old = q.popleft()\\n        \\n        # remove the old num\\n        r = sl.bisect_right(old)\\n\\t\\t# maintain sum_k\\n        if r <= k:\\n            self.sum_k -= old\\n            self.sum_k += sl[k]\\n\\t\\t# maintain sum_m_k\\n        if r <= m - k:\\n            self.sum_m_k -= old\\n            self.sum_m_k += sl[m-k]\\n        # remove the old num\\n        sl.remove(old)\\n        \\n        # add the new num\\n        r = sl.bisect_right(num)\\n        if r < k:\\n            self.sum_k -= sl[k-1]\\n            self.sum_k += num\\n        if r < m - k:\\n            self.sum_m_k -= sl[m - k - 1]\\n            self.sum_m_k += num\\n        \\n        sl.add(num)\\n            \\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n\\t\\t# Time: O(1)\\n        if self.sl[0] == 0:\\n            return -1\\n        return (self.sum_m_k - self.sum_k) // (self.m - self.k * 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388111,
                "title": "python-100-faster-bst-solution-explained",
                "content": "So the challenge here is how can we quickly sum the k-largest and k-smallest elements, and I want to talk about how I did that with a binary search tree. The key idea was to store the number of items in each sub-tree, as well as the sum of all the items in each sub tree. By storing the size of each node it becomes possible to determine if the ith smallest node is to the left of the current node, at the current node, or to the right of the current node. This means the ith smallest node can be found in a single trip down the tree. Because the sums are stored, we can also choose to sum elements which are smaller or larger than the target as we go (without having to actually traverse the tree).\\n\\nThe other aspects of my algorithm are fairly straightforward. I used a deque to store the last m elements in the stream, and an integer to store the sliding window sum for all of the last m elements. This means that to compute the average I have to subtract the sum of the k largest/smallest elements from the sliding window sum, and then divide by the number of elements (which is pre-computed since it\\'s a constant). Whenever I add/remove an element to/from the queue I also/remove add it to/from the tree and update the sum, with different cases to handle when the tree is null, when the queue isn\\'t full.\\n\\nBST Height (n is the number of nodes in the tree): \\nBest : O(logn)\\nAverage : O(logn)\\nWorst : O(n)\\n\\nBST Runtimes (h is the height of the tree):\\n\\\\_\\\\_init\\\\_\\\\_ : O(1)\\ninsert/remove : O(h)\\nklargets/ksmallest : O(h)\\n\\nMKAverage Runtimes:\\n\\\\_\\\\_init\\\\_\\\\_ : O(1)\\naddElement : O(h)\\ncalculateMKAverage : O(h)\\n\\nBest Performance: 864 ms/49.3 MB : 100%/98%\\n\\nA more complete version of the binary search tree is below the code for this puzzle.\\n\\'\\'\\'\\n\\n\\t#Binary Search Tree\\n\\tclass Node:\\n\\t\\t#Create a Node\\n\\t\\tdef __init__(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Create a New Binary Search Tree Node\"\"\"\\n\\t\\t\\tself.val = val\\n\\t\\t\\tself.sum = val\\n\\t\\t\\tself.size = 1\\n\\t\\t\\tself.count = 1\\n\\t\\t\\tself.left = None\\n\\t\\t\\tself.right = None\\n\\t\\t\\n\\t\\t#Add a Node to the Tree\\n\\t\\tdef insert(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Add a Value to the Tree\"\"\"\\n\\t\\t\\t#Update the Size/Sum\\n\\t\\t\\tself.size += 1\\n\\t\\t\\tself.sum += val\\n\\t\\t\\t\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif val < self.val:\\n\\t\\t\\t\\t#Check the Left Node\\n\\t\\t\\t\\tif self.left:\\n\\t\\t\\t\\t\\t#Recurse\\n\\t\\t\\t\\t\\tself.left.insert(val)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Make a New Node\\n\\t\\t\\t\\t\\tself.left = Node(val)\\n\\t\\t\\telif val > self.val:\\n\\t\\t\\t\\t#Check the Right Node\\n\\t\\t\\t\\tif self.right:\\n\\t\\t\\t\\t\\t#Recurse\\n\\t\\t\\t\\t\\tself.right.insert(val)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Make a New Node\\n\\t\\t\\t\\t\\tself.right = Node(val)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Increment the Count\\n\\t\\t\\t\\tself.count += 1\\n\\n\\t\\t#Remove a Node from the Tree (Safetys Removed)\\n\\t\\tdef remove(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Remove a Value From the Tree\"\"\"\\n\\t\\t\\t#Update the Size/Sum\\n\\t\\t\\tself.size -= 1\\n\\t\\t\\tself.sum -= val\\n\\t\\t\\t\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif val < self.val:\\n\\t\\t\\t\\t#Recurse Left\\n\\t\\t\\t\\treturn self.left.remove(val)\\n\\t\\t\\telif val > self.val:\\n\\t\\t\\t\\t#Recurse Right\\n\\t\\t\\t\\treturn self.right.remove(val)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Decrement the Count\\n\\t\\t\\t\\tself.count -= 1\\n\\n\\t\\t#Sum the k Smallest Numbers\\n\\t\\tdef ksmallest(self, k:int) -> int:\\n\\t\\t\\t\"\"\"Efficiently Sum the k Smallest Values in the Tree\"\"\"\\n\\t\\t\\t#Check the Left Branch\\n\\t\\t\\ts = 0\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\t#Check the Case\\n\\t\\t\\t\\tif k <= self.left.size:\\n\\t\\t\\t\\t\\t#Recurse Left\\n\\t\\t\\t\\t\\treturn self.left.ksmallest(k)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Update k/s\\n\\t\\t\\t\\t\\tk -= self.left.size\\n\\t\\t\\t\\t\\ts = self.left.sum\\n\\n\\t\\t\\t#Check the Current Value\\n\\t\\t\\tif k <= self.count:\\n\\t\\t\\t\\treturn s + k*self.val\\n\\t\\t\\telif self.right:\\n\\t\\t\\t\\t#Recurse Right\\n\\t\\t\\t\\treturn s + self.count*self.val + self.right.ksmallest(k - self.count)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Return Search Failure\\n\\t\\t\\t\\treturn None\\n\\n\\tclass MKAverage:\\n\\t\\tdef __init__(self, m: int, k: int):\\n\\t\\t\\tself.k = k\\n\\t\\t\\tself.l = m - k\\n\\t\\t\\tself.m = m\\n\\t\\t\\tself.n = self.m - 2*self.k\\n\\t\\t\\tself.window = deque()\\n\\t\\t\\tself.tree = None\\n\\n\\t\\tdef addElement(self, num: int) -> None:\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif len(self.window) == self.m:\\n\\t\\t\\t\\t#Remove the Previous Number from the Window/Tree\\n\\t\\t\\t\\tself.tree.remove(self.window.popleft())\\n\\n\\t\\t\\t\\t#Add the New Number to the Window/Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree.insert(num)\\n\\t\\t\\telif self.window:\\n\\t\\t\\t\\t#Add the New Number to the Window/Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree.insert(num)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Make a New Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree = Node(num)\\n\\n\\t\\tdef calculateMKAverage(self) -> int:\\n\\t\\t\\t#Check the Window\\n\\t\\t\\tif len(self.window) < self.m:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Compute Return the Average\\n\\t\\t\\t\\treturn (self.tree.ksmallest(self.l) - self.tree.ksmallest(self.k))//self.n\\n\\'\\'\\'\\n\\nHere is my binary search tree class as it exists on my computer!\\n\\n\\'\\'\\'\\n\\n    #Binary Search Tree\\n    class Node:\\n        #Create a Node\\n        def __init__(self, val:int) -> None:\\n            \"\"\"Create a New Binary Search Tree Node\"\"\"\\n            self.val = val\\n            self.sum = val\\n            self.size = 1\\n            self.count = 1\\n            self.left = None\\n            self.right = None\\n        \\n        #Get the Size of the Tree\\n        def __len__(self) -> int:\\n            \"\"\"Return the Number of Items in the Tree\"\"\"\\n            return self.size\\n        \\n        #Search for an Item (Index Validity Guaranteed)\\n        def find(self, i:int):\\n            \"\"\"Find and Return the Node at Index i\\n            \\n            It also returns an index describing which version of the \\n            current node was returned.\\n            \\n            If i is not a valid index then it returns None (but still \\n            does a non-trivial amount of work to figure that out, so \\n            be cautious when using this)\\n            \"\"\"\\n            #Check the Left Branch\\n            if self.left:\\n                #Check the Case\\n                if i < self.left.size:\\n                    #Recurse Left\\n                    return self.left.find(i)\\n                else:\\n                    #Update i\\n                    i -= self.left.size\\n            \\n            #Check the Current Value\\n            if i < self.count:\\n                return self, i\\n            elif self.right:\\n                #Recurse Right\\n                return self.right.find(i - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n        \\n        #Find the ith Smallest Element\\n        def __getitem__(self, i:int) -> int:\\n            \"\"\"Get and Return the Value of the Node at Index i\"\"\"\\n            #Check i\\n            if i < -self.size or i >= self.size:\\n                #Index Out of Range\\n                return None\\n            elif i >= 0:\\n                #Find the Index Recursively\\n                return self.find(i)[0].val\\n            else:\\n                #Find the Index Recursively\\n                return self.find(self.size + i)[0].val\\n        \\n        #Count the Number of Occurences of an Item in the Tree\\n        def Count(self, val:int) -> int:\\n            #Check the Case\\n            if val == self.val:\\n                #Return the Count\\n                return self.count\\n            elif val < self.val:\\n                #Recurse Left\\n                return self.left.Count(val) if self.left else 0\\n            else:\\n                #Recurse Right\\n                return self.right.Count(val) if self.right else 0\\n        \\n        #Check if an Item is in the Tree\\n        def __contains__(self, val:int) -> bool:\\n            \"\"\"Check Whether a Value is in the Tree\"\"\"\\n            return self.Count(val) > 0\\n        \\n        #Find the Minimum Item\\n        def getMin(self) -> int:\\n            \"\"\"Returns the Minimum Value in the Tree\"\"\"\\n            return self[0]\\n        \\n        #Find the Maximum Item\\n        def getMax(self) -> int:\\n            \"\"\"Returns the Maximum Valud in the Tree\"\"\"\\n            return self[-1]\\n        \\n        #Find the Median\\n        def median(self) -> float:\\n            \"\"\"Returns the Median Value in the Tree\"\"\"\\n            #Check the Case\\n            if self.size%2:\\n                #The Median is a Single Item\\n                return self[self.size//2]\\n            else:\\n                #Find the Larger Item\\n                node, i = self.find(self.size//2)\\n                \\n                #Check the Case\\n                if i > 0:\\n                    #The Median is Already Found\\n                    return node.val\\n                elif node.left and node.left.size:\\n                    #Get the Largest Value from the Left\\n                    return (node.val + node.left[-1])/2\\n                else:\\n                    #Do a Separate Search\\n                    return (node.val + self[self.size//2 - 1])/2\\n        \\n        #Find the Average\\n        def mean(self) -> float:\\n            \"\"\"Returns the Average Value in the Tree\"\"\"\\n            return self.sum/self.size\\n        \\n        #Add a Node to the Tree\\n        def insert(self, val:int) -> None:\\n            \"\"\"Add a Value to the Tree\"\"\"\\n            #Check the Case\\n            self.size += 1\\n            self.sum += val\\n            if val < self.val:\\n                #Check the Left Node\\n                if self.left:\\n                    #Recurse\\n                    self.left.insert(val)\\n                else:\\n                    #Make a New Node\\n                    self.left = Node(val)\\n            elif val > self.val:\\n                #Check the Right Node\\n                if self.right:\\n                    #Recurse\\n                    self.right.insert(val)\\n                else:\\n                    #Make a New Node\\n                    self.right = Node(val)\\n            else:\\n                #Increment the Count\\n                self.count += 1\\n        \\n        #Remove a Node from the Tree\\n        def remove(self, val:int) -> bool:\\n            \"\"\"Remove a Value From the Tree\"\"\"\\n            #Check the Case\\n            if val < self.val:\\n                #Check the Left Node\\n                if self.left and self.left.remove(val):\\n                    #Decrement the Sum/Size\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #The Node Wasn\\'t Found\\n                    return False\\n            elif val > self.val:\\n                #Check the Right Node\\n                if self.right and self.right.remove(val):\\n                    #Decrement the Sum/Size\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #The Node Wasn\\'t Found\\n                    return False\\n            else:\\n                #Check the Count\\n                if self.count:\\n                    #Decrement the Count, Sum, and Size\\n                    self.count -= 1\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #Return Failure\\n                    return False\\n        \\n        #Pop an Item at a Specified Index\\n        def pop(self, i:int) -> int:\\n            \"\"\"Remove and Return the Item at Index i\"\"\"\\n            #Check i\\n            if i < 0 or i >= self.size:\\n                #Return Search Failure\\n                return None\\n            \\n            #Update the Size\\n            self.size -= 1\\n            \\n            #Check the Left Branch\\n            if self.left:\\n                #Check the Case\\n                if i < self.left.size:\\n                    #Recurse Left\\n                    val = self.left.pop(i)\\n                    \\n                    #Update the Sum\\n                    self.sum -= val\\n                    \\n                    #Return the Value\\n                    return val\\n                else:\\n                    #Update i\\n                    i -= self.left.size\\n            \\n            #Check the Current Value\\n            if i < self.count:\\n                #Update the Count/Sum\\n                self.count -= 1\\n                self.sum -= self.val\\n                \\n                #Return the Value\\n                return self.val\\n            else:\\n                #Recurse Right\\n                val = self.right.pop(i - self.count)\\n                \\n                #Update the Sum\\n                self.sum -= val\\n                \\n                #Return the Value\\n                return val\\n        \\n        #Yield Nodes in Increasing Order\\n        def increasing(self, unique:bool = False) -> int:\\n            \"\"\"Yield the Values of the Tree in Increasing Order\"\"\"\\n            #Check the Left Node\\n            if self.left:\\n                #Recurse\\n                yield from self.left.increasing(unique)\\n            \\n            #Yield the Current Node\\n            if unique:\\n                yield self.val, self.count\\n            else:\\n                yield from (self.val for i in range(self.count))\\n            \\n            #Check the Right Node\\n            if self.right:\\n                #Recurse\\n                yield from self.right.increasing(unique)\\n        \\n        #Make the Tree Iterable\\n        def __iter__(self):\\n            return self.increasing()\\n        \\n        #Yield Nodes in Decreasing Order\\n        def decreasing(self, unique:bool = False) -> int:\\n            \"\"\"Yield the Values in the Tree in Decreasing Order\"\"\"\\n            #Check the Right Node\\n            if self.right:\\n                #Recurse\\n                yield from self.right.decreasing(unique)\\n            \\n            #Yield the Current Node\\n            if unique:\\n                yield self.val, self.count\\n            else:\\n                yield from (self.val for i in range(self.count))\\n            \\n            #Check the Left Node\\n            if self.left:\\n                #Recurse\\n                yield from self.left.decreasing(unique)\\n        \\n        #Sum the k Largest Numbers\\n        def klargest(self, k:int) -> int:\\n            \"\"\"Efficiently Sum the k Largest Values in the Tree\"\"\"\\n            #Check the Right Branch\\n            s = 0\\n            if self.right:\\n                #Check the Case\\n                if k <= self.right.size:\\n                    #Recurse Left\\n                    return self.right.klargest(k)\\n                else:\\n                    #Update k/s\\n                    k -= self.right.size\\n                    s = self.right.sum\\n            \\n            #Check the Current Value\\n            if k <= self.count:\\n                return s + k*self.val\\n            elif self.left:\\n                #Recurse Left\\n                return s + self.count*self.val + self.left.klargest(k - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n        \\n        #Sum the k Smallest Numbers\\n        def ksmallest(self, k:int) -> int:\\n            \"\"\"Efficiently Sum the k Smallest Values in the Tree\"\"\"\\n            #Check the Left Branch\\n            s = 0\\n            if self.left:\\n                #Check the Case\\n                if k <= self.left.size:\\n                    #Recurse Left\\n                    return self.left.ksmallest(k)\\n                else:\\n                    #Update k/s\\n                    k -= self.left.size\\n                    s = self.left.sum\\n            \\n            #Check the Current Value\\n            if k <= self.count:\\n                return s + k*self.val\\n            elif self.right:\\n                #Recurse Right\\n                return s + self.count*self.val + self.right.ksmallest(k - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "So the challenge here is how can we quickly sum the k-largest and k-smallest elements, and I want to talk about how I did that with a binary search tree. The key idea was to store the number of items in each sub-tree, as well as the sum of all the items in each sub tree. By storing the size of each node it becomes possible to determine if the ith smallest node is to the left of the current node, at the current node, or to the right of the current node. This means the ith smallest node can be found in a single trip down the tree. Because the sums are stored, we can also choose to sum elements which are smaller or larger than the target as we go (without having to actually traverse the tree).\\n\\nThe other aspects of my algorithm are fairly straightforward. I used a deque to store the last m elements in the stream, and an integer to store the sliding window sum for all of the last m elements. This means that to compute the average I have to subtract the sum of the k largest/smallest elements from the sliding window sum, and then divide by the number of elements (which is pre-computed since it\\'s a constant). Whenever I add/remove an element to/from the queue I also/remove add it to/from the tree and update the sum, with different cases to handle when the tree is null, when the queue isn\\'t full.\\n\\nBST Height (n is the number of nodes in the tree): \\nBest : O(logn)\\nAverage : O(logn)\\nWorst : O(n)\\n\\nBST Runtimes (h is the height of the tree):\\n\\\\_\\\\_init\\\\_\\\\_ : O(1)\\ninsert/remove : O(h)\\nklargets/ksmallest : O(h)\\n\\nMKAverage Runtimes:\\n\\\\_\\\\_init\\\\_\\\\_ : O(1)\\naddElement : O(h)\\ncalculateMKAverage : O(h)\\n\\nBest Performance: 864 ms/49.3 MB : 100%/98%\\n\\nA more complete version of the binary search tree is below the code for this puzzle.\\n\\'\\'\\'\\n\\n\\t#Binary Search Tree\\n\\tclass Node:\\n\\t\\t#Create a Node\\n\\t\\tdef __init__(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Create a New Binary Search Tree Node\"\"\"\\n\\t\\t\\tself.val = val\\n\\t\\t\\tself.sum = val\\n\\t\\t\\tself.size = 1\\n\\t\\t\\tself.count = 1\\n\\t\\t\\tself.left = None\\n\\t\\t\\tself.right = None\\n\\t\\t\\n\\t\\t#Add a Node to the Tree\\n\\t\\tdef insert(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Add a Value to the Tree\"\"\"\\n\\t\\t\\t#Update the Size/Sum\\n\\t\\t\\tself.size += 1\\n\\t\\t\\tself.sum += val\\n\\t\\t\\t\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif val < self.val:\\n\\t\\t\\t\\t#Check the Left Node\\n\\t\\t\\t\\tif self.left:\\n\\t\\t\\t\\t\\t#Recurse\\n\\t\\t\\t\\t\\tself.left.insert(val)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Make a New Node\\n\\t\\t\\t\\t\\tself.left = Node(val)\\n\\t\\t\\telif val > self.val:\\n\\t\\t\\t\\t#Check the Right Node\\n\\t\\t\\t\\tif self.right:\\n\\t\\t\\t\\t\\t#Recurse\\n\\t\\t\\t\\t\\tself.right.insert(val)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Make a New Node\\n\\t\\t\\t\\t\\tself.right = Node(val)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Increment the Count\\n\\t\\t\\t\\tself.count += 1\\n\\n\\t\\t#Remove a Node from the Tree (Safetys Removed)\\n\\t\\tdef remove(self, val:int) -> None:\\n\\t\\t\\t\"\"\"Remove a Value From the Tree\"\"\"\\n\\t\\t\\t#Update the Size/Sum\\n\\t\\t\\tself.size -= 1\\n\\t\\t\\tself.sum -= val\\n\\t\\t\\t\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif val < self.val:\\n\\t\\t\\t\\t#Recurse Left\\n\\t\\t\\t\\treturn self.left.remove(val)\\n\\t\\t\\telif val > self.val:\\n\\t\\t\\t\\t#Recurse Right\\n\\t\\t\\t\\treturn self.right.remove(val)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Decrement the Count\\n\\t\\t\\t\\tself.count -= 1\\n\\n\\t\\t#Sum the k Smallest Numbers\\n\\t\\tdef ksmallest(self, k:int) -> int:\\n\\t\\t\\t\"\"\"Efficiently Sum the k Smallest Values in the Tree\"\"\"\\n\\t\\t\\t#Check the Left Branch\\n\\t\\t\\ts = 0\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\t#Check the Case\\n\\t\\t\\t\\tif k <= self.left.size:\\n\\t\\t\\t\\t\\t#Recurse Left\\n\\t\\t\\t\\t\\treturn self.left.ksmallest(k)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#Update k/s\\n\\t\\t\\t\\t\\tk -= self.left.size\\n\\t\\t\\t\\t\\ts = self.left.sum\\n\\n\\t\\t\\t#Check the Current Value\\n\\t\\t\\tif k <= self.count:\\n\\t\\t\\t\\treturn s + k*self.val\\n\\t\\t\\telif self.right:\\n\\t\\t\\t\\t#Recurse Right\\n\\t\\t\\t\\treturn s + self.count*self.val + self.right.ksmallest(k - self.count)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Return Search Failure\\n\\t\\t\\t\\treturn None\\n\\n\\tclass MKAverage:\\n\\t\\tdef __init__(self, m: int, k: int):\\n\\t\\t\\tself.k = k\\n\\t\\t\\tself.l = m - k\\n\\t\\t\\tself.m = m\\n\\t\\t\\tself.n = self.m - 2*self.k\\n\\t\\t\\tself.window = deque()\\n\\t\\t\\tself.tree = None\\n\\n\\t\\tdef addElement(self, num: int) -> None:\\n\\t\\t\\t#Check the Case\\n\\t\\t\\tif len(self.window) == self.m:\\n\\t\\t\\t\\t#Remove the Previous Number from the Window/Tree\\n\\t\\t\\t\\tself.tree.remove(self.window.popleft())\\n\\n\\t\\t\\t\\t#Add the New Number to the Window/Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree.insert(num)\\n\\t\\t\\telif self.window:\\n\\t\\t\\t\\t#Add the New Number to the Window/Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree.insert(num)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Make a New Tree\\n\\t\\t\\t\\tself.window.append(num)\\n\\t\\t\\t\\tself.tree = Node(num)\\n\\n\\t\\tdef calculateMKAverage(self) -> int:\\n\\t\\t\\t#Check the Window\\n\\t\\t\\tif len(self.window) < self.m:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\t#Compute Return the Average\\n\\t\\t\\t\\treturn (self.tree.ksmallest(self.l) - self.tree.ksmallest(self.k))//self.n\\n\\'\\'\\'\\n\\nHere is my binary search tree class as it exists on my computer!\\n\\n\\'\\'\\'\\n\\n    #Binary Search Tree\\n    class Node:\\n        #Create a Node\\n        def __init__(self, val:int) -> None:\\n            \"\"\"Create a New Binary Search Tree Node\"\"\"\\n            self.val = val\\n            self.sum = val\\n            self.size = 1\\n            self.count = 1\\n            self.left = None\\n            self.right = None\\n        \\n        #Get the Size of the Tree\\n        def __len__(self) -> int:\\n            \"\"\"Return the Number of Items in the Tree\"\"\"\\n            return self.size\\n        \\n        #Search for an Item (Index Validity Guaranteed)\\n        def find(self, i:int):\\n            \"\"\"Find and Return the Node at Index i\\n            \\n            It also returns an index describing which version of the \\n            current node was returned.\\n            \\n            If i is not a valid index then it returns None (but still \\n            does a non-trivial amount of work to figure that out, so \\n            be cautious when using this)\\n            \"\"\"\\n            #Check the Left Branch\\n            if self.left:\\n                #Check the Case\\n                if i < self.left.size:\\n                    #Recurse Left\\n                    return self.left.find(i)\\n                else:\\n                    #Update i\\n                    i -= self.left.size\\n            \\n            #Check the Current Value\\n            if i < self.count:\\n                return self, i\\n            elif self.right:\\n                #Recurse Right\\n                return self.right.find(i - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n        \\n        #Find the ith Smallest Element\\n        def __getitem__(self, i:int) -> int:\\n            \"\"\"Get and Return the Value of the Node at Index i\"\"\"\\n            #Check i\\n            if i < -self.size or i >= self.size:\\n                #Index Out of Range\\n                return None\\n            elif i >= 0:\\n                #Find the Index Recursively\\n                return self.find(i)[0].val\\n            else:\\n                #Find the Index Recursively\\n                return self.find(self.size + i)[0].val\\n        \\n        #Count the Number of Occurences of an Item in the Tree\\n        def Count(self, val:int) -> int:\\n            #Check the Case\\n            if val == self.val:\\n                #Return the Count\\n                return self.count\\n            elif val < self.val:\\n                #Recurse Left\\n                return self.left.Count(val) if self.left else 0\\n            else:\\n                #Recurse Right\\n                return self.right.Count(val) if self.right else 0\\n        \\n        #Check if an Item is in the Tree\\n        def __contains__(self, val:int) -> bool:\\n            \"\"\"Check Whether a Value is in the Tree\"\"\"\\n            return self.Count(val) > 0\\n        \\n        #Find the Minimum Item\\n        def getMin(self) -> int:\\n            \"\"\"Returns the Minimum Value in the Tree\"\"\"\\n            return self[0]\\n        \\n        #Find the Maximum Item\\n        def getMax(self) -> int:\\n            \"\"\"Returns the Maximum Valud in the Tree\"\"\"\\n            return self[-1]\\n        \\n        #Find the Median\\n        def median(self) -> float:\\n            \"\"\"Returns the Median Value in the Tree\"\"\"\\n            #Check the Case\\n            if self.size%2:\\n                #The Median is a Single Item\\n                return self[self.size//2]\\n            else:\\n                #Find the Larger Item\\n                node, i = self.find(self.size//2)\\n                \\n                #Check the Case\\n                if i > 0:\\n                    #The Median is Already Found\\n                    return node.val\\n                elif node.left and node.left.size:\\n                    #Get the Largest Value from the Left\\n                    return (node.val + node.left[-1])/2\\n                else:\\n                    #Do a Separate Search\\n                    return (node.val + self[self.size//2 - 1])/2\\n        \\n        #Find the Average\\n        def mean(self) -> float:\\n            \"\"\"Returns the Average Value in the Tree\"\"\"\\n            return self.sum/self.size\\n        \\n        #Add a Node to the Tree\\n        def insert(self, val:int) -> None:\\n            \"\"\"Add a Value to the Tree\"\"\"\\n            #Check the Case\\n            self.size += 1\\n            self.sum += val\\n            if val < self.val:\\n                #Check the Left Node\\n                if self.left:\\n                    #Recurse\\n                    self.left.insert(val)\\n                else:\\n                    #Make a New Node\\n                    self.left = Node(val)\\n            elif val > self.val:\\n                #Check the Right Node\\n                if self.right:\\n                    #Recurse\\n                    self.right.insert(val)\\n                else:\\n                    #Make a New Node\\n                    self.right = Node(val)\\n            else:\\n                #Increment the Count\\n                self.count += 1\\n        \\n        #Remove a Node from the Tree\\n        def remove(self, val:int) -> bool:\\n            \"\"\"Remove a Value From the Tree\"\"\"\\n            #Check the Case\\n            if val < self.val:\\n                #Check the Left Node\\n                if self.left and self.left.remove(val):\\n                    #Decrement the Sum/Size\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #The Node Wasn\\'t Found\\n                    return False\\n            elif val > self.val:\\n                #Check the Right Node\\n                if self.right and self.right.remove(val):\\n                    #Decrement the Sum/Size\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #The Node Wasn\\'t Found\\n                    return False\\n            else:\\n                #Check the Count\\n                if self.count:\\n                    #Decrement the Count, Sum, and Size\\n                    self.count -= 1\\n                    self.sum -= val\\n                    self.size -= 1\\n                    \\n                    #Return Success\\n                    return True\\n                else:\\n                    #Return Failure\\n                    return False\\n        \\n        #Pop an Item at a Specified Index\\n        def pop(self, i:int) -> int:\\n            \"\"\"Remove and Return the Item at Index i\"\"\"\\n            #Check i\\n            if i < 0 or i >= self.size:\\n                #Return Search Failure\\n                return None\\n            \\n            #Update the Size\\n            self.size -= 1\\n            \\n            #Check the Left Branch\\n            if self.left:\\n                #Check the Case\\n                if i < self.left.size:\\n                    #Recurse Left\\n                    val = self.left.pop(i)\\n                    \\n                    #Update the Sum\\n                    self.sum -= val\\n                    \\n                    #Return the Value\\n                    return val\\n                else:\\n                    #Update i\\n                    i -= self.left.size\\n            \\n            #Check the Current Value\\n            if i < self.count:\\n                #Update the Count/Sum\\n                self.count -= 1\\n                self.sum -= self.val\\n                \\n                #Return the Value\\n                return self.val\\n            else:\\n                #Recurse Right\\n                val = self.right.pop(i - self.count)\\n                \\n                #Update the Sum\\n                self.sum -= val\\n                \\n                #Return the Value\\n                return val\\n        \\n        #Yield Nodes in Increasing Order\\n        def increasing(self, unique:bool = False) -> int:\\n            \"\"\"Yield the Values of the Tree in Increasing Order\"\"\"\\n            #Check the Left Node\\n            if self.left:\\n                #Recurse\\n                yield from self.left.increasing(unique)\\n            \\n            #Yield the Current Node\\n            if unique:\\n                yield self.val, self.count\\n            else:\\n                yield from (self.val for i in range(self.count))\\n            \\n            #Check the Right Node\\n            if self.right:\\n                #Recurse\\n                yield from self.right.increasing(unique)\\n        \\n        #Make the Tree Iterable\\n        def __iter__(self):\\n            return self.increasing()\\n        \\n        #Yield Nodes in Decreasing Order\\n        def decreasing(self, unique:bool = False) -> int:\\n            \"\"\"Yield the Values in the Tree in Decreasing Order\"\"\"\\n            #Check the Right Node\\n            if self.right:\\n                #Recurse\\n                yield from self.right.decreasing(unique)\\n            \\n            #Yield the Current Node\\n            if unique:\\n                yield self.val, self.count\\n            else:\\n                yield from (self.val for i in range(self.count))\\n            \\n            #Check the Left Node\\n            if self.left:\\n                #Recurse\\n                yield from self.left.decreasing(unique)\\n        \\n        #Sum the k Largest Numbers\\n        def klargest(self, k:int) -> int:\\n            \"\"\"Efficiently Sum the k Largest Values in the Tree\"\"\"\\n            #Check the Right Branch\\n            s = 0\\n            if self.right:\\n                #Check the Case\\n                if k <= self.right.size:\\n                    #Recurse Left\\n                    return self.right.klargest(k)\\n                else:\\n                    #Update k/s\\n                    k -= self.right.size\\n                    s = self.right.sum\\n            \\n            #Check the Current Value\\n            if k <= self.count:\\n                return s + k*self.val\\n            elif self.left:\\n                #Recurse Left\\n                return s + self.count*self.val + self.left.klargest(k - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n        \\n        #Sum the k Smallest Numbers\\n        def ksmallest(self, k:int) -> int:\\n            \"\"\"Efficiently Sum the k Smallest Values in the Tree\"\"\"\\n            #Check the Left Branch\\n            s = 0\\n            if self.left:\\n                #Check the Case\\n                if k <= self.left.size:\\n                    #Recurse Left\\n                    return self.left.ksmallest(k)\\n                else:\\n                    #Update k/s\\n                    k -= self.left.size\\n                    s = self.left.sum\\n            \\n            #Check the Current Value\\n            if k <= self.count:\\n                return s + k*self.val\\n            elif self.right:\\n                #Recurse Right\\n                return s + self.count*self.val + self.right.ksmallest(k - self.count)\\n            else:\\n                #Return Search Failure\\n                return None\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1152701,
                "title": "java-solution-priorityqueue-lazy-deletion-o-log-m-add-o-1-calculate-detailed-explanations",
                "content": "The structure of this solution may be a little complex, but easy to understand. Here, I keep 4 priority_queues to record the smallest k elements, (m -k*2) elments in middle window and the largest k elements. For each operation, I just need to check which priority_queue the queue_in number and queue_out number locates, and conduct the transmission process. Here is a demonstration figure for this solution.\\n![image](https://assets.leetcode.com/users/images/49697ece-380c-483d-9f71-34f11353621f_1618116262.3197303.png)\\nSince priority_queue cannot directly delete a specific element, here I employ a lazy deletetion technique. Everytime I want to delete an element from a priority_queue, I use a hash table to record the elements required to delete. When I want to poll an element from such priority_queue, I would first do the deletion process if the top element of such priority_queue is contained in the delete table.\\n\\nHere take the sample example to explaine the process.\\nInput\\n[\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\\nOutput\\n[null, null, null, -1, null, 3, null, null, null, 5]\\nSteps:\\n1. Initial: left_maxHeap: [], middle_minHeap: [], middle_maxHeap: [], right_minHeap: [], sum : 0, vals_queue: []\\n2. Add 3: left_maxHeap: [], middle_minHeap: [], middle_maxHeap: [], right_minHeap: [], sum : 0, vals_queue: [3]\\n3. Add 1: left_maxHeap: [], middle_minHeap: [], middle_maxHeap: [], right_minHeap: [], sum : 0, vals_queue: [3, 1]\\n4. Calculate: Since size(vals_queue) < m, return -1;\\n5. Add 1: left_maxHeap: [], middle_minHeap: [], middle_maxHeap: [], right_minHeap: [], sum : 0, vals_queue: [3, 1, 10]\\n\\t* Since size(vals_queue) == m, initialize all the priority_queues. left_maxHeap: [1], middle_minHeap: [3], middle_maxHeap: [3], right_minHeap: [10], sum : 3, vals_queue: [3, 1, 10]\\n6. Calculate: return sum / (m - 2k) = 3\\n7. Add 5: vals_queue: [3, 1, 10, 5]. Required to poll 3 from left.\\n\\t* \\tPoll 3: Since 3 is located in middle priority_queue, just delete it from middle_minHeap and middle_maxHeap. Update the sum = 0.\\n\\t* \\tAdd 5: Since 5 is also located in middle priority_queue, just add it to middle_minHeap and middle_maxHeap. Update the sum = 5.\\n\\t* \\tleft_maxHeap: [1], middle_minHeap: [5], middle_maxHeap: [5], right_minHeap: [10], vals_queue: [1, 10, 5], sum: 5.\\n8. Add 5: vals_queue: [1, 10, 5, 5]. Required to poll 1 from left.\\n\\t*  Poll 1: Since 1 is located in left priority_queue, delete it from left priority_queue and transmit the smallest value from middle_minHeap to the left priority_queue. Here remember this value also needed to be deleted from the middle_maxHeap to syncronize. Update the sum = 0.\\n\\t*  Add 5: Since 5 is located in left priority_queue, first transmit the largest value from left priority_queue to the middle priority_queues and add 5 to the left priority_queue. Update the sum = 5.\\n\\t*  left_maxHeap: [5], middle_minHeap: [5], middle_maxHeap: [5], right_minHeap: [10], vals_queue: [10, 5, 5], sum: 5.\\n9. Add 5: vals_queue: [10, 5, 5, 5]. Required to poll 10 from left.\\n\\t*  Poll 10: Since 10 is located in right priority_queue, delete it from right priority_queue and transmit the largest value from middle_maxHeap to the right priority_queue. Here remember this value also needed to be deleted from the middle_minHeap to syncronize. Update the sum = 0.\\n\\t*  Add 5: Since 5 is located in left (right, either is ok) priority_queue, first transmit the largest value from left priority_queue to the middle priority_queues and add 5 to the left priority_queue. Update the sum = 5.\\n\\t*  left_maxHeap: [5], middle_minHeap: [5], middle_maxHeap: [5], right_minHeap: [5], vals_queue: [5, 5, 5], sum: 5.\\n10. Calculate: return sum / (m - 2k) = 5\\n\\nFor each add operation (despite the initialization), I do 2 priority_queue manipulation process which would cost O(log m) time. The lazy deletion process can be amortized to all add operations which should only cost O(1) time in average.\\nFor each calculation operation, it cost O(1) time.\\n\\nIt it helps you, please upvote. Thanks!\\n\\n```java\\nclass MKAverage {\\n    PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> b - a);\\n    PriorityQueue<Integer> right = new PriorityQueue<>((a, b) -> a - b);\\n    PriorityQueue<Integer> minMiddle = new PriorityQueue<>((a, b) -> a - b);\\n    PriorityQueue<Integer> maxMiddle = new PriorityQueue<>((a, b) -> b - a);\\n    Queue<Integer> vals = new LinkedList<>();\\n    Map<Integer, Integer> deleteLeft = new HashMap<>(), deleteRight = new HashMap<>(), deleteMinMiddle = new HashMap<>(), deleteMaxMiddle = new HashMap<>();\\n    \\n    long sum;\\n    int m, k;\\n    boolean flag;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        sum = 0;\\n        flag = false;\\n    }\\n    \\n    public void addElement(int num) {\\n        vals.offer(num);\\n        \\n        if (!flag && vals.size() == m) {\\n            initialize();\\n            flag = true;\\n        }\\n        else if (flag) {\\n            int lv = vals.poll();\\n            update(left, deleteLeft);\\n            update(right, deleteRight);\\n            if (!left.isEmpty() && left.peek() >= lv) {\\n                update(minMiddle, deleteMinMiddle);\\n                int v = minMiddle.poll();\\n                deleteMaxMiddle.put(v, deleteMaxMiddle.getOrDefault(v, 0) + 1);\\n                left.offer(v);\\n                deleteLeft.put(lv, deleteLeft.getOrDefault(lv, 0) + 1);\\n                sum -= v;\\n            }\\n            else if (!right.isEmpty() && right.peek() <= lv) {\\n                update(maxMiddle, deleteMaxMiddle);\\n                int v = maxMiddle.poll();\\n                deleteMinMiddle.put(v, deleteMinMiddle.getOrDefault(v, 0) + 1);\\n                right.offer(v);\\n                deleteRight.put(lv, deleteRight.getOrDefault(lv, 0) + 1);\\n                sum -= v;\\n            }\\n            else {\\n                deleteMinMiddle.put(lv, deleteMinMiddle.getOrDefault(lv, 0) + 1);\\n                deleteMaxMiddle.put(lv, deleteMaxMiddle.getOrDefault(lv, 0) + 1);\\n                sum -= lv;\\n            }\\n            \\n            update(left, deleteLeft);\\n            update(right, deleteRight);\\n            if (!left.isEmpty() && left.peek() >= num) {\\n                int v = left.poll();\\n                minMiddle.offer(v);\\n                maxMiddle.offer(v);\\n                left.offer(num);\\n                sum += v;\\n            }\\n            else if (!right.isEmpty() && right.peek() <= num) {\\n                int v = right.poll();\\n                minMiddle.offer(v);\\n                maxMiddle.offer(v);\\n                right.offer(num);\\n                sum += v;\\n            }\\n            else {\\n                minMiddle.offer(num);\\n                maxMiddle.offer(num);\\n                sum += num;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        // System.out.println(sum);\\n        return flag? (int)(sum / (m - 2 * k)) : -1;\\n    }\\n    \\n    private void initialize() {\\n        int i;\\n        for (i = 0; i < m; ++i) {\\n            int v = vals.poll();\\n            minMiddle.offer(v);\\n            maxMiddle.offer(v);\\n            sum += v;\\n            vals.offer(v);\\n        }\\n        i = 0;\\n        while (i < k) {\\n            update(minMiddle, deleteMinMiddle);\\n            int v = minMiddle.poll();\\n            left.offer(v);\\n            deleteMaxMiddle.put(v, deleteMaxMiddle.getOrDefault(v, 0) + 1);\\n            sum -= v;\\n            i ++;\\n        }\\n        \\n        i = 0;\\n        while (i < k) {\\n            update(maxMiddle, deleteMaxMiddle);\\n            int v = maxMiddle.poll();\\n            right.offer(v);\\n            deleteMinMiddle.put(v, deleteMinMiddle.getOrDefault(v, 0) + 1);\\n            sum -= v;\\n            i ++;\\n        }\\n    }\\n    \\n    private void update(PriorityQueue<Integer> pq, Map<Integer, Integer> delete) {\\n        while (!pq.isEmpty() && delete.containsKey(pq.peek()) && delete.get(pq.peek()) > 0) {\\n            int v = pq.poll();\\n            delete.put(v, delete.get(v) - 1);\\n            if (delete.get(v) == 0)\\n                delete.remove(v);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass MKAverage {\\n    PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> b - a);\\n    PriorityQueue<Integer> right = new PriorityQueue<>((a, b) -> a - b);\\n    PriorityQueue<Integer> minMiddle = new PriorityQueue<>((a, b) -> a - b);\\n    PriorityQueue<Integer> maxMiddle = new PriorityQueue<>((a, b) -> b - a);\\n    Queue<Integer> vals = new LinkedList<>();\\n    Map<Integer, Integer> deleteLeft = new HashMap<>(), deleteRight = new HashMap<>(), deleteMinMiddle = new HashMap<>(), deleteMaxMiddle = new HashMap<>();\\n    \\n    long sum;\\n    int m, k;\\n    boolean flag;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        sum = 0;\\n        flag = false;\\n    }\\n    \\n    public void addElement(int num) {\\n        vals.offer(num);\\n        \\n        if (!flag && vals.size() == m) {\\n            initialize();\\n            flag = true;\\n        }\\n        else if (flag) {\\n            int lv = vals.poll();\\n            update(left, deleteLeft);\\n            update(right, deleteRight);\\n            if (!left.isEmpty() && left.peek() >= lv) {\\n                update(minMiddle, deleteMinMiddle);\\n                int v = minMiddle.poll();\\n                deleteMaxMiddle.put(v, deleteMaxMiddle.getOrDefault(v, 0) + 1);\\n                left.offer(v);\\n                deleteLeft.put(lv, deleteLeft.getOrDefault(lv, 0) + 1);\\n                sum -= v;\\n            }\\n            else if (!right.isEmpty() && right.peek() <= lv) {\\n                update(maxMiddle, deleteMaxMiddle);\\n                int v = maxMiddle.poll();\\n                deleteMinMiddle.put(v, deleteMinMiddle.getOrDefault(v, 0) + 1);\\n                right.offer(v);\\n                deleteRight.put(lv, deleteRight.getOrDefault(lv, 0) + 1);\\n                sum -= v;\\n            }\\n            else {\\n                deleteMinMiddle.put(lv, deleteMinMiddle.getOrDefault(lv, 0) + 1);\\n                deleteMaxMiddle.put(lv, deleteMaxMiddle.getOrDefault(lv, 0) + 1);\\n                sum -= lv;\\n            }\\n            \\n            update(left, deleteLeft);\\n            update(right, deleteRight);\\n            if (!left.isEmpty() && left.peek() >= num) {\\n                int v = left.poll();\\n                minMiddle.offer(v);\\n                maxMiddle.offer(v);\\n                left.offer(num);\\n                sum += v;\\n            }\\n            else if (!right.isEmpty() && right.peek() <= num) {\\n                int v = right.poll();\\n                minMiddle.offer(v);\\n                maxMiddle.offer(v);\\n                right.offer(num);\\n                sum += v;\\n            }\\n            else {\\n                minMiddle.offer(num);\\n                maxMiddle.offer(num);\\n                sum += num;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        // System.out.println(sum);\\n        return flag? (int)(sum / (m - 2 * k)) : -1;\\n    }\\n    \\n    private void initialize() {\\n        int i;\\n        for (i = 0; i < m; ++i) {\\n            int v = vals.poll();\\n            minMiddle.offer(v);\\n            maxMiddle.offer(v);\\n            sum += v;\\n            vals.offer(v);\\n        }\\n        i = 0;\\n        while (i < k) {\\n            update(minMiddle, deleteMinMiddle);\\n            int v = minMiddle.poll();\\n            left.offer(v);\\n            deleteMaxMiddle.put(v, deleteMaxMiddle.getOrDefault(v, 0) + 1);\\n            sum -= v;\\n            i ++;\\n        }\\n        \\n        i = 0;\\n        while (i < k) {\\n            update(maxMiddle, deleteMaxMiddle);\\n            int v = maxMiddle.poll();\\n            right.offer(v);\\n            deleteMinMiddle.put(v, deleteMinMiddle.getOrDefault(v, 0) + 1);\\n            sum -= v;\\n            i ++;\\n        }\\n    }\\n    \\n    private void update(PriorityQueue<Integer> pq, Map<Integer, Integer> delete) {\\n        while (!pq.isEmpty() && delete.containsKey(pq.peek()) && delete.get(pq.peek()) > 0) {\\n            int v = pq.poll();\\n            delete.put(v, delete.get(v) - 1);\\n            if (delete.get(v) == 0)\\n                delete.remove(v);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152436,
                "title": "python-short-solution",
                "content": "**Warning: As the wonderful test cases have been updated, now the code gets TLE.**\\n\\nThis one is slightly outlandish as I use the `SortedList` from `sortedcontainers` class - it\\'s not part of standard library. With that said this container proves useful in several questions, such as \"1649. Create Sorted Array through Instructions\".\\n\\nAnyway, `SortedList` insertions are, well, sorted. So at any time you can find the desired average simply by `sum(self.slist[self.k:-self.k]) // (self.m - 2*self.k)`. We use a queue to keep the least recently used entries and remove when necessary. For that purpose the built-in removel tool of `SortedList` is fast.\\n\\n```python\\nimport collections\\nimport sortedcontainers\\nclass MKAverage:\\n    def __init__(self, m, k):\\n        self.m = m\\n        self.k = k\\n        self.que = collections.deque([])\\n        self.slist = sortedcontainers.SortedList()\\n        \\n\\n    def addElement(self, num):\\n        self.que.append(num)\\n        self.slist.add(num)\\n        if len(self.que) > self.m:\\n            lru = self.que.popleft()\\n            self.slist.remove(lru)\\n\\n            \\n    def calculateMKAverage(self):\\n        if len(self.que) < self.m:\\n            return -1\\n        return sum(self.slist[self.k:-self.k]) // (self.m - 2*self.k)\\n```",
                "solutionTags": [],
                "code": "```python\\nimport collections\\nimport sortedcontainers\\nclass MKAverage:\\n    def __init__(self, m, k):\\n        self.m = m\\n        self.k = k\\n        self.que = collections.deque([])\\n        self.slist = sortedcontainers.SortedList()\\n        \\n\\n    def addElement(self, num):\\n        self.que.append(num)\\n        self.slist.add(num)\\n        if len(self.que) > self.m:\\n            lru = self.que.popleft()\\n            self.slist.remove(lru)\\n\\n            \\n    def calculateMKAverage(self):\\n        if len(self.que) < self.m:\\n            return -1\\n        return sum(self.slist[self.k:-self.k]) // (self.m - 2*self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157928,
                "title": "binary-indexed-trees-bit-or-fenwick-tree-binary-lifting-logn-time-complexity",
                "content": "ref: https://leetcode-cn.com/circle/article/OeMXPy/\\nTwo properties of BIT:\\n(1) nodes[i] or sums[i] manages the sum in the range nums[i - i & (-i), i - 1].\\ne.g.\\nnodes[4] = nums[0] + nums[1] + nums[2] + nums[3]\\nnodes[6] = nums[4] + nums[5]\\n(2) parent(i) = i + i&(-i)\\n\\nAssuming we have added nums[0], ..., nums[7] to our tree. \\nThe following figure illustrates how BIT works.\\n![image](https://assets.leetcode.com/users/images/edd35b3f-d823-426d-9651-d4f410464cf1_1618455497.7438943.jpeg)\\n\\nref: https://leetcode.com/problems/finding-mk-average/discuss/1152438/Python3-Fenwick-tree\\nref: https://codeforces.com/blog/entry/61364\\n[Tutorial] Searching Binary Indexed Tree in O(log(N)) using Binary Lifting\\nmake use of binary lifting to achieve O(log(N)) for search_low_boundary\\nWhat is binary lifting?\\nIn binary lifting, a value is increased (or lifted) by powers of 2,\\nstarting with the highest possible power of 2 = 2^\\u230Alog(N)\\u230B, down to the lowest power, 2^0.\\n\\nHow binary lifting is used?\\nWe are trying to find pos, which is the position of lower bound of v in prefix sums array,\\nwhere v is the value we are searching for.\\nSo, we initialize pos = 0 and set each bit of pos, from most significant bit to least significant bit.\\nWhenever a bit is set to 1, the value of pos increases (or lifts).\\nWhile increasing or lifting pos, we make sure that prefix sum till pos should be less than v,\\nfor which we maintain the prefix sum and update it whenever we increase or lift pos.\\n\\n\\nTime:\\n    addElement: O(logN)\\n        N is the parameter of addElement\\n    calculateMKAverage: O(logM)\\n        M is the max_num = 10^5\\n        search_low_boundary takes O(logM)\\n        each BinaryIndexTree.query takes O(logM) and there are four queries in total.\\nSpace: O(M)\\n    M is the max_num = 10^5\\n    \\nSimilar Questions:\\n307. Range Sum Query - Mutable\\n308. Range Sum Query 2D - Mutable\\n1619. Mean of Array After Removing Some Elements\\n1825. Finding MK Average\\n\\n\\n```\\n\\nimport math\\nfrom collections import deque\\n\\n\\nclass BinaryIndexTree:\\n    def __init__(self, n: int):\\n        self.leng = n + 1\\n        \"\"\"\\n        i is the number, nodes[i] = sum(nums[i - i & (-i), i - 1]), \\n        nums is the original array\\n        e.g.: https://pic.leetcode-cn.com/755dd21358e8cd6ac39c85bdbaa67188dcf67dad7bd8c32d4ad777c1f376ff08-binaryindexedtreeexpandedtreewithinfo.gif\\n        \"\"\"\\n        self.nodes = [0] * self.leng\\n\\n    def query(self, i: int) -> int:\\n        \"\"\"\\n        i is a number\\n        return the sum of numbers that is less than or equal to,\\n        which is equivalent to the sum of logN ranges (\\u7B49\\u4E8Ei\\u4EE3\\u8868\\u7684logi\\u4E2A\\u533A\\u95F4\\u7684\\u603B\\u548C\\u3002)\\n        \"\"\"\\n        ans = 0\\n        while i:\\n            ans += self.nodes[i]\\n            i -= i & -i  # remove the lowbit of i\\n        return ans\\n\\n    def update(self, i: int, delta: int) -> None:\\n        while i < self.leng:\\n            self.nodes[i] += delta\\n            # parent(i) = i + i&(-i), i&(-i) is the lowbit of i,\\n            # e.g. i = 10, 10 = (1100)2, lowbit(1100_2) = 100_2\\n            i += i & -i\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        \"\"\"\\n        Constraints:\\n            3 <= m <= 105\\n            1 <= k*2 < m\\n            1 <= num <= 105\\n            At most 105 calls will be made to addElement and calculateMKAverage.\\n        \"\"\"\\n        self.max_num = 10 ** 5\\n        self.m = m\\n        self.k = k\\n        # self.queue_len_limit = m - 2 * k\\n        self.queue = deque([])\\n        \"\"\"\\n        self.value_tree.query(num) = the sum of the number which <= num\\n        self.count_tree.query(num) = the count of the number which <=num\\n        \"\"\"\\n        self.value_tree = BinaryIndexTree(self.max_num)\\n        self.count_tree = BinaryIndexTree(self.max_num)\\n\\n        self.remaining_cnt = m - 2 * k\\n        self.MKAverage = None  # avoid repetitive computing for MKAverage\\n\\n    def addElement(self, num: int) -> None:\\n        self.value_tree.update(num, num)\\n        self.count_tree.update(num, 1)\\n        self.queue.append(num)\\n        if len(self.queue) > self.m:\\n            removed_num = self.queue.popleft()\\n            self.value_tree.update(removed_num, -removed_num)\\n            self.count_tree.update(removed_num, -1)\\n\\n        self.MKAverage = None  # avoid recomputing MKAverage if no new number added\\n\\n    def search_low_boundary(self, count: int) -> int:\\n        \"\"\"\\n        search the minimum num that makes self.count_tree.query(num) >= count\\n        \\u5373self.queue\\u4E2D\\u5C0F\\u4E8E\\u7B49\\u4E8Enum\\u7684\\u6570\\u81F3\\u5C11\\u6709count\\u4E2A\\n        e.g, input 1,\\n        self.value_tree.nodes = [0, 1, 3, 3, 10, 5, 11, 7, 36]\\n        self.count_tree.nodes = [0, 1, 2, 1, 4, 1, 2, 1, 8]\\n        self.max_num = 8\\n        i, low_boundary_num, prefix_sum\\n        3,   0,     0\\n        2,   0,     0\\n        1,   2,     2\\n        0,   2,     2\\n\\n        low_boundary_num = 2, low_boundary_num + 1 = 3,\\n        so search_low_boundary(3) = 3 means the minimum num that makes self.count_tree.query(num) >= 3\\n        \"\"\"\\n        # there are prefix_sum numbers that are less than count\\n        low_boundary_num, prefix_sum = 0, 0\\n        # self.max_num + 1 \\u662Fself.count_tree.sums\\u7684\\u957F\\u5EA6\\n        for i in range(int(math.log2(self.max_num + 1)), -1, -1):\\n            low_boundary_num2 = low_boundary_num + (1 << i)\\n            # print(i, low_boundary_num, prefix_sum, low_boundary_num2)\\n\\n            if low_boundary_num2 <= self.max_num and prefix_sum + self.count_tree.nodes[low_boundary_num2] < count:\\n                prefix_sum += self.count_tree.nodes[low_boundary_num2]\\n                low_boundary_num = low_boundary_num2\\n\\n        # +1 because \\'low_boundary_num\\' will have position of largest value less than \\'count\\'\\n        return low_boundary_num + 1\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue) < self.m:\\n            return -1\\n        if self.MKAverage is not None:\\n            return self.MKAverage\\n        low_num, high_num = self.search_low_boundary(self.k), self.search_low_boundary(self.m - self.k)\\n        num_sum = self.value_tree.query(high_num) - self.value_tree.query(low_num)\\n        \"\"\"\\n        https://leetcode.com/problems/finding-mk-average/discuss/1152438/Python3-Fenwick-tree/903394\\n        Because probably there are more than k number that is less than or equal to low_num, \\n        and there are more than m-k number that is less than or equal to high_num, we have to make some adjustments.\\n        \\u5373\\u6709\\u7684\\u6570\\u591A\\u51CF\\u4E86, \\u6709\\u7684\\u6570\\u5C11\\u51CF\\u4E86\\u3002\\u9700\\u8981\\u91CD\\u65B0\\u8C03\\u6574\\n        e.g. m = 6, k = 2, nums = [1,2,2,3,3,4]\\n        prefix_sum = [0,1,3,5,6] prefix_sum[i] \\u8868\\u793A <= i\\u7684\\u6570\\u7684\\u4E2A\\u6570\\n        k1 = k, k2 = m - k = 4\\n        -> prefix_sum[lo=2]=3>=k1=2\\n        -> prefix_sum[hi=3]=5>=k2=4\\n        -> values_tree.query(hi)-values_tree.query(lo) = sum([1,2,2,3,3]) - sum([1,2,2]) = sum([3,3])\\n        But the actual solution here is sum([2,3]), we need to remove a 3 and add back a 2.\\n        \"\"\"\\n        num_sum += (self.count_tree.query(low_num) - self.k) * low_num\\n        num_sum -= (self.count_tree.query(high_num) - (self.m - self.k)) * high_num\\n\\n        # rounded down to the nearest integer\\n        self.MKAverage = num_sum // self.remaining_cnt\\n        return self.MKAverage\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nimport math\\nfrom collections import deque\\n\\n\\nclass BinaryIndexTree:\\n    def __init__(self, n: int):\\n        self.leng = n + 1\\n        \"\"\"\\n        i is the number, nodes[i] = sum(nums[i - i & (-i), i - 1]), \\n        nums is the original array\\n        e.g.: https://pic.leetcode-cn.com/755dd21358e8cd6ac39c85bdbaa67188dcf67dad7bd8c32d4ad777c1f376ff08-binaryindexedtreeexpandedtreewithinfo.gif\\n        \"\"\"\\n        self.nodes = [0] * self.leng\\n\\n    def query(self, i: int) -> int:\\n        \"\"\"\\n        i is a number\\n        return the sum of numbers that is less than or equal to,\\n        which is equivalent to the sum of logN ranges (\\u7B49\\u4E8Ei\\u4EE3\\u8868\\u7684logi\\u4E2A\\u533A\\u95F4\\u7684\\u603B\\u548C\\u3002)\\n        \"\"\"\\n        ans = 0\\n        while i:\\n            ans += self.nodes[i]\\n            i -= i & -i  # remove the lowbit of i\\n        return ans\\n\\n    def update(self, i: int, delta: int) -> None:\\n        while i < self.leng:\\n            self.nodes[i] += delta\\n            # parent(i) = i + i&(-i), i&(-i) is the lowbit of i,\\n            # e.g. i = 10, 10 = (1100)2, lowbit(1100_2) = 100_2\\n            i += i & -i\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        \"\"\"\\n        Constraints:\\n            3 <= m <= 105\\n            1 <= k*2 < m\\n            1 <= num <= 105\\n            At most 105 calls will be made to addElement and calculateMKAverage.\\n        \"\"\"\\n        self.max_num = 10 ** 5\\n        self.m = m\\n        self.k = k\\n        # self.queue_len_limit = m - 2 * k\\n        self.queue = deque([])\\n        \"\"\"\\n        self.value_tree.query(num) = the sum of the number which <= num\\n        self.count_tree.query(num) = the count of the number which <=num\\n        \"\"\"\\n        self.value_tree = BinaryIndexTree(self.max_num)\\n        self.count_tree = BinaryIndexTree(self.max_num)\\n\\n        self.remaining_cnt = m - 2 * k\\n        self.MKAverage = None  # avoid repetitive computing for MKAverage\\n\\n    def addElement(self, num: int) -> None:\\n        self.value_tree.update(num, num)\\n        self.count_tree.update(num, 1)\\n        self.queue.append(num)\\n        if len(self.queue) > self.m:\\n            removed_num = self.queue.popleft()\\n            self.value_tree.update(removed_num, -removed_num)\\n            self.count_tree.update(removed_num, -1)\\n\\n        self.MKAverage = None  # avoid recomputing MKAverage if no new number added\\n\\n    def search_low_boundary(self, count: int) -> int:\\n        \"\"\"\\n        search the minimum num that makes self.count_tree.query(num) >= count\\n        \\u5373self.queue\\u4E2D\\u5C0F\\u4E8E\\u7B49\\u4E8Enum\\u7684\\u6570\\u81F3\\u5C11\\u6709count\\u4E2A\\n        e.g, input 1,\\n        self.value_tree.nodes = [0, 1, 3, 3, 10, 5, 11, 7, 36]\\n        self.count_tree.nodes = [0, 1, 2, 1, 4, 1, 2, 1, 8]\\n        self.max_num = 8\\n        i, low_boundary_num, prefix_sum\\n        3,   0,     0\\n        2,   0,     0\\n        1,   2,     2\\n        0,   2,     2\\n\\n        low_boundary_num = 2, low_boundary_num + 1 = 3,\\n        so search_low_boundary(3) = 3 means the minimum num that makes self.count_tree.query(num) >= 3\\n        \"\"\"\\n        # there are prefix_sum numbers that are less than count\\n        low_boundary_num, prefix_sum = 0, 0\\n        # self.max_num + 1 \\u662Fself.count_tree.sums\\u7684\\u957F\\u5EA6\\n        for i in range(int(math.log2(self.max_num + 1)), -1, -1):\\n            low_boundary_num2 = low_boundary_num + (1 << i)\\n            # print(i, low_boundary_num, prefix_sum, low_boundary_num2)\\n\\n            if low_boundary_num2 <= self.max_num and prefix_sum + self.count_tree.nodes[low_boundary_num2] < count:\\n                prefix_sum += self.count_tree.nodes[low_boundary_num2]\\n                low_boundary_num = low_boundary_num2\\n\\n        # +1 because \\'low_boundary_num\\' will have position of largest value less than \\'count\\'\\n        return low_boundary_num + 1\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue) < self.m:\\n            return -1\\n        if self.MKAverage is not None:\\n            return self.MKAverage\\n        low_num, high_num = self.search_low_boundary(self.k), self.search_low_boundary(self.m - self.k)\\n        num_sum = self.value_tree.query(high_num) - self.value_tree.query(low_num)\\n        \"\"\"\\n        https://leetcode.com/problems/finding-mk-average/discuss/1152438/Python3-Fenwick-tree/903394\\n        Because probably there are more than k number that is less than or equal to low_num, \\n        and there are more than m-k number that is less than or equal to high_num, we have to make some adjustments.\\n        \\u5373\\u6709\\u7684\\u6570\\u591A\\u51CF\\u4E86, \\u6709\\u7684\\u6570\\u5C11\\u51CF\\u4E86\\u3002\\u9700\\u8981\\u91CD\\u65B0\\u8C03\\u6574\\n        e.g. m = 6, k = 2, nums = [1,2,2,3,3,4]\\n        prefix_sum = [0,1,3,5,6] prefix_sum[i] \\u8868\\u793A <= i\\u7684\\u6570\\u7684\\u4E2A\\u6570\\n        k1 = k, k2 = m - k = 4\\n        -> prefix_sum[lo=2]=3>=k1=2\\n        -> prefix_sum[hi=3]=5>=k2=4\\n        -> values_tree.query(hi)-values_tree.query(lo) = sum([1,2,2,3,3]) - sum([1,2,2]) = sum([3,3])\\n        But the actual solution here is sum([2,3]), we need to remove a 3 and add back a 2.\\n        \"\"\"\\n        num_sum += (self.count_tree.query(low_num) - self.k) * low_num\\n        num_sum -= (self.count_tree.query(high_num) - (self.m - self.k)) * high_num\\n\\n        # rounded down to the nearest integer\\n        self.MKAverage = num_sum // self.remaining_cnt\\n        return self.MKAverage\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152796,
                "title": "c-2-methods-segment-tree-heaps",
                "content": "The core of this problem is:\\n\\n> How to find the sum of the smallest/biggest 1~k th numbers in an array?\\n\\nSegment tree can do this in `O(nlogn)` time.\\n\\nWe can keep a segment tree which stores the information about: \"For a given value x, how many x are there in the array?\".\\n\\nFor example the current array is `[3,1,10,5,5]`, then the tree node for value `5` will have a `cnt = 2`. To further speed up the code, we can keep an extra `sum` in the tree node. \\n\\nTo be more precise, if a tree node tells about the information of `[l,r]`, then the `cnt` and `sum` implies:\\n`cnt` is the number of elements `x`, where `l <= x <= r`.\\n`sum` is the **sum of elements** `x`, where `l <= x <= r`.\\n\\nNow we can easily query about the sum of first `k-th` smallest and biggest elements. \\n\\n<hr>\\n\\n```cpp\\n#define maxn (100005<<2)\\n#define ll long long\\nstruct node {\\n    int cnt;\\n    ll sum;\\n} tr[maxn];\\n\\nvoid push_up(int cur) {\\n    tr[cur].cnt = tr[cur<<1].cnt + tr[cur<<1|1].cnt;\\n    tr[cur].sum = tr[cur<<1].sum + tr[cur<<1|1].sum;\\n}\\n\\nvoid update(int cur, int l, int r, int p, int x) {\\n    if (l == r) {\\n        tr[cur].sum += (ll)(x * p);\\n        tr[cur].cnt += x;\\n        return;\\n    }\\n    int mid = (l+r) >> 1;\\n    if (p <= mid) update(cur<<1, l, mid, p, x);\\n    else update(cur<<1|1, mid+1, r, p, x);\\n    push_up(cur);\\n}\\n\\n// return the sum of the smallest 1~kth numbers\\nll query_small(int cur, int l, int r, int k) {\\n    if (k <= 0) return 0;\\n    if (tr[cur].cnt <= k) return tr[cur].sum;\\n    if (l == r) {\\n        return (ll)(l) * (ll)(k);  // for example [5,5,5], k = 1, only return 5, not 15\\n    }\\n    int mid = (l+r) >> 1;\\n    ll res = 0;\\n    res += query_small(cur<<1, l, mid, k);\\n    res += query_small(cur<<1|1, mid+1, r, k-tr[cur<<1].cnt);\\n    return res;\\n}\\n\\n// return the sum of the biggest 1~kth numbers\\nll query_big(int cur, int l, int r, int k) {\\n    if (k <= 0) return 0;\\n    if (tr[cur].cnt <= k) return tr[cur].sum;\\n    if (l == r) {\\n        return (ll)(l) * (ll)(k);  // for example [5,5,5], k = 1, only return 5, not 15\\n    }\\n    int mid = (l+r) >> 1;\\n    ll res = 0;\\n    res += query_big(cur<<1, l, mid, k-tr[cur<<1|1].cnt);\\n    res += query_big(cur<<1|1, mid+1, r, k);\\n    return res;\\n}\\n\\nclass MKAverage {\\npublic:\\n    int m,k;\\n    vector<int> vec;\\n    ll sum = 0;\\n    int de;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        de = m-2*k;\\n        memset(tr, 0, sizeof(tr));\\n    }\\n            \\n    void addElement(int num) {\\n        vec.push_back(num);\\n        sum += (ll)(num);\\n        int n = vec.size();\\n        update(1, 1, 1e5, num, 1);\\n        \\n        if (n > m) {\\n            int cur = vec[n-m-1];\\n            sum -= cur;\\n            update(1, 1, 1e5, cur, -1);\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (vec.size() < m) return -1;\\n        ll res = query_small(1, 1, 1e5, k) + query_big(1, 1, 1e5, k);\\n        return (sum - res) / de;\\n    }\\n};\\n```\\n\\n<hr>\\n\\nSome sidenotes:\\n\\nSegment tree can also solve the following problems:\\n\\n1. Find the `k` th smallest element in an array.\\n2. Find the number of pairs `(i,j)` such that `arr[i] > arr[j]`.\\n3. Find the maximum **unique** element in a sliding window. (https://codeforces.com/problemset/problem/69/E).\\n\\nPlease see my blog (Chinese only) for Segment tree: https://tom0727.gitee.io/post/035-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91/\\n\\nIf you are interested, you can also learn about **Persistent Segment Tree**, which can solve problems like:\\n\\n1. Find the `k` th smallest element in **any segment** of an array.\\n2. Answer queries about **any history version** of an array.\\n3. Find the **LCM** of any segments of an array. (https://codeforces.com/problemset/problem/1422/F)\\n4. In a **tree (n vertices, n-1 edges, connected graph)**, where every edge has a weight, find the `k`th smallest weight in the shortest path between `u,v`.\\n\\nPlease see my blog (Chinese only) for Persistent Segment tree: https://tom0727.gitee.io/post/036-%E4%B8%BB%E5%B8%AD%E6%A0%91/\\n\\n\\n\\n<hr>\\n\\nThe second method is using 3 heaps. Others have explained that solution well enough. I will only post my code here:\\n\\n```cpp\\nclass MKAverage {\\npublic:\\n    #define ll long long\\n    int m,k;\\n    vector<int> vec;\\n    multiset<int> small, mid, big;\\n    ll sum = 0;\\n    int de;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        de = m-2*k;\\n    }\\n\\t\\n    void addElement(int num) {\\n        vec.push_back(num);\\n        sum += (ll)(num);\\n        mid.insert(num);\\n        int n = vec.size();\\n        if (n < m) return;\\n        \\n        if (n == m) {\\n            for (int i = 0; i < k; i++) {\\n                auto itr = prev(mid.end());\\n                int cur = *itr;\\n                big.insert(cur);\\n                mid.erase(itr);\\n                sum -= cur;\\n            }\\n            for (int i = 0; i < k; i++) {\\n                auto itr = mid.begin();\\n                int cur = *itr;\\n                small.insert(cur);\\n                mid.erase(itr);\\n                sum -= cur;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if (n > m) {\\n            int cur = vec[n-m-1];\\n            if (small.count(cur)) {\\n                small.erase(small.find(cur));\\n            } else if (big.count(cur)) {\\n                big.erase(big.find(cur));\\n            } else if (mid.count(cur)) {\\n                sum -= cur;\\n                mid.erase(mid.find(cur));\\n            }\\n        }\\n        \\n        if (small.size() < k) {\\n            auto itr = mid.begin();\\n            int cur = *itr;\\n            sum -= cur;\\n            small.insert(cur);\\n            mid.erase(itr);\\n        }\\n        if (big.size() < k) {\\n            auto itr = prev(mid.end());\\n            int cur = *itr;\\n            sum -= cur;\\n            big.insert(cur);\\n            mid.erase(itr);\\n        }\\n        \\n        while (*prev(small.end()) > *mid.begin()) {\\n            auto itr1 = prev(small.end());\\n            auto itr2 = mid.begin();\\n            int cur1 = *itr1, cur2 = *itr2;\\n            small.erase(itr1); mid.erase(itr2);\\n            small.insert(cur2); mid.insert(cur1);\\n            sum -= cur2, sum += cur1;\\n        }\\n        \\n        while (*big.begin() < *prev(mid.end())) {\\n            auto itr1 = big.begin();\\n            auto itr2 = prev(mid.end());\\n            int cur1 = *itr1, cur2 = *itr2;\\n            big.erase(itr1); mid.erase(itr2);\\n            big.insert(cur2); mid.insert(cur1);\\n            sum -= cur2, sum += cur1;\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (vec.size() < m) return -1;\\n        return sum / de;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n#define maxn (100005<<2)\\n#define ll long long\\nstruct node {\\n    int cnt;\\n    ll sum;\\n} tr[maxn];\\n\\nvoid push_up(int cur) {\\n    tr[cur].cnt = tr[cur<<1].cnt + tr[cur<<1|1].cnt;\\n    tr[cur].sum = tr[cur<<1].sum + tr[cur<<1|1].sum;\\n}\\n\\nvoid update(int cur, int l, int r, int p, int x) {\\n    if (l == r) {\\n        tr[cur].sum += (ll)(x * p);\\n        tr[cur].cnt += x;\\n        return;\\n    }\\n    int mid = (l+r) >> 1;\\n    if (p <= mid) update(cur<<1, l, mid, p, x);\\n    else update(cur<<1|1, mid+1, r, p, x);\\n    push_up(cur);\\n}\\n\\n// return the sum of the smallest 1~kth numbers\\nll query_small(int cur, int l, int r, int k) {\\n    if (k <= 0) return 0;\\n    if (tr[cur].cnt <= k) return tr[cur].sum;\\n    if (l == r) {\\n        return (ll)(l) * (ll)(k);  // for example [5,5,5], k = 1, only return 5, not 15\\n    }\\n    int mid = (l+r) >> 1;\\n    ll res = 0;\\n    res += query_small(cur<<1, l, mid, k);\\n    res += query_small(cur<<1|1, mid+1, r, k-tr[cur<<1].cnt);\\n    return res;\\n}\\n\\n// return the sum of the biggest 1~kth numbers\\nll query_big(int cur, int l, int r, int k) {\\n    if (k <= 0) return 0;\\n    if (tr[cur].cnt <= k) return tr[cur].sum;\\n    if (l == r) {\\n        return (ll)(l) * (ll)(k);  // for example [5,5,5], k = 1, only return 5, not 15\\n    }\\n    int mid = (l+r) >> 1;\\n    ll res = 0;\\n    res += query_big(cur<<1, l, mid, k-tr[cur<<1|1].cnt);\\n    res += query_big(cur<<1|1, mid+1, r, k);\\n    return res;\\n}\\n\\nclass MKAverage {\\npublic:\\n    int m,k;\\n    vector<int> vec;\\n    ll sum = 0;\\n    int de;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        de = m-2*k;\\n        memset(tr, 0, sizeof(tr));\\n    }\\n            \\n    void addElement(int num) {\\n        vec.push_back(num);\\n        sum += (ll)(num);\\n        int n = vec.size();\\n        update(1, 1, 1e5, num, 1);\\n        \\n        if (n > m) {\\n            int cur = vec[n-m-1];\\n            sum -= cur;\\n            update(1, 1, 1e5, cur, -1);\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (vec.size() < m) return -1;\\n        ll res = query_small(1, 1, 1e5, k) + query_big(1, 1, 1e5, k);\\n        return (sum - res) / de;\\n    }\\n};\\n```\n```cpp\\nclass MKAverage {\\npublic:\\n    #define ll long long\\n    int m,k;\\n    vector<int> vec;\\n    multiset<int> small, mid, big;\\n    ll sum = 0;\\n    int de;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        de = m-2*k;\\n    }\\n\\t\\n    void addElement(int num) {\\n        vec.push_back(num);\\n        sum += (ll)(num);\\n        mid.insert(num);\\n        int n = vec.size();\\n        if (n < m) return;\\n        \\n        if (n == m) {\\n            for (int i = 0; i < k; i++) {\\n                auto itr = prev(mid.end());\\n                int cur = *itr;\\n                big.insert(cur);\\n                mid.erase(itr);\\n                sum -= cur;\\n            }\\n            for (int i = 0; i < k; i++) {\\n                auto itr = mid.begin();\\n                int cur = *itr;\\n                small.insert(cur);\\n                mid.erase(itr);\\n                sum -= cur;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if (n > m) {\\n            int cur = vec[n-m-1];\\n            if (small.count(cur)) {\\n                small.erase(small.find(cur));\\n            } else if (big.count(cur)) {\\n                big.erase(big.find(cur));\\n            } else if (mid.count(cur)) {\\n                sum -= cur;\\n                mid.erase(mid.find(cur));\\n            }\\n        }\\n        \\n        if (small.size() < k) {\\n            auto itr = mid.begin();\\n            int cur = *itr;\\n            sum -= cur;\\n            small.insert(cur);\\n            mid.erase(itr);\\n        }\\n        if (big.size() < k) {\\n            auto itr = prev(mid.end());\\n            int cur = *itr;\\n            sum -= cur;\\n            big.insert(cur);\\n            mid.erase(itr);\\n        }\\n        \\n        while (*prev(small.end()) > *mid.begin()) {\\n            auto itr1 = prev(small.end());\\n            auto itr2 = mid.begin();\\n            int cur1 = *itr1, cur2 = *itr2;\\n            small.erase(itr1); mid.erase(itr2);\\n            small.insert(cur2); mid.insert(cur1);\\n            sum -= cur2, sum += cur1;\\n        }\\n        \\n        while (*big.begin() < *prev(mid.end())) {\\n            auto itr1 = big.begin();\\n            auto itr2 = prev(mid.end());\\n            int cur1 = *itr1, cur2 = *itr2;\\n            big.erase(itr1); mid.erase(itr2);\\n            big.insert(cur2); mid.insert(cur1);\\n            sum -= cur2, sum += cur1;\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (vec.size() < m) return -1;\\n        return sum / de;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413698,
                "title": "java-one-treemap-and-deque-solution",
                "content": "- Maintain a deque so we can remove the `m+1` element. Maintain current sum and tot elements.\\n- Keep a treemap and remove `m+1` element on each `add`.\\n- To compute avg get low `k` elements, and top `k` elements, and subtract from current sum.\\n\\n```\\nclass MKAverage {\\n\\n    int tot = 0;\\n    int sum = 0;\\n    int m = 0;\\n    int k = 0;\\n    \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        deque.offerLast(num);\\n        map.put(num, map.getOrDefault(num, 0)+1);\\n        sum += num;\\n        tot++;\\n        if (tot > m) {\\n            int v = deque.pollFirst();\\n            sum -= v;\\n            tot--;\\n            int tot = map.get(v);\\n            if (tot == 1) map.remove(v);\\n            else map.put(v, tot-1);\\n        }\\n        \\n    }\\n    \\n    public int calculateMKAverage() {\\n       if (tot < m) return -1;\\n        int totLess = k;\\n        int s = sum;\\n        for (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n            if (totLess == 0) break;\\n            int v = Math.min(totLess, e.getValue());\\n            s -= e.getKey()*v;\\n            totLess -= v;\\n        }\\n        \\n        totLess = k;\\n        for (Map.Entry<Integer, Integer> e : map.descendingMap().entrySet()) {\\n            if (totLess == 0) break;\\n            int v = Math.min(totLess, e.getValue());\\n            s -= e.getKey()*v;\\n            totLess -= v;\\n        }\\n        \\n        return s/(tot-2*k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n\\n    int tot = 0;\\n    int sum = 0;\\n    int m = 0;\\n    int k = 0;\\n    \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        deque.offerLast(num);\\n        map.put(num, map.getOrDefault(num, 0)+1);\\n        sum += num;\\n        tot++;\\n        if (tot > m) {\\n            int v = deque.pollFirst();\\n            sum -= v;\\n            tot--;\\n            int tot = map.get(v);\\n            if (tot == 1) map.remove(v);\\n            else map.put(v, tot-1);\\n        }\\n        \\n    }\\n    \\n    public int calculateMKAverage() {\\n       if (tot < m) return -1;\\n        int totLess = k;\\n        int s = sum;\\n        for (Map.Entry<Integer, Integer> e : map.entrySet()) {\\n            if (totLess == 0) break;\\n            int v = Math.min(totLess, e.getValue());\\n            s -= e.getKey()*v;\\n            totLess -= v;\\n        }\\n        \\n        totLess = k;\\n        for (Map.Entry<Integer, Integer> e : map.descendingMap().entrySet()) {\\n            if (totLess == 0) break;\\n            int v = Math.min(totLess, e.getValue());\\n            s -= e.getKey()*v;\\n            totLess -= v;\\n        }\\n        \\n        return s/(tot-2*k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152674,
                "title": "java-treeset-easy-to-understand",
                "content": "```\\nclass MKAverage {\\n    TreeSet<Long> small, medium, large;\\n    Queue<Long> queue;\\n    long sum = 0;\\n    int m, k, total;\\n    long ind = 0;\\n    public MKAverage(int m, int k) {\\n        queue = new ArrayDeque();\\n        small = new TreeSet();\\n        large = new TreeSet();\\n        medium = new TreeSet();\\n        this.m = m;\\n        this.k = k;\\n        total = m - 2*k;\\n    }\\n    \\n    // each operation at O(logn)\\n    public void addElement(int num) {\\n        ind ++;\\n        long n = num*1000000L+ind;\\n        if(queue.size() < m){\\n            queue.add(n);\\n            \\n            //one time operation - O(nlogn)\\n            if(queue.size() == m){\\n                List<Long> al = new ArrayList(queue);\\n                Collections.sort(al);\\n                for(int i=0;i<k;i++){\\n                    small.add(al.get(i));\\n                }\\n                for(int i=k;i<al.size()-k;i++){\\n                    sum += al.get(i);\\n                    medium.add(al.get(i));\\n                }\\n                for(int i=al.size()-k;i<al.size();i++){\\n                    large.add(al.get(i));\\n                }\\n            }\\n        }else{\\n            long val = queue.poll();\\n            queue.add(n);\\n            \\n            long mFirst = medium.first();\\n            long mLast = medium.last();\\n            if(medium.contains(val)){\\n                medium.remove(val);\\n                sum -= val;\\n            }else if(small.contains(val)){\\n                small.remove(val);\\n            }else{\\n                large.remove(val);\\n            }\\n            \\n            if(n < mFirst){\\n                small.add(n);\\n            }else if(n > mFirst && n < mLast){\\n                medium.add(n);\\n                sum += n;\\n            }else{\\n                large.add(n);\\n            }\\n            \\n            if(large.size() == k+1){\\n                long largeFirst = large.first();\\n                large.remove(largeFirst);\\n                medium.add(largeFirst);\\n                sum += largeFirst;\\n            }\\n            if(small.size() == k+1){\\n                long smallLast = small.last();\\n                small.remove(smallLast);\\n                medium.add(smallLast);\\n                sum += smallLast;\\n            }\\n            if(small.size() == k-1){\\n                long mediumFirst = medium.first();\\n                small.add(mediumFirst);\\n                medium.remove(mediumFirst);\\n                sum -= mediumFirst;\\n            }\\n            if(large.size() == k-1){\\n                long mediumLast = medium.last();\\n                medium.remove(mediumLast);\\n                large.add(mediumLast);\\n                sum -= mediumLast;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size() < m){\\n            return -1;\\n        }\\n        return (int)(sum/(1000000L*total)); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    TreeSet<Long> small, medium, large;\\n    Queue<Long> queue;\\n    long sum = 0;\\n    int m, k, total;\\n    long ind = 0;\\n    public MKAverage(int m, int k) {\\n        queue = new ArrayDeque();\\n        small = new TreeSet();\\n        large = new TreeSet();\\n        medium = new TreeSet();\\n        this.m = m;\\n        this.k = k;\\n        total = m - 2*k;\\n    }\\n    \\n    // each operation at O(logn)\\n    public void addElement(int num) {\\n        ind ++;\\n        long n = num*1000000L+ind;\\n        if(queue.size() < m){\\n            queue.add(n);\\n            \\n            //one time operation - O(nlogn)\\n            if(queue.size() == m){\\n                List<Long> al = new ArrayList(queue);\\n                Collections.sort(al);\\n                for(int i=0;i<k;i++){\\n                    small.add(al.get(i));\\n                }\\n                for(int i=k;i<al.size()-k;i++){\\n                    sum += al.get(i);\\n                    medium.add(al.get(i));\\n                }\\n                for(int i=al.size()-k;i<al.size();i++){\\n                    large.add(al.get(i));\\n                }\\n            }\\n        }else{\\n            long val = queue.poll();\\n            queue.add(n);\\n            \\n            long mFirst = medium.first();\\n            long mLast = medium.last();\\n            if(medium.contains(val)){\\n                medium.remove(val);\\n                sum -= val;\\n            }else if(small.contains(val)){\\n                small.remove(val);\\n            }else{\\n                large.remove(val);\\n            }\\n            \\n            if(n < mFirst){\\n                small.add(n);\\n            }else if(n > mFirst && n < mLast){\\n                medium.add(n);\\n                sum += n;\\n            }else{\\n                large.add(n);\\n            }\\n            \\n            if(large.size() == k+1){\\n                long largeFirst = large.first();\\n                large.remove(largeFirst);\\n                medium.add(largeFirst);\\n                sum += largeFirst;\\n            }\\n            if(small.size() == k+1){\\n                long smallLast = small.last();\\n                small.remove(smallLast);\\n                medium.add(smallLast);\\n                sum += smallLast;\\n            }\\n            if(small.size() == k-1){\\n                long mediumFirst = medium.first();\\n                small.add(mediumFirst);\\n                medium.remove(mediumFirst);\\n                sum -= mediumFirst;\\n            }\\n            if(large.size() == k-1){\\n                long mediumLast = medium.last();\\n                medium.remove(mediumLast);\\n                large.add(mediumLast);\\n                sum -= mediumLast;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size() < m){\\n            return -1;\\n        }\\n        return (int)(sum/(1000000L*total)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165609,
                "title": "c-and-multisets",
                "content": "```\\nclass MKAverage {\\n    queue<int> q;\\n    multiset<int> minheap;\\n    multiset<int> midheap;\\n    multiset<int> maxheap;\\n    int m;\\n    int k;\\n    int count;\\n    long sum;\\npublic:\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        count = 0;\\n        sum = 0;\\n    }\\n    \\n    void addElement(int num) {\\n        count++;\\n        q.push(num);\\n        int x = q.front();\\n        if (count > m) {\\n            q.pop();\\n            if (maxheap.count(x)) {\\n                maxheap.erase(maxheap.find(x));\\n                int v = *midheap.begin();\\n                maxheap.insert(v);\\n                sum -= v;\\n                midheap.erase(midheap.find(v));\\n            } else if (minheap.count(x)) {\\n                minheap.erase(minheap.find(x));\\n                int v = *midheap.rbegin();\\n                sum -= v;\\n                minheap.insert(v);\\n                midheap.erase(midheap.find(v));\\n            } else {\\n                sum -= x;\\n                midheap.erase(midheap.find(x));\\n            }\\n        }\\n        maxheap.insert(num);\\n        if (maxheap.size() > k) {\\n            int v = *maxheap.rbegin();\\n            maxheap.erase(maxheap.find(v));\\n            minheap.insert(v);\\n            if (minheap.size() > k) {\\n                v = *minheap.begin();\\n                minheap.erase(minheap.begin());\\n                midheap.insert(v);\\n                sum += v;\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (count < m)\\n            return -1;\\n        return sum / midheap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    queue<int> q;\\n    multiset<int> minheap;\\n    multiset<int> midheap;\\n    multiset<int> maxheap;\\n    int m;\\n    int k;\\n    int count;\\n    long sum;\\npublic:\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        count = 0;\\n        sum = 0;\\n    }\\n    \\n    void addElement(int num) {\\n        count++;\\n        q.push(num);\\n        int x = q.front();\\n        if (count > m) {\\n            q.pop();\\n            if (maxheap.count(x)) {\\n                maxheap.erase(maxheap.find(x));\\n                int v = *midheap.begin();\\n                maxheap.insert(v);\\n                sum -= v;\\n                midheap.erase(midheap.find(v));\\n            } else if (minheap.count(x)) {\\n                minheap.erase(minheap.find(x));\\n                int v = *midheap.rbegin();\\n                sum -= v;\\n                minheap.insert(v);\\n                midheap.erase(midheap.find(v));\\n            } else {\\n                sum -= x;\\n                midheap.erase(midheap.find(x));\\n            }\\n        }\\n        maxheap.insert(num);\\n        if (maxheap.size() > k) {\\n            int v = *maxheap.rbegin();\\n            maxheap.erase(maxheap.find(v));\\n            minheap.insert(v);\\n            if (minheap.size() > k) {\\n                v = *minheap.begin();\\n                minheap.erase(minheap.begin());\\n                midheap.insert(v);\\n                sum += v;\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (count < m)\\n            return -1;\\n        return sum / midheap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217409,
                "title": "c-easy-deque-ordered-map-add-o-logm-avg-o-k-space-o-m",
                "content": "### Idea\\n##### addElement\\n- Use a deque to keep track of the last m elements.\\n- Use a ordered map to store the m elements in order.\\n- Use a varaiable sum to sum all m elements\\n\\n#### calculateMKAverage\\n- We iterate through the first K and last K elements in ordered map, and subtract them from sum. And calculate the average.\\n\\n### Time Complexity\\nTime:\\n- addElement O(logM)\\n- calculateMKAverage O(K)\\n\\nSpace:\\n- O(M)\\n\\n### Code\\n```cpp\\nclass MKAverage {\\npublic:\\n    MKAverage(int m, int k): m(m), k(k) {\\n        \\n    }\\n    \\n    void addElement(int num) {\\n        //O(logN)\\n        dq.push_back(num);\\n        mp[num]++;\\n        sum+=num;\\n        if(dq.size()>m) {\\n            //if there are more then m elements, remove the first element.\\n            //from deque and mp.\\n            int front = dq.front();\\n            mp[front]--;\\n            sum-=front;\\n            if(mp[front]==0) mp.erase(front);\\n            dq.pop_front();\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        //O(K)\\n        if(dq.size()<m) return -1;\\n        long long int temp_sum = sum;\\n        \\n        //normal order: remove smallest k number from sum\\n        int temp_k = k;\\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(temp_k >= it->second){\\n                temp_sum -= it->first*it->second;\\n                temp_k-=it->second;\\n            }\\n            else{\\n                temp_sum -= it->first*temp_k;\\n                break;\\n            }\\n        }\\n        \\n        //reverse order: remove largest k number from sum\\n        temp_k = k;\\n        for(auto it = mp.rbegin(); it!=mp.rend(); it++){\\n            if(temp_k >= it->second){\\n                temp_sum -= it->first*it->second;\\n                temp_k-=it->second;\\n            }\\n            else{\\n                temp_sum -= it->first*temp_k;\\n                break;\\n            }\\n        }\\n        \\n        return temp_sum/(m-2*k);\\n    }\\nprivate:\\n    const int m = 0;\\n    const int k = 0;\\n    deque<int> dq; //used for keeping only m elements\\n    map<int, int> mp; //act as an sorted array\\n    long long int sum = 0; //the sum of current m numbers.\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass MKAverage {\\npublic:\\n    MKAverage(int m, int k): m(m), k(k) {\\n        \\n    }\\n    \\n    void addElement(int num) {\\n        //O(logN)\\n        dq.push_back(num);\\n        mp[num]++;\\n        sum+=num;\\n        if(dq.size()>m) {\\n            //if there are more then m elements, remove the first element.\\n            //from deque and mp.\\n            int front = dq.front();\\n            mp[front]--;\\n            sum-=front;\\n            if(mp[front]==0) mp.erase(front);\\n            dq.pop_front();\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        //O(K)\\n        if(dq.size()<m) return -1;\\n        long long int temp_sum = sum;\\n        \\n        //normal order: remove smallest k number from sum\\n        int temp_k = k;\\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(temp_k >= it->second){\\n                temp_sum -= it->first*it->second;\\n                temp_k-=it->second;\\n            }\\n            else{\\n                temp_sum -= it->first*temp_k;\\n                break;\\n            }\\n        }\\n        \\n        //reverse order: remove largest k number from sum\\n        temp_k = k;\\n        for(auto it = mp.rbegin(); it!=mp.rend(); it++){\\n            if(temp_k >= it->second){\\n                temp_sum -= it->first*it->second;\\n                temp_k-=it->second;\\n            }\\n            else{\\n                temp_sum -= it->first*temp_k;\\n                break;\\n            }\\n        }\\n        \\n        return temp_sum/(m-2*k);\\n    }\\nprivate:\\n    const int m = 0;\\n    const int k = 0;\\n    deque<int> dq; //used for keeping only m elements\\n    map<int, int> mp; //act as an sorted array\\n    long long int sum = 0; //the sum of current m numbers.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222887,
                "title": "java-elegant-o-log-m-add-o-1-avg-treeset-solution",
                "content": "Thanks to the suggestion by @anindya-saha; Here is a very elegant Solution. The solution works great in these questions: \\n* [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/discuss/1246287/Java-clean-O(logN)-TreeSet-Solution-oror-with-comments)\\n* [1825. Finding MK Average](https://leetcode.com/problems/finding-mk-average/discuss/1222887/Java-Elegant-O(log-M)-add-O(1)-avg-TreeSet-Solution)\\n```\\nclass MKAverage {\\n    class Node implements Comparable<Node> {\\n        int val;\\n        int time;\\n        \\n        Node(int val, int time) {\\n            this.val = val;\\n            this.time = time;\\n        }\\n        \\n        @Override\\n        public int compareTo(Node other) {\\n            return (this.val != other.val ? this.val - other.val \\n                                          : this.time - other.time);\\n        }\\n    }\\n    \\n    private TreeSet<Node> set = new TreeSet<>();          // natural order\\n    private Deque<Node> queue = new LinkedList<>();\\n    private Node kLeft;\\n    private Node kRight;\\n    \\n    private int m, k;\\n    \\n    private int time = 0;\\n    private int sum = 0;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        Node node = new Node(num, time++);\\n\\n        addNode(node);\\n        removeNode();\\n        \\n        if (time == m) init();\\n    }\\n    \\n    private void init() {\\n        int i = 0;\\n        for (Node node : set) {\\n            if (i < k-1);\\n            else if (i == k-1) kLeft = node;\\n            else if (i < m-k) sum += node.val;\\n            else if (i == m-k) {\\n                kRight = node;\\n                return;\\n            }\\n            \\n            i++;\\n        }\\n        return;\\n    }\\n    \\n    private void addNode(Node node) {\\n        queue.offerLast(node);\\n        set.add(node);\\n        \\n        if (queue.size() <= m) return;\\n        \\n        if (node.compareTo(kLeft) < 0) {\\n            sum += kLeft.val;\\n            kLeft = set.lower(kLeft);\\n        } else if (node.compareTo(kRight) > 0) {\\n            sum += kRight.val;\\n            kRight = set.higher(kRight);\\n        } else {\\n            sum += node.val;\\n        } \\n    }\\n    \\n    private void removeNode() {\\n        if (queue.size() <= m) return;\\n        \\n        Node node = queue.pollFirst();\\n        \\n        if (node.compareTo(kLeft) <= 0) {\\n            kLeft = set.higher(kLeft);\\n            sum -= kLeft.val;\\n        } else if (node.compareTo(kRight) >= 0) {\\n            kRight = set.lower(kRight);\\n            sum -= kRight.val;\\n        } else {\\n            sum -= node.val;\\n        }\\n        \\n        set.remove(node);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return (queue.size() < m ? -1 : sum / (m - 2 * k));\\n    }\\n}\\n```\\n\\n**Original Post:** \\n```\\nclass MKAverage {\\n    class Node {\\n        int val;\\n        int time;\\n        Node(int val, int time) {\\n            this.val = val;\\n            this.time = time;\\n        }\\n    }\\n    \\n    private TreeSet<Node> set; \\n    private Deque<Node> queue;\\n    private Node kLeft;\\n    private Node kRight;\\n    \\n    int m;\\n    int k;\\n    \\n    int time;\\n    int sum;\\n\\n    public MKAverage(int m, int k) {\\n        this.set = new TreeSet<>((a,b) -> (a.val != b.val) ? a.val - b.val : a.time - b.time);\\n        this.queue = new LinkedList<>();\\n        this.m = m;\\n        this.k = k;\\n        \\n        this.time = 0;\\n        this.sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        Node node = new Node(num, time++);\\n\\n        addNode(node);\\n        removeNode();\\n        \\n        if (time == m) init();\\n    }\\n    \\n    private void init() {\\n        int i = 0;\\n        for (Node node : set) {\\n            if (i < k-1);\\n            else if (i == k-1) kLeft = node;\\n            else if (i < m-k) sum += node.val;\\n            else if (i == m-k) {\\n                kRight = node;\\n                return;\\n            }\\n            \\n            i++;\\n        }\\n        return;\\n    }\\n    \\n    private void addNode(Node node) {\\n        queue.offerLast(node);\\n        set.add(node);\\n        \\n        if (queue.size() <= m) return;\\n        \\n        if (node.val < kLeft.val) {\\n            sum += kLeft.val;\\n            kLeft = set.lower(kLeft);\\n        } else if (node.val >= kRight.val) {\\n            sum += kRight.val;\\n            kRight = set.higher(kRight);\\n        } else {\\n            sum += node.val;\\n        } \\n    }\\n    \\n    private void removeNode() {\\n        if (queue.size() <= m) return;\\n        \\n        Node node = queue.pollFirst();\\n        \\n        if (node.val < kLeft.val || (node.val == kLeft.val && node.time <= kLeft.time)) {\\n            kLeft = set.higher(kLeft);\\n            sum -= kLeft.val;\\n        } else if (node.val > kRight.val || (node.val == kRight.val && node.time >= kRight.time)) {\\n            kRight = set.lower(kRight);\\n            sum -= kRight.val;\\n        } else {\\n            sum -= node.val;\\n        }\\n        \\n        set.remove(node);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return (queue.size() < m ? -1 : sum / (m - 2 * k));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass MKAverage {\\n    class Node implements Comparable<Node> {\\n        int val;\\n        int time;\\n        \\n        Node(int val, int time) {\\n            this.val = val;\\n            this.time = time;\\n        }\\n        \\n        @Override\\n        public int compareTo(Node other) {\\n            return (this.val != other.val ? this.val - other.val \\n                                          : this.time - other.time);\\n        }\\n    }\\n    \\n    private TreeSet<Node> set = new TreeSet<>();          // natural order\\n    private Deque<Node> queue = new LinkedList<>();\\n    private Node kLeft;\\n    private Node kRight;\\n    \\n    private int m, k;\\n    \\n    private int time = 0;\\n    private int sum = 0;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        Node node = new Node(num, time++);\\n\\n        addNode(node);\\n        removeNode();\\n        \\n        if (time == m) init();\\n    }\\n    \\n    private void init() {\\n        int i = 0;\\n        for (Node node : set) {\\n            if (i < k-1);\\n            else if (i == k-1) kLeft = node;\\n            else if (i < m-k) sum += node.val;\\n            else if (i == m-k) {\\n                kRight = node;\\n                return;\\n            }\\n            \\n            i++;\\n        }\\n        return;\\n    }\\n    \\n    private void addNode(Node node) {\\n        queue.offerLast(node);\\n        set.add(node);\\n        \\n        if (queue.size() <= m) return;\\n        \\n        if (node.compareTo(kLeft) < 0) {\\n            sum += kLeft.val;\\n            kLeft = set.lower(kLeft);\\n        } else if (node.compareTo(kRight) > 0) {\\n            sum += kRight.val;\\n            kRight = set.higher(kRight);\\n        } else {\\n            sum += node.val;\\n        } \\n    }\\n    \\n    private void removeNode() {\\n        if (queue.size() <= m) return;\\n        \\n        Node node = queue.pollFirst();\\n        \\n        if (node.compareTo(kLeft) <= 0) {\\n            kLeft = set.higher(kLeft);\\n            sum -= kLeft.val;\\n        } else if (node.compareTo(kRight) >= 0) {\\n            kRight = set.lower(kRight);\\n            sum -= kRight.val;\\n        } else {\\n            sum -= node.val;\\n        }\\n        \\n        set.remove(node);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return (queue.size() < m ? -1 : sum / (m - 2 * k));\\n    }\\n}\\n```\n```\\nclass MKAverage {\\n    class Node {\\n        int val;\\n        int time;\\n        Node(int val, int time) {\\n            this.val = val;\\n            this.time = time;\\n        }\\n    }\\n    \\n    private TreeSet<Node> set; \\n    private Deque<Node> queue;\\n    private Node kLeft;\\n    private Node kRight;\\n    \\n    int m;\\n    int k;\\n    \\n    int time;\\n    int sum;\\n\\n    public MKAverage(int m, int k) {\\n        this.set = new TreeSet<>((a,b) -> (a.val != b.val) ? a.val - b.val : a.time - b.time);\\n        this.queue = new LinkedList<>();\\n        this.m = m;\\n        this.k = k;\\n        \\n        this.time = 0;\\n        this.sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        Node node = new Node(num, time++);\\n\\n        addNode(node);\\n        removeNode();\\n        \\n        if (time == m) init();\\n    }\\n    \\n    private void init() {\\n        int i = 0;\\n        for (Node node : set) {\\n            if (i < k-1);\\n            else if (i == k-1) kLeft = node;\\n            else if (i < m-k) sum += node.val;\\n            else if (i == m-k) {\\n                kRight = node;\\n                return;\\n            }\\n            \\n            i++;\\n        }\\n        return;\\n    }\\n    \\n    private void addNode(Node node) {\\n        queue.offerLast(node);\\n        set.add(node);\\n        \\n        if (queue.size() <= m) return;\\n        \\n        if (node.val < kLeft.val) {\\n            sum += kLeft.val;\\n            kLeft = set.lower(kLeft);\\n        } else if (node.val >= kRight.val) {\\n            sum += kRight.val;\\n            kRight = set.higher(kRight);\\n        } else {\\n            sum += node.val;\\n        } \\n    }\\n    \\n    private void removeNode() {\\n        if (queue.size() <= m) return;\\n        \\n        Node node = queue.pollFirst();\\n        \\n        if (node.val < kLeft.val || (node.val == kLeft.val && node.time <= kLeft.time)) {\\n            kLeft = set.higher(kLeft);\\n            sum -= kLeft.val;\\n        } else if (node.val > kRight.val || (node.val == kRight.val && node.time >= kRight.time)) {\\n            kRight = set.lower(kRight);\\n            sum -= kRight.val;\\n        } else {\\n            sum -= node.val;\\n        }\\n        \\n        set.remove(node);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return (queue.size() < m ? -1 : sum / (m - 2 * k));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741331,
                "title": "java-easy-solution-treemap-queue",
                "content": "```\\nclass MKAverage {\\n\\n  int sum,total,m,k;\\n\\n    TreeMap<Integer,Integer> map=new TreeMap<>();\\n    Queue<Integer> queue=new LinkedList<>();\\n    public MKAverage(int m, int k) {\\n\\n       this.m=m;\\n       this.k=k;\\n    }\\n\\n    public void addElement(int num) {\\n\\n       total++;\\n       sum+=num;\\n       queue.add(num);\\n       map.put(num,map.getOrDefault(num,0)+1);\\n       if (total>m){\\n           total--;\\n          int first=queue.poll();\\n          sum-=first;\\n          if (map.get(first)==1)\\n             map.remove(first);\\n          else map.put(first,map.get(first)-1);\\n\\n       }\\n\\n\\n    }\\n\\n    public int calculateMKAverage() {\\n\\n       if (total<m) return -1;\\n\\n       int count=k;\\n       int temp_sum=sum;\\n       for (Map.Entry<Integer,Integer> entry:map.entrySet()){\\n          if (count==0) break;\\n          int val=entry.getValue();\\n          int key=entry.getKey();\\n          int min=Math.min(count,val);\\n          count-=min;\\n          temp_sum-=min*key;\\n\\n       }\\n       count=k;\\n       for (Map.Entry<Integer,Integer> entry:map.descendingMap().entrySet()){\\n          if (count==0) break;\\n          int val=entry.getValue();\\n          int key=entry.getKey();\\n          int min=Math.min(count,val);\\n          count-=min;\\n          temp_sum-=min*key;\\n       }\\n\\n\\n       return temp_sum/(m-2*k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n\\n  int sum,total,m,k;\\n\\n    TreeMap<Integer,Integer> map=new TreeMap<>();\\n    Queue<Integer> queue=new LinkedList<>();\\n    public MKAverage(int m, int k) {\\n\\n       this.m=m;\\n       this.k=k;\\n    }\\n\\n    public void addElement(int num) {\\n\\n       total++;\\n       sum+=num;\\n       queue.add(num);\\n       map.put(num,map.getOrDefault(num,0)+1);\\n       if (total>m){\\n           total--;\\n          int first=queue.poll();\\n          sum-=first;\\n          if (map.get(first)==1)\\n             map.remove(first);\\n          else map.put(first,map.get(first)-1);\\n\\n       }\\n\\n\\n    }\\n\\n    public int calculateMKAverage() {\\n\\n       if (total<m) return -1;\\n\\n       int count=k;\\n       int temp_sum=sum;\\n       for (Map.Entry<Integer,Integer> entry:map.entrySet()){\\n          if (count==0) break;\\n          int val=entry.getValue();\\n          int key=entry.getKey();\\n          int min=Math.min(count,val);\\n          count-=min;\\n          temp_sum-=min*key;\\n\\n       }\\n       count=k;\\n       for (Map.Entry<Integer,Integer> entry:map.descendingMap().entrySet()){\\n          if (count==0) break;\\n          int val=entry.getValue();\\n          int key=entry.getKey();\\n          int min=Math.min(count,val);\\n          count-=min;\\n          temp_sum-=min*key;\\n       }\\n\\n\\n       return temp_sum/(m-2*k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218695,
                "title": "java-just-one-treeset-add-o-logm-avg-o-1",
                "content": "Last m stream elements are kept sorted using TreeSet. First K and Last K elements are identified by remembering the edge elements, and updated with each addition (with O(logM)). Sum of m-2k \"middle\" elements is updated with each addition (and used to calculate average in O(1)). \\nDuplicate elements are distinguished using a \"timestamp\" (here we can use just a simple serial integer, since number of calls to addElement <= 10^5)\\n\\nMore comments inline.\\n```\\nclass MKAverage {\\n    private TreeSet<Pair<Integer, Integer>> order= new TreeSet<>((a,b)->{\\n        int diff= a.getKey()-b.getKey();\\n        return diff!=0 ? diff : a.getValue()-b.getValue();\\n    });\\n    private LinkedList<Pair<Integer, Integer>> stream= new LinkedList<>();\\n    private Pair<Integer, Integer> kLeft= null, kRight= null;\\n    private int m, k;\\n    private int serial= 0;  // \"timestamp\"\\n    private int midSum= 0, midSize= 0;\\n\\n    public MKAverage(int m, int k) {\\n        this.m= m;\\n        this.k= k;\\n        this.midSize= m-2*k;\\n    }\\n    \\n    private void init(){\\n        // one off once we reach the size of m\\n        // find kLeft and kRight elements (NOT in midSum)\\n        // calculate initial midSum\\n        int i=0;\\n        for(Pair<Integer,Integer> elt:order){\\n            if(i<k-1);\\n            else if(i==k-1) kLeft= elt;\\n            else if(i<m-k) midSum+= elt.getKey();\\n            else if(i==m-k){kRight= elt; break;}\\n            i++;\\n        }\\n    }\\n    \\n    public void addElement(int num) {\\n        Pair<Integer, Integer> addElt= new Pair<>(num, serial++);\\n        stream.addLast(addElt);\\n        add(addElt);\\n        if(stream.size()==m)\\n            init();\\n        else if(stream.size() > m)\\n            remove(stream.removeFirst());\\n    }\\n    \\n    private void add(Pair<Integer, Integer> elt){\\n        if(order.size()<m){\\n            order.add(elt);            \\n            return;\\n        }\\n        // compare new elt with kLeft and kRight\\n        int eltKey= elt.getKey(), kLeftKey= kLeft.getKey(), kRightKey= kRight.getKey();\\n        order.add(elt);\\n        if(eltKey < kLeftKey){\\n            // add to left k and move kLeftKey to previous, \\n            // adding kLeft to midSum\\n            midSum+= kLeftKey;\\n            // finding the elt immediately before the current kLeft\\n            kLeft= order.floor(new Pair(kLeftKey, kLeft.getValue()-1));\\n        }else if(eltKey < kRightKey){\\n            // add to midSum, no change to kLeft or kRight\\n            midSum+= eltKey;\\n        }else{\\n            // add to right k and move kRightKey to next\\n            // adding kRight to midSum\\n            midSum+= kRightKey;\\n            // finding the elt immediately after the current kRight\\n            kRight= order.ceiling(new Pair(kRightKey, kRight.getValue()+1));\\n        }\\n    }\\n    \\n    private void remove(Pair<Integer, Integer> elt){\\n        // compare the elt being removed with kLeft and kRight\\n        int eltKey= elt.getKey(), kLeftKey= kLeft.getKey(), kRightKey= kRight.getKey();\\n        order.remove(elt);\\n        if(eltKey <= kLeftKey){\\n            // remove elt from left k and move kLeftKey to next, \\n            // finding the elt immediately after the current kLeft\\n            kLeft= order.ceiling(new Pair(kLeftKey, kLeft.getValue()+1));\\n            // removing the new kLeft from midSum\\n            midSum-= kLeft.getKey();\\n        }else if(eltKey < kRightKey){\\n            // remove from midSum, no change to kLeft or kRight\\n            midSum-= eltKey;\\n        }else{\\n            // remove from right k and move kRightKey to previous\\n            // finding the elt immediately before the current kRight\\n            kRight= order.floor(new Pair(kRightKey, kRight.getValue()-1));\\n            // removing the new kRight from  midSum\\n            midSum-= kRight.getKey();\\n        }\\n    }    \\n    \\n    public int calculateMKAverage() {\\n        return stream.size()==m ? midSum/midSize : -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "Last m stream elements are kept sorted using TreeSet. First K and Last K elements are identified by remembering the edge elements, and updated with each addition (with O(logM)). Sum of m-2k \"middle\" elements is updated with each addition (and used to calculate average in O(1)). \\nDuplicate elements are distinguished using a \"timestamp\" (here we can use just a simple serial integer, since number of calls to addElement <= 10^5)\\n\\nMore comments inline.\\n```\\nclass MKAverage {\\n    private TreeSet<Pair<Integer, Integer>> order= new TreeSet<>((a,b)->{\\n        int diff= a.getKey()-b.getKey();\\n        return diff!=0 ? diff : a.getValue()-b.getValue();\\n    });\\n    private LinkedList<Pair<Integer, Integer>> stream= new LinkedList<>();\\n    private Pair<Integer, Integer> kLeft= null, kRight= null;\\n    private int m, k;\\n    private int serial= 0;  // \"timestamp\"\\n    private int midSum= 0, midSize= 0;\\n\\n    public MKAverage(int m, int k) {\\n        this.m= m;\\n        this.k= k;\\n        this.midSize= m-2*k;\\n    }\\n    \\n    private void init(){\\n        // one off once we reach the size of m\\n        // find kLeft and kRight elements (NOT in midSum)\\n        // calculate initial midSum\\n        int i=0;\\n        for(Pair<Integer,Integer> elt:order){\\n            if(i<k-1);\\n            else if(i==k-1) kLeft= elt;\\n            else if(i<m-k) midSum+= elt.getKey();\\n            else if(i==m-k){kRight= elt; break;}\\n            i++;\\n        }\\n    }\\n    \\n    public void addElement(int num) {\\n        Pair<Integer, Integer> addElt= new Pair<>(num, serial++);\\n        stream.addLast(addElt);\\n        add(addElt);\\n        if(stream.size()==m)\\n            init();\\n        else if(stream.size() > m)\\n            remove(stream.removeFirst());\\n    }\\n    \\n    private void add(Pair<Integer, Integer> elt){\\n        if(order.size()<m){\\n            order.add(elt);            \\n            return;\\n        }\\n        // compare new elt with kLeft and kRight\\n        int eltKey= elt.getKey(), kLeftKey= kLeft.getKey(), kRightKey= kRight.getKey();\\n        order.add(elt);\\n        if(eltKey < kLeftKey){\\n            // add to left k and move kLeftKey to previous, \\n            // adding kLeft to midSum\\n            midSum+= kLeftKey;\\n            // finding the elt immediately before the current kLeft\\n            kLeft= order.floor(new Pair(kLeftKey, kLeft.getValue()-1));\\n        }else if(eltKey < kRightKey){\\n            // add to midSum, no change to kLeft or kRight\\n            midSum+= eltKey;\\n        }else{\\n            // add to right k and move kRightKey to next\\n            // adding kRight to midSum\\n            midSum+= kRightKey;\\n            // finding the elt immediately after the current kRight\\n            kRight= order.ceiling(new Pair(kRightKey, kRight.getValue()+1));\\n        }\\n    }\\n    \\n    private void remove(Pair<Integer, Integer> elt){\\n        // compare the elt being removed with kLeft and kRight\\n        int eltKey= elt.getKey(), kLeftKey= kLeft.getKey(), kRightKey= kRight.getKey();\\n        order.remove(elt);\\n        if(eltKey <= kLeftKey){\\n            // remove elt from left k and move kLeftKey to next, \\n            // finding the elt immediately after the current kLeft\\n            kLeft= order.ceiling(new Pair(kLeftKey, kLeft.getValue()+1));\\n            // removing the new kLeft from midSum\\n            midSum-= kLeft.getKey();\\n        }else if(eltKey < kRightKey){\\n            // remove from midSum, no change to kLeft or kRight\\n            midSum-= eltKey;\\n        }else{\\n            // remove from right k and move kRightKey to previous\\n            // finding the elt immediately before the current kRight\\n            kRight= order.floor(new Pair(kRightKey, kRight.getValue()-1));\\n            // removing the new kRight from  midSum\\n            midSum-= kRight.getKey();\\n        }\\n    }    \\n    \\n    public int calculateMKAverage() {\\n        return stream.size()==m ? midSum/midSize : -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2791751,
                "title": "python3-1-sortedlist-queue-with-a-thought-process",
                "content": "**Intuition**\\n* To manage current m values, we can use a queue.\\n* But if we sort and count the middle sum on every insertion, A single Insertion will take O(MlogM) time, O(TM log M) as total where M is the number of elements in the window, T is the total stream elements.  \\n\\n* So we can use the following ideas.\\n\\t* Idea1: Use TreeSet to keep M elements sorted.\\n\\t* Idea2: Incrementally update the middle value\\'s sum rather than scanning multiple elements every time.\\n\\n**Algorithm**\\n* The key part is how we can incrementally update the middle sum. We can divide the sorted list into 3 partitions like the following.\\n```\\n        # Array: [A | B | C]  \\n\\t\\t#     : A -> k-smallest values.  B -> middle values.  C-> k-largest values.\\n\\t\\t# Index range\\n\\t\\t#       [0..k-1 | k ... m-k-1 | m-k .. m-1]\\n```\\n\\n* And when we remove staled element from the sorted list, there are 3 possible patterns.\\n\\n```\\n# If we remove element from C -> that does not affect the middle sum.\\n#                      from B -> we lose that value, C\\'s left most value become B\\'s right most value so add that value to the middle sum.\\n#                      from A -> we lose B\\'s leftmost value and obtain C\\'s leftmost value to the middle sum, since they are pushed to left.\\n```\\n\\n* Then when we add a new value to the sorted list, there are also 3 possible patterns.\\n\\n```\\n# If we insert element to C -> that does not affect the middle sum.\\n#                         B -> we need to add that value, and lost B\\'s rightmost value since it will be pushed to C.\\n#                         A -> we need to add A\\'s rightmost value to the middle sum and subtract B\\'s rightmost value from the middle sum since they are pushed to right.\\n```\\n\\n* An edge case you need to consider is that the sorted list contains multiple possible values. We need to use the same rule between insertion/deletion, for now, I use bisect_right method so that we can always manipulate the rightmost value.\\n\\n* When we remove/add elements to sorted list, we can update the middle sum based on its deletion/insertion index.\\n\\n**Code Example**\\n```\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.middleSum = 0\\n        self.queue = deque()\\n        self.sortedValues = SortedList()\\n        self.m = m\\n        self.k = k   \\n\\n    def addElement(self, num: int) -> None: # Total O(mlogm)\\n        # [A | B | C]\\n        # [0..k-1 | k   m-k-1 | m-k .. m-1]\\n        # A -> k-smallest B-> middle C-> k-largest\\n\\n        if len(self.queue) < self.m: \\n            self.queue.append(num)\\n            self.sortedValues.add(num)\\n\\t\\t    # This initialization will be triggered only once when the queue size become m-1 to m.\\n            if len(self.queue) == self.m: # O(mlogm) for initialization.\\n                self.middleSum = sum(self.sortedValues[self.k:(self.m - self.k)])\\n            return\\n        \\n        # After the queue size become m, each Operation cost is O(logm)\\n        remove_val = self.queue.popleft()\\n            \\n        # Phase1: Remove\\n        removal_idx = self.sortedValues.bisect_right(remove_val) - 1 # pick right most element.\\n        if removal_idx < self.k: #  on A\\n            self.middleSum -= self.sortedValues[self.k] # leftmost B\\n            self.middleSum += self.sortedValues[self.m - self.k] # leftmost C\\n        elif removal_idx > self.m - self.k - 1: # on C\\n            pass\\n        else: # on B\\n            self.middleSum -= remove_val\\n            self.middleSum += self.sortedValues[self.m - self.k] # leftmost C\\n        \\n        self.sortedValues.remove(remove_val)\\n        \\n        # Phase2: Insert\\n        self.queue.append(num)\\n        \\n        insertion_idx = self.sortedValues.bisect_right(num)\\n        if insertion_idx < self.k: # on A\\n            self.middleSum += self.sortedValues[self.k - 1] # rightmost A\\n            self.middleSum -= self.sortedValues[self.m - self.k - 1] # rightmost B\\n        elif insertion_idx > self.m - self.k - 1: # on C\\n            pass\\n        else: # on B\\n            self.middleSum += num\\n            self.middleSum -= self.sortedValues[self.m - self.k - 1] # rightmost B\\n            \\n        self.sortedValues.add(num)       \\n\\n    def calculateMKAverage(self) -> int: # O(1)\\n        if len(self.queue) < self.m:\\n            return -1\\n        return self.middleSum // (self.m - (2 * self.k))\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```\\n\\n**Complexity Analysis**\\n\\nTime:\\n* Total O(TlogM)  # T = Total elements in a stream.  M = Total elements in a window.\\n\\t* Initialization: O(MlogM)\\n\\t* Insertion: O(logM)\\n\\t* Query: O(1)\\n\\nMemory:\\n* O(M) for queue / sorted list\\n\\n**Runtime History**\\n* Runtime: 3212 ms, faster than 48.67% of Python3 online submissions for Finding MK Average.\\n* Memory Usage: 49.6 MB, less than 74.34% of Python3 online submissions for Finding MK Average.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n        # Array: [A | B | C]  \\n\\t\\t#     : A -> k-smallest values.  B -> middle values.  C-> k-largest values.\\n\\t\\t# Index range\\n\\t\\t#       [0..k-1 | k ... m-k-1 | m-k .. m-1]\\n```\n```\\n# If we remove element from C -> that does not affect the middle sum.\\n#                      from B -> we lose that value, C\\'s left most value become B\\'s right most value so add that value to the middle sum.\\n#                      from A -> we lose B\\'s leftmost value and obtain C\\'s leftmost value to the middle sum, since they are pushed to left.\\n```\n```\\n# If we insert element to C -> that does not affect the middle sum.\\n#                         B -> we need to add that value, and lost B\\'s rightmost value since it will be pushed to C.\\n#                         A -> we need to add A\\'s rightmost value to the middle sum and subtract B\\'s rightmost value from the middle sum since they are pushed to right.\\n```\n```\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.middleSum = 0\\n        self.queue = deque()\\n        self.sortedValues = SortedList()\\n        self.m = m\\n        self.k = k   \\n\\n    def addElement(self, num: int) -> None: # Total O(mlogm)\\n        # [A | B | C]\\n        # [0..k-1 | k   m-k-1 | m-k .. m-1]\\n        # A -> k-smallest B-> middle C-> k-largest\\n\\n        if len(self.queue) < self.m: \\n            self.queue.append(num)\\n            self.sortedValues.add(num)\\n\\t\\t    # This initialization will be triggered only once when the queue size become m-1 to m.\\n            if len(self.queue) == self.m: # O(mlogm) for initialization.\\n                self.middleSum = sum(self.sortedValues[self.k:(self.m - self.k)])\\n            return\\n        \\n        # After the queue size become m, each Operation cost is O(logm)\\n        remove_val = self.queue.popleft()\\n            \\n        # Phase1: Remove\\n        removal_idx = self.sortedValues.bisect_right(remove_val) - 1 # pick right most element.\\n        if removal_idx < self.k: #  on A\\n            self.middleSum -= self.sortedValues[self.k] # leftmost B\\n            self.middleSum += self.sortedValues[self.m - self.k] # leftmost C\\n        elif removal_idx > self.m - self.k - 1: # on C\\n            pass\\n        else: # on B\\n            self.middleSum -= remove_val\\n            self.middleSum += self.sortedValues[self.m - self.k] # leftmost C\\n        \\n        self.sortedValues.remove(remove_val)\\n        \\n        # Phase2: Insert\\n        self.queue.append(num)\\n        \\n        insertion_idx = self.sortedValues.bisect_right(num)\\n        if insertion_idx < self.k: # on A\\n            self.middleSum += self.sortedValues[self.k - 1] # rightmost A\\n            self.middleSum -= self.sortedValues[self.m - self.k - 1] # rightmost B\\n        elif insertion_idx > self.m - self.k - 1: # on C\\n            pass\\n        else: # on B\\n            self.middleSum += num\\n            self.middleSum -= self.sortedValues[self.m - self.k - 1] # rightmost B\\n            \\n        self.sortedValues.add(num)       \\n\\n    def calculateMKAverage(self) -> int: # O(1)\\n        if len(self.queue) < self.m:\\n            return -1\\n        return self.middleSum // (self.m - (2 * self.k))\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248262,
                "title": "c-modular-code-with-3-maps-o-log-n-time",
                "content": "```\\n/* \\n    Time: addElement: O(logm) | calculateMKAverage: O(1)\\n    Space: O(m)\\n    Tag: TreeMap, Sorting, Queue\\n    Difficulty: H\\n*/\\n\\nclass MKAverage {\\n    map<int, int> left, middle, right;\\n    queue<int> q;\\n    int sizeofLeft, sizeofMiddle, sizeofRight;\\n    int k;\\n    long long mkSum;\\n    int m;\\n\\n    void addToSet1(int num) {\\n        left[num]++;\\n        sizeofLeft++;\\n    }\\n\\n    void deleteFromSet1(int num) {\\n        left[num]--;\\n        if (left[num] == 0) left.erase(num);\\n        sizeofLeft--;\\n    }\\n\\n    void addToSet2(int num) {\\n        middle[num]++;\\n        sizeofMiddle++;\\n        mkSum += num;\\n    }\\n\\n    void deleteFromSet2(int num) {\\n        middle[num]--;\\n        if (middle[num] == 0) middle.erase(num);\\n        sizeofMiddle--;\\n        mkSum -= num;\\n    }\\n\\n    void addToSet3(int num) {\\n        right[num]++;\\n        sizeofRight++;\\n    }\\n\\n    void deleteFromSet3(int num) {\\n        right[num]--;\\n        if (right[num] == 0) right.erase(num);\\n        sizeofRight--;\\n    }\\n\\npublic:\\n    MKAverage(int m, int k) {\\n        sizeofLeft = 0, sizeofMiddle = 0, sizeofRight = 0;\\n        mkSum = 0;\\n        this->k = k;\\n        this->m = m;\\n    }\\n\\n    void addElement(int num) {\\n        if (sizeofLeft < k) {\\n            addToSet1(num);\\n            q.push(num);\\n        } else if (sizeofMiddle < (m - (2 * k))) {\\n            int lastEle = prev(left.end())->first;\\n            if (num >= lastEle) {\\n                addToSet2(num);\\n            } else {\\n                deleteFromSet1(lastEle);\\n                addToSet1(num);\\n                addToSet2(lastEle);\\n            }\\n            q.push(num);\\n        } else if (sizeofRight < k) {\\n            int last1 = prev(left.end())->first;\\n            int last2 = prev(middle.end())->first;\\n            if (num >= last1 && num >= last2) {\\n                addToSet3(num);\\n            } else if (num >= last1 && num < last2) {\\n                deleteFromSet2(last2);\\n                addToSet2(num);\\n                addToSet3(last2);\\n            } else {\\n                deleteFromSet2(last2);\\n                addToSet3(last2);\\n                deleteFromSet1(last1);\\n                addToSet2(last1);\\n                addToSet1(num);\\n            }\\n            q.push(num);\\n        } else {\\n            int toErase = q.front();\\n            q.pop();\\n            int first3 = right.begin()->first;\\n            int first2 = middle.begin()->first;\\n            int first1 = left.begin()->first;\\n\\n            if (toErase >= first3) {\\n                deleteFromSet3(toErase);\\n            } else if (toErase >= first2) {\\n                deleteFromSet3(first3);\\n                deleteFromSet2(toErase);\\n                addToSet2(first3);\\n            } else {\\n                deleteFromSet3(first3);\\n                deleteFromSet2(first2);\\n                deleteFromSet1(toErase);\\n                addToSet1(first2);\\n                addToSet2(first3);\\n            }\\n            addElement(num);\\n        }\\n    }\\n\\n    int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        return mkSum / (m - (2 * k));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\n/* \\n    Time: addElement: O(logm) | calculateMKAverage: O(1)\\n    Space: O(m)\\n    Tag: TreeMap, Sorting, Queue\\n    Difficulty: H\\n*/\\n\\nclass MKAverage {\\n    map<int, int> left, middle, right;\\n    queue<int> q;\\n    int sizeofLeft, sizeofMiddle, sizeofRight;\\n    int k;\\n    long long mkSum;\\n    int m;\\n\\n    void addToSet1(int num) {\\n        left[num]++;\\n        sizeofLeft++;\\n    }\\n\\n    void deleteFromSet1(int num) {\\n        left[num]--;\\n        if (left[num] == 0) left.erase(num);\\n        sizeofLeft--;\\n    }\\n\\n    void addToSet2(int num) {\\n        middle[num]++;\\n        sizeofMiddle++;\\n        mkSum += num;\\n    }\\n\\n    void deleteFromSet2(int num) {\\n        middle[num]--;\\n        if (middle[num] == 0) middle.erase(num);\\n        sizeofMiddle--;\\n        mkSum -= num;\\n    }\\n\\n    void addToSet3(int num) {\\n        right[num]++;\\n        sizeofRight++;\\n    }\\n\\n    void deleteFromSet3(int num) {\\n        right[num]--;\\n        if (right[num] == 0) right.erase(num);\\n        sizeofRight--;\\n    }\\n\\npublic:\\n    MKAverage(int m, int k) {\\n        sizeofLeft = 0, sizeofMiddle = 0, sizeofRight = 0;\\n        mkSum = 0;\\n        this->k = k;\\n        this->m = m;\\n    }\\n\\n    void addElement(int num) {\\n        if (sizeofLeft < k) {\\n            addToSet1(num);\\n            q.push(num);\\n        } else if (sizeofMiddle < (m - (2 * k))) {\\n            int lastEle = prev(left.end())->first;\\n            if (num >= lastEle) {\\n                addToSet2(num);\\n            } else {\\n                deleteFromSet1(lastEle);\\n                addToSet1(num);\\n                addToSet2(lastEle);\\n            }\\n            q.push(num);\\n        } else if (sizeofRight < k) {\\n            int last1 = prev(left.end())->first;\\n            int last2 = prev(middle.end())->first;\\n            if (num >= last1 && num >= last2) {\\n                addToSet3(num);\\n            } else if (num >= last1 && num < last2) {\\n                deleteFromSet2(last2);\\n                addToSet2(num);\\n                addToSet3(last2);\\n            } else {\\n                deleteFromSet2(last2);\\n                addToSet3(last2);\\n                deleteFromSet1(last1);\\n                addToSet2(last1);\\n                addToSet1(num);\\n            }\\n            q.push(num);\\n        } else {\\n            int toErase = q.front();\\n            q.pop();\\n            int first3 = right.begin()->first;\\n            int first2 = middle.begin()->first;\\n            int first1 = left.begin()->first;\\n\\n            if (toErase >= first3) {\\n                deleteFromSet3(toErase);\\n            } else if (toErase >= first2) {\\n                deleteFromSet3(first3);\\n                deleteFromSet2(toErase);\\n                addToSet2(first3);\\n            } else {\\n                deleteFromSet3(first3);\\n                deleteFromSet2(first2);\\n                deleteFromSet1(toErase);\\n                addToSet1(first2);\\n                addToSet2(first3);\\n            }\\n            addElement(num);\\n        }\\n    }\\n\\n    int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        return mkSum / (m - (2 * k));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171562,
                "title": "c-solution",
                "content": "```\\nclass MKAverage\\n{\\n    public:\\n        multiset<int> left, mid, right;\\n    int k;\\n    int m;\\n    long long sum;\\n    queue<int> q;\\n    MKAverage(int mt, int kt)\\n    {\\n        sum = 0;\\n        m = mt;\\n        k = kt;\\n    }\\n    void remove()\\n    {\\n        int val = q.front();\\n        q.pop();\\n        if (val <= *left.rbegin())\\n        {\\n            left.erase(left.find(val));\\n            left.insert(*mid.begin());\\n            sum -= *mid.begin();\\n            mid.erase(mid.begin());\\n        }\\n        else if (val >= *right.begin())\\n        {\\n            right.erase(right.find(val));\\n            right.insert(*mid.rbegin());\\n            sum -= *mid.rbegin();\\n            mid.erase(--mid.end());\\n        }\\n        else\\n        {\\n            sum -= val;\\n            mid.erase(mid.find(val));\\n        }\\n    }\\n    void add(int val)\\n    {\\n        q.push(val);\\n        if (mid.size() == 0)\\n        {\\n            if (q.size() == m)\\n            {\\n                queue<int> nq = q;\\n                vector<int> v;\\n                while (nq.size())\\n                {\\n                    v.push_back(nq.front());\\n                    nq.pop();\\n                }\\n                sort(v.begin(), v.end());\\n                for (int i = 0; i < m; i++)\\n                {\\n                    if (i < k)\\n                    {\\n                        left.insert(v[i]);\\n                    }\\n                    else if (i > m - 1 - k)\\n                    {\\n                        right.insert(v[i]);\\n                    }\\n                    else\\n                    {\\n                        mid.insert(v[i]);\\n                        sum += v[i];\\n                    }\\n                }\\n            }\\n        }\\n        else if (val<*left.rbegin())\\n        {\\n            int curr = *left.rbegin();\\n            left.insert(val);\\n            mid.insert(curr);\\n            left.erase(--left.end());\\n            sum += curr;\\n        }\\n        else if (val > *right.begin())\\n        {\\n            int curr = *right.begin();\\n            right.erase(right.begin());\\n            right.insert(val);\\n            sum += curr;\\n            mid.insert(curr);\\n        }\\n        else\\n        {\\n            sum += val;\\n            mid.insert(val);\\n        }\\n    }\\n    void addElement(int num)\\n    {\\n        add(num);\\n        if (q.size() > m)\\n        {\\n            remove();\\n        }\\n    }\\n\\n    int calculateMKAverage()\\n    {\\n        if (q.size() < m)\\n        {\\n            return -1;\\n        }\\n        return sum / mid.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MKAverage\\n{\\n    public:\\n        multiset<int> left, mid, right;\\n    int k;\\n    int m;\\n    long long sum;\\n    queue<int> q;\\n    MKAverage(int mt, int kt)\\n    {\\n        sum = 0;\\n        m = mt;\\n        k = kt;\\n    }\\n    void remove()\\n    {\\n        int val = q.front();\\n        q.pop();\\n        if (val <= *left.rbegin())\\n        {\\n            left.erase(left.find(val));\\n            left.insert(*mid.begin());\\n            sum -= *mid.begin();\\n            mid.erase(mid.begin());\\n        }\\n        else if (val >= *right.begin())\\n        {\\n            right.erase(right.find(val));\\n            right.insert(*mid.rbegin());\\n            sum -= *mid.rbegin();\\n            mid.erase(--mid.end());\\n        }\\n        else\\n        {\\n            sum -= val;\\n            mid.erase(mid.find(val));\\n        }\\n    }\\n    void add(int val)\\n    {\\n        q.push(val);\\n        if (mid.size() == 0)\\n        {\\n            if (q.size() == m)\\n            {\\n                queue<int> nq = q;\\n                vector<int> v;\\n                while (nq.size())\\n                {\\n                    v.push_back(nq.front());\\n                    nq.pop();\\n                }\\n                sort(v.begin(), v.end());\\n                for (int i = 0; i < m; i++)\\n                {\\n                    if (i < k)\\n                    {\\n                        left.insert(v[i]);\\n                    }\\n                    else if (i > m - 1 - k)\\n                    {\\n                        right.insert(v[i]);\\n                    }\\n                    else\\n                    {\\n                        mid.insert(v[i]);\\n                        sum += v[i];\\n                    }\\n                }\\n            }\\n        }\\n        else if (val<*left.rbegin())\\n        {\\n            int curr = *left.rbegin();\\n            left.insert(val);\\n            mid.insert(curr);\\n            left.erase(--left.end());\\n            sum += curr;\\n        }\\n        else if (val > *right.begin())\\n        {\\n            int curr = *right.begin();\\n            right.erase(right.begin());\\n            right.insert(val);\\n            sum += curr;\\n            mid.insert(curr);\\n        }\\n        else\\n        {\\n            sum += val;\\n            mid.insert(val);\\n        }\\n    }\\n    void addElement(int num)\\n    {\\n        add(num);\\n        if (q.size() > m)\\n        {\\n            remove();\\n        }\\n    }\\n\\n    int calculateMKAverage()\\n    {\\n        if (q.size() < m)\\n        {\\n            return -1;\\n        }\\n        return sum / mid.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482612,
                "title": "c-404ms-78-queue-and-set",
                "content": "Runtime: 404 ms, faster than 78.26% of C++ online submissions for Finding MK Average.\\nMemory Usage: 146 MB, less than 62.50% of C++ online submissions for Finding MK Average.\\n**General idea :**\\n**1.** create queue with current of elements {element, id of element in stream} \\n**2.** while size of queue less than **m** only put elements in queue\\n**3.** one time whan size of queue will be equal **m** sort all elements from queue and put all elements into 3 sets : **mini** , **midi**, **maxi** , where mini contain first k elements, midi - next n( n = m - k - k) elements and maxi contain last k elements. And calculate sum of **midi** elements\\n\\n**from step 3 will repeat :**\\n**1** delete old element from queue and from mini or midi or maxi\\n**2** after deleting always will be reconstruct our mini, midi and maxi in such manner : mini - k elements, midi - n-1 elements and maxi - k elements (will support mini and maxi with maximal size)\\n**3** put new element into mini , midi or maxi (for all theese steps recalculate sum)\\n```\\nclass MKAverage {\\npublic:\\n  set<pair<int,int>> mini,midi,maxi;\\n  queue<pair<int,int>> q;\\n  int id, k, n, m, lim, sum;\\n  \\n  MKAverage(int m, int k) {\\n    sum = id = 0, this->k = k, this->m = m, n = m - k - k, lim = m + 1;      \\n  }\\n    \\n  void addElement(int num) {\\n    q.push({num, ++id});\\n    \\n    if(q.size() == lim){\\n      auto p = q.front(); q.pop();\\n      \\n      if(mini.count(p)) mini.erase(p);                      //delete old\\n      else if(maxi.count(p)) maxi.erase(p);\\n      else midi.erase(p), sum -= p.first;\\n      \\n      if(mini.size() != k){                                 //replace\\n        mini.insert(*midi.begin()), sum -= midi.begin()->first;\\n        midi.erase(*midi.begin());\\n      }\\n      else if(maxi.size() != k){\\n        maxi.insert(*midi.rbegin()), sum -= midi.rbegin()->first;\\n        midi.erase(*midi.rbegin());\\n      }\\n  \\n      if(num >= mini.rbegin()->first && num <= maxi.begin()->first) midi.insert({num, id}), sum += num;    //insert new\\n      else if(num < mini.rbegin()->first){\\n        sum += mini.rbegin()->first;\\n        midi.insert(*mini.rbegin());\\n        mini.erase(*mini.rbegin());\\n        mini.insert({num, id});\\n      }else {\\n        sum += maxi.begin()->first;\\n        midi.insert(*maxi.begin());\\n        maxi.erase(*maxi.begin());\\n        maxi.insert({num, id});\\n      } \\n    }\\n    else if(q.size() == m){\\n      vector<pair<int,int>>v(m);\\n      \\n      for(int i = 0; i != m; i++){\\n        q.push(v[i] = q.front()); q.pop();\\n      }\\n      \\n      sort(v.begin(), v.end());\\n      int i = 0;\\n      while(i != k) mini.insert(v[i++]);\\n      for(int l = k + n; i != l; i++) midi.insert(v[i]), sum += v[i].first;\\n      while(i != m) maxi.insert(v[i++]);\\n    }\\n  }\\n    \\n  int calculateMKAverage() {\\n    return q.size() == m ? sum / n : -1;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MKAverage {\\npublic:\\n  set<pair<int,int>> mini,midi,maxi;\\n  queue<pair<int,int>> q;\\n  int id, k, n, m, lim, sum;\\n  \\n  MKAverage(int m, int k) {\\n    sum = id = 0, this->k = k, this->m = m, n = m - k - k, lim = m + 1;      \\n  }\\n    \\n  void addElement(int num) {\\n    q.push({num, ++id});\\n    \\n    if(q.size() == lim){\\n      auto p = q.front(); q.pop();\\n      \\n      if(mini.count(p)) mini.erase(p);                      //delete old\\n      else if(maxi.count(p)) maxi.erase(p);\\n      else midi.erase(p), sum -= p.first;\\n      \\n      if(mini.size() != k){                                 //replace\\n        mini.insert(*midi.begin()), sum -= midi.begin()->first;\\n        midi.erase(*midi.begin());\\n      }\\n      else if(maxi.size() != k){\\n        maxi.insert(*midi.rbegin()), sum -= midi.rbegin()->first;\\n        midi.erase(*midi.rbegin());\\n      }\\n  \\n      if(num >= mini.rbegin()->first && num <= maxi.begin()->first) midi.insert({num, id}), sum += num;    //insert new\\n      else if(num < mini.rbegin()->first){\\n        sum += mini.rbegin()->first;\\n        midi.insert(*mini.rbegin());\\n        mini.erase(*mini.rbegin());\\n        mini.insert({num, id});\\n      }else {\\n        sum += maxi.begin()->first;\\n        midi.insert(*maxi.begin());\\n        maxi.erase(*maxi.begin());\\n        maxi.insert({num, id});\\n      } \\n    }\\n    else if(q.size() == m){\\n      vector<pair<int,int>>v(m);\\n      \\n      for(int i = 0; i != m; i++){\\n        q.push(v[i] = q.front()); q.pop();\\n      }\\n      \\n      sort(v.begin(), v.end());\\n      int i = 0;\\n      while(i != k) mini.insert(v[i++]);\\n      for(int l = k + n; i != l; i++) midi.insert(v[i]), sum += v[i].first;\\n      while(i != m) maxi.insert(v[i++]);\\n    }\\n  }\\n    \\n  int calculateMKAverage() {\\n    return q.size() == m ? sum / n : -1;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255274,
                "title": "c-treemap-queue",
                "content": "```\\nclass MKAverage {\\npublic:\\n    map<int,int>record;\\n    long long total;\\n    queue<int>q;\\n    int m;\\n    int k;\\n    MKAverage(int m, int k) {\\n        this->m=m;\\n        this->k=k;\\n        total=0;\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        total+=(long long)num;\\n        record[num]++;\\n        if(q.size()>m)\\n        {\\n            int nums=q.front();\\n            q.pop();\\n            total-=nums;\\n            record[nums]--;\\n            if(record[nums]==0)record.erase(nums);\\n        }\\n        return;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(q.size()<m)return -1;\\n        long long sum=total;\\n        cout << sum << endl;\\n        int count=k;\\n        for(auto &x:record)\\n        {\\n            int nums=x.first;\\n            int times=x.second;\\n            if(times<=count)\\n            {\\n                count-=times;\\n                sum-=(long long)nums*times;\\n            }else\\n            {\\n                sum-=(long long)nums*count;\\n                count=0;\\n            }\\n            if(count==0)break;\\n        }\\n        count=k;\\n        for(auto x=record.rbegin();x!=record.rend();x++)\\n        {\\n            int nums=x->first;\\n            int times=x->second;\\n            if(x->second<=count)\\n            {\\n                count-=x->second;\\n                sum-=(long long)nums*x->second;\\n            }else\\n            {\\n                sum-=(long long)nums*count;\\n                count=0;\\n            }\\n            if(count==0)break;\\n        }\\n        return sum/(long long)(m-k*2);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nclass MKAverage {\\npublic:\\n    map<int,int>record;\\n    long long total;\\n    queue<int>q;\\n    int m;\\n    int k;\\n    MKAverage(int m, int k) {\\n        this->m=m;\\n        this->k=k;\\n        total=0;\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        total+=(long long)num;\\n        record[num]++;\\n        if(q.size()>m)\\n        {\\n            int nums=q.front();\\n            q.pop();\\n            total-=nums;\\n            record[nums]--;\\n            if(record[nums]==0)record.erase(nums);\\n        }\\n        return;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(q.size()<m)return -1;\\n        long long sum=total;\\n        cout << sum << endl;\\n        int count=k;\\n        for(auto &x:record)\\n        {\\n            int nums=x.first;\\n            int times=x.second;\\n            if(times<=count)\\n            {\\n                count-=times;\\n                sum-=(long long)nums*times;\\n            }else\\n            {\\n                sum-=(long long)nums*count;\\n                count=0;\\n            }\\n            if(count==0)break;\\n        }\\n        count=k;\\n        for(auto x=record.rbegin();x!=record.rend();x++)\\n        {\\n            int nums=x->first;\\n            int times=x->second;\\n            if(x->second<=count)\\n            {\\n                count-=x->second;\\n                sum-=(long long)nums*x->second;\\n            }else\\n            {\\n                sum-=(long long)nums*count;\\n                count=0;\\n            }\\n            if(count==0)break;\\n        }\\n        return sum/(long long)(m-k*2);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1251928,
                "title": "java-3-treesets-1-queue-clear-and-easy-to-write-code",
                "content": "## Similar problems\\nThis problem is a variant of\\n- [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)\\n\\nAnd I strongly suggest you read [this post](https://leetcode.com/problems/sliding-window-median/discuss/96346/), which shows an elegant way to rebalance between disjoint sorted sets.\\n\\n## Intuition\\n\\nLet\\'s get back to this problem. We\\'re asked to maintain the last `m` elements of a stream, while return its average excluding top `k` and bottom `k` elements. It\\'s easy to infer that some kind of sorted set data structure should be used, and logarithmic maintenance time is required.\\n\\n### Difficulties\\n\\nThe major difficulties include\\n1. How to maintain a dynamic sorted set in the first place\\n2. How to distinguish the top `k` and bottom `k` elements from the candidates for MK average\\n\\nFor 1, C++ users are lucky since there is built-in multiset. However, it\\'s not difficult to implement one in Java. The key is to differentiate between elements with the same value, which can be done using a logical counter incrementing by 1, and this assigned unique identifier can be stored with the value. Several lines of code should suffice to define such a class and corresponding comparator (or alternatively the `Comparable` interface).\\n\\nFor 2, similar to the aforementioned problems, we can use multiple disjoint dynamic sorted sets to distinguish between and maintain subsets of a population. In particular, a top `k` set, a bottom `k` set and a window of candidates for evaluation of MK average should be identified in this problem. Thus 3 multisets are needed. In addition, we should be able to remove expired elements, which can be done by recording the entry order of elements with a single queue.\\n\\n###  Invariant Maintenance\\n\\nThe most complicated part is maintain the invariant that\\n> Top `k` set and bottom `k` set contain the corresponding top or bottom `k` elements, while the remaining set contains the `m - 2k` elements left.\\n\\nAgain, I would recommend you reading the post above to learn about the intuition to rebalance between multiple sorted sets. The most important part is to define a **balancing operation**.\\n\\n## Implementation\\n\\n```java\\nclass MKAverage {\\n    static class Element {\\n        int id;\\n        int val;\\n        \\n        Element(int id, int val) {\\n            this.id = id;\\n            this.val = val;\\n        }\\n    }\\n    \\n    int m;\\n    int k;\\n    int size = 0;\\n    int sum = 0;\\n    Comparator<Element> cmp = Comparator.<Element>comparingInt(e -> e.val).thenComparingInt(e -> e.id);\\n    TreeSet<Element> window = new TreeSet<>(cmp);\\n    TreeSet<Element> topK = new TreeSet<>(cmp);\\n    TreeSet<Element> bottomK = new TreeSet<>(cmp);\\n    Queue<Element> queue = new ArrayDeque<Element>();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        var element = new Element(size++, num);\\n        queue.offer(element);\\n        window.add(element);\\n        sum += num;\\n        \\n        if (size == m) {\\n            while (window.size() > m - 2 * k) {\\n                balance();\\n            }\\n        } else if (size > m) {\\n            if (window.last().val > topK.first().val) {\\n                move(window, topK);\\n            } else {\\n                move(window, bottomK);\\n            }  \\n            var toRemove = queue.poll();\\n            topK.remove(toRemove);\\n            bottomK.remove(toRemove);\\n            if (window.remove(toRemove)) {\\n                sum -= toRemove.val;\\n            }\\n            balance();\\n        }\\n    }\\n    \\n    private void move(TreeSet<Element> from, TreeSet<Element> to) {\\n        var element = (from == topK || to == bottomK) ? from.pollFirst() : from.pollLast();\\n        to.add(element);\\n        sum += to == window ? element.val : -element.val;\\n    }\\n    \\n    private void balance() {\\n        if (topK.size() > k) {\\n            move(topK, window);\\n        } else if (bottomK.size() > k) {\\n            move(bottomK, window);\\n        }\\n        \\n        if (topK.size() < k) {\\n            move(window, topK);\\n        } else if (bottomK.size() < k) {\\n            move(window, bottomK);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return size < m ? -1 : sum / (m - 2 * k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass MKAverage {\\n    static class Element {\\n        int id;\\n        int val;\\n        \\n        Element(int id, int val) {\\n            this.id = id;\\n            this.val = val;\\n        }\\n    }\\n    \\n    int m;\\n    int k;\\n    int size = 0;\\n    int sum = 0;\\n    Comparator<Element> cmp = Comparator.<Element>comparingInt(e -> e.val).thenComparingInt(e -> e.id);\\n    TreeSet<Element> window = new TreeSet<>(cmp);\\n    TreeSet<Element> topK = new TreeSet<>(cmp);\\n    TreeSet<Element> bottomK = new TreeSet<>(cmp);\\n    Queue<Element> queue = new ArrayDeque<Element>();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        var element = new Element(size++, num);\\n        queue.offer(element);\\n        window.add(element);\\n        sum += num;\\n        \\n        if (size == m) {\\n            while (window.size() > m - 2 * k) {\\n                balance();\\n            }\\n        } else if (size > m) {\\n            if (window.last().val > topK.first().val) {\\n                move(window, topK);\\n            } else {\\n                move(window, bottomK);\\n            }  \\n            var toRemove = queue.poll();\\n            topK.remove(toRemove);\\n            bottomK.remove(toRemove);\\n            if (window.remove(toRemove)) {\\n                sum -= toRemove.val;\\n            }\\n            balance();\\n        }\\n    }\\n    \\n    private void move(TreeSet<Element> from, TreeSet<Element> to) {\\n        var element = (from == topK || to == bottomK) ? from.pollFirst() : from.pollLast();\\n        to.add(element);\\n        sum += to == window ? element.val : -element.val;\\n    }\\n    \\n    private void balance() {\\n        if (topK.size() > k) {\\n            move(topK, window);\\n        } else if (bottomK.size() > k) {\\n            move(bottomK, window);\\n        }\\n        \\n        if (topK.size() < k) {\\n            move(window, topK);\\n        } else if (bottomK.size() < k) {\\n            move(window, bottomK);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return size < m ? -1 : sum / (m - 2 * k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158588,
                "title": "c-intuitive-fenwick-tree-solution-o-n-logn-2-w-explanation",
                "content": "First of all we only need to maintain a windows of size m at any point, so we maintain a queue for storing the numbers. \\n\\nFor MK Avg calculation, the whole search space of ```[1,10^5]``` is used for each testcase. \\nI used 2 Fenwick Trees, for finding the sum of a given range in ```O(logN)``` time, the first tree is used.\\n\\nBut how to find the range?\\nThere comes the second tree. We maintain a tree for getting the count of numbers upto a given number optimally. Then again, what we can do with a mere count? So, we do a search for the number from both the start and end to find the right value at which our wanted window for the answer starts and ends. Since we are searching in the space of ```[1,10^5]```, we can do a binary search for these 2 errands. \\n\\nSo if we know the boundary values, we can simply find the sum of all the elements, currently in our queue, which lie within these 2 values. \\n\\nOne last thing, when we update our queue, we update both our trees also, because we only want to search among the numbers which are currently in window of length ```m```.\\n\\nOne final optimization, if the starting and ending values occur more than once and we don\\'t need all of them, for the given solution, I did a linear search. For that also a binary search can e done thus obtaining the mentioned complexity. That fragment of code is given in the comments.\\n\\n```\\nclass FenwickTree\\n{\\npublic:\\n\\tvector<long> tree;\\n\\tlong sum=0;\\n\\tFenwickTree(int n)\\n\\t{\\n\\t\\ttree.resize(n+1);\\n\\t}\\n\\tvoid update(int i,int val)\\n\\t{\\n\\t\\twhile(i<tree.size())\\n\\t\\t{\\n\\t\\t\\ttree[i]+=val;\\n\\t\\t\\ti+=i&(-i);\\n\\t\\t}\\n\\t\\tsum+=val;\\n\\t}\\n\\tint query(int i)\\n\\t{\\n\\t\\tint ret=0;\\n\\t\\twhile(i)\\n\\t\\t{\\n\\t\\t\\tret+=tree[i];\\n\\t\\t\\ti=i&(i-1);\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n\\tvoid append(int i)\\n\\t{\\n\\t\\tint parent=tree.size();\\n\\t\\tparent=parent&(parent-1);\\n\\t\\tsum+=i;\\n\\t\\ttree.push_back(sum-query(parent));\\n\\t}\\n\\tint binarySearch(int target)\\n\\t{\\n\\t\\tint start=1,end=tree.size()-1;\\n\\t\\twhile(start<end)\\n\\t\\t{\\n\\t\\t\\tint q=start+(end-start)/2;\\n\\t\\t\\tint temp=query(q);\\n\\t\\t\\tif(temp>=target)\\n\\t\\t\\t\\tend=q;\\n\\t\\t\\telse start=q+1;\\n\\t\\t}\\n\\t\\treturn end;\\n\\t}\\n};\\nclass MKAverage \\n{\\npublic:\\n\\tFenwickTree* sum=new FenwickTree(100000);\\n\\tFenwickTree* count = new FenwickTree(100000);\\n\\tint m,k;\\n\\tqueue<int> q;\\n    MKAverage(int x, int y) \\n    {\\n        m=x;\\n        k=y;\\n    }\\n    \\n    void addElement(int num) \\n    {\\n        q.push(num);\\n        if(q.size()>m)\\n        {\\n        \\tint temp=q.front();\\n        \\tcount->update(temp,-1);\\n        \\tsum->update(temp,-temp);\\n        \\tq.pop();\\n        }\\n        count->update(num,1);\\n        sum->update(num,num);\\n    }\\n    \\n    int calculateMKAverage() \\n    {\\n        if(q.size()<m)\\n        \\treturn -1;\\n        int temp=count->sum;\\n        int first=count->binarySearch(k),last=count->binarySearch(temp-k);\\n        int firstCount=count->query(first),lastCount=count->query(last);\\n        int firstSum=sum->query(first),lastSum=sum->query(last);\\n        while(firstCount-->k)\\n        \\tfirstSum-=first;\\n        while(lastCount-->temp-k)\\n        \\tlastSum-=last;\\n        return (lastSum-firstSum)/(m-2*k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```[1,10^5]```\n```O(logN)```\n```[1,10^5]```\n```m```\n```\\nclass FenwickTree\\n{\\npublic:\\n\\tvector<long> tree;\\n\\tlong sum=0;\\n\\tFenwickTree(int n)\\n\\t{\\n\\t\\ttree.resize(n+1);\\n\\t}\\n\\tvoid update(int i,int val)\\n\\t{\\n\\t\\twhile(i<tree.size())\\n\\t\\t{\\n\\t\\t\\ttree[i]+=val;\\n\\t\\t\\ti+=i&(-i);\\n\\t\\t}\\n\\t\\tsum+=val;\\n\\t}\\n\\tint query(int i)\\n\\t{\\n\\t\\tint ret=0;\\n\\t\\twhile(i)\\n\\t\\t{\\n\\t\\t\\tret+=tree[i];\\n\\t\\t\\ti=i&(i-1);\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n\\tvoid append(int i)\\n\\t{\\n\\t\\tint parent=tree.size();\\n\\t\\tparent=parent&(parent-1);\\n\\t\\tsum+=i;\\n\\t\\ttree.push_back(sum-query(parent));\\n\\t}\\n\\tint binarySearch(int target)\\n\\t{\\n\\t\\tint start=1,end=tree.size()-1;\\n\\t\\twhile(start<end)\\n\\t\\t{\\n\\t\\t\\tint q=start+(end-start)/2;\\n\\t\\t\\tint temp=query(q);\\n\\t\\t\\tif(temp>=target)\\n\\t\\t\\t\\tend=q;\\n\\t\\t\\telse start=q+1;\\n\\t\\t}\\n\\t\\treturn end;\\n\\t}\\n};\\nclass MKAverage \\n{\\npublic:\\n\\tFenwickTree* sum=new FenwickTree(100000);\\n\\tFenwickTree* count = new FenwickTree(100000);\\n\\tint m,k;\\n\\tqueue<int> q;\\n    MKAverage(int x, int y) \\n    {\\n        m=x;\\n        k=y;\\n    }\\n    \\n    void addElement(int num) \\n    {\\n        q.push(num);\\n        if(q.size()>m)\\n        {\\n        \\tint temp=q.front();\\n        \\tcount->update(temp,-1);\\n        \\tsum->update(temp,-temp);\\n        \\tq.pop();\\n        }\\n        count->update(num,1);\\n        sum->update(num,num);\\n    }\\n    \\n    int calculateMKAverage() \\n    {\\n        if(q.size()<m)\\n        \\treturn -1;\\n        int temp=count->sum;\\n        int first=count->binarySearch(k),last=count->binarySearch(temp-k);\\n        int firstCount=count->query(first),lastCount=count->query(last);\\n        int firstSum=sum->query(first),lastSum=sum->query(last);\\n        while(firstCount-->k)\\n        \\tfirstSum-=first;\\n        while(lastCount-->temp-k)\\n        \\tlastSum-=last;\\n        return (lastSum-firstSum)/(m-2*k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156157,
                "title": "java-bit-fenwick-60ms",
                "content": "```\\nclass MKAverage {\\n    Deque<Integer> queue;\\n    Bit countBit;\\n    Bit valueBit;\\n    int m;\\n    int k;\\n    public MKAverage(int m, int k) {\\n        queue = new ArrayDeque();\\n        countBit = new Bit(100001);\\n        valueBit = new Bit(100001);\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        queue.addLast(num);\\n        countBit.add(num, 1);\\n        valueBit.add(num, num);\\n        if(queue.size()>m)\\n        {\\n            var polledNum = queue.pollFirst();\\n            countBit.add(polledNum, -1);\\n            valueBit.add(polledNum, -polledNum);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size() < m)\\n            return -1;\\n        \\n\\t\\t// Get first k elements index\\n        var left = binarySearch(k);\\n\\t\\t\\n\\t\\t// Get last k elements index\\n        var right = binarySearch(m-k);\\n        \\n        // Ex: [5 5 5] \\n        // left and right are equal, so difference is 0. What this means is the answer is at either left or right.\\n        // Using the countBit we can calculate the correct sum at index left.\\n        // Thats why we also have to do step 1 and step 2. \\n        long result = valueBit.sum(right) - valueBit.sum(left); \\n        \\n        result += (countBit.sum(left) - k)*left; // step 1\\n        result -= (countBit.sum(right) - m + k)*right; // step 2\\n        \\n        return (int)(result/(m-2*k));\\n    }\\n    \\n    public int binarySearch(int val)\\n    {\\n        int l = 0;\\n        int r = 100001;\\n        while(l<r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if(countBit.sum(mid) < val)\\n                l = mid + 1;\\n            else \\n                r = mid;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    \\n    class Bit\\n    {\\n\\t    // Use long because the sum can exceed Integer.MAX_VALUE\\n        long[] bit;\\n        public Bit(int size)\\n        {\\n\\t\\t\\t// 1-indexed\\n            bit = new long[size+1];\\n        }\\n        \\n        public void add(int num, int value)\\n        {         \\n            num += 1;\\n            while(num < bit.length)\\n            {\\n                bit[num] += value;              \\n                num += num & (-num);\\n            }\\n        }\\n    \\n        public long sum(int num)\\n        {\\n            long s = 0;\\n            num += 1;\\n            while(num>0)\\n            {\\n                s += bit[num];\\n                num &= num-1;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    Deque<Integer> queue;\\n    Bit countBit;\\n    Bit valueBit;\\n    int m;\\n    int k;\\n    public MKAverage(int m, int k) {\\n        queue = new ArrayDeque();\\n        countBit = new Bit(100001);\\n        valueBit = new Bit(100001);\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        queue.addLast(num);\\n        countBit.add(num, 1);\\n        valueBit.add(num, num);\\n        if(queue.size()>m)\\n        {\\n            var polledNum = queue.pollFirst();\\n            countBit.add(polledNum, -1);\\n            valueBit.add(polledNum, -polledNum);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size() < m)\\n            return -1;\\n        \\n\\t\\t// Get first k elements index\\n        var left = binarySearch(k);\\n\\t\\t\\n\\t\\t// Get last k elements index\\n        var right = binarySearch(m-k);\\n        \\n        // Ex: [5 5 5] \\n        // left and right are equal, so difference is 0. What this means is the answer is at either left or right.\\n        // Using the countBit we can calculate the correct sum at index left.\\n        // Thats why we also have to do step 1 and step 2. \\n        long result = valueBit.sum(right) - valueBit.sum(left); \\n        \\n        result += (countBit.sum(left) - k)*left; // step 1\\n        result -= (countBit.sum(right) - m + k)*right; // step 2\\n        \\n        return (int)(result/(m-2*k));\\n    }\\n    \\n    public int binarySearch(int val)\\n    {\\n        int l = 0;\\n        int r = 100001;\\n        while(l<r)\\n        {\\n            int mid = l + (r-l)/2;\\n            if(countBit.sum(mid) < val)\\n                l = mid + 1;\\n            else \\n                r = mid;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    \\n    class Bit\\n    {\\n\\t    // Use long because the sum can exceed Integer.MAX_VALUE\\n        long[] bit;\\n        public Bit(int size)\\n        {\\n\\t\\t\\t// 1-indexed\\n            bit = new long[size+1];\\n        }\\n        \\n        public void add(int num, int value)\\n        {         \\n            num += 1;\\n            while(num < bit.length)\\n            {\\n                bit[num] += value;              \\n                num += num & (-num);\\n            }\\n        }\\n    \\n        public long sum(int num)\\n        {\\n            long s = 0;\\n            num += 1;\\n            while(num>0)\\n            {\\n                s += bit[num];\\n                num &= num-1;\\n            }\\n            \\n            return s;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152671,
                "title": "naive-java-solution-with-2-pqs-treemap-probably-will-be-tle-soon-though",
                "content": "Comments are in line.\\n\\nI expect this to be TLE soon with more test cases added, but I find this to be naive enough so sharing it.\\n\\n```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    List<Integer> lastM; // Record last m numbers, ordered by when they were added. This is for removing number.\\n    TreeMap<Integer, Integer> middle; // Record the numbers in the middle. Remains empty until we have more than 2*k numbers.\\n    PriorityQueue<Integer> smallerK;\\n    long smallerSum;\\n    PriorityQueue<Integer> largerK;\\n    long largerSum;\\n    long sum;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        lastM = new ArrayList<>();\\n        middle = new TreeMap<>();\\n        smallerK = new PriorityQueue<>((a, b) -> b - a);\\n        smallerSum = 0;\\n        largerK = new PriorityQueue<>();\\n        largerSum = 0;\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        /**\\n\\t\\t * First, check if need to remove number.\\n\\t\\t * If yes, remove it from the head of lastM and update total sum.\\n\\t\\t * Also check if need to remove it from middle M, smaller K or larger K, and update smaller sum and larger sum.\\n\\t\\t */\\n        if (lastM.size() == m) {\\n            int toRemove = lastM.remove(0);\\n            sum -= toRemove;\\n            if (middle.containsKey(toRemove)) {\\n                middle.put(toRemove, middle.get(toRemove) - 1);\\n                if (middle.get(toRemove) == 0) {\\n                    middle.remove(toRemove);\\n                }\\n            }\\n            \\n            if (toRemove <= smallerK.peek()) {\\n                smallerK.remove(toRemove);\\n                smallerSum -= toRemove;\\n                int toOffer = middle.firstKey();\\n                middle.put(toOffer, middle.get(toOffer) - 1);\\n                if (middle.get(toOffer) == 0) {\\n                    middle.remove(toOffer);\\n                }\\n                smallerK.offer(toOffer);\\n                smallerSum += toOffer;\\n            } else if (toRemove >= largerK.peek()) {\\n                largerK.remove(toRemove);\\n                largerSum -= toRemove;\\n                int toOffer = middle.lastKey();\\n                middle.put(toOffer, middle.get(toOffer) - 1);\\n                if (middle.get(toOffer) == 0) {\\n                    middle.remove(toOffer);\\n                }\\n                largerK.offer(toOffer);\\n                largerSum += toOffer;\\n            }\\n        }\\n        \\n\\t\\t/**\\n\\t\\t * Add it to the tail of lastM, and update total sum.\\n\\t\\t * Set the number to add to middle m to just be the current num for now, this might change if num is put into either smaller/larger half.\\n\\t\\t */\\n        lastM.add(num);\\n        int addToMiddle = num;\\n        sum += num;\\n        if (smallerK.size() < k) {\\n\\t\\t    /**\\n\\t\\t\\t * Don\\'t have k numbers yet, simply add the number to both halves and update smaller and larger sum.\\n\\t\\t\\t */\\n            smallerK.offer(num);\\n            smallerSum += num;\\n            largerK.offer(num);\\n            largerSum += num;\\n        } else {\\n\\t\\t    /**\\n\\t\\t\\t * Have more than k numbers, check whether to put the number to smaller k or larger k.\\n\\t\\t\\t * \\n\\t\\t\\t * The reason to do both check is that when we don\\'t have 2*k numbers, the two halves will overlap,\\n\\t\\t\\t * the number may still need to be in both halves.\\n\\t\\t\\t * \\n\\t\\t\\t * Update the eventual number to be added to middle m.\\n\\t\\t\\t */\\n            if (num <= smallerK.peek()) {\\n                addToMiddle = smallerK.poll();\\n                smallerSum -= addToMiddle;\\n                smallerK.offer(num);\\n                smallerSum += num;\\n            }\\n            \\n            if (num >= largerK.peek()) {\\n                addToMiddle = largerK.poll();\\n                largerSum -= addToMiddle;\\n                largerK.offer(num);\\n                largerSum += num;\\n            }\\n        }\\n        \\n\\t\\t/**\\n\\t\\t * Finally, only add to middle m if we have more than 2*k numbers.\\n\\t\\t */\\n        if (lastM.size() > 2 * k) {\\n            middle.put(addToMiddle, middle.getOrDefault(addToMiddle, 0) + 1);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (lastM.size() != m) {\\n            return -1;\\n        }\\n        \\n        return (int) ((sum - smallerSum - largerSum) / (m - 2 * k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    List<Integer> lastM; // Record last m numbers, ordered by when they were added. This is for removing number.\\n    TreeMap<Integer, Integer> middle; // Record the numbers in the middle. Remains empty until we have more than 2*k numbers.\\n    PriorityQueue<Integer> smallerK;\\n    long smallerSum;\\n    PriorityQueue<Integer> largerK;\\n    long largerSum;\\n    long sum;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        lastM = new ArrayList<>();\\n        middle = new TreeMap<>();\\n        smallerK = new PriorityQueue<>((a, b) -> b - a);\\n        smallerSum = 0;\\n        largerK = new PriorityQueue<>();\\n        largerSum = 0;\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        /**\\n\\t\\t * First, check if need to remove number.\\n\\t\\t * If yes, remove it from the head of lastM and update total sum.\\n\\t\\t * Also check if need to remove it from middle M, smaller K or larger K, and update smaller sum and larger sum.\\n\\t\\t */\\n        if (lastM.size() == m) {\\n            int toRemove = lastM.remove(0);\\n            sum -= toRemove;\\n            if (middle.containsKey(toRemove)) {\\n                middle.put(toRemove, middle.get(toRemove) - 1);\\n                if (middle.get(toRemove) == 0) {\\n                    middle.remove(toRemove);\\n                }\\n            }\\n            \\n            if (toRemove <= smallerK.peek()) {\\n                smallerK.remove(toRemove);\\n                smallerSum -= toRemove;\\n                int toOffer = middle.firstKey();\\n                middle.put(toOffer, middle.get(toOffer) - 1);\\n                if (middle.get(toOffer) == 0) {\\n                    middle.remove(toOffer);\\n                }\\n                smallerK.offer(toOffer);\\n                smallerSum += toOffer;\\n            } else if (toRemove >= largerK.peek()) {\\n                largerK.remove(toRemove);\\n                largerSum -= toRemove;\\n                int toOffer = middle.lastKey();\\n                middle.put(toOffer, middle.get(toOffer) - 1);\\n                if (middle.get(toOffer) == 0) {\\n                    middle.remove(toOffer);\\n                }\\n                largerK.offer(toOffer);\\n                largerSum += toOffer;\\n            }\\n        }\\n        \\n\\t\\t/**\\n\\t\\t * Add it to the tail of lastM, and update total sum.\\n\\t\\t * Set the number to add to middle m to just be the current num for now, this might change if num is put into either smaller/larger half.\\n\\t\\t */\\n        lastM.add(num);\\n        int addToMiddle = num;\\n        sum += num;\\n        if (smallerK.size() < k) {\\n\\t\\t    /**\\n\\t\\t\\t * Don\\'t have k numbers yet, simply add the number to both halves and update smaller and larger sum.\\n\\t\\t\\t */\\n            smallerK.offer(num);\\n            smallerSum += num;\\n            largerK.offer(num);\\n            largerSum += num;\\n        } else {\\n\\t\\t    /**\\n\\t\\t\\t * Have more than k numbers, check whether to put the number to smaller k or larger k.\\n\\t\\t\\t * \\n\\t\\t\\t * The reason to do both check is that when we don\\'t have 2*k numbers, the two halves will overlap,\\n\\t\\t\\t * the number may still need to be in both halves.\\n\\t\\t\\t * \\n\\t\\t\\t * Update the eventual number to be added to middle m.\\n\\t\\t\\t */\\n            if (num <= smallerK.peek()) {\\n                addToMiddle = smallerK.poll();\\n                smallerSum -= addToMiddle;\\n                smallerK.offer(num);\\n                smallerSum += num;\\n            }\\n            \\n            if (num >= largerK.peek()) {\\n                addToMiddle = largerK.poll();\\n                largerSum -= addToMiddle;\\n                largerK.offer(num);\\n                largerSum += num;\\n            }\\n        }\\n        \\n\\t\\t/**\\n\\t\\t * Finally, only add to middle m if we have more than 2*k numbers.\\n\\t\\t */\\n        if (lastM.size() > 2 * k) {\\n            middle.put(addToMiddle, middle.getOrDefault(addToMiddle, 0) + 1);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (lastM.size() != m) {\\n            return -1;\\n        }\\n        \\n        return (int) ((sum - smallerSum - largerSum) / (m - 2 * k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152605,
                "title": "java-o-1-calcualte-o-log-m-add-three-multiset",
                "content": "Should be short if Java has a native MultiSet implement as [Guava TreeMultiSet](https://guava.dev/releases/21.0/api/docs/com/google/common/collect/TreeMultiset.html)\\n```\\nclass MKAverage {\\n    private MultiTreeSet bottom = new MultiTreeSet();\\n    private MultiTreeSet middle = new MultiTreeSet();\\n    private MultiTreeSet top = new MultiTreeSet();    \\n    private int m, k;\\n    private LinkedList<Integer> elements = new LinkedList<>();\\n    private long sum = 0;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        elements.add(num);\\n        bottom.add(num); // blindly add to bottom\\n\\t\\t// remove the element from the corresponding stack\\n        if (elements.size() > m) {\\n            int removed = elements.removeFirst();\\n            if (bottom.contains(removed)) {\\n                bottom.remove(removed);\\n            } else if (middle.contains(removed)) {\\n                middle.remove(removed);\\n                sum -= removed;\\n            } else if (top.contains(removed)) {\\n                top.remove(removed);\\n            }\\n        }\\n        if (elements.size() == m) {\\n\\t\\t    // once we reach m, bottom can only be >= k (because each call, we add 1 element to bottom, and remove at most 1 element from it)\\n            while (bottom.total > k) {\\n                int element = bottom.pollLast();\\n                middle.add(element);\\n                sum += element;\\n            }\\n\\t\\t\\t// fix size of middle stack\\n            while (middle.total > m - 2*k) {\\n                int element = middle.pollLast();\\n                top.add(element);\\n                sum -= element;\\n            }\\n            // fix ordering of bottom-middle stack\\n            while (bottom.getLast() > middle.getFirst()) {\\n                int e1 = middle.pollFirst();\\n                int e2 = bottom.pollLast();\\n                middle.add(e2);\\n                bottom.add(e1);\\n                sum = sum - e1 + e2;\\n            }\\n            // fix ordering of middle-top stack\\n            while (middle.getLast() > top.getFirst()) {\\n                int e1 = top.pollFirst();\\n                int e2 = middle.pollLast();\\n                middle.add(e1);\\n                top.add(e2);\\n                sum = sum + e1 - e2;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return elements.size() == m ? (int)(sum/(m - 2*k)) : -1;\\n    }\\n    \\n    static class MultiTreeSet {\\n        private TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\\n        private int total = 0;\\n        \\n        public void add(int val) {\\n            int count = map.getOrDefault(val, 0) + 1;\\n            map.put(val, count);\\n            total++;\\n        }\\n        \\n        public void remove(int val) {\\n            int count = map.get(val);\\n            if (count == 1) map.remove(val);\\n            else map.put(val, count-1);\\n            total--;\\n        }\\n        \\n        public boolean contains(int val) {\\n            return map.containsKey(val);\\n        }\\n        \\n        public int getFirst() {\\n            return map.firstKey();\\n        }\\n        \\n        public int getLast() {\\n            return map.lastKey();\\n        }\\n        \\n        public int pollFirst() {\\n            int first = map.firstKey();\\n            remove(first);\\n            return first;\\n        }\\n        \\n        public int pollLast() {\\n            int last = map.lastKey();\\n            remove(last);\\n            return last;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    private MultiTreeSet bottom = new MultiTreeSet();\\n    private MultiTreeSet middle = new MultiTreeSet();\\n    private MultiTreeSet top = new MultiTreeSet();    \\n    private int m, k;\\n    private LinkedList<Integer> elements = new LinkedList<>();\\n    private long sum = 0;\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        elements.add(num);\\n        bottom.add(num); // blindly add to bottom\\n\\t\\t// remove the element from the corresponding stack\\n        if (elements.size() > m) {\\n            int removed = elements.removeFirst();\\n            if (bottom.contains(removed)) {\\n                bottom.remove(removed);\\n            } else if (middle.contains(removed)) {\\n                middle.remove(removed);\\n                sum -= removed;\\n            } else if (top.contains(removed)) {\\n                top.remove(removed);\\n            }\\n        }\\n        if (elements.size() == m) {\\n\\t\\t    // once we reach m, bottom can only be >= k (because each call, we add 1 element to bottom, and remove at most 1 element from it)\\n            while (bottom.total > k) {\\n                int element = bottom.pollLast();\\n                middle.add(element);\\n                sum += element;\\n            }\\n\\t\\t\\t// fix size of middle stack\\n            while (middle.total > m - 2*k) {\\n                int element = middle.pollLast();\\n                top.add(element);\\n                sum -= element;\\n            }\\n            // fix ordering of bottom-middle stack\\n            while (bottom.getLast() > middle.getFirst()) {\\n                int e1 = middle.pollFirst();\\n                int e2 = bottom.pollLast();\\n                middle.add(e2);\\n                bottom.add(e1);\\n                sum = sum - e1 + e2;\\n            }\\n            // fix ordering of middle-top stack\\n            while (middle.getLast() > top.getFirst()) {\\n                int e1 = top.pollFirst();\\n                int e2 = middle.pollLast();\\n                middle.add(e1);\\n                top.add(e2);\\n                sum = sum + e1 - e2;\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return elements.size() == m ? (int)(sum/(m - 2*k)) : -1;\\n    }\\n    \\n    static class MultiTreeSet {\\n        private TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\\n        private int total = 0;\\n        \\n        public void add(int val) {\\n            int count = map.getOrDefault(val, 0) + 1;\\n            map.put(val, count);\\n            total++;\\n        }\\n        \\n        public void remove(int val) {\\n            int count = map.get(val);\\n            if (count == 1) map.remove(val);\\n            else map.put(val, count-1);\\n            total--;\\n        }\\n        \\n        public boolean contains(int val) {\\n            return map.containsKey(val);\\n        }\\n        \\n        public int getFirst() {\\n            return map.firstKey();\\n        }\\n        \\n        public int getLast() {\\n            return map.lastKey();\\n        }\\n        \\n        public int pollFirst() {\\n            int first = map.firstKey();\\n            remove(first);\\n            return first;\\n        }\\n        \\n        public int pollLast() {\\n            int last = map.lastKey();\\n            remove(last);\\n            return last;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152497,
                "title": "c-fenwick-tree-solution",
                "content": "The idea for the problem is to maintain a data structure so that it can list the first k numbers\\' sum and last k numbers\\' sum quickly. It will also have the capability of counting how many elements there are between specific range of the values. The data structure has the aformentioned abilities is a Fenwick Tree. You can have the implementation of a segment tree as well. But it will overcomplicate the issue.\\n\\nHow do we find the sum of first k elements? Essentially, whenever a new element flies in, we have a sliding window to window out an element that is out of the last m elements. We can use -1 and -value on the Fenwick tree to undo its effect. \\n\\nNow, we want to find the first k elements\\' sum. We can use binary search to find the value such that the sum of the occurence of values less than a given value x is less than k, and we will have to find the first spot such property violated.\\n\\nWe just need to do some simple math to figure out what exactly the sum of the first k elements will be given the value of the violator and the value of the sum before the violator. And we will get the first k elements\\' sum.\\n\\nFor the last k elements, it works the same.\\n\\nMy code is written in cLay, a transpiler written by LayCurse. For accessing it, you can either visit his yukicoder page or you can visit the link here: [LayCurse\\'s Blog](http://rsujskf.s602.xrea.com/)\\n\\n```\\n#define main dummy_main\\n{}\\n#undef main\\n\\nconst int MN = 1d5+10;\\nclass MKAverage {\\npublic:\\n    int m, k, size, a[MN];\\n    fenwick<ll> tr[2];\\n\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        this->size = 0;\\n        dummy_main();\\n        rep(i,0,2){\\n            tr[i].walloc(MN);\\n            tr[i].init(MN);\\n        }\\n    }\\n    \\n    void addElement(int num) {\\n        int & x = this->size;\\n        if( x >= m){\\n            tr[0].add(a[x-m], -1);\\n            tr[1].add(a[x-m], -a[x-m]);\\n        }\\n        a[x] = num;\\n        tr[0].add(num, 1);\\n        tr[1].add(num, num); \\n        ++x; \\n    }\\n    \\n    int calculateMKAverage() {\\n        // tr[0].range(0, x);\\n        // tr[0].range(x,1d5+2);\\n        if(size < m) return -1;\\n        auto u =bsearch_max[int, x, 0, 1d5+2] (tr[0].range(0,x) <= k);\\n        u = max(u-2,0);\\n        while(tr[0].range(0,u) <= k) ++u;\\n        --u;\\n        auto v = tr[0].range(0,u);\\n        auto vv = k-v;\\n        auto lowex = vv*(u+1) + tr[1].range(0,u);\\n        //part one\\n\\n        auto uu = bsearch_min[int, x, 0, 1d5+2] (tr[0].range(x,1d5+2) <= k);\\n        uu = min(uu+2,1d5+2);\\n        while(tr[0].range(uu, 1d5+2) <= k) --uu;\\n        ++uu;\\n        auto vvv = tr[0].range(uu, 1d5+2);\\n        auto vx = k-vvv;\\n        auto upperx = vx * (uu-1)+tr[1].range(uu, 1d5+2);\\n        auto whole = tr[1].range(0,1d5+2);\\n        return (whole-upperx-lowex)/(m-2*k);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n\\n\\n// void main(){\\n\\n//     MKAverage mk(3,1);\\n//     mk.addElement(3);\\n//     mk.addElement(1);\\n//     wt( mk.calculateMKAverage());\\n//     mk.addElement(10);\\n//     wt(mk.calculateMKAverage());\\n//     mk.addElement(5);\\n//     mk.addElement(5);\\n//     mk.addElement(5);\\n//     __asm int 3;\\n//     wt(mk.calculateMKAverage());\\n// }\\n```",
                "solutionTags": [],
                "code": "```\\n#define main dummy_main\\n{}\\n#undef main\\n\\nconst int MN = 1d5+10;\\nclass MKAverage {\\npublic:\\n    int m, k, size, a[MN];\\n    fenwick<ll> tr[2];\\n\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        this->size = 0;\\n        dummy_main();\\n        rep(i,0,2){\\n            tr[i].walloc(MN);\\n            tr[i].init(MN);\\n        }\\n    }\\n    \\n    void addElement(int num) {\\n        int & x = this->size;\\n        if( x >= m){\\n            tr[0].add(a[x-m], -1);\\n            tr[1].add(a[x-m], -a[x-m]);\\n        }\\n        a[x] = num;\\n        tr[0].add(num, 1);\\n        tr[1].add(num, num); \\n        ++x; \\n    }\\n    \\n    int calculateMKAverage() {\\n        // tr[0].range(0, x);\\n        // tr[0].range(x,1d5+2);\\n        if(size < m) return -1;\\n        auto u =bsearch_max[int, x, 0, 1d5+2] (tr[0].range(0,x) <= k);\\n        u = max(u-2,0);\\n        while(tr[0].range(0,u) <= k) ++u;\\n        --u;\\n        auto v = tr[0].range(0,u);\\n        auto vv = k-v;\\n        auto lowex = vv*(u+1) + tr[1].range(0,u);\\n        //part one\\n\\n        auto uu = bsearch_min[int, x, 0, 1d5+2] (tr[0].range(x,1d5+2) <= k);\\n        uu = min(uu+2,1d5+2);\\n        while(tr[0].range(uu, 1d5+2) <= k) --uu;\\n        ++uu;\\n        auto vvv = tr[0].range(uu, 1d5+2);\\n        auto vx = k-vvv;\\n        auto upperx = vx * (uu-1)+tr[1].range(uu, 1d5+2);\\n        auto whole = tr[1].range(0,1d5+2);\\n        return (whole-upperx-lowex)/(m-2*k);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n\\n\\n// void main(){\\n\\n//     MKAverage mk(3,1);\\n//     mk.addElement(3);\\n//     mk.addElement(1);\\n//     wt( mk.calculateMKAverage());\\n//     mk.addElement(10);\\n//     wt(mk.calculateMKAverage());\\n//     mk.addElement(5);\\n//     mk.addElement(5);\\n//     mk.addElement(5);\\n//     __asm int 3;\\n//     wt(mk.calculateMKAverage());\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938332,
                "title": "python3-keeping-three-containers-for-small-middle-large-values-runtime-98-memory-94",
                "content": "# Intuition\\nSince this data structure deals only with the last m elements from a data stream, it\\'s natural to use a deque that only stores the latest m elements (*self.container*). The first solution I came up was precisely that, as can be seen from the commented data block. \\n\\nIn that straight-forward approach, whenever a valid \"calculateMKAverage\" query is sent, we will sort *self.container* ad hoc in order to preserve the order of the data stream from sorting. It\\'s pretty obvious why that approach is unfeasible with larger m, as each sort operation is an $$O(m log m)$$ operation. I tried implementing a basic cache that only gets refreshed when the data is changed, and the newly added value does not equal to the removed value. This however is inadequate for this question. It was this tinkering with cache that led me to the solution that I finally came up with\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe use *self.container* to keep track of the data stream order, and use three separate sorted containers (*self.smallest, self.middle, self.largest*) to keep track of the minimum/maximum-k elements, and the m-2k elements in the middle. \\nUsing SortedList provides many crucial advantages for our purpose:\\n1. The sorted nature of the elements means that add, delete and membership operations benefit from binary search algorithm (which is natively provided by the SortedList). As can be seen on https://grantjenks.com/docs/sortedcontainers/sortedlist.html, add, remove and pop operations only have $$O(log(k))$$ time complexity on SortedList\\n2. Because the three containers are separately sorted, moving between smallest/middle and largest/middle becomes very easy: we know that it must happen at their respective ends (for example, when a new added value is smaller than existing values in the smallest container, it will naturally be sorted to take the index of middle[0], and the element that no longer is the smallest would sit at the index of smallest[-1] after we move the new value into the smallest container)\\n3. Sorting operations have the average time complexity of $$O(n log n)$$. This means that doing a lump-sum sorting of the entire container will certainly be less efficient than doing three sortings of smaller containers($$max(O(klogk), O((m-2k)log(m-2k))$$). What\\'s more, by using SortedList we aren\\'t even doing a complete sorting each time! A full sorting only happens when we initialize the three containers, and all subsequent operations involve the adding and deleting of single elements, which are $$O(log(k))$$ operations.\\n\\nThe other optimization is keeping a running sum instead of calculating the sum of *self.middle* every time when average is queried. With any addition and deletion of element it will only impact the running_sum in 2 ways:\\n1. When an element is put in the *self.middle* (either as a new element, or moving from the extremes), we add it to the running sum\\n2. When an element is removed from *self.middle* (either directly removed, or moving to the extremes), we subtract it from the running sum.\\n\\n\\nLet\\'s break down what happens when a new element(*num*) gets added:\\n\\n1. When the container has not reached m, we simply appended *num* at the end of *self.container*. If after appending it we have reached the target size of m, we initialize the partition of values into *self.smallest, self.middle, self.largest*, and calculate the initial running sum *self.mid_sum*\\n\\n2. For any subsequent data stream, it will be pushed onto *self.container*, and the oldest one gets popped. After keeping track of stream order with this deque, we move our attention to how this will impact the three containers (Tip: *smallest[-1] == max(smallest), largest[0] == min(largest)*):\\n- If both the popped element and the added element belong to the middle container, we don\\'t have to worry about anything else: we delete the old value and add the new value to our running sum\\n- If the popped element is from the middle, and the added element goes to the extremes, we will check where it will actually go to (*num_small = num<= self.smallest[-1]*). Remember, since only the k number of extreme values get discarded, after adding a new element it will now contain k+1 elements, with the one at their respective end (*max(smallest) and min(largest)*) disqualified and moved back to the middle. We then adjust the running sum based on which one moved into and which one moved out of the midle\\n- If the popped element is from the extremes, we will first put the new element in the middle, and move min(middle) or max(middle) to the side the of extreme that has its element just popped. **And here\\'s a pitfall: the new value can potentially update the other extreme.** Here\\'s the debugging log when you didn\\'t check for that: As you can see, we didn\\'t check if 64938 can update the largest, resulting in 64938 incorrectly placed in the middle.\\n\\n```\\nSortedList([8272]) SortedList([15456]) SortedList([33433])\\nContainer before adding: deque([8272, 33433, 15456])\\nPopped: 8272 Num: 64938\\nSortedList([15456]) SortedList([64938]) SortedList([33433])\\n\\n```\\n\\n- Solving the above mentioned bug is easy: it doesn\\'t hurt if we simply try to update the other extreme by moving the potential update candidate there, and pulling back the disqualified one! If the new value doesn\\'t update it, nothing happens since they\\'ll be pulled back, but if it does, then it will correctly update it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log k)$$ for *addElement* since each time it only involves a handful of operations involving adding and removing values from three SortedList.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$, since we store a m-sized deque and a partition of that deque, with total size of 2m\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# from collections import deque\\n\\n\\n# class MKAverage:\\n#     container = None\\n#     m = None\\n#     k = None\\n#     cached = None\\n#     def __init__(self, m: int, k: int):\\n#         self.container = deque()\\n#         self.m = m\\n#         self.k = k\\n#         self.cached = None\\n\\n#     def addElement(self, num: int) -> None:\\n#         popped = None\\n#         if len(self.container) < self.m:\\n#             self.container.append(num)\\n#         else:\\n#             popped = self.container.popleft()\\n#             self.container.append(num)\\n#         if popped != num:\\n#             self.cached = None\\n\\n#     def calculateMKAverage(self) -> int:\\n#         if len(self.container) < self.m:\\n#             return -1\\n#         if self.cached is not None:\\n#             return self.cached\\n#         m = self.m\\n#         k = self.k\\n#         self.cached = int(sum(sorted(self.container)[k:m-k])/(m-2*k))\\n#         return self.cached\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n\\n\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.smallest = SortedList()\\n        self.middle = SortedList()\\n        self.largest = SortedList()\\n        self.container = deque()\\n        self.mid_sum = None\\n        self.m = m\\n        self.k = k\\n \\n        \\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.container) < self.m:\\n            self.container.append(num)\\n            if len(self.container) == self.m:\\n                #initializing partition when first filled\\n                sorted_result = sorted(self.container)\\n                self.smallest = SortedList(sorted_result[:self.k])\\n                self.middle = SortedList(sorted_result[self.k:self.m-self.k])\\n                self.largest = SortedList(sorted_result[-self.k:])\\n                self.mid_sum = sum(self.middle)\\n        else:\\n            #print (\"Container before adding:\", self.container)\\n            popped = self.container.popleft()\\n            self.container.append(num)\\n            #print (\"Popped:\", popped, \"Num:\", num)\\n            # if popped from middle and added to middle, don\\'t worry about anything\\n            if self.smallest[-1]<popped<self.largest[0] and self.smallest[-1]<num<self.largest[0]:\\n                self.mid_sum+=num-popped\\n                self.middle.add(num)\\n                self.middle.remove(popped)\\n\\n                \\n            # if popped from the middle and added to the extremes, update corresponding container\\n            elif self.smallest[-1]<popped<self.largest[0]:\\n                self.middle.remove(popped)\\n                # where should num go\\n                num_small = num<= self.smallest[-1]\\n                if num_small:\\n                    self.smallest.add(num)\\n                    # element that moved to the middle\\n                    moved = self.smallest.pop()\\n                else:\\n                    self.largest.add(num)\\n                    # element that moved to the middle\\n                    moved = self.largest.pop(0)\\n                self.middle.add(moved)\\n                self.mid_sum += moved-popped\\n                \\n            # if popped from the extremes, first putting the new number in the middle, then move\\n            # popped from smallest\\n            elif popped<= self.smallest[-1]:\\n                self.smallest.remove(popped)\\n                self.middle.add(num)\\n                # smallest in the middle moved to smallest container\\n                moved = self.middle.pop(0)\\n                self.smallest.add(moved)\\n                # First adding num to middle, then moving moved from middle\\n                self.mid_sum += num-moved\\n                # Updating the largest container\\n                # moving max(middle) to largest\\n                moved = self.middle.pop()\\n                self.mid_sum -= moved\\n                self.largest.add(moved)\\n                # moving min(largest) to middle\\n                moved = self.largest.pop(0)\\n                self.mid_sum += moved\\n                self.middle.add(moved)\\n                \\n            elif popped>= self.largest[0]:\\n                self.largest.remove(popped)\\n                self.middle.add(num)\\n                # largest in the middle moved to largest container\\n                moved = self.middle.pop()\\n                self.largest.add(moved)\\n                # First adding num to middle, then moving moved from middle\\n                self.mid_sum += num-moved\\n                # Updating the smallest container\\n                # moving min(middle) to smallest\\n                moved = self.middle.pop(0)\\n                self.mid_sum -= moved\\n                self.smallest.add(moved)\\n                # moving max(smallest) to middle\\n                moved = self.smallest.pop()\\n                self.mid_sum += moved\\n                self.middle.add(moved)\\n\\n    \\n            #print (self.smallest, self.middle, self.largest)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.container) < self.m:\\n            return -1\\n        return self.mid_sum // (self.m - 2* self.k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nSortedList([8272]) SortedList([15456]) SortedList([33433])\\nContainer before adding: deque([8272, 33433, 15456])\\nPopped: 8272 Num: 64938\\nSortedList([15456]) SortedList([64938]) SortedList([33433])\\n\\n```\n```\\n# from collections import deque\\n\\n\\n# class MKAverage:\\n#     container = None\\n#     m = None\\n#     k = None\\n#     cached = None\\n#     def __init__(self, m: int, k: int):\\n#         self.container = deque()\\n#         self.m = m\\n#         self.k = k\\n#         self.cached = None\\n\\n#     def addElement(self, num: int) -> None:\\n#         popped = None\\n#         if len(self.container) < self.m:\\n#             self.container.append(num)\\n#         else:\\n#             popped = self.container.popleft()\\n#             self.container.append(num)\\n#         if popped != num:\\n#             self.cached = None\\n\\n#     def calculateMKAverage(self) -> int:\\n#         if len(self.container) < self.m:\\n#             return -1\\n#         if self.cached is not None:\\n#             return self.cached\\n#         m = self.m\\n#         k = self.k\\n#         self.cached = int(sum(sorted(self.container)[k:m-k])/(m-2*k))\\n#         return self.cached\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n\\n\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.smallest = SortedList()\\n        self.middle = SortedList()\\n        self.largest = SortedList()\\n        self.container = deque()\\n        self.mid_sum = None\\n        self.m = m\\n        self.k = k\\n \\n        \\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.container) < self.m:\\n            self.container.append(num)\\n            if len(self.container) == self.m:\\n                #initializing partition when first filled\\n                sorted_result = sorted(self.container)\\n                self.smallest = SortedList(sorted_result[:self.k])\\n                self.middle = SortedList(sorted_result[self.k:self.m-self.k])\\n                self.largest = SortedList(sorted_result[-self.k:])\\n                self.mid_sum = sum(self.middle)\\n        else:\\n            #print (\"Container before adding:\", self.container)\\n            popped = self.container.popleft()\\n            self.container.append(num)\\n            #print (\"Popped:\", popped, \"Num:\", num)\\n            # if popped from middle and added to middle, don\\'t worry about anything\\n            if self.smallest[-1]<popped<self.largest[0] and self.smallest[-1]<num<self.largest[0]:\\n                self.mid_sum+=num-popped\\n                self.middle.add(num)\\n                self.middle.remove(popped)\\n\\n                \\n            # if popped from the middle and added to the extremes, update corresponding container\\n            elif self.smallest[-1]<popped<self.largest[0]:\\n                self.middle.remove(popped)\\n                # where should num go\\n                num_small = num<= self.smallest[-1]\\n                if num_small:\\n                    self.smallest.add(num)\\n                    # element that moved to the middle\\n                    moved = self.smallest.pop()\\n                else:\\n                    self.largest.add(num)\\n                    # element that moved to the middle\\n                    moved = self.largest.pop(0)\\n                self.middle.add(moved)\\n                self.mid_sum += moved-popped\\n                \\n            # if popped from the extremes, first putting the new number in the middle, then move\\n            # popped from smallest\\n            elif popped<= self.smallest[-1]:\\n                self.smallest.remove(popped)\\n                self.middle.add(num)\\n                # smallest in the middle moved to smallest container\\n                moved = self.middle.pop(0)\\n                self.smallest.add(moved)\\n                # First adding num to middle, then moving moved from middle\\n                self.mid_sum += num-moved\\n                # Updating the largest container\\n                # moving max(middle) to largest\\n                moved = self.middle.pop()\\n                self.mid_sum -= moved\\n                self.largest.add(moved)\\n                # moving min(largest) to middle\\n                moved = self.largest.pop(0)\\n                self.mid_sum += moved\\n                self.middle.add(moved)\\n                \\n            elif popped>= self.largest[0]:\\n                self.largest.remove(popped)\\n                self.middle.add(num)\\n                # largest in the middle moved to largest container\\n                moved = self.middle.pop()\\n                self.largest.add(moved)\\n                # First adding num to middle, then moving moved from middle\\n                self.mid_sum += num-moved\\n                # Updating the smallest container\\n                # moving min(middle) to smallest\\n                moved = self.middle.pop(0)\\n                self.mid_sum -= moved\\n                self.smallest.add(moved)\\n                # moving max(smallest) to middle\\n                moved = self.smallest.pop()\\n                self.mid_sum += moved\\n                self.middle.add(moved)\\n\\n    \\n            #print (self.smallest, self.middle, self.largest)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.container) < self.m:\\n            return -1\\n        return self.mid_sum // (self.m - 2* self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507362,
                "title": "python-faster-than-100-using-1-hash",
                "content": "Algorithm is fairly straightforward. Keep track of the m window with a hash. Use hash to find MK Average. Ran 4x. Faster than 100% each time and 100% less memory 3x (89% the other).\\n\\nMore Details:\\n\\nOn insert\\n1. Increment the counter for the newest number in the hash.\\n2. If we\\'ve already added m elements to the hash, decrement the counter for the oldest element.\\n3. Clean up unnecessary keys\\n\\nCalculating Average\\nHash already contains exactly the m window as (k,v) where sum of values == m.\\n1. Sort the keys. Keys represent the numbers in the m window.\\n2. Loop through the keys from both sides simultaneously; decreasing the values of endpoints until only middle keys have v > 0.\\n3. Instead of adding every number in the m window, take the product sum of k,v to save on operations. Skip the multiplication for kth largest and smallest elements in the hash.\\n4. Return the average\\n\\nCode\\n```\\nclass MKAverage(object):\\n\\n    def __init__(self, m, k):\\n        \"\"\"\\n        :type m: int\\n        :type k: int\\n        \"\"\"\\n        self.m = m\\n        self.k = k\\n        self.values = []\\n        self.holder = {}\\n\\n    def addElement(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        self.values.append(num)\\n        self.holder[num] = 1 if num not in self.holder else self.holder[num] + 1\\n        if len(self.values) > self.m:\\n            val = self.values[-self.m-1]\\n            if self.holder[val] == 1:\\n                del(self.holder[val])\\n            else:\\n                self.holder[val] -= 1\\n\\n    def calculateMKAverage(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if len(self.values) < self.m:\\n            return -1\\n        \\n        kbegin,kend = self.k,self.k\\n        workingcopy = self.holder.copy()\\n        sortedkeys = sorted(self.holder.keys())\\n\\n        for i,x in enumerate(sortedkeys):\\n           \\n            if kbegin <= 0 and kend <= 0: break\\n            \\n            if kbegin < workingcopy[x] and kbegin > 0:\\n                workingcopy[x] -= kbegin\\n                kbegin = 0\\n            elif kbegin >= workingcopy[x]:\\n                kbegin -= workingcopy[x]\\n                workingcopy[x] = 0\\n            \\n            if kend < workingcopy[sortedkeys[-i-1]] and kend > 0:\\n                workingcopy[sortedkeys[-i-1]] -= kend\\n                kend = 0\\n            elif kend >= workingcopy[sortedkeys[-i-1]]:\\n                kend -= workingcopy[sortedkeys[-i-1]]\\n                workingcopy[sortedkeys[-i-1]] = 0\\n        \\n        nums = [ k*workingcopy[k] for k in workingcopy if workingcopy[k] > 0]\\n        \\n        return sum(nums)//(self.m-self.k*2)\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Algorithm is fairly straightforward. Keep track of the m window with a hash. Use hash to find MK Average. Ran 4x. Faster than 100% each time and 100% less memory 3x (89% the other).\\n\\nMore Details:\\n\\nOn insert\\n1. Increment the counter for the newest number in the hash.\\n2. If we\\'ve already added m elements to the hash, decrement the counter for the oldest element.\\n3. Clean up unnecessary keys\\n\\nCalculating Average\\nHash already contains exactly the m window as (k,v) where sum of values == m.\\n1. Sort the keys. Keys represent the numbers in the m window.\\n2. Loop through the keys from both sides simultaneously; decreasing the values of endpoints until only middle keys have v > 0.\\n3. Instead of adding every number in the m window, take the product sum of k,v to save on operations. Skip the multiplication for kth largest and smallest elements in the hash.\\n4. Return the average\\n\\nCode\\n```\\nclass MKAverage(object):\\n\\n    def __init__(self, m, k):\\n        \"\"\"\\n        :type m: int\\n        :type k: int\\n        \"\"\"\\n        self.m = m\\n        self.k = k\\n        self.values = []\\n        self.holder = {}\\n\\n    def addElement(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        self.values.append(num)\\n        self.holder[num] = 1 if num not in self.holder else self.holder[num] + 1\\n        if len(self.values) > self.m:\\n            val = self.values[-self.m-1]\\n            if self.holder[val] == 1:\\n                del(self.holder[val])\\n            else:\\n                self.holder[val] -= 1\\n\\n    def calculateMKAverage(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if len(self.values) < self.m:\\n            return -1\\n        \\n        kbegin,kend = self.k,self.k\\n        workingcopy = self.holder.copy()\\n        sortedkeys = sorted(self.holder.keys())\\n\\n        for i,x in enumerate(sortedkeys):\\n           \\n            if kbegin <= 0 and kend <= 0: break\\n            \\n            if kbegin < workingcopy[x] and kbegin > 0:\\n                workingcopy[x] -= kbegin\\n                kbegin = 0\\n            elif kbegin >= workingcopy[x]:\\n                kbegin -= workingcopy[x]\\n                workingcopy[x] = 0\\n            \\n            if kend < workingcopy[sortedkeys[-i-1]] and kend > 0:\\n                workingcopy[sortedkeys[-i-1]] -= kend\\n                kend = 0\\n            elif kend >= workingcopy[sortedkeys[-i-1]]:\\n                kend -= workingcopy[sortedkeys[-i-1]]\\n                workingcopy[sortedkeys[-i-1]] = 0\\n        \\n        nums = [ k*workingcopy[k] for k in workingcopy if workingcopy[k] > 0]\\n        \\n        return sum(nums)//(self.m-self.k*2)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2425057,
                "title": "python-solution-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.arr = SortedList()\\n        self.m = m\\n        self.k = k\\n        self.q = deque()\\n        self.total = None\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        m = self.m\\n        k = self.k\\n        if len(self.q) > m:\\n            val = self.q.popleft()            \\n            ind1 = self.arr.bisect_left(val)\\n            ind2 = self.arr.bisect_right(val)\\n            left, right, mid = False, False, False\\n            kth, mth = self.arr[k], self.arr[m - k - 1]\\n            if k <= ind1 < m - k or k <= ind2 - 1 < m - k or (ind1 <= k and  m - k <= ind2 - 1 < m):\\n                mid = True\\n            elif ind1 < k:\\n                left = True\\n            elif ind2 - 1 >= m - k:\\n                right = True            \\n            \\n            self.arr.remove(val)\\n            ind1 = self.arr.bisect_left(num)\\n            ind2 = self.arr.bisect_right(num)            \\n            self.arr.add(num)            \\n            \\n            if k <= ind1 < m - k or k <= ind2 < m - k or (ind1 <= k and  m - k <= ind2 < m):\\n                if mid:\\n                    self.total += num - val\\n                if left:\\n                    self.total += num - kth\\n                if right:\\n                    self.total += num - mth\\n            elif ind1 < k:\\n                if mid:\\n                    self.total += self.arr[k] - val\\n                if left:\\n                    pass\\n                if right:\\n                    self.total += self.arr[k] - mth\\n            elif ind2 >= m - k:\\n                if mid:\\n                    self.total += self.arr[m - k - 1] - val\\n                if left:\\n                    self.total += self.arr[m - k - 1] - kth\\n                if right:\\n                    pass\\n        else:\\n            self.arr.add(num)\\n            if self.total is None and len(self.arr) == self.m:\\n                self.total = sum(self.arr[k:m-k])\\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        \\n        return int(self.total / (self.m - 2 * self.k))\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.arr = SortedList()\\n        self.m = m\\n        self.k = k\\n        self.q = deque()\\n        self.total = None\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        m = self.m\\n        k = self.k\\n        if len(self.q) > m:\\n            val = self.q.popleft()            \\n            ind1 = self.arr.bisect_left(val)\\n            ind2 = self.arr.bisect_right(val)\\n            left, right, mid = False, False, False\\n            kth, mth = self.arr[k], self.arr[m - k - 1]\\n            if k <= ind1 < m - k or k <= ind2 - 1 < m - k or (ind1 <= k and  m - k <= ind2 - 1 < m):\\n                mid = True\\n            elif ind1 < k:\\n                left = True\\n            elif ind2 - 1 >= m - k:\\n                right = True            \\n            \\n            self.arr.remove(val)\\n            ind1 = self.arr.bisect_left(num)\\n            ind2 = self.arr.bisect_right(num)            \\n            self.arr.add(num)            \\n            \\n            if k <= ind1 < m - k or k <= ind2 < m - k or (ind1 <= k and  m - k <= ind2 < m):\\n                if mid:\\n                    self.total += num - val\\n                if left:\\n                    self.total += num - kth\\n                if right:\\n                    self.total += num - mth\\n            elif ind1 < k:\\n                if mid:\\n                    self.total += self.arr[k] - val\\n                if left:\\n                    pass\\n                if right:\\n                    self.total += self.arr[k] - mth\\n            elif ind2 >= m - k:\\n                if mid:\\n                    self.total += self.arr[m - k - 1] - val\\n                if left:\\n                    self.total += self.arr[m - k - 1] - kth\\n                if right:\\n                    pass\\n        else:\\n            self.arr.add(num)\\n            if self.total is None and len(self.arr) == self.m:\\n                self.total = sum(self.arr[k:m-k])\\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        \\n        return int(self.total / (self.m - 2 * self.k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058455,
                "title": "segment-tree-solution",
                "content": "```\\nclass MKAverage {\\npublic:\\n    #define LL long long\\n    struct node {\\n        int frq;\\n        LL sum;\\n        \\n        node() { frq = 0; sum = 0; }\\n        node(int _frq, LL _sum): frq(_frq), sum(_sum) {}\\n    };\\n    \\n    node Tree[100005 * 4];\\n    const int limit = 100000;\\n\\n    \\n    node merge_segments(const node &lf, const node &rt) {\\n        return node(lf.frq + rt.frq, lf.sum + rt.sum);\\n    }\\n    \\n    void update(int node, int b, int e, int pos, int add) {\\n        if (b == e) {\\n            Tree[node].frq += add;\\n            Tree[node].sum += (add * pos);\\n            return ;\\n        }\\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        if (pos <= mid) update(lf, b, mid, pos, add);\\n        else update(rt, mid + 1, e, pos, add);\\n        \\n        Tree[node] = merge_segments(Tree[lf], Tree[rt]);\\n    }\\n    \\n    \\n    LL get_left_kth_sum(int node, int b, int e, int kth) {\\n        if (kth <= 0) return 0;\\n        if (kth >= Tree[node].frq) return Tree[node].sum;\\n        if (b == e) {\\n            return kth * 1LL * b;\\n        }\\n        \\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        return get_left_kth_sum(lf, b, mid, kth) + get_left_kth_sum(rt, mid + 1, e, kth - Tree[lf].frq);\\n    }\\n    \\n    LL get_right_kth_sum(int node, int b, int e, int kth) {\\n        if (kth <= 0) return 0;\\n        if (kth >= Tree[node].frq) return Tree[node].sum;\\n        if (b == e) {\\n            return kth * 1LL * b;\\n        }\\n        \\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        return get_right_kth_sum(lf, b, mid, kth - Tree[rt].frq) + get_right_kth_sum(rt, mid + 1, e, kth);\\n    }\\n    \\n    int M, K;\\n    queue <int> window;\\n\\n    MKAverage(int m, int k) {\\n        M = m;\\n        K = k;\\n    }\\n    \\n    void addElement(int num) {\\n        window.push(num);\\n        update(1, 0, limit, num, +1);\\n        \\n        if (window.size() > M) {\\n            update(1, 0, limit, window.front(), -1);\\n            window.pop();\\n        }\\n        \\n    }\\n    \\n    int calculateMKAverage() {\\n        if (window.size() < M) return -1;\\n        LL total = Tree[1].sum;\\n        LL left_k_sum = get_left_kth_sum(1, 0, limit, K);\\n        LL right_k_sum = get_right_kth_sum(1, 0, limit, K);\\n        \\n        \\n        return (total - left_k_sum - right_k_sum) / (M - 2 * K);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n    #define LL long long\\n    struct node {\\n        int frq;\\n        LL sum;\\n        \\n        node() { frq = 0; sum = 0; }\\n        node(int _frq, LL _sum): frq(_frq), sum(_sum) {}\\n    };\\n    \\n    node Tree[100005 * 4];\\n    const int limit = 100000;\\n\\n    \\n    node merge_segments(const node &lf, const node &rt) {\\n        return node(lf.frq + rt.frq, lf.sum + rt.sum);\\n    }\\n    \\n    void update(int node, int b, int e, int pos, int add) {\\n        if (b == e) {\\n            Tree[node].frq += add;\\n            Tree[node].sum += (add * pos);\\n            return ;\\n        }\\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        if (pos <= mid) update(lf, b, mid, pos, add);\\n        else update(rt, mid + 1, e, pos, add);\\n        \\n        Tree[node] = merge_segments(Tree[lf], Tree[rt]);\\n    }\\n    \\n    \\n    LL get_left_kth_sum(int node, int b, int e, int kth) {\\n        if (kth <= 0) return 0;\\n        if (kth >= Tree[node].frq) return Tree[node].sum;\\n        if (b == e) {\\n            return kth * 1LL * b;\\n        }\\n        \\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        return get_left_kth_sum(lf, b, mid, kth) + get_left_kth_sum(rt, mid + 1, e, kth - Tree[lf].frq);\\n    }\\n    \\n    LL get_right_kth_sum(int node, int b, int e, int kth) {\\n        if (kth <= 0) return 0;\\n        if (kth >= Tree[node].frq) return Tree[node].sum;\\n        if (b == e) {\\n            return kth * 1LL * b;\\n        }\\n        \\n        int mid = (b + e) >> 1;\\n        int lf = node << 1;\\n        int rt = lf | 1;\\n        \\n        return get_right_kth_sum(lf, b, mid, kth - Tree[rt].frq) + get_right_kth_sum(rt, mid + 1, e, kth);\\n    }\\n    \\n    int M, K;\\n    queue <int> window;\\n\\n    MKAverage(int m, int k) {\\n        M = m;\\n        K = k;\\n    }\\n    \\n    void addElement(int num) {\\n        window.push(num);\\n        update(1, 0, limit, num, +1);\\n        \\n        if (window.size() > M) {\\n            update(1, 0, limit, window.front(), -1);\\n            window.pop();\\n        }\\n        \\n    }\\n    \\n    int calculateMKAverage() {\\n        if (window.size() < M) return -1;\\n        LL total = Tree[1].sum;\\n        LL left_k_sum = get_left_kth_sum(1, 0, limit, K);\\n        LL right_k_sum = get_right_kth_sum(1, 0, limit, K);\\n        \\n        \\n        return (total - left_k_sum - right_k_sum) / (M - 2 * K);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036995,
                "title": "python-window-sortedlist-o-nlogn",
                "content": "addElement: O(log n)\\ncalculateMKAverage: O(1)\\n```\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.sl = SortedList()\\n        self.window = deque()\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.sl) < self.m:\\n            self.window.append(num)\\n            self.sl.add(num)\\n            if len(self.sl) == self.m:\\n                self.sum = sum(self.sl[self.k:-self.k])\\n        else:\\n            v = self.window.popleft()\\n            self.window.append(num)\\n            i = self.sl.bisect_left(v)\\n            j = self.sl.bisect_left(num)\\n            if 0<=i<self.k:\\n                if self.k < j:\\n                    self.sum -= self.sl[self.k]\\n                    if j <= self.m - self.k:\\n                        self.sum += num\\n                    else:\\n                        self.sum += self.sl[self.m-self.k]\\n            elif self.k <= i < self.m - self.k:\\n                self.sum -= v\\n                if 0<= j < self.k:\\n                    self.sum += self.sl[self.k-1]\\n                elif self.k <= j <= self.m-self.k:\\n                    self.sum += num\\n                else:\\n                    self.sum += self.sl[self.m-self.k]\\n            else:\\n                if j < self.m - self.k:\\n                    self.sum -= self.sl[self.m-self.k-1]\\n                    if self.k <= j:\\n                        self.sum += num\\n                    else:\\n                        self.sum += self.sl[self.k-1]\\n            self.sl.remove(v)\\n            self.sl.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl) < self.m:\\n            return -1\\n        return self.sum//(self.m-2*self.k)\\n        \\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()",
                "solutionTags": [
                    "Python"
                ],
                "code": "addElement: O(log n)\\ncalculateMKAverage: O(1)\\n```\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.sl = SortedList()\\n        self.window = deque()\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.sl) < self.m:\\n            self.window.append(num)\\n            self.sl.add(num)\\n            if len(self.sl) == self.m:\\n                self.sum = sum(self.sl[self.k:-self.k])\\n        else:\\n            v = self.window.popleft()\\n            self.window.append(num)\\n            i = self.sl.bisect_left(v)\\n            j = self.sl.bisect_left(num)\\n            if 0<=i<self.k:\\n                if self.k < j:\\n                    self.sum -= self.sl[self.k]\\n                    if j <= self.m - self.k:\\n                        self.sum += num\\n                    else:\\n                        self.sum += self.sl[self.m-self.k]\\n            elif self.k <= i < self.m - self.k:\\n                self.sum -= v\\n                if 0<= j < self.k:\\n                    self.sum += self.sl[self.k-1]\\n                elif self.k <= j <= self.m-self.k:\\n                    self.sum += num\\n                else:\\n                    self.sum += self.sl[self.m-self.k]\\n            else:\\n                if j < self.m - self.k:\\n                    self.sum -= self.sl[self.m-self.k-1]\\n                    if self.k <= j:\\n                        self.sum += num\\n                    else:\\n                        self.sum += self.sl[self.k-1]\\n            self.sl.remove(v)\\n            self.sl.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl) < self.m:\\n            return -1\\n        return self.sum//(self.m-2*self.k)\\n        \\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()",
                "codeTag": "Java"
            },
            {
                "id": 1832392,
                "title": "c-bst-queue",
                "content": "The idea is to have addElement and calculateMKAverage both in O(log m), although it still is O(m) in the worst case: a left only(or right only) childs tree.\\n\\n```\\nclass BST {\\n    struct node {\\n        int data;\\n        node* left;\\n        node* right;\\n        int lCount;\\n        int rCount;\\n        int lsum;\\n        int rsum;\\n        int multiplicity;\\n    };\\n\\n    node* insert(int x, node* t) {\\n        if(t == NULL)\\n        {\\n            t = new node;\\n            t->data = x;\\n            t->lCount = 0;\\n            t->rCount = 0;\\n            t->lsum = 0;\\n            t->rsum = 0;\\n            t->multiplicity = 1;\\n            t->left = t->right = NULL;\\n        }\\n        else if(x < t->data)\\n        {\\n            t->lCount++;\\n            t->lsum += x;\\n            t->left = insert(x, t->left);\\n        }\\n        else if(x > t->data)\\n        {\\n            t->rCount++;\\n            t->rsum += x;\\n            t->right = insert(x, t->right);\\n        } else {\\n            t->multiplicity++;\\n        }\\n        return t;\\n    }\\n\\n    node* findMin(node* t) {\\n        if(t == NULL)\\n            return NULL;\\n        else if(t->left == NULL)\\n            return t;\\n        else\\n            return findMin(t->left);\\n    }\\n    \\n    node* fullRemove(int x, node* t, int qt, int sr) {\\n        node* temp;\\n\\n        // Element not found\\n        if(t == NULL)\\n            return NULL;\\n\\n        // Searching for element\\n        else if(x < t->data) {\\n            t->lCount-=qt;\\n            t->lsum -= sr;\\n            t->left = fullRemove(x, t->left, qt,sr);\\n        }\\n        else if(x > t->data) {\\n            t->rCount-=qt;\\n            t->rsum -= sr;\\n            t->right = fullRemove(x, t->right, qt,sr);\\n        }\\n\\n        // Element found\\n        // With one or zero child\\n        else\\n        {\\n            temp = t;\\n            if(t->left == NULL)\\n                t = t->right;\\n            else if(t->right == NULL)\\n                t = t->left;\\n            delete temp;\\n        }\\n\\n        return t;\\n    }\\n\\n    node* remove(int x, node* t) {\\n        node* temp;\\n\\n        // Element not found\\n        if(t == NULL)\\n            return NULL;\\n\\n        // Searching for element\\n        else if(x < t->data) {\\n            t->lCount--;\\n            t->lsum -= x;\\n            t->left = remove(x, t->left);\\n        }\\n        else if(x > t->data) {\\n            t->rCount--;\\n            t->rsum -= x;\\n            t->right = remove(x, t->right);\\n        }\\n\\n        // Element found\\n        // repeated\\n        else if(t->multiplicity > 1) {\\n            t->multiplicity--;\\n        }\\n        // With 2 children\\n        else if(t->left && t->right)\\n        {\\n            temp = findMin(t->right);\\n            t->data = temp->data;\\n            t->rCount-=temp->multiplicity;\\n            t->rsum -= t->data*temp->multiplicity;\\n            t->right = fullRemove(t->data, t->right,temp->multiplicity,t->data*temp->multiplicity);\\n        }\\n        // With one or zero child\\n        else\\n        {\\n            temp = t;\\n            if(t->left == NULL)\\n                t = t->right;\\n            else if(t->right == NULL)\\n                t = t->left;\\n            delete temp;\\n        }\\n        if(t == NULL)\\n            return t;\\n\\n        return t;\\n    }\\n    \\n    node* root;\\n    void kSmallestSumRec(node *root, int k , int &temp_sum) {\\n        if (root == NULL)\\n            return ;\\n\\n        // if we fount k smallest element then break the function\\n        if ((root->lCount + root->multiplicity) == k) {\\n            temp_sum += root->data*root->multiplicity + root->lsum ;\\n            return ;\\n        }\\n\\n        else if (k > root->lCount)\\n        {\\n            // store sum of all element smaller than current root ;\\n            temp_sum += root->lsum;\\n            k -= root->lCount;\\n            \\n            if(root->multiplicity >= k) {\\n                temp_sum += root->data*k;\\n                return;\\n            } else {\\n                temp_sum += root->data*root->multiplicity;\\n                k -= root->multiplicity;\\n            }\\n            \\n            kSmallestSumRec(root->right , k , temp_sum);\\n        }\\n        else // call left sub-tree\\n            kSmallestSumRec(root->left , k , temp_sum );\\n    }\\n    \\n    void kGreatestSumRec(node *root, int k , int &temp_sum) {\\n        if (root == NULL)\\n            return ;\\n\\n        // if we fount k smallest element then break the function\\n        if ((root->rCount + root->multiplicity) == k) {\\n            temp_sum += root->data*root->multiplicity + root->rsum ;\\n            return ;\\n        }\\n\\n        else if (k > root->rCount)\\n        {\\n            temp_sum += root->rsum;\\n            k -= root->rCount;\\n            \\n            if(root->multiplicity >= k) {\\n                temp_sum += root->data*k;\\n                return;\\n            } else {\\n                temp_sum += root->data*root->multiplicity;\\n                k -= root->multiplicity;\\n            }\\n\\n            kGreatestSumRec(root->left, k , temp_sum);\\n        }\\n        else // call left sub-tree\\n            kGreatestSumRec(root->right, k , temp_sum);\\n    }\\n\\n    public:\\n    BST() {\\n        root = NULL;\\n    }\\n\\n    void insert(int x) {\\n        root = insert(x, root);\\n    }\\n\\n    void remove(int x) {\\n        root = remove(x, root);\\n    }\\n\\n    int kElementSum(int k) {\\n        int sum = 0;\\n        kSmallestSumRec(root, k, sum);\\n        kGreatestSumRec(root, k, sum);\\n        return sum;\\n    }\\n};\\n\\nclass MKAverage {\\n    long long sum;\\n    queue<int> elements;\\n    int m;\\n    int k;\\n    BST* tree;\\npublic:\\n    MKAverage(int m, int k):m(m), k(k), sum(0) {\\n        tree = new BST();\\n    }\\n    \\n    void addElement(int num) {\\n        if(elements.size() == m) {\\n            sum = sum - elements.front();\\n            tree->remove(elements.front());\\n            elements.pop();\\n        }\\n\\n        sum = sum + num;\\n        tree->insert(num);\\n        elements.push(num);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(elements.size() < m) return -1;\\n        \\n        return (sum - tree->kElementSum(k))/(m - 2*k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Queue"
                ],
                "code": "```\\nclass BST {\\n    struct node {\\n        int data;\\n        node* left;\\n        node* right;\\n        int lCount;\\n        int rCount;\\n        int lsum;\\n        int rsum;\\n        int multiplicity;\\n    };\\n\\n    node* insert(int x, node* t) {\\n        if(t == NULL)\\n        {\\n            t = new node;\\n            t->data = x;\\n            t->lCount = 0;\\n            t->rCount = 0;\\n            t->lsum = 0;\\n            t->rsum = 0;\\n            t->multiplicity = 1;\\n            t->left = t->right = NULL;\\n        }\\n        else if(x < t->data)\\n        {\\n            t->lCount++;\\n            t->lsum += x;\\n            t->left = insert(x, t->left);\\n        }\\n        else if(x > t->data)\\n        {\\n            t->rCount++;\\n            t->rsum += x;\\n            t->right = insert(x, t->right);\\n        } else {\\n            t->multiplicity++;\\n        }\\n        return t;\\n    }\\n\\n    node* findMin(node* t) {\\n        if(t == NULL)\\n            return NULL;\\n        else if(t->left == NULL)\\n            return t;\\n        else\\n            return findMin(t->left);\\n    }\\n    \\n    node* fullRemove(int x, node* t, int qt, int sr) {\\n        node* temp;\\n\\n        // Element not found\\n        if(t == NULL)\\n            return NULL;\\n\\n        // Searching for element\\n        else if(x < t->data) {\\n            t->lCount-=qt;\\n            t->lsum -= sr;\\n            t->left = fullRemove(x, t->left, qt,sr);\\n        }\\n        else if(x > t->data) {\\n            t->rCount-=qt;\\n            t->rsum -= sr;\\n            t->right = fullRemove(x, t->right, qt,sr);\\n        }\\n\\n        // Element found\\n        // With one or zero child\\n        else\\n        {\\n            temp = t;\\n            if(t->left == NULL)\\n                t = t->right;\\n            else if(t->right == NULL)\\n                t = t->left;\\n            delete temp;\\n        }\\n\\n        return t;\\n    }\\n\\n    node* remove(int x, node* t) {\\n        node* temp;\\n\\n        // Element not found\\n        if(t == NULL)\\n            return NULL;\\n\\n        // Searching for element\\n        else if(x < t->data) {\\n            t->lCount--;\\n            t->lsum -= x;\\n            t->left = remove(x, t->left);\\n        }\\n        else if(x > t->data) {\\n            t->rCount--;\\n            t->rsum -= x;\\n            t->right = remove(x, t->right);\\n        }\\n\\n        // Element found\\n        // repeated\\n        else if(t->multiplicity > 1) {\\n            t->multiplicity--;\\n        }\\n        // With 2 children\\n        else if(t->left && t->right)\\n        {\\n            temp = findMin(t->right);\\n            t->data = temp->data;\\n            t->rCount-=temp->multiplicity;\\n            t->rsum -= t->data*temp->multiplicity;\\n            t->right = fullRemove(t->data, t->right,temp->multiplicity,t->data*temp->multiplicity);\\n        }\\n        // With one or zero child\\n        else\\n        {\\n            temp = t;\\n            if(t->left == NULL)\\n                t = t->right;\\n            else if(t->right == NULL)\\n                t = t->left;\\n            delete temp;\\n        }\\n        if(t == NULL)\\n            return t;\\n\\n        return t;\\n    }\\n    \\n    node* root;\\n    void kSmallestSumRec(node *root, int k , int &temp_sum) {\\n        if (root == NULL)\\n            return ;\\n\\n        // if we fount k smallest element then break the function\\n        if ((root->lCount + root->multiplicity) == k) {\\n            temp_sum += root->data*root->multiplicity + root->lsum ;\\n            return ;\\n        }\\n\\n        else if (k > root->lCount)\\n        {\\n            // store sum of all element smaller than current root ;\\n            temp_sum += root->lsum;\\n            k -= root->lCount;\\n            \\n            if(root->multiplicity >= k) {\\n                temp_sum += root->data*k;\\n                return;\\n            } else {\\n                temp_sum += root->data*root->multiplicity;\\n                k -= root->multiplicity;\\n            }\\n            \\n            kSmallestSumRec(root->right , k , temp_sum);\\n        }\\n        else // call left sub-tree\\n            kSmallestSumRec(root->left , k , temp_sum );\\n    }\\n    \\n    void kGreatestSumRec(node *root, int k , int &temp_sum) {\\n        if (root == NULL)\\n            return ;\\n\\n        // if we fount k smallest element then break the function\\n        if ((root->rCount + root->multiplicity) == k) {\\n            temp_sum += root->data*root->multiplicity + root->rsum ;\\n            return ;\\n        }\\n\\n        else if (k > root->rCount)\\n        {\\n            temp_sum += root->rsum;\\n            k -= root->rCount;\\n            \\n            if(root->multiplicity >= k) {\\n                temp_sum += root->data*k;\\n                return;\\n            } else {\\n                temp_sum += root->data*root->multiplicity;\\n                k -= root->multiplicity;\\n            }\\n\\n            kGreatestSumRec(root->left, k , temp_sum);\\n        }\\n        else // call left sub-tree\\n            kGreatestSumRec(root->right, k , temp_sum);\\n    }\\n\\n    public:\\n    BST() {\\n        root = NULL;\\n    }\\n\\n    void insert(int x) {\\n        root = insert(x, root);\\n    }\\n\\n    void remove(int x) {\\n        root = remove(x, root);\\n    }\\n\\n    int kElementSum(int k) {\\n        int sum = 0;\\n        kSmallestSumRec(root, k, sum);\\n        kGreatestSumRec(root, k, sum);\\n        return sum;\\n    }\\n};\\n\\nclass MKAverage {\\n    long long sum;\\n    queue<int> elements;\\n    int m;\\n    int k;\\n    BST* tree;\\npublic:\\n    MKAverage(int m, int k):m(m), k(k), sum(0) {\\n        tree = new BST();\\n    }\\n    \\n    void addElement(int num) {\\n        if(elements.size() == m) {\\n            sum = sum - elements.front();\\n            tree->remove(elements.front());\\n            elements.pop();\\n        }\\n\\n        sum = sum + num;\\n        tree->insert(num);\\n        elements.push(num);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(elements.size() < m) return -1;\\n        \\n        return (sum - tree->kElementSum(k))/(m - 2*k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478886,
                "title": "c-simple-solution-using-sorted-map-faster-than-98",
                "content": "```\\nclass MKAverage {\\npublic:\\n    vector<int> items;\\n    map<int,int> lastM;\\n    int m,k,s,e;\\n    long total;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        s = 0;\\n        e = 0;\\n        total = 0;\\n    }\\n    \\n\\t// O(logM)\\n    void addElement(int num) {\\n        items.push_back(num);\\n        lastM[num]++;\\n        total += num;\\n        e++;\\n        \\n        if(e-s>m) \\n        {\\n            if(--lastM[items[s]] == 0) lastM.erase(items[s]);\\n            total -= items[s++];\\n        }\\n    }\\n    \\n\\t// O(K)\\n    int calculateMKAverage() {\\n        if(e - s < m) return -1;\\n        int n = k, minVal = 0, maxVal = 0;\\n        auto itr = lastM.begin();\\n        while(n>0) \\n        {\\n            minVal += itr->first * min(itr->second, n);\\n            n -= min(itr->second, n);\\n            if(n > 0)\\n            {\\n                itr++;\\n            }\\n        }\\n        \\n        auto _itr = lastM.rbegin();\\n        n = k;\\n        while(n>0) \\n        {\\n            maxVal += _itr->first * min(_itr->second, n);\\n            n -= min(_itr->second, n);\\n            if(n > 0)\\n            {\\n                _itr++;\\n            }\\n        }\\n        \\n        return (total - minVal - maxVal) / (m-2*k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n    vector<int> items;\\n    map<int,int> lastM;\\n    int m,k,s,e;\\n    long total;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        s = 0;\\n        e = 0;\\n        total = 0;\\n    }\\n    \\n\\t// O(logM)\\n    void addElement(int num) {\\n        items.push_back(num);\\n        lastM[num]++;\\n        total += num;\\n        e++;\\n        \\n        if(e-s>m) \\n        {\\n            if(--lastM[items[s]] == 0) lastM.erase(items[s]);\\n            total -= items[s++];\\n        }\\n    }\\n    \\n\\t// O(K)\\n    int calculateMKAverage() {\\n        if(e - s < m) return -1;\\n        int n = k, minVal = 0, maxVal = 0;\\n        auto itr = lastM.begin();\\n        while(n>0) \\n        {\\n            minVal += itr->first * min(itr->second, n);\\n            n -= min(itr->second, n);\\n            if(n > 0)\\n            {\\n                itr++;\\n            }\\n        }\\n        \\n        auto _itr = lastM.rbegin();\\n        n = k;\\n        while(n>0) \\n        {\\n            maxVal += _itr->first * min(_itr->second, n);\\n            n -= min(_itr->second, n);\\n            if(n > 0)\\n            {\\n                _itr++;\\n            }\\n        }\\n        \\n        return (total - minVal - maxVal) / (m-2*k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467336,
                "title": "python-using-sortedlist-add-in-o-n-calculate-in-o-1",
                "content": "Use 3 SortedList `left`, `mid`, `right` to maintain the smallest k elements, mid part and the biggest k elements seperately. \\nWe can do insert, delete, search operations in SortedList in O(logN). It\\'s somehow like TreeSet/TreeMap in Java(but SortedList can store duplicate elements) and MultiSet in C++.\\n```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    # T:O(1) for calculateMKAverage O(Log(N)) for addElement\\n    def __init__(self, m: int, k: int):\\n        self.queue = collections.deque();\\n        self.m = m\\n        self.k = k\\n        self.N = m-2*k #numbers needed to calculate MKAve\\n        self.sum = 0\\n        self.left = SortedList()\\n        self.mid = SortedList()\\n        self.right = SortedList()\\n\\n    def addElement(self, num: int) -> None:\\n        if (len(self.queue)==self.m):\\n            self.remove(self.queue[0])\\n            self.queue.popleft()\\n        self.queue.append(num)\\n        self.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue)<self.m:\\n            return -1\\n        else:\\n            return self.sum//self.N\\n    def add(self, x):\\n        self.left.add(x)\\n        if len(self.left)>self.k:\\n            mxLeft = self.left.pop()\\n            self.sum+=mxLeft\\n            self.mid.add(mxLeft)\\n        if len(self.mid)>self.N:\\n            mxMid = self.mid.pop()\\n            self.sum-=mxMid\\n            self.right.add(mxMid)\\n            \\n    def remove(self, x):\\n        if x<=self.left[-1]:\\n            self.left.remove(x)\\n        elif x<=self.mid[-1]:\\n            self.sum-=x\\n            self.mid.remove(x)\\n        else:\\n            self.right.remove(x)\\n        if len(self.left)<self.k:\\n            mnMid = self.mid.pop(0)\\n            self.sum-=mnMid\\n            self.left.add(mnMid)\\n        if len(self.mid)<self.N:\\n            mnRight = self.right.pop(0)\\n            self.sum+=mnRight\\n            self.mid.add(mnRight)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    # T:O(1) for calculateMKAverage O(Log(N)) for addElement\\n    def __init__(self, m: int, k: int):\\n        self.queue = collections.deque();\\n        self.m = m\\n        self.k = k\\n        self.N = m-2*k #numbers needed to calculate MKAve\\n        self.sum = 0\\n        self.left = SortedList()\\n        self.mid = SortedList()\\n        self.right = SortedList()\\n\\n    def addElement(self, num: int) -> None:\\n        if (len(self.queue)==self.m):\\n            self.remove(self.queue[0])\\n            self.queue.popleft()\\n        self.queue.append(num)\\n        self.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue)<self.m:\\n            return -1\\n        else:\\n            return self.sum//self.N\\n    def add(self, x):\\n        self.left.add(x)\\n        if len(self.left)>self.k:\\n            mxLeft = self.left.pop()\\n            self.sum+=mxLeft\\n            self.mid.add(mxLeft)\\n        if len(self.mid)>self.N:\\n            mxMid = self.mid.pop()\\n            self.sum-=mxMid\\n            self.right.add(mxMid)\\n            \\n    def remove(self, x):\\n        if x<=self.left[-1]:\\n            self.left.remove(x)\\n        elif x<=self.mid[-1]:\\n            self.sum-=x\\n            self.mid.remove(x)\\n        else:\\n            self.right.remove(x)\\n        if len(self.left)<self.k:\\n            mnMid = self.mid.pop(0)\\n            self.sum-=mnMid\\n            self.left.add(mnMid)\\n        if len(self.mid)<self.N:\\n            mnRight = self.right.pop(0)\\n            self.sum+=mnRight\\n            self.mid.add(mnRight)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419002,
                "title": "what-should-i-do-when-meeting-this-question-in-interview-a-step-by-step-guide",
                "content": "Code first.\\n```\\nclass MultiMap {\\n    public TreeMap<Integer, Integer> map;\\n    private int cnt = 0;\\n    private double sum = 0.0;\\n    \\n    public MultiMap() {\\n        this.map = new TreeMap<>();\\n    }\\n    \\n    public void add(Integer key) {\\n        this.cnt ++;\\n        this.sum += key;\\n        this.map.put(key, this.map.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public boolean containsKey(Integer key) {\\n        return this.map.getOrDefault(key, 0) > 0;\\n    }\\n    \\n    public void remove(Integer key) {\\n        if (!this.map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        this.cnt --;\\n        this.sum -= key;\\n        this.map.put(key, this.map.get(key)-1);\\n        \\n        if (this.map.get(key) == 0) {\\n            this.map.remove(key);\\n        }\\n    }\\n    \\n    public Integer getMin() {\\n        return this.map.firstKey();\\n    }\\n    \\n    public Integer getMax() {\\n        return this.map.lastKey();\\n    }\\n    \\n    public int avg() {\\n        return (int)(this.sum/this.cnt);\\n    }\\n    \\n    public int size() {\\n        return this.cnt;\\n    }\\n}\\n\\nclass TripleMap {\\n    public MultiMap small;\\n    public MultiMap mid;\\n    public MultiMap big;\\n    private int m;\\n    private int k;\\n    \\n    public TripleMap(int m, int k) {\\n        this.small = new MultiMap();\\n        this.mid = new MultiMap();\\n        this.big = new MultiMap();\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void add(int num) {\\n        if (mid.size() == 0) {\\n            mid.add(num);\\n            return;\\n        }\\n        \\n        if (num < mid.getMin()) {\\n            small.add(num);\\n        } else if (num > mid.getMax()) {\\n            big.add(num);\\n        } else {\\n            mid.add(num);\\n        }\\n        \\n        this.balance();\\n    }\\n    \\n    private void balance() {\\n        int size = small.size() + mid.size() + big.size();\\n        \\n        if (size < m) {\\n            return;\\n        }\\n        \\n        while (small.size() > k) {\\n            int victim = small.getMax();\\n            small.remove(victim);\\n            mid.add(victim);\\n        }\\n        \\n        while (big.size() > k) {\\n            int victim = big.getMin();\\n            big.remove(victim);\\n            mid.add(victim);\\n        }\\n        \\n        while (small.size() < k) {\\n            int victim = mid.getMin();\\n            mid.remove(victim);\\n            small.add(victim);\\n        }\\n        \\n        while (big.size() < k) {\\n            int victim = mid.getMax();\\n            mid.remove(victim);\\n            big.add(victim);\\n        }\\n    }\\n    \\n    public void remove(int num) {\\n        if (small.containsKey(num)) {\\n            small.remove(num);\\n        } else if (mid.containsKey(num)) {\\n            mid.remove(num);\\n        } else if (big.containsKey(num)) {\\n            big.remove(num);\\n        }\\n        \\n        this.balance();\\n    }\\n    \\n    public int avg() {\\n        return this.mid.avg();\\n    }\\n}\\n\\nclass MKAverage {\\n    private TripleMap map;\\n    private Queue<Integer> q;\\n    private int m;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.map = new TripleMap(m, k);\\n        this.q = new LinkedList<Integer>();\\n    }\\n    \\n    public void addElement(int num) {\\n        this.q.add(num);\\n        this.map.add(num);\\n        \\n        if (this.q.size() > m) {\\n            int victim = this.q.remove();\\n            this.map.remove(victim);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (this.q.size() < m) {\\n            return -1;\\n        }\\n                \\n        return this.map.avg();\\n    }\\n}\\n```\\n\\nLong code, and nearly un-implementable during a 1-hour interview. \\n\\nThe trick is: define the interface, implement the core logic, and implement the interface when having time. I define 2 extra classes in this solution `TripleMap` and `MultiMap`. During an intervew, you can call out these 2 data structure, and define the function signature first. Then, write down the MKAverage first without implementing the functions in  `TripleMap` and `MultiMap`.\\n\\nLike below\\n\\n```\\nclass MultiMap {\\n    public void add(Integer key) {\\n    }\\n    \\n    public boolean containsKey(Integer key) {\\n    }\\n    \\n    public void remove(Integer key) {\\n    }\\n    \\n    public Integer getMin() {\\n    }\\n    \\n    public Integer getMax() {\\n    }\\n    \\n    public int avg() {\\n    }\\n    \\n    public int size() {\\n    }\\n}\\n\\nclass TripleMap {\\n    public MultiMap small;\\n    public MultiMap mid;\\n    public MultiMap big;\\n    private int m;\\n    private int k;\\n    \\n    public void add(int num) {\\n    }\\n\\n    public void remove(int num) {\\n    }\\n    \\n    public int avg() {\\n    }\\n}\\n\\nclass MKAverage {\\n    private TripleMap map;\\n    private Queue<Integer> q;\\n    private int m;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.map = new TripleMap(m, k);\\n        this.q = new LinkedList<Integer>();\\n    }\\n    \\n    public void addElement(int num) {\\n        this.q.add(num);\\n        this.map.add(num);\\n        \\n        if (this.q.size() > m) {\\n            int victim = this.q.remove();\\n            this.map.remove(victim);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (this.q.size() < m) {\\n            return -1;\\n        }\\n                \\n        return this.map.avg();\\n    }\\n}\\n```\\n\\nThen, walk through the core algorithm with your interviewer. And start to implement the 2 classes",
                "solutionTags": [],
                "code": "```\\nclass MultiMap {\\n    public TreeMap<Integer, Integer> map;\\n    private int cnt = 0;\\n    private double sum = 0.0;\\n    \\n    public MultiMap() {\\n        this.map = new TreeMap<>();\\n    }\\n    \\n    public void add(Integer key) {\\n        this.cnt ++;\\n        this.sum += key;\\n        this.map.put(key, this.map.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public boolean containsKey(Integer key) {\\n        return this.map.getOrDefault(key, 0) > 0;\\n    }\\n    \\n    public void remove(Integer key) {\\n        if (!this.map.containsKey(key)) {\\n            return;\\n        }\\n        \\n        this.cnt --;\\n        this.sum -= key;\\n        this.map.put(key, this.map.get(key)-1);\\n        \\n        if (this.map.get(key) == 0) {\\n            this.map.remove(key);\\n        }\\n    }\\n    \\n    public Integer getMin() {\\n        return this.map.firstKey();\\n    }\\n    \\n    public Integer getMax() {\\n        return this.map.lastKey();\\n    }\\n    \\n    public int avg() {\\n        return (int)(this.sum/this.cnt);\\n    }\\n    \\n    public int size() {\\n        return this.cnt;\\n    }\\n}\\n\\nclass TripleMap {\\n    public MultiMap small;\\n    public MultiMap mid;\\n    public MultiMap big;\\n    private int m;\\n    private int k;\\n    \\n    public TripleMap(int m, int k) {\\n        this.small = new MultiMap();\\n        this.mid = new MultiMap();\\n        this.big = new MultiMap();\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void add(int num) {\\n        if (mid.size() == 0) {\\n            mid.add(num);\\n            return;\\n        }\\n        \\n        if (num < mid.getMin()) {\\n            small.add(num);\\n        } else if (num > mid.getMax()) {\\n            big.add(num);\\n        } else {\\n            mid.add(num);\\n        }\\n        \\n        this.balance();\\n    }\\n    \\n    private void balance() {\\n        int size = small.size() + mid.size() + big.size();\\n        \\n        if (size < m) {\\n            return;\\n        }\\n        \\n        while (small.size() > k) {\\n            int victim = small.getMax();\\n            small.remove(victim);\\n            mid.add(victim);\\n        }\\n        \\n        while (big.size() > k) {\\n            int victim = big.getMin();\\n            big.remove(victim);\\n            mid.add(victim);\\n        }\\n        \\n        while (small.size() < k) {\\n            int victim = mid.getMin();\\n            mid.remove(victim);\\n            small.add(victim);\\n        }\\n        \\n        while (big.size() < k) {\\n            int victim = mid.getMax();\\n            mid.remove(victim);\\n            big.add(victim);\\n        }\\n    }\\n    \\n    public void remove(int num) {\\n        if (small.containsKey(num)) {\\n            small.remove(num);\\n        } else if (mid.containsKey(num)) {\\n            mid.remove(num);\\n        } else if (big.containsKey(num)) {\\n            big.remove(num);\\n        }\\n        \\n        this.balance();\\n    }\\n    \\n    public int avg() {\\n        return this.mid.avg();\\n    }\\n}\\n\\nclass MKAverage {\\n    private TripleMap map;\\n    private Queue<Integer> q;\\n    private int m;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.map = new TripleMap(m, k);\\n        this.q = new LinkedList<Integer>();\\n    }\\n    \\n    public void addElement(int num) {\\n        this.q.add(num);\\n        this.map.add(num);\\n        \\n        if (this.q.size() > m) {\\n            int victim = this.q.remove();\\n            this.map.remove(victim);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (this.q.size() < m) {\\n            return -1;\\n        }\\n                \\n        return this.map.avg();\\n    }\\n}\\n```\n```\\nclass MultiMap {\\n    public void add(Integer key) {\\n    }\\n    \\n    public boolean containsKey(Integer key) {\\n    }\\n    \\n    public void remove(Integer key) {\\n    }\\n    \\n    public Integer getMin() {\\n    }\\n    \\n    public Integer getMax() {\\n    }\\n    \\n    public int avg() {\\n    }\\n    \\n    public int size() {\\n    }\\n}\\n\\nclass TripleMap {\\n    public MultiMap small;\\n    public MultiMap mid;\\n    public MultiMap big;\\n    private int m;\\n    private int k;\\n    \\n    public void add(int num) {\\n    }\\n\\n    public void remove(int num) {\\n    }\\n    \\n    public int avg() {\\n    }\\n}\\n\\nclass MKAverage {\\n    private TripleMap map;\\n    private Queue<Integer> q;\\n    private int m;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.map = new TripleMap(m, k);\\n        this.q = new LinkedList<Integer>();\\n    }\\n    \\n    public void addElement(int num) {\\n        this.q.add(num);\\n        this.map.add(num);\\n        \\n        if (this.q.size() > m) {\\n            int victim = this.q.remove();\\n            this.map.remove(victim);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (this.q.size() < m) {\\n            return -1;\\n        }\\n                \\n        return this.map.avg();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312322,
                "title": "4-heaps-1-queue-list-50-00-speed",
                "content": "This solution is referenced from [C++ 3 multisets by Izl124631x](https://leetcode.com/problems/finding-mk-average/discuss/1152418/C%2B%2B-3-multisets)\\nI don\\'t know how to implement `ordered set` with `duplicates` in `javascript`, or `lazy update / delete` in `Heap`\\nSo I will just implement and use `Heap` in a intuitive way, it\\'s mostly sufficient, since solution using `multiset` are dealing mostly `min` and `max` of the `Heap`\\n\\nThe idea is to have 3 balanced `Heap` , and 1 copy `Heap`\\n* `Left Heap`, storing smallest `k`s, implemented in `Max Heap`\\n* `Mid Heap`, storing numbers which forms actual sum, implemented in `Min Heap`\\n* `Mid Copy Heap`, this is redundant `Heap`, which is just to get the `max` of `Mid Min Heap`, this follows every action of `Mid Min Heap` when adding an element. This obviusly needs to improve, since it\\'s waste of memory. But you would notice in my solution below, I didn\\'t have this, instead I just use `O(m)` to get the `max`. I\\'m lazy to copy paste.\\n* `Right Heap`, storing largest `k`s, implemented in `Min Heap`\\n\\nSo this way, the four `Heap`s form a `Moving Window` and could transfer `min` and `max` between each other, please refer to `Leetcode 480 Sliding Window Median` for similar idea\\n\\nNote: for the `queue`, I\\'m lazy to implement the `Queue` with `LinkedList`, instead I just use `array.shift`\\n```\\nclass MKAverage {\\n    constructor(m, k) {\\n        this.m = m;\\n        this.k = k;\\n        this.sum = 0;\\n        this.left = new Heap((a, b) => a > b);\\n        this.mid = new Heap((a, b) => a < b)\\n        this.right = new Heap((a, b) => a < b)\\n        this.q = [];\\n    }\\n    \\n    addElement(num) {\\n\\n        // add new num\\n        if (this.q.length < this.m) {\\n            this.mid.push(num);\\n        }\\n        this.q.push(num);\\n        if (this.q.length === this.m) {\\n            for (let i = 0; i < this.k; ++i) {\\n                this.left.push(this.mid.pop());\\n            }\\n            for (let i = 0; i < this.k; ++i) {\\n                this.right.push(this.mid.popMax());\\n            }\\n            this.sum += this.mid.sum\\n        } else if (this.q.length > this.m) {\\n            if (num < this.left.top()) {\\n                this.left.push(num);\\n                const value = this.left.pop();\\n                this.mid.push(value);\\n                this.sum += value; \\n            } else if (num > this.right.top()) {\\n                this.right.push(num);\\n                const value = this.right.pop();\\n                this.mid.push(value);\\n                this.sum += value;\\n            } else {\\n                this.mid.push(num)\\n                this.sum += num;\\n            }\\n            \\n            // remove old num\\n            const value = this.q.shift();\\n            if (this.mid.has(value)) {\\n                this.mid.remove(value);\\n                this.sum -= value;\\n            } else if (this.right.has(value)) {\\n                this.right.remove(value)\\n            } else {\\n                this.left.remove(value)\\n            }\\n\\n            // balance three heaps\\n            if (this.left.size < this.k) {\\n                const value = this.mid.pop();\\n                this.left.push(value);\\n                this.sum -= value;\\n            } else if (this.right.size < this.k) {\\n                const value = this.mid.popMax();\\n                this.right.push(value);\\n                this.sum -= value;\\n            }\\n        }\\n    }\\n    \\n    calculateMKAverage() {\\n        return this.q.length === this.m ? Math.trunc(this.sum / (this.m - 2 * this.k)) : -1;\\n    }\\n};\\n\\nclass Heap {\\n    constructor(compare) {\\n        this.store = [];\\n        this.compare = compare;\\n        this.index = {};\\n    }\\n    \\n    top() {\\n        return this.store[0];\\n    }\\n    \\n    get size() {\\n        return this.store.length;\\n    }\\n    \\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n\\n    has(value) {\\n        return Boolean(this.index[value] && this.index[value].size)\\n    }\\n    \\n    push(value) {\\n        this.store.push(value);\\n        const i = this.store.length - 1;\\n        if (!this.index[value]) this.index[value] = new Set([i]);\\n        else this.index[value].add(i)\\n        this.heapifyUp(i);\\n    }\\n    \\n    remove(value) {\\n        const i = this.index[value].values().next().value;\\n        this.index[value].delete(i);\\n        if (i === this.store.length - 1) return this.store.pop();\\n        this.store[i] = this.store.pop()\\n        this.index[this.store[i]].delete(this.store.length);\\n        this.index[this.store[i]].add(i);\\n        this.heapifyDown(this.heapifyUp(i));\\n    }\\n\\n    popMax() {\\n        const max = Math.max(...this.store);\\n        this.remove(max);\\n        return max;\\n    }\\n\\n    get sum() {\\n        return this.store.reduce((p, c) => p + c, 0);\\n    }\\n    \\n    pop() {\\n        const value = this.store[0];\\n        this.index[value].delete(0);\\n        if (this.store.length < 2) return this.store.pop();\\n        this.store[0] = this.store.pop();\\n        this.index[this.store[0]].delete(this.store.length);\\n        this.index[this.store[0]].add(0);\\n        this.heapifyDown(0);\\n        return value;\\n    }\\n    \\n    heapifyDown(parent) {\\n        const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n        let child = childs[0];\\n        if (childs[1] && this.compare(this.store[childs[1]], this.store[child])) {\\n            child = childs[1];\\n        }\\n        if (child && this.compare(this.store[child], this.store[parent])) {\\n            const childVal = this.store[child];\\n            const parentVal = this.store[parent];\\n            this.store[child] = parentVal;\\n            this.store[parent] = childVal;\\n            this.index[childVal].delete(child);\\n            this.index[childVal].add(parent);\\n            this.index[parentVal].delete(parent);\\n            this.index[parentVal].add(child);\\n            return this.heapifyDown(child);\\n        }\\n        return parent;\\n    }\\n    \\n    heapifyUp(child) {\\n        const parent = Math.floor((child - 1) / 2);\\n        if (child && this.compare(this.store[child], this.store[parent])) {\\n            const childVal = this.store[child];\\n            const parentVal = this.store[parent];\\n            this.store[child] = parentVal;\\n            this.store[parent] = childVal;\\n            this.index[childVal].delete(child);\\n            this.index[childVal].add(parent);\\n            this.index[parentVal].delete(parent);\\n            this.index[parentVal].add(child);\\n            return this.heapifyUp(parent);\\n        }\\n        return child;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MKAverage {\\n    constructor(m, k) {\\n        this.m = m;\\n        this.k = k;\\n        this.sum = 0;\\n        this.left = new Heap((a, b) => a > b);\\n        this.mid = new Heap((a, b) => a < b)\\n        this.right = new Heap((a, b) => a < b)\\n        this.q = [];\\n    }\\n    \\n    addElement(num) {\\n\\n        // add new num\\n        if (this.q.length < this.m) {\\n            this.mid.push(num);\\n        }\\n        this.q.push(num);\\n        if (this.q.length === this.m) {\\n            for (let i = 0; i < this.k; ++i) {\\n                this.left.push(this.mid.pop());\\n            }\\n            for (let i = 0; i < this.k; ++i) {\\n                this.right.push(this.mid.popMax());\\n            }\\n            this.sum += this.mid.sum\\n        } else if (this.q.length > this.m) {\\n            if (num < this.left.top()) {\\n                this.left.push(num);\\n                const value = this.left.pop();\\n                this.mid.push(value);\\n                this.sum += value; \\n            } else if (num > this.right.top()) {\\n                this.right.push(num);\\n                const value = this.right.pop();\\n                this.mid.push(value);\\n                this.sum += value;\\n            } else {\\n                this.mid.push(num)\\n                this.sum += num;\\n            }\\n            \\n            // remove old num\\n            const value = this.q.shift();\\n            if (this.mid.has(value)) {\\n                this.mid.remove(value);\\n                this.sum -= value;\\n            } else if (this.right.has(value)) {\\n                this.right.remove(value)\\n            } else {\\n                this.left.remove(value)\\n            }\\n\\n            // balance three heaps\\n            if (this.left.size < this.k) {\\n                const value = this.mid.pop();\\n                this.left.push(value);\\n                this.sum -= value;\\n            } else if (this.right.size < this.k) {\\n                const value = this.mid.popMax();\\n                this.right.push(value);\\n                this.sum -= value;\\n            }\\n        }\\n    }\\n    \\n    calculateMKAverage() {\\n        return this.q.length === this.m ? Math.trunc(this.sum / (this.m - 2 * this.k)) : -1;\\n    }\\n};\\n\\nclass Heap {\\n    constructor(compare) {\\n        this.store = [];\\n        this.compare = compare;\\n        this.index = {};\\n    }\\n    \\n    top() {\\n        return this.store[0];\\n    }\\n    \\n    get size() {\\n        return this.store.length;\\n    }\\n    \\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n\\n    has(value) {\\n        return Boolean(this.index[value] && this.index[value].size)\\n    }\\n    \\n    push(value) {\\n        this.store.push(value);\\n        const i = this.store.length - 1;\\n        if (!this.index[value]) this.index[value] = new Set([i]);\\n        else this.index[value].add(i)\\n        this.heapifyUp(i);\\n    }\\n    \\n    remove(value) {\\n        const i = this.index[value].values().next().value;\\n        this.index[value].delete(i);\\n        if (i === this.store.length - 1) return this.store.pop();\\n        this.store[i] = this.store.pop()\\n        this.index[this.store[i]].delete(this.store.length);\\n        this.index[this.store[i]].add(i);\\n        this.heapifyDown(this.heapifyUp(i));\\n    }\\n\\n    popMax() {\\n        const max = Math.max(...this.store);\\n        this.remove(max);\\n        return max;\\n    }\\n\\n    get sum() {\\n        return this.store.reduce((p, c) => p + c, 0);\\n    }\\n    \\n    pop() {\\n        const value = this.store[0];\\n        this.index[value].delete(0);\\n        if (this.store.length < 2) return this.store.pop();\\n        this.store[0] = this.store.pop();\\n        this.index[this.store[0]].delete(this.store.length);\\n        this.index[this.store[0]].add(0);\\n        this.heapifyDown(0);\\n        return value;\\n    }\\n    \\n    heapifyDown(parent) {\\n        const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n        let child = childs[0];\\n        if (childs[1] && this.compare(this.store[childs[1]], this.store[child])) {\\n            child = childs[1];\\n        }\\n        if (child && this.compare(this.store[child], this.store[parent])) {\\n            const childVal = this.store[child];\\n            const parentVal = this.store[parent];\\n            this.store[child] = parentVal;\\n            this.store[parent] = childVal;\\n            this.index[childVal].delete(child);\\n            this.index[childVal].add(parent);\\n            this.index[parentVal].delete(parent);\\n            this.index[parentVal].add(child);\\n            return this.heapifyDown(child);\\n        }\\n        return parent;\\n    }\\n    \\n    heapifyUp(child) {\\n        const parent = Math.floor((child - 1) / 2);\\n        if (child && this.compare(this.store[child], this.store[parent])) {\\n            const childVal = this.store[child];\\n            const parentVal = this.store[parent];\\n            this.store[child] = parentVal;\\n            this.store[parent] = childVal;\\n            this.index[childVal].delete(child);\\n            this.index[childVal].add(parent);\\n            this.index[parentVal].delete(parent);\\n            this.index[parentVal].add(child);\\n            return this.heapifyUp(parent);\\n        }\\n        return child;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214773,
                "title": "python-queue-and-binary-search-add-o-log-m-average-o-1",
                "content": "```\\nimport bisect\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.list = [] ##Used as a sorted list. Elements are sorted in non decreasing order\\n        self.added = [] ##Used as a queue\\n        self.sum = None\\n\\t\\t\\n    def addElement(self, num: int) -> None:\\n        ln = len(self.list)\\n        if ln < self.m:\\n            self.added.append(num)\\n            index = bisect.bisect_right(self.list, num)\\n            self.list.insert(index, num)\\n            if len(self.list) == self.m:\\n                self.sum = sum(self.list[self.k:self.m-self.k])\\n        else:\\n\\t\\t\\t## Pop the element to get the last m-1 elements added\\n            x = self.added.pop(0)\\n            self.added.append(num)\\n            pop_index = bisect.bisect_left(self.list, x)\\n            if pop_index<self.k:\\n                self.sum -= self.list[self.k]\\n            elif pop_index >= self.m-self.k:\\n                self.sum -= self.list[self.m-self.k-1]\\n            else:\\n                self.sum -= x\\n            self.list.pop(pop_index)\\n\\t\\t\\t\\n\\t\\t\\t##Get the index of the new element to be added in the sorted list\\n            add_index = bisect.bisect_right(self.list, num)\\n            self.list.insert(add_index, num)\\n            if add_index<self.k:\\n                self.sum += self.list[self.k]\\n            elif add_index >= self.m-self.k:\\n                self.sum += self.list[self.m-self.k-1]\\n            else:\\n                self.sum += num\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.list)<self.m:\\n            return -1\\n        else:\\n            return self.sum//(self.m - 2*self.k)\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.list = [] ##Used as a sorted list. Elements are sorted in non decreasing order\\n        self.added = [] ##Used as a queue\\n        self.sum = None\\n\\t\\t\\n    def addElement(self, num: int) -> None:\\n        ln = len(self.list)\\n        if ln < self.m:\\n            self.added.append(num)\\n            index = bisect.bisect_right(self.list, num)\\n            self.list.insert(index, num)\\n            if len(self.list) == self.m:\\n                self.sum = sum(self.list[self.k:self.m-self.k])\\n        else:\\n\\t\\t\\t## Pop the element to get the last m-1 elements added\\n            x = self.added.pop(0)\\n            self.added.append(num)\\n            pop_index = bisect.bisect_left(self.list, x)\\n            if pop_index<self.k:\\n                self.sum -= self.list[self.k]\\n            elif pop_index >= self.m-self.k:\\n                self.sum -= self.list[self.m-self.k-1]\\n            else:\\n                self.sum -= x\\n            self.list.pop(pop_index)\\n\\t\\t\\t\\n\\t\\t\\t##Get the index of the new element to be added in the sorted list\\n            add_index = bisect.bisect_right(self.list, num)\\n            self.list.insert(add_index, num)\\n            if add_index<self.k:\\n                self.sum += self.list[self.k]\\n            elif add_index >= self.m-self.k:\\n                self.sum += self.list[self.m-self.k-1]\\n            else:\\n                self.sum += num\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.list)<self.m:\\n            return -1\\n        else:\\n            return self.sum//(self.m - 2*self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176048,
                "title": "multiset-approach-easy-to-understand",
                "content": "```\\n#define ll long long int\\nclass MKAverage {\\n    ll m,k,tot,midsum;\\n    queue<ll> dq;\\n    multiset<ll> low,mid,high;\\npublic:\\n    MKAverage(int M, int K) {\\n        low.clear(); // store k smallest numbers in latest stream of m numbers\\n        high.clear();// stores k largest numbers in latest stream of m numbers\\n        mid.clear(); // stores the remaining numbers of the curr stream of numbers\\n        midsum=0; // sum of elements in middle midset\\n        m=M;\\n        tot=0; // intialized tot number of elements\\n        k=K;\\n    }\\n    \\n    void addElement(int num) {\\n\\t\\t// push the current element into queue\\n        dq.push(num);\\n\\t\\t// if number of elements < k then insert into smaller set only\\n        if(low.size()<k)\\n            low.insert(num);\\n        \\n        else{\\n\\t\\t\\t// initiallly we only fill low and high multisets\\n            if(high.size()<k){\\n                auto it=low.end();\\n                --it;\\n                // if given element is greater than current max of all k smallest\\n                if(*it<=num)\\n                    high.insert(num); // insert into high multiset\\n                else{\\n\\t\\t\\t\\t\\t// else insert new element into low and max from low into high multiset\\n                    int val=*it;\\n                    low.erase(it);\\n                    high.insert(val);\\n                    low.insert(num);\\n                }\\n            }\\n            // if tot >= 2*k\\n\\t\\t\\t// now we need to insert elements into middle set depending upon the following conditions\\n            else{\\n                auto it=low.end();\\n                --it;\\n                auto it2=high.begin();\\n\\t\\t\\t\\t// if current number is one of the smallest then insert into low\\n\\t\\t\\t\\t// insert the max of low into middle set\\n                if(num<*it){\\n                    ll val=*it;\\n                    low.erase(it);\\n                    mid.insert(val);\\n                    midsum+=val;\\n                    low.insert(num);\\n                }\\n                \\n\\t\\t\\t\\t// if curr number is one of the k largest put into high\\n\\t\\t\\t\\t// put the smallest from high into middle set\\n                else if(num>*it2){\\n                    ll val=*it2;\\n                    high.erase(it2);\\n                    mid.insert(val);\\n                    midsum+=val;\\n                    high.insert(num);\\n                }\\n                \\n\\t\\t\\t\\t// if curr number itself lies in middle set inherently\\n                else{\\n                    mid.insert(num);\\n                    midsum+=num;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have more than m elements we need to remove the oldest element from front of queue\\n\\t\\t\\t\\t// we search for that element in three sets and do the needful maintainigng the size of low and high always equal to k\\n                if(dq.size()==m+1){\\n                    ll f=dq.front();\\n                    dq.pop();\\n\\t\\t\\t\\t\\t// if element in middle then delete from middle set and just be done with it\\n                    if(mid.find(f)!=mid.end()){\\n                        mid.erase(mid.find(f));\\n                        midsum-=f;\\n                    }\\n\\t\\t\\t\\t\\t// deletion from low decreases its size so need to insert one of the smaller element from middle set\\n                    else if(low.find(f)!=low.end()){\\n                        low.erase(low.find(f));\\n                        auto it=mid.begin();\\n                        ll val=*it;\\n                        midsum-=val;\\n                        mid.erase(it);\\n                        low.insert(val);\\n                    }\\n\\t\\t\\t\\t\\t// deletion from high reduces its size so we insert the max from middle into high set\\n                    else{\\n                        high.erase(high.find(f));\\n                        auto it=mid.end();\\n                        --it;\\n                        ll val=*it;\\n                        mid.erase(it);\\n                        midsum-=val;\\n                        high.insert(val);\\n                    }\\n                } \\n            }\\n        }\\n    }    \\n    \\n    int calculateMKAverage() {\\n        ll ls=low.size(),ms=mid.size(),hs=high.size();\\n        tot=ls+ms+hs;\\n\\t\\t// if tot size < m\\n        if(tot<m)\\n            return -1;\\n\\t\\t// calculating the average\\n        ll mss=mid.size();\\n        ll ans=(midsum)/mss;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass MKAverage {\\n    ll m,k,tot,midsum;\\n    queue<ll> dq;\\n    multiset<ll> low,mid,high;\\npublic:\\n    MKAverage(int M, int K) {\\n        low.clear(); // store k smallest numbers in latest stream of m numbers\\n        high.clear();// stores k largest numbers in latest stream of m numbers\\n        mid.clear(); // stores the remaining numbers of the curr stream of numbers\\n        midsum=0; // sum of elements in middle midset\\n        m=M;\\n        tot=0; // intialized tot number of elements\\n        k=K;\\n    }\\n    \\n    void addElement(int num) {\\n\\t\\t// push the current element into queue\\n        dq.push(num);\\n\\t\\t// if number of elements < k then insert into smaller set only\\n        if(low.size()<k)\\n            low.insert(num);\\n        \\n        else{\\n\\t\\t\\t// initiallly we only fill low and high multisets\\n            if(high.size()<k){\\n                auto it=low.end();\\n                --it;\\n                // if given element is greater than current max of all k smallest\\n                if(*it<=num)\\n                    high.insert(num); // insert into high multiset\\n                else{\\n\\t\\t\\t\\t\\t// else insert new element into low and max from low into high multiset\\n                    int val=*it;\\n                    low.erase(it);\\n                    high.insert(val);\\n                    low.insert(num);\\n                }\\n            }\\n            // if tot >= 2*k\\n\\t\\t\\t// now we need to insert elements into middle set depending upon the following conditions\\n            else{\\n                auto it=low.end();\\n                --it;\\n                auto it2=high.begin();\\n\\t\\t\\t\\t// if current number is one of the smallest then insert into low\\n\\t\\t\\t\\t// insert the max of low into middle set\\n                if(num<*it){\\n                    ll val=*it;\\n                    low.erase(it);\\n                    mid.insert(val);\\n                    midsum+=val;\\n                    low.insert(num);\\n                }\\n                \\n\\t\\t\\t\\t// if curr number is one of the k largest put into high\\n\\t\\t\\t\\t// put the smallest from high into middle set\\n                else if(num>*it2){\\n                    ll val=*it2;\\n                    high.erase(it2);\\n                    mid.insert(val);\\n                    midsum+=val;\\n                    high.insert(num);\\n                }\\n                \\n\\t\\t\\t\\t// if curr number itself lies in middle set inherently\\n                else{\\n                    mid.insert(num);\\n                    midsum+=num;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have more than m elements we need to remove the oldest element from front of queue\\n\\t\\t\\t\\t// we search for that element in three sets and do the needful maintainigng the size of low and high always equal to k\\n                if(dq.size()==m+1){\\n                    ll f=dq.front();\\n                    dq.pop();\\n\\t\\t\\t\\t\\t// if element in middle then delete from middle set and just be done with it\\n                    if(mid.find(f)!=mid.end()){\\n                        mid.erase(mid.find(f));\\n                        midsum-=f;\\n                    }\\n\\t\\t\\t\\t\\t// deletion from low decreases its size so need to insert one of the smaller element from middle set\\n                    else if(low.find(f)!=low.end()){\\n                        low.erase(low.find(f));\\n                        auto it=mid.begin();\\n                        ll val=*it;\\n                        midsum-=val;\\n                        mid.erase(it);\\n                        low.insert(val);\\n                    }\\n\\t\\t\\t\\t\\t// deletion from high reduces its size so we insert the max from middle into high set\\n                    else{\\n                        high.erase(high.find(f));\\n                        auto it=mid.end();\\n                        --it;\\n                        ll val=*it;\\n                        mid.erase(it);\\n                        midsum-=val;\\n                        high.insert(val);\\n                    }\\n                } \\n            }\\n        }\\n    }    \\n    \\n    int calculateMKAverage() {\\n        ll ls=low.size(),ms=mid.size(),hs=high.size();\\n        tot=ls+ms+hs;\\n\\t\\t// if tot size < m\\n        if(tot<m)\\n            return -1;\\n\\t\\t// calculating the average\\n        ll mss=mid.size();\\n        ll ans=(midsum)/mss;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156775,
                "title": "help-needed-last-test-case-giving-tle",
                "content": "```\\nclass MKAverage {\\npublic:\\n    int m,k;\\n    int temp;\\n    multiset<int,greater<int>> s;\\n    vector<int> v;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        v.clear();\\n        temp = 0;\\n    }\\n    \\n    void addElement(int num) {\\n        v.push_back(num);\\n        if(s.size()<m){\\n            s.insert(num);\\n        }else{\\n            s.erase(s.lower_bound(v[temp]));\\n            temp++;\\n            s.insert(num);\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(s.size()<m) return -1;\\n        vector<int> arr;\\n        for(auto it:s){\\n            arr.push_back(it);\\n        }\\n        long long ress=0;\\n        long long count = 0;\\n        int i=k;\\n        for(int j=k;j<arr.size();j++){\\n            i++;\\n            if(i>k && i<=(m-k)){\\n                ress+=arr[j];\\n                count++;\\n            }\\n            if(i>(m-k)) break;\\n        }\\n        int res = ress/count ;\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n    int m,k;\\n    int temp;\\n    multiset<int,greater<int>> s;\\n    vector<int> v;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        v.clear();\\n        temp = 0;\\n    }\\n    \\n    void addElement(int num) {\\n        v.push_back(num);\\n        if(s.size()<m){\\n            s.insert(num);\\n        }else{\\n            s.erase(s.lower_bound(v[temp]));\\n            temp++;\\n            s.insert(num);\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(s.size()<m) return -1;\\n        vector<int> arr;\\n        for(auto it:s){\\n            arr.push_back(it);\\n        }\\n        long long ress=0;\\n        long long count = 0;\\n        int i=k;\\n        for(int j=k;j<arr.size();j++){\\n            i++;\\n            if(i>k && i<=(m-k)){\\n                ress+=arr[j];\\n                count++;\\n            }\\n            if(i>(m-k)) break;\\n        }\\n        int res = ress/count ;\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156553,
                "title": "javascript-2-segment-trees-divide-and-conquer",
                "content": "\\nThe main idea is to create two seperate segment trees. One will store the count of the elements up to a specific element. So for example if the elements 1,2, 3, 3, 4, 4 are given then it ll look sth like\\n\\n0 1 2 3 4 \\n**0 1 2 4 5** <=cumulative counts up to a specific element (think prefix sums [0,i] )\\n\\nThe other segment tree will store the sum of the given elements. So in the previous example:\\n0 1 2 3 4 \\n**0 1 3 9 17**  <=cumualtive sum of given elements\\n\\nWhat I intend to do is always maintain m values in those trees, namely the m last elements. \\nIf I can achieve that, then the required MK average boils down to calculating the average of the inbetween  range of elements.\\n\\nLet us denote with S and E the start and the end of my required window after we removed the first and last K elements. \\nIn order to find those two indices, we ll have to use Divide and Conquer on the segment tree queries of the first segment tree. The whole idea is creating the function seachPrefixIndex(x) that recursively finds the leftmost index where the prefix[0,i]>=x\\n\\n\\n![image](https://assets.leetcode.com/users/images/1006dba3-a478-40f0-8b19-c6c442aa8ff7_1618320195.3242278.jpeg)\\nSince we know that my window will begin after I removed the first k elements, S will start from the k+1-th element. But the thing is that a given prefix may not contain the value k+1 per se. That would mean that I have multiple occurences of a value. \\nIn the first example, if I wanted to remove k=2 elements, then i\\'d have to search for (k+1=3), but as you can see there is no such value inside the Index segment tree values. That\\'s because we have two occurences of the element 3 and as such the prefix is 4 instead of 3. So we ll have to adjust the divide and conquer method to search for the leftmost occurence of any value>=k+1 . \\nOnce we find said index we ll have to take the (last) prefix[0:index]-k elements. \\nThe same idea goes for the E (end) index of my window. Once a new element is given, we roll the whole thing by removing the earliest( first) element that was given. \\n\\n```\\n\\nclass ArraySegTree{\\n    // Array to perfrom operations on, range query operation, PointUpdate operation\\n    constructor(A,op=(a,b)=>a+b,upOp=(a,b)=>a+b,opSentinel=0){\\n        this.n=A.length,this.t=[...Array(4*this.n+1)],this.op=op,this.upOp=upOp,this.opSentinel=opSentinel\\n        //root\\'s idx =1\\n        this.build(A,1,0,this.n-1)\\n    }\\n    left=x=>this.t[2*x];right=x=>this.t[2*x+1]\\n    build(A,idx,left,right){\\n        if(left==right)\\n            return this.t[idx]=A[left]\\n        let mid=(left+right)>>1\\n        this.build(A,2*idx,left,mid) //go left\\n        this.build(A,2*idx+1,mid+1,right) //go right\\n        this.t[idx]=this.op(this.left(idx),this.right(idx)) //merge\\n    }\\n    //just specify l,r on actual queries\\n    //Here queries use the actul indices of the starting array A, so rangeQuery(0,n-1) returns the whole array\\n    rangeQuery=(l,r,tl=0,tr=this.n-1,idx=1)=>{\\n        if(l>r)\\n            return this.opSentinel\\n        if(l===tl&&r===tr)\\n            return this.t[idx]\\n        let mid=(tl+tr)>>1\\n        return this.op(\\n                this.rangeQuery(l,Math.min(r,mid),tl,mid,idx*2),\\n                this.rangeQuery(Math.max(l,mid+1),r,mid+1,tr,idx*2+1)\\n        ) \\n    }\\n    //just specify arrIdx,newVal on actual pointUpdates\\n    pointUpdate=(arrIdx,newVal,tl=0,tr=this.n-1,idx=1)=>{\\n        if(tl==tr)\\n            return this.t[idx]=this.upOp(this.t[idx],newVal)\\n        let mid=(tl+tr)>>1\\n        if(arrIdx<=mid)\\n            this.pointUpdate(arrIdx,newVal,tl,mid,2*idx)\\n        else\\n            this.pointUpdate(arrIdx,newVal,mid+1,tr,2*idx+1)\\n        this.t[idx]=this.op(this.left(idx),this.right(idx))\\n    }\\n    seachPrefixIndex=(x,start=0,end=this.n-1)=>{\\n        let s=this.rangeQuery(start,end)\\n        if(s<x)\\n            return -1\\n        if(start===end)\\n            return start\\n        let mid=start+end>>1,left=this.rangeQuery(start,mid)\\n        if( left>=x)\\n            return this.seachPrefixIndex(x,start,mid)\\n        else\\n            return this.seachPrefixIndex(x-left,mid+1,end)\\n    }\\n}\\n\\nvar MKAverage = function(m, k) {\\n    this.A=[],this.m=m,this.k=k,this.div=m-2*k\\n    this.S1=new ArraySegTree([...Array(1e5+2)].map(d=>0))//indices\\n    this.S2=new ArraySegTree([...Array(1e5+2)].map(d=>0))//sums\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMKAverage.prototype.addElement = function(num) {\\n    this.A.push(num)\\n    this.S1.pointUpdate(num,1)\\n    this.S2.pointUpdate(num,num)\\n    if(this.A.length>this.m){\\n        let z=this.A.shift()\\n        this.S1.pointUpdate(z,-1)\\n        this.S2.pointUpdate(z,-z)\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMKAverage.prototype.calculateMKAverage = function() {\\n    if(this.A.length<this.m)\\n        return -1\\n    \\n    let S=this.S1.seachPrefixIndex(this.k+1),\\n        count1=this.S1.rangeQuery(0,S),\\n        take=(count1-this.k)*S\\n    \\n    let E=this.S1.seachPrefixIndex(this.m-this.k),\\n        count2=this.S1.rangeQuery(0,E),\\n        remove=(count2-this.m+this.k)*E\\n    \\n    let midSum=this.S2.rangeQuery(S+1,E)\\n    return (take+midSum-remove)/this.div>>0\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\n\\nclass ArraySegTree{\\n    // Array to perfrom operations on, range query operation, PointUpdate operation\\n    constructor(A,op=(a,b)=>a+b,upOp=(a,b)=>a+b,opSentinel=0){\\n        this.n=A.length,this.t=[...Array(4*this.n+1)],this.op=op,this.upOp=upOp,this.opSentinel=opSentinel\\n        //root\\'s idx =1\\n        this.build(A,1,0,this.n-1)\\n    }\\n    left=x=>this.t[2*x];right=x=>this.t[2*x+1]\\n    build(A,idx,left,right){\\n        if(left==right)\\n            return this.t[idx]=A[left]\\n        let mid=(left+right)>>1\\n        this.build(A,2*idx,left,mid) //go left\\n        this.build(A,2*idx+1,mid+1,right) //go right\\n        this.t[idx]=this.op(this.left(idx),this.right(idx)) //merge\\n    }\\n    //just specify l,r on actual queries\\n    //Here queries use the actul indices of the starting array A, so rangeQuery(0,n-1) returns the whole array\\n    rangeQuery=(l,r,tl=0,tr=this.n-1,idx=1)=>{\\n        if(l>r)\\n            return this.opSentinel\\n        if(l===tl&&r===tr)\\n            return this.t[idx]\\n        let mid=(tl+tr)>>1\\n        return this.op(\\n                this.rangeQuery(l,Math.min(r,mid),tl,mid,idx*2),\\n                this.rangeQuery(Math.max(l,mid+1),r,mid+1,tr,idx*2+1)\\n        ) \\n    }\\n    //just specify arrIdx,newVal on actual pointUpdates\\n    pointUpdate=(arrIdx,newVal,tl=0,tr=this.n-1,idx=1)=>{\\n        if(tl==tr)\\n            return this.t[idx]=this.upOp(this.t[idx],newVal)\\n        let mid=(tl+tr)>>1\\n        if(arrIdx<=mid)\\n            this.pointUpdate(arrIdx,newVal,tl,mid,2*idx)\\n        else\\n            this.pointUpdate(arrIdx,newVal,mid+1,tr,2*idx+1)\\n        this.t[idx]=this.op(this.left(idx),this.right(idx))\\n    }\\n    seachPrefixIndex=(x,start=0,end=this.n-1)=>{\\n        let s=this.rangeQuery(start,end)\\n        if(s<x)\\n            return -1\\n        if(start===end)\\n            return start\\n        let mid=start+end>>1,left=this.rangeQuery(start,mid)\\n        if( left>=x)\\n            return this.seachPrefixIndex(x,start,mid)\\n        else\\n            return this.seachPrefixIndex(x-left,mid+1,end)\\n    }\\n}\\n\\nvar MKAverage = function(m, k) {\\n    this.A=[],this.m=m,this.k=k,this.div=m-2*k\\n    this.S1=new ArraySegTree([...Array(1e5+2)].map(d=>0))//indices\\n    this.S2=new ArraySegTree([...Array(1e5+2)].map(d=>0))//sums\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nMKAverage.prototype.addElement = function(num) {\\n    this.A.push(num)\\n    this.S1.pointUpdate(num,1)\\n    this.S2.pointUpdate(num,num)\\n    if(this.A.length>this.m){\\n        let z=this.A.shift()\\n        this.S1.pointUpdate(z,-1)\\n        this.S2.pointUpdate(z,-z)\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMKAverage.prototype.calculateMKAverage = function() {\\n    if(this.A.length<this.m)\\n        return -1\\n    \\n    let S=this.S1.seachPrefixIndex(this.k+1),\\n        count1=this.S1.rangeQuery(0,S),\\n        take=(count1-this.k)*S\\n    \\n    let E=this.S1.seachPrefixIndex(this.m-this.k),\\n        count2=this.S1.rangeQuery(0,E),\\n        remove=(count2-this.m+this.k)*E\\n    \\n    let midSum=this.S2.rangeQuery(S+1,E)\\n    return (take+midSum-remove)/this.div>>0\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155507,
                "title": "java-clean-code-with-minmaxheap-implementation",
                "content": "O(logN) for addElement\\nO(1) for calculateMKAverage\\n```\\nclass MKAverage {\\n    int m , k;\\n    LinkedList<Integer> q = new LinkedList<>();\\n    MinMaxQ head = new MinMaxQ();\\n    MinMaxQ body = new MinMaxQ();\\n    MinMaxQ tail = new MinMaxQ();\\n    \\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (q.size()==m) {\\n            int pre = q.poll();\\n            if (tail.contains(pre)) {\\n                tail.remove(pre);\\n            } else if (body.contains(pre)) {\\n                body.remove(pre);\\n                body.add(tail.pollMin());\\n            } else if (head.contains(pre)){\\n                head.remove(pre);\\n                body.add(tail.pollMin());\\n                head.add(body.pollMin());\\n            }\\n        }\\n        \\n        head.add(num);\\n        if (head.count>k) {\\n            body.add(head.pollMax());\\n            if (body.count>(m-2*k)) \\n                tail.add(body.pollMax());\\n        }\\n        q.offer(num);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size()<m) return -1; \\n        return (int)Math.floor(body.sum/(m-2*k));\\n    }\\n    \\n    class MinMaxQ {\\n        int count = 0;\\n        long sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        Integer min() { return map.firstKey();}\\n        Integer max() { return map.lastKey();}\\n        int count() { return count;}\\n        long sum() { return sum;}\\n        boolean contains(int num) { return map.containsKey(num);}\\n        boolean isEmpty(){ return map.isEmpty();}\\n        \\n        int add(int num) {\\n            map.merge(num, 1, (a,b)->a+b);\\n            sum+=num;\\n            return ++count;\\n        }\\n        \\n        Integer pollMin() {\\n            Integer min = this.min();\\n            if (min!=null) remove(min);\\n            return min;\\n        }\\n        \\n        Integer pollMax() {\\n            Integer max = this.max();\\n            if (max!=null) remove(max);\\n            return max;\\n        }\\n        \\n        boolean remove(int num) {\\n            if (!map.containsKey(num)) return false;\\n            map.merge(num, -1, (a,b)->a+b);\\n            if (map.get(num)==0) \\n                map.remove(num);\\n            count--;\\n            sum-=num;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    int m , k;\\n    LinkedList<Integer> q = new LinkedList<>();\\n    MinMaxQ head = new MinMaxQ();\\n    MinMaxQ body = new MinMaxQ();\\n    MinMaxQ tail = new MinMaxQ();\\n    \\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (q.size()==m) {\\n            int pre = q.poll();\\n            if (tail.contains(pre)) {\\n                tail.remove(pre);\\n            } else if (body.contains(pre)) {\\n                body.remove(pre);\\n                body.add(tail.pollMin());\\n            } else if (head.contains(pre)){\\n                head.remove(pre);\\n                body.add(tail.pollMin());\\n                head.add(body.pollMin());\\n            }\\n        }\\n        \\n        head.add(num);\\n        if (head.count>k) {\\n            body.add(head.pollMax());\\n            if (body.count>(m-2*k)) \\n                tail.add(body.pollMax());\\n        }\\n        q.offer(num);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size()<m) return -1; \\n        return (int)Math.floor(body.sum/(m-2*k));\\n    }\\n    \\n    class MinMaxQ {\\n        int count = 0;\\n        long sum = 0;\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        Integer min() { return map.firstKey();}\\n        Integer max() { return map.lastKey();}\\n        int count() { return count;}\\n        long sum() { return sum;}\\n        boolean contains(int num) { return map.containsKey(num);}\\n        boolean isEmpty(){ return map.isEmpty();}\\n        \\n        int add(int num) {\\n            map.merge(num, 1, (a,b)->a+b);\\n            sum+=num;\\n            return ++count;\\n        }\\n        \\n        Integer pollMin() {\\n            Integer min = this.min();\\n            if (min!=null) remove(min);\\n            return min;\\n        }\\n        \\n        Integer pollMax() {\\n            Integer max = this.max();\\n            if (max!=null) remove(max);\\n            return max;\\n        }\\n        \\n        boolean remove(int num) {\\n            if (!map.containsKey(num)) return false;\\n            map.merge(num, -1, (a,b)->a+b);\\n            if (map.get(num)==0) \\n                map.remove(num);\\n            count--;\\n            sum-=num;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155323,
                "title": "java-fenwick-tree-binary-search-o-logn-for-both-addelement-calculatemkaverage",
                "content": "```\\n// Time complexity : O(logN)\\n// Space complexity : O(N)\\n// N is the possible max value in stream, which is 100000 based on the description\\n\\nclass MKAverage {\\n    \\n    private int LIMIT = 100000;\\n    \\n    int m, k;\\n    long sum;\\n    Queue<Integer> q;\\n    BIT bit1, bit2;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        sum = 0;\\n        q = new LinkedList<>();\\n        bit1 = new BIT(LIMIT + 1);\\n        bit2 = new BIT(LIMIT + 1);\\n    }\\n    \\n    public void addElement(int num) {\\n        q.offer(num);\\n        bit1.update(num, 1);\\n        bit2.update(num, num);\\n        sum += num;\\n        \\n        if (q.size() > m) {\\n            int r = q.poll();\\n            bit1.update(r, -1);\\n            bit2.update(r, -r);\\n            sum -= r;\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        \\n        long lSum = findKSmallest(),\\n             rSum = findKLargest();\\n\\n        return (int)((sum - lSum -rSum) / (m - 2 * k));\\n        \\n    }\\n    \\n    private long rangQuery(BIT bit, int hig, int low) {\\n        return bit.query(hig) - bit.query(low - 1);\\n    }\\n    \\n    private long findKSmallest() {\\n        int l = 1, r = LIMIT, number = -1;\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            long count = rangQuery(bit1, m, 1);\\n            if (count >= k) r = m;\\n            else l = m;\\n        }\\n        \\n        if (rangQuery(bit1, l, 1) >= k) number = l;\\n        else number = r;\\n        \\n        long cnt = rangQuery(bit1, number, 1),\\n             sum = rangQuery(bit2, number, 1);\\n        \\n        return removeMoreThanK(sum, cnt, number);\\n    }\\n    \\n    private long findKLargest() {\\n        int l = 1, r = LIMIT, number = -1;\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            long count = rangQuery(bit1, LIMIT, m);\\n            if (count >= k) l = m;\\n            else r = m;\\n        }\\n        \\n        if (rangQuery(bit1, LIMIT, r) >= k) number = r;\\n        else number = l;\\n        \\n        long cnt = rangQuery(bit1, LIMIT, number),\\n             sum = rangQuery(bit2, LIMIT, number);\\n        \\n        return removeMoreThanK(sum, cnt, number);\\n    }\\n    \\n    private long removeMoreThanK(long sum, long cnt, int number) {\\n        if (cnt > k) {\\n            return sum - (cnt - k) * number;\\n        }\\n        return sum;\\n    }\\n    \\n    class BIT {\\n        long[] array;\\n        \\n        BIT(int size) {\\n            array = new long[size];\\n        }\\n        \\n        public void update(int ind, int v) {\\n            while (ind < array.length) {\\n                array[ind] += v;\\n                ind += ind & -ind;\\n            }\\n        }\\n        \\n        public long query(int ind) {\\n            long res = 0;\\n            while (ind > 0) {\\n                res += array[ind];\\n                ind -= ind & -ind;\\n            }\\n            return res;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n// Time complexity : O(logN)\\n// Space complexity : O(N)\\n// N is the possible max value in stream, which is 100000 based on the description\\n\\nclass MKAverage {\\n    \\n    private int LIMIT = 100000;\\n    \\n    int m, k;\\n    long sum;\\n    Queue<Integer> q;\\n    BIT bit1, bit2;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        sum = 0;\\n        q = new LinkedList<>();\\n        bit1 = new BIT(LIMIT + 1);\\n        bit2 = new BIT(LIMIT + 1);\\n    }\\n    \\n    public void addElement(int num) {\\n        q.offer(num);\\n        bit1.update(num, 1);\\n        bit2.update(num, num);\\n        sum += num;\\n        \\n        if (q.size() > m) {\\n            int r = q.poll();\\n            bit1.update(r, -1);\\n            bit2.update(r, -r);\\n            sum -= r;\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        \\n        long lSum = findKSmallest(),\\n             rSum = findKLargest();\\n\\n        return (int)((sum - lSum -rSum) / (m - 2 * k));\\n        \\n    }\\n    \\n    private long rangQuery(BIT bit, int hig, int low) {\\n        return bit.query(hig) - bit.query(low - 1);\\n    }\\n    \\n    private long findKSmallest() {\\n        int l = 1, r = LIMIT, number = -1;\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            long count = rangQuery(bit1, m, 1);\\n            if (count >= k) r = m;\\n            else l = m;\\n        }\\n        \\n        if (rangQuery(bit1, l, 1) >= k) number = l;\\n        else number = r;\\n        \\n        long cnt = rangQuery(bit1, number, 1),\\n             sum = rangQuery(bit2, number, 1);\\n        \\n        return removeMoreThanK(sum, cnt, number);\\n    }\\n    \\n    private long findKLargest() {\\n        int l = 1, r = LIMIT, number = -1;\\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            long count = rangQuery(bit1, LIMIT, m);\\n            if (count >= k) l = m;\\n            else r = m;\\n        }\\n        \\n        if (rangQuery(bit1, LIMIT, r) >= k) number = r;\\n        else number = l;\\n        \\n        long cnt = rangQuery(bit1, LIMIT, number),\\n             sum = rangQuery(bit2, LIMIT, number);\\n        \\n        return removeMoreThanK(sum, cnt, number);\\n    }\\n    \\n    private long removeMoreThanK(long sum, long cnt, int number) {\\n        if (cnt > k) {\\n            return sum - (cnt - k) * number;\\n        }\\n        return sum;\\n    }\\n    \\n    class BIT {\\n        long[] array;\\n        \\n        BIT(int size) {\\n            array = new long[size];\\n        }\\n        \\n        public void update(int ind, int v) {\\n            while (ind < array.length) {\\n                array[ind] += v;\\n                ind += ind & -ind;\\n            }\\n        }\\n        \\n        public long query(int ind) {\\n            long res = 0;\\n            while (ind > 0) {\\n                res += array[ind];\\n                ind -= ind & -ind;\\n            }\\n            return res;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154386,
                "title": "python-3-o-logm-lazysumheap-and-partitionsum",
                "content": "```\\nclass LazySumHeap:\\n    \\n    def __init__(self, key):\\n        self.heap = []\\n        self.key = key\\n        self.c = Counter()\\n        self.sz = 0\\n        self.sum = 0\\n    \\n    def __len__(self):\\n        return self.sz\\n    \\n    def clean(self):\\n        while self.heap and not self.c[self.heap[0][2]]:\\n            heappop(self.heap)\\n    \\n    def peek(self):\\n        self.clean()\\n        return self.heap[0][2]\\n    \\n    def pop(self):\\n        self.clean()\\n        \\n        ret = heappop(self.heap)[2]\\n        \\n        self.c[ret] -= 1\\n        self.sz -= 1\\n        self.sum -= ret\\n        \\n        return ret\\n    \\n    def remove(self, x):\\n        self.c[x] -= 1\\n        self.sz -= 1\\n        self.sum -= x\\n    \\n    def push(self, x):\\n        \\n        entry = [self.key(x), id(x), x]\\n        \\n        heappush(self.heap, entry)\\n        \\n        self.c[x] += 1\\n        self.sz += 1\\n        self.sum += x\\n        \\n        \\nclass PartitionSum:\\n    \\n    # lowest <= k elements\\n    def __init__(self, k):\\n        self.k = k\\n        self.lo = LazySumHeap(lambda x:-x)\\n        self.hi = LazySumHeap(lambda x:x)\\n    \\n    def rebalance(self):\\n        \\n        while len(self.lo) > self.k:\\n            self.hi.push(self.lo.pop())\\n        \\n        while self.hi and len(self.lo) < self.k:\\n            self.lo.push(self.hi.pop())\\n    \\n    def add(self, x):\\n        \\n        if not self.hi or (self.hi and x < self.hi.peek()):\\n            self.lo.push(x)\\n        else:\\n            self.hi.push(x)\\n\\n        self.rebalance()\\n    \\n    def remove(self, x):\\n        \\n        if x <= self.lo.peek():\\n            self.lo.remove(x)\\n        else:\\n            self.hi.remove(x)\\n        \\n        self.rebalance()\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, M: int, K: int):\\n        global m,k,q,lo,hi\\n        \\n        m = M\\n        k = K\\n        \\n        q = deque()\\n        \\n        lo = PartitionSum(k)\\n        hi = PartitionSum(m-k)\\n        \\n\\n    def addElement(self, x: int) -> None:\\n        global m,k,q,lo,hi\\n        \\n        if len(q) <= m-1:\\n            q.append(x)\\n            lo.add(x)\\n            hi.add(x)\\n            \\n        else:\\n            \\n            y = q.popleft()\\n            lo.remove(y)\\n            hi.remove(y)\\n            \\n            q.append(x)\\n            lo.add(x)\\n            hi.add(x)\\n\\n    def calculateMKAverage(self) -> int:\\n        global m,k,q,lo,hi\\n        \\n        if len(q) < m:\\n            return -1\\n        else:\\n            return (lo.hi.sum - hi.hi.sum) // (m-k-k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LazySumHeap:\\n    \\n    def __init__(self, key):\\n        self.heap = []\\n        self.key = key\\n        self.c = Counter()\\n        self.sz = 0\\n        self.sum = 0\\n    \\n    def __len__(self):\\n        return self.sz\\n    \\n    def clean(self):\\n        while self.heap and not self.c[self.heap[0][2]]:\\n            heappop(self.heap)\\n    \\n    def peek(self):\\n        self.clean()\\n        return self.heap[0][2]\\n    \\n    def pop(self):\\n        self.clean()\\n        \\n        ret = heappop(self.heap)[2]\\n        \\n        self.c[ret] -= 1\\n        self.sz -= 1\\n        self.sum -= ret\\n        \\n        return ret\\n    \\n    def remove(self, x):\\n        self.c[x] -= 1\\n        self.sz -= 1\\n        self.sum -= x\\n    \\n    def push(self, x):\\n        \\n        entry = [self.key(x), id(x), x]\\n        \\n        heappush(self.heap, entry)\\n        \\n        self.c[x] += 1\\n        self.sz += 1\\n        self.sum += x\\n        \\n        \\nclass PartitionSum:\\n    \\n    # lowest <= k elements\\n    def __init__(self, k):\\n        self.k = k\\n        self.lo = LazySumHeap(lambda x:-x)\\n        self.hi = LazySumHeap(lambda x:x)\\n    \\n    def rebalance(self):\\n        \\n        while len(self.lo) > self.k:\\n            self.hi.push(self.lo.pop())\\n        \\n        while self.hi and len(self.lo) < self.k:\\n            self.lo.push(self.hi.pop())\\n    \\n    def add(self, x):\\n        \\n        if not self.hi or (self.hi and x < self.hi.peek()):\\n            self.lo.push(x)\\n        else:\\n            self.hi.push(x)\\n\\n        self.rebalance()\\n    \\n    def remove(self, x):\\n        \\n        if x <= self.lo.peek():\\n            self.lo.remove(x)\\n        else:\\n            self.hi.remove(x)\\n        \\n        self.rebalance()\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, M: int, K: int):\\n        global m,k,q,lo,hi\\n        \\n        m = M\\n        k = K\\n        \\n        q = deque()\\n        \\n        lo = PartitionSum(k)\\n        hi = PartitionSum(m-k)\\n        \\n\\n    def addElement(self, x: int) -> None:\\n        global m,k,q,lo,hi\\n        \\n        if len(q) <= m-1:\\n            q.append(x)\\n            lo.add(x)\\n            hi.add(x)\\n            \\n        else:\\n            \\n            y = q.popleft()\\n            lo.remove(y)\\n            hi.remove(y)\\n            \\n            q.append(x)\\n            lo.add(x)\\n            hi.add(x)\\n\\n    def calculateMKAverage(self) -> int:\\n        global m,k,q,lo,hi\\n        \\n        if len(q) < m:\\n            return -1\\n        else:\\n            return (lo.hi.sum - hi.hi.sum) // (m-k-k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153727,
                "title": "python3-sortedlist",
                "content": "Create a SortedList srr and an array arr.\\narr contains all elements in the order they are inserted.\\nsrr contains last m elements of arr in sorted order.\\nmidsum is the sum of elements of srr excluding 1st k and last k elements.\\nWhile taking average size would be n = m - 2 * k\\nwhenever a new element has to be inserted, remove (arr.length-m)th element from srr,\\ndo this operation while keeping track of midsum so that complexity for addElement() is log(n).\\ninserpos() used to determine at what position will a new elemet get inserted when added to srr.\\n```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        self.srr = SortedList([])\\n        self.midsum = 0\\n        self.n = self.m - 2*self.k\\n    def insertpos(self, x: int) -> int:\\n        l = 0\\n        r = self.m-1\\n        if x<=self.srr[0]:\\n            return 0\\n        if x>=self.srr[-1]:\\n            return self.m\\n        while l<=r:\\n            m = (l+r)//2\\n            if self.srr[m]<x and (m+1==len(self.srr) or self.srr[m+1]>=x):\\n                return m+1\\n            elif self.srr[m]<x:\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return -1\\n    def addElement(self, x: int) -> None:\\n        self.arr.append(x)\\n        if len(self.arr)==self.m:\\n            arr = sorted(self.arr)\\n            for i in range(self.k):\\n                self.srr.add(arr[i])\\n            for i in range(self.k, self.m-self.k):\\n                self.srr.add(arr[i])\\n                self.midsum += arr[i]\\n            for i in range(self.m-self.k, self.m):\\n                self.srr.add(arr[i])\\n        if len(self.arr)<=self.m:\\n            return\\n        rem = self.arr[-self.m-1]\\n        if rem<=self.srr[self.k-1]:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            if ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x - self.srr[self.k-1]\\n            elif ip>self.m-self.k-1:\\n                self.midsum += self.srr[self.m-self.k-1] - self.srr[self.k-1]\\n            self.srr.add(x)\\n        elif rem<=self.srr[self.m-self.k-1]:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            self.midsum -= rem\\n            if ip<self.k:\\n                self.midsum += self.srr[self.k-1]\\n            elif ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x\\n            else:\\n                self.midsum += self.srr[self.m-self.k-1]\\n            self.srr.add(x)\\n        else:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            if ip<self.k:\\n                self.midsum += self.srr[self.k-1] - self.srr[self.m-self.k-1]\\n            elif ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x - self.srr[self.m-self.k-1]\\n            self.srr.add(x)\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr)<self.m:\\n            return -1\\n        else:\\n            return self.midsum//self.n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        self.srr = SortedList([])\\n        self.midsum = 0\\n        self.n = self.m - 2*self.k\\n    def insertpos(self, x: int) -> int:\\n        l = 0\\n        r = self.m-1\\n        if x<=self.srr[0]:\\n            return 0\\n        if x>=self.srr[-1]:\\n            return self.m\\n        while l<=r:\\n            m = (l+r)//2\\n            if self.srr[m]<x and (m+1==len(self.srr) or self.srr[m+1]>=x):\\n                return m+1\\n            elif self.srr[m]<x:\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return -1\\n    def addElement(self, x: int) -> None:\\n        self.arr.append(x)\\n        if len(self.arr)==self.m:\\n            arr = sorted(self.arr)\\n            for i in range(self.k):\\n                self.srr.add(arr[i])\\n            for i in range(self.k, self.m-self.k):\\n                self.srr.add(arr[i])\\n                self.midsum += arr[i]\\n            for i in range(self.m-self.k, self.m):\\n                self.srr.add(arr[i])\\n        if len(self.arr)<=self.m:\\n            return\\n        rem = self.arr[-self.m-1]\\n        if rem<=self.srr[self.k-1]:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            if ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x - self.srr[self.k-1]\\n            elif ip>self.m-self.k-1:\\n                self.midsum += self.srr[self.m-self.k-1] - self.srr[self.k-1]\\n            self.srr.add(x)\\n        elif rem<=self.srr[self.m-self.k-1]:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            self.midsum -= rem\\n            if ip<self.k:\\n                self.midsum += self.srr[self.k-1]\\n            elif ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x\\n            else:\\n                self.midsum += self.srr[self.m-self.k-1]\\n            self.srr.add(x)\\n        else:\\n            self.srr.remove(rem)\\n            ip = self.insertpos(x)\\n            if ip<self.k:\\n                self.midsum += self.srr[self.k-1] - self.srr[self.m-self.k-1]\\n            elif ip>=self.k and ip<=self.m-self.k-1:\\n                self.midsum += x - self.srr[self.m-self.k-1]\\n            self.srr.add(x)\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr)<self.m:\\n            return -1\\n        else:\\n            return self.midsum//self.n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153286,
                "title": "c-balance-3-multisets-heaps",
                "content": "Have 3 multisets: f*irst multiset, middle multiset, last multiset.*\\n\\nWe can limit the elements under consideration to  \\'m\\'. Because we are always interested in last m elements from the numbers stream. \\nThe first multiset will contain first K smallest elements. and the last multiset will contain last K elements. \\nThe middle multiset will contain *m - 2K* elements. (i.e we don\\'t have to remove K smaller element and K larger elements from the stream to calculate average ).\\n\\nIf less than  \\'m\\' elements are processed in the number stream, the average will always be -1.\\nSo we arrive at the following property which we will keep satisfying when more than \\'m\\' elemens are processed. \\n**Property 1: At any given point, first.size() + middle.size() + last.size() should be equal to m**\\n\\nAlso have a queue or a vector to track the last element which is to be removed. \\nWhen less than m elements are processed, push the element to the queue as well as to the middle multiset. \\n\\nWhen exactly m elemens are processed, then relalace the multisets in the following manner.\\n\\tAdd the first k elements from the middle multiset to the first multiset. \\n\\tAdd the last k elements form the middle multiset to the last multiset. \\n\\t\\n```\\n\\t    int count = 0;\\n\\t\\twhile(count < k)\\n\\t\\t{\\n\\t\\t\\tfirst.insert(*middle.begin());\\n\\t\\t\\tmiddle.erase(middle.begin());\\n\\n\\t\\t\\tlast.insert(*middle.rbegin());\\n\\t\\t\\tmiddle.erase(prev(middle.end()));\\n\\t\\t\\tcount++;\\n\\t\\t}\\n```\\n\\nNow all the multisets are balanced, When a new element is encountered, \\nFirst add the element to the middle multiset.  \\nWe also need to remove the first element from the queue and from one of the multisets (we need to look for the multisets one by one where the element exists) to satisfy **property 1** \\nFind the multiset where the element exists and , then -\\tRemove the element from the multiset and Adjust the multisets. \\n\\nAdjusting the multisets:\\n*Both the first multiset and last multiset should have K elements.*\\n\\nif first multiset is having less than K elements, then adjust with middle multiset, so that first multiset will have K elements. \\nif last multiset is haveing less than K elements, then adjust with middle multiset, so that last multiset will have K elements.\\n```\\nwhile(first.size() < k)\\n{\\n\\tfirst.insert(*middle.begin());\\n\\tmiddle.erase(middle.begin());\\n}\\n\\nwhile(last.size() < k)\\n{\\n\\tlast.insert(*prev(middle.end()));\\n\\tmiddle.erase(prev(middle.end()));\\n}  \\n```\\n*Since multisets are sorted in nature, the last element in first multiset should be less than or equal to the first element of the middle multiset. \\nSimilarly the last element of the middle multiset should be less than or equal to the first element of the last multiset.*\\n\\nIf the above property is not satisfied, we make adjustments to the multisets. \\n```\\n        while(*last.begin() < *prev(middle.end()))\\n        {\\n            middle.insert(*last.begin());\\n            last.erase(last.begin());\\n            \\n            last.insert(*prev(middle.end()));\\n            middle.erase(prev(middle.end()));\\n        } \\n\\n        while(*prev(first.end()) > *middle.begin())\\n        {\\n            middle.insert(*prev(first.end()));\\n            first.erase(prev(first.end()));\\n            \\n            first.insert(*middle.begin());\\n            middle.erase(middle.begin());\\n        }\\n```\\n\\nHow to calculate the MK Average ?\\nWe can add all the element in the middle multiset, and return the average. This approach will have linear complexity. \\n\\n*We can calculate MK Average in constant time by keeping a running sum of elements in the middle multiset.*\\n\\ni.e. whenever an element is removed  from the middle multiset, we subtract the element from the sum. Similarly when an element is added to the middle multiset, we add the element to the sum. When ```calculateMKAverage``` function is called we simply return \\n```\\nreturn q.size() < m ? -1 : sum/middle.size(); // sum is the running sum of elements in middle multiset.\\n```\\n\\nFull code:\\n```\\nclass MKAverage {\\n    \\n    private:\\n    void adjustHeaps(multiset<int>& first, multiset<int>& middle, multiset<int>& last)\\n    {\\n        while(first.size() < k)\\n        {\\n            first.insert(*middle.begin());\\n            sum -= *middle.begin();\\n            middle.erase(middle.begin());\\n        }\\n        \\n        while(last.size() < k)\\n        {\\n            last.insert(*prev(middle.end()));\\n            sum -= *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n        }  \\n        \\n        while(*last.begin() < *prev(middle.end()))\\n        {\\n            middle.insert(*last.begin());\\n            sum += *last.begin();\\n            last.erase(last.begin());\\n            \\n            last.insert(*prev(middle.end()));\\n            sum -= *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n        } \\n\\n        while(*prev(first.end()) > *middle.begin())\\n        {\\n            sum += *prev(first.end());\\n            middle.insert(*prev(first.end()));\\n            first.erase(prev(first.end()));\\n            \\n            first.insert(*middle.begin());\\n            sum -= *middle.begin();\\n            middle.erase(middle.begin());\\n        }\\n    }\\npublic:\\n    int m,k;\\n    long long sum = 0;\\n    multiset<int> first, last, middle;\\n    queue<int> q;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n    }\\n    \\n    void addElement(int num) {\\n        if(q.size() < m-1)\\n        {\\n            middle.insert(num);\\n            q.push(num);\\n        }\\n        else if(q.size() == m-1)\\n        {\\n            auto f = middle.begin();\\n            auto l = middle.rbegin();\\n            q.push(num);\\n            middle.insert(num);\\n            int count = 0;\\n            while(count < k)\\n            {\\n                first.insert(*middle.begin());\\n                middle.erase(middle.begin());\\n                \\n                last.insert(*middle.rbegin());\\n                middle.erase(prev(middle.end()));\\n                \\n                count++;\\n            }\\n            for(auto i : middle) sum += i;\\n        }\\n        else\\n        {\\n            q.push(num);\\n            auto elem = q.front();\\n            q.pop();\\n            middle.insert(num);\\n            sum += num;\\n            \\n            if(first.find(elem)!= first.end()){\\n                first.erase(first.find(elem));               \\n                adjustHeaps(first, middle, last);\\n            }\\n            \\n            else if(middle.find(elem) != middle.end())\\n            {\\n                sum -= elem;\\n                middle.erase(middle.find(elem));\\n                adjustHeaps(first, middle, last);\\n            }\\n            \\n            else if(last.find(elem)!= last.end())\\n            {\\n                last.erase(last.find(elem));                \\n                adjustHeaps(first, middle, last);\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        return q.size() < m ? -1 : sum/middle.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    int count = 0;\\n\\t\\twhile(count < k)\\n\\t\\t{\\n\\t\\t\\tfirst.insert(*middle.begin());\\n\\t\\t\\tmiddle.erase(middle.begin());\\n\\n\\t\\t\\tlast.insert(*middle.rbegin());\\n\\t\\t\\tmiddle.erase(prev(middle.end()));\\n\\t\\t\\tcount++;\\n\\t\\t}\\n```\n```\\nwhile(first.size() < k)\\n{\\n\\tfirst.insert(*middle.begin());\\n\\tmiddle.erase(middle.begin());\\n}\\n\\nwhile(last.size() < k)\\n{\\n\\tlast.insert(*prev(middle.end()));\\n\\tmiddle.erase(prev(middle.end()));\\n}  \\n```\n```\\n        while(*last.begin() < *prev(middle.end()))\\n        {\\n            middle.insert(*last.begin());\\n            last.erase(last.begin());\\n            \\n            last.insert(*prev(middle.end()));\\n            middle.erase(prev(middle.end()));\\n        } \\n\\n        while(*prev(first.end()) > *middle.begin())\\n        {\\n            middle.insert(*prev(first.end()));\\n            first.erase(prev(first.end()));\\n            \\n            first.insert(*middle.begin());\\n            middle.erase(middle.begin());\\n        }\\n```\n```calculateMKAverage```\n```\\nreturn q.size() < m ? -1 : sum/middle.size(); // sum is the running sum of elements in middle multiset.\\n```\n```\\nclass MKAverage {\\n    \\n    private:\\n    void adjustHeaps(multiset<int>& first, multiset<int>& middle, multiset<int>& last)\\n    {\\n        while(first.size() < k)\\n        {\\n            first.insert(*middle.begin());\\n            sum -= *middle.begin();\\n            middle.erase(middle.begin());\\n        }\\n        \\n        while(last.size() < k)\\n        {\\n            last.insert(*prev(middle.end()));\\n            sum -= *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n        }  \\n        \\n        while(*last.begin() < *prev(middle.end()))\\n        {\\n            middle.insert(*last.begin());\\n            sum += *last.begin();\\n            last.erase(last.begin());\\n            \\n            last.insert(*prev(middle.end()));\\n            sum -= *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n        } \\n\\n        while(*prev(first.end()) > *middle.begin())\\n        {\\n            sum += *prev(first.end());\\n            middle.insert(*prev(first.end()));\\n            first.erase(prev(first.end()));\\n            \\n            first.insert(*middle.begin());\\n            sum -= *middle.begin();\\n            middle.erase(middle.begin());\\n        }\\n    }\\npublic:\\n    int m,k;\\n    long long sum = 0;\\n    multiset<int> first, last, middle;\\n    queue<int> q;\\n    \\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n    }\\n    \\n    void addElement(int num) {\\n        if(q.size() < m-1)\\n        {\\n            middle.insert(num);\\n            q.push(num);\\n        }\\n        else if(q.size() == m-1)\\n        {\\n            auto f = middle.begin();\\n            auto l = middle.rbegin();\\n            q.push(num);\\n            middle.insert(num);\\n            int count = 0;\\n            while(count < k)\\n            {\\n                first.insert(*middle.begin());\\n                middle.erase(middle.begin());\\n                \\n                last.insert(*middle.rbegin());\\n                middle.erase(prev(middle.end()));\\n                \\n                count++;\\n            }\\n            for(auto i : middle) sum += i;\\n        }\\n        else\\n        {\\n            q.push(num);\\n            auto elem = q.front();\\n            q.pop();\\n            middle.insert(num);\\n            sum += num;\\n            \\n            if(first.find(elem)!= first.end()){\\n                first.erase(first.find(elem));               \\n                adjustHeaps(first, middle, last);\\n            }\\n            \\n            else if(middle.find(elem) != middle.end())\\n            {\\n                sum -= elem;\\n                middle.erase(middle.find(elem));\\n                adjustHeaps(first, middle, last);\\n            }\\n            \\n            else if(last.find(elem)!= last.end())\\n            {\\n                last.erase(last.find(elem));                \\n                adjustHeaps(first, middle, last);\\n            }\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        return q.size() < m ? -1 : sum/middle.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153255,
                "title": "c-bit-300-ms",
                "content": "I had similar idea just with @ye15. So I posted c++ version here\\n```\\nclass MKAverage {\\npublic:\\n    int m, k;\\n    deque<int> dq;\\n    long sum[100003], cnt[100003];\\n    MKAverage(int m, int k) {\\n        memset(sum, 0, sizeof(sum));\\n        this->m = m, this->k = k;\\n    }\\n    void update(int num, int val) {\\n        int u = val / num;\\n        num += 1;\\n        while (num < 100002) {\\n            cnt[num] += u;\\n            sum[num] += val;\\n            num += num & -num;\\n        }\\n    }\\n    long get(long BIT[],int x) {\\n        long res = 0;\\n        x += 1;\\n        while (x) {\\n            res += BIT[x];\\n            x -= x & -x;\\n        }\\n        return res;\\n    }\\n    void addElement(int num) {\\n        dq.push_back(num);\\n        update(num, num);\\n        if (dq.size() > m) {\\n            update(dq.front(), -dq.front());\\n            dq.pop_front();\\n        }\\n    }\\n    int searchIndex(int kk) { // binary search\\n        int low = 0, high = 1e5 + 1;\\n        while (low < high) {\\n            int mid = high + low >> 1;\\n            if (get(cnt, mid) < kk) low = mid + 1;\\n            else high = mid;\\n        }\\n        return low;\\n    }\\n    int calculateMKAverage() {\\n        if (dq.size() < m)\\n            return -1;\\n        int low = searchIndex(k);\\n        int high = searchIndex(m - k);\\n        long ans = get(sum, high) - get(sum, low);\\n        ans += (get(cnt, low) - k) * low;\\n        ans -= (get(cnt, high) - (m - k)) * high;\\n        return ans / (m - 2 * k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass MKAverage {\\npublic:\\n    int m, k;\\n    deque<int> dq;\\n    long sum[100003], cnt[100003];\\n    MKAverage(int m, int k) {\\n        memset(sum, 0, sizeof(sum));\\n        this->m = m, this->k = k;\\n    }\\n    void update(int num, int val) {\\n        int u = val / num;\\n        num += 1;\\n        while (num < 100002) {\\n            cnt[num] += u;\\n            sum[num] += val;\\n            num += num & -num;\\n        }\\n    }\\n    long get(long BIT[],int x) {\\n        long res = 0;\\n        x += 1;\\n        while (x) {\\n            res += BIT[x];\\n            x -= x & -x;\\n        }\\n        return res;\\n    }\\n    void addElement(int num) {\\n        dq.push_back(num);\\n        update(num, num);\\n        if (dq.size() > m) {\\n            update(dq.front(), -dq.front());\\n            dq.pop_front();\\n        }\\n    }\\n    int searchIndex(int kk) { // binary search\\n        int low = 0, high = 1e5 + 1;\\n        while (low < high) {\\n            int mid = high + low >> 1;\\n            if (get(cnt, mid) < kk) low = mid + 1;\\n            else high = mid;\\n        }\\n        return low;\\n    }\\n    int calculateMKAverage() {\\n        if (dq.size() < m)\\n            return -1;\\n        int low = searchIndex(k);\\n        int high = searchIndex(m - k);\\n        long ans = get(sum, high) - get(sum, low);\\n        ans += (get(cnt, low) - k) * low;\\n        ans -= (get(cnt, high) - (m - k)) * high;\\n        return ans / (m - 2 * k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152801,
                "title": "c-three-multisets",
                "content": "## idea\\n\\n* store the last m elements in three sets: `L, M, R`, the sum of elements in M is `S`\\n\\n* every time we add a new element, besides an insertion operation, we may also need to erase one extra element.\\n\\n* after the insertion and erasion, adjust L, M; adjust M, R\\n\\n\\t(I added an `int adjust(multiset<int> &a, multiset<int> &b, int n)` function to make set `a`\\'s size <= n, and return the difference of sum(a) after the adjustment.)\\n\\t\\n## code\\n```c++\\ntypedef long long ll;\\nclass MKAverage {\\nprivate:\\n    int m, mm, K;\\n    vector<int> A;\\n    multiset<int> L, M, R;\\n    ll S;\\npublic:\\n    MKAverage(int m, int k): m(m), mm(m - 2*k), K(k), S(0) {}\\n\\n    int adjust(multiset<int> &a, multiset<int> &b, int n) {\\n        int diff = 0; // sum(a) diff\\n        if (a.size() < n) {\\n            if (!b.empty()) {\\n                auto it = b.begin();\\n                diff += *it;\\n                a.insert(*it);\\n                b.erase(it);\\n            }\\n        } else if (a.size() > n) {\\n            auto it = a.rbegin();\\n            diff -= *it;\\n            b.insert(*it);\\n            a.erase(prev(a.end()));\\n        }\\n        return diff;\\n    }\\n    \\n    void addElement(int num) {\\n        A.push_back(num);\\n        if (L.empty() || *L.rbegin() >= num) {\\n            L.insert(num);\\n        } else if (M.empty() || *M.rbegin() >= num) {\\n            M.insert(num);\\n            S += num;\\n        } else {\\n            R.insert(num);\\n        }\\n        if (A.size() > m) {\\n            int v = A[A.size() - 1 - m];\\n            if (v <= *L.rbegin()) {\\n                L.erase(L.find(v));\\n            } else if (v <= *M.rbegin()) {\\n                M.erase(M.find(v));\\n                S -= v;\\n            } else {\\n                R.erase(R.find(v));\\n            }\\n        }\\n        S -= adjust(L, M, K);\\n        S += adjust(M, R, mm);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (A.size() < m) return -1;\\n        return S / mm;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\ntypedef long long ll;\\nclass MKAverage {\\nprivate:\\n    int m, mm, K;\\n    vector<int> A;\\n    multiset<int> L, M, R;\\n    ll S;\\npublic:\\n    MKAverage(int m, int k): m(m), mm(m - 2*k), K(k), S(0) {}\\n\\n    int adjust(multiset<int> &a, multiset<int> &b, int n) {\\n        int diff = 0; // sum(a) diff\\n        if (a.size() < n) {\\n            if (!b.empty()) {\\n                auto it = b.begin();\\n                diff += *it;\\n                a.insert(*it);\\n                b.erase(it);\\n            }\\n        } else if (a.size() > n) {\\n            auto it = a.rbegin();\\n            diff -= *it;\\n            b.insert(*it);\\n            a.erase(prev(a.end()));\\n        }\\n        return diff;\\n    }\\n    \\n    void addElement(int num) {\\n        A.push_back(num);\\n        if (L.empty() || *L.rbegin() >= num) {\\n            L.insert(num);\\n        } else if (M.empty() || *M.rbegin() >= num) {\\n            M.insert(num);\\n            S += num;\\n        } else {\\n            R.insert(num);\\n        }\\n        if (A.size() > m) {\\n            int v = A[A.size() - 1 - m];\\n            if (v <= *L.rbegin()) {\\n                L.erase(L.find(v));\\n            } else if (v <= *M.rbegin()) {\\n                M.erase(M.find(v));\\n                S -= v;\\n            } else {\\n                R.erase(R.find(v));\\n            }\\n        }\\n        S -= adjust(L, M, K);\\n        S += adjust(M, R, mm);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (A.size() < m) return -1;\\n        return S / mm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152643,
                "title": "python3-deque-and-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.q = deque()\\n        self.mid = SortedList()\\n        self.total = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        self.mid.add(num)\\n        self.total += num\\n        if len(self.q) > self.m:\\n            x = self.q.popleft()\\n            self.mid.remove(x)\\n            self.total -= x\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n        remove = sum(self.mid[:self.k]) + sum(self.mid[-self.k:])\\n        return int((self.total - remove) / (self.m - self.k * 2))\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.q = deque()\\n        self.mid = SortedList()\\n        self.total = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        self.mid.add(num)\\n        self.total += num\\n        if len(self.q) > self.m:\\n            x = self.q.popleft()\\n            self.mid.remove(x)\\n            self.total -= x\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n        remove = sum(self.mid[:self.k]) + sum(self.mid[-self.k:])\\n        return int((self.total - remove) / (self.m - self.k * 2))\\n",
                "codeTag": "Java"
            },
            {
                "id": 1152558,
                "title": "c-solution-o-m-2-using-list",
                "content": "C# does not have any sorted tree classes that allow duplicate elements. So fast workaround is maintain a sorted List with small optimization for large M.\\n\\nWe maintain sorted list of all nums in current sliding window. To maintain expiration of numbers in sliding window we can use queue.\\nWhen new number arrives we do two actions:\\n1) binarysearch and remove expiring number. Adjust average value. Time is O(logM + M) but usually less\\n2) binarysearch and insert new number. Adjust average value. Time is O(logM + M) but usually less\\n\\nRuntime is ~1.6sec so it barely makes a cut. But its fast and easy implementation if you not comfortable with implementing Trees on your own.\\n\\n```\\npublic class MKAverage {\\n    private Queue<int> window = new Queue<int>();\\n    private List<int> sorted;\\n    private int lowIdx;\\n    private int highIdx;\\n    private int m;\\n    private int k;\\n    private long currSum = 0;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        lowIdx = k;\\n        highIdx = m - k - 1;\\n        sorted = new List<int>(m);\\n    }\\n    \\n    public void AddElement(int num) {\\n        var sCount = sorted.Count;\\n        if (window.Count == m){\\n            var t = window.Dequeue();\\n            var tIdx = sorted.BinarySearch(t);\\n            if (tIdx <= lowIdx){\\n                currSum -= sorted[lowIdx];\\n                currSum += sorted[highIdx + 1];\\n            } else if (tIdx <= highIdx){\\n                currSum -= t;\\n                currSum += sorted[highIdx + 1];                \\n            }\\n\\n            sorted.RemoveAt(tIdx);\\n        }\\n        \\n        \\n        if (sCount < m - 1){\\n\\t\\t    // no need to sort untill M elements are in the window\\n            sorted.Add(num);\\n        } else if (sCount == m - 1){\\n\\t\\t    // when first time hitting M elements in window we sort List from here on we maintain sorted order\\n            sorted.Add(num);\\n            sorted.Sort();\\n            for(var i = lowIdx; i <= highIdx; i++){\\n                currSum += sorted[i];\\n            }\\n        } else{\\n            var numIdx = sorted.BinarySearch(num);\\n            numIdx = numIdx < 0 ? ~numIdx : numIdx;\\n            sorted.Insert(numIdx, num); \\n            if (numIdx <= lowIdx){\\n                currSum -= sorted[highIdx+1];\\n                currSum += sorted[lowIdx];\\n            } else if (numIdx <= highIdx){\\n                currSum -= sorted[highIdx+1];\\n                currSum += num;\\n            }\\n        }\\n        \\n        window.Enqueue(num);\\n        \\n    }\\n    \\n    public int CalculateMKAverage() {\\n        return sorted.Count < m ? -1 : (int)(currSum/(m-k-k));\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MKAverage {\\n    private Queue<int> window = new Queue<int>();\\n    private List<int> sorted;\\n    private int lowIdx;\\n    private int highIdx;\\n    private int m;\\n    private int k;\\n    private long currSum = 0;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        lowIdx = k;\\n        highIdx = m - k - 1;\\n        sorted = new List<int>(m);\\n    }\\n    \\n    public void AddElement(int num) {\\n        var sCount = sorted.Count;\\n        if (window.Count == m){\\n            var t = window.Dequeue();\\n            var tIdx = sorted.BinarySearch(t);\\n            if (tIdx <= lowIdx){\\n                currSum -= sorted[lowIdx];\\n                currSum += sorted[highIdx + 1];\\n            } else if (tIdx <= highIdx){\\n                currSum -= t;\\n                currSum += sorted[highIdx + 1];                \\n            }\\n\\n            sorted.RemoveAt(tIdx);\\n        }\\n        \\n        \\n        if (sCount < m - 1){\\n\\t\\t    // no need to sort untill M elements are in the window\\n            sorted.Add(num);\\n        } else if (sCount == m - 1){\\n\\t\\t    // when first time hitting M elements in window we sort List from here on we maintain sorted order\\n            sorted.Add(num);\\n            sorted.Sort();\\n            for(var i = lowIdx; i <= highIdx; i++){\\n                currSum += sorted[i];\\n            }\\n        } else{\\n            var numIdx = sorted.BinarySearch(num);\\n            numIdx = numIdx < 0 ? ~numIdx : numIdx;\\n            sorted.Insert(numIdx, num); \\n            if (numIdx <= lowIdx){\\n                currSum -= sorted[highIdx+1];\\n                currSum += sorted[lowIdx];\\n            } else if (numIdx <= highIdx){\\n                currSum -= sorted[highIdx+1];\\n                currSum += num;\\n            }\\n        }\\n        \\n        window.Enqueue(num);\\n        \\n    }\\n    \\n    public int CalculateMKAverage() {\\n        return sorted.Count < m ? -1 : (int)(currSum/(m-k-k));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152551,
                "title": "debug-avl-tree-python3-not-a-solution",
                "content": "i did not get it during the contest using the following avl tree structure (which should be more sophisticated than a preorder traversal but i ran out of time), any idea on what went wrong? the avl tree is from geeks4geeks.\\n```\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n        \\n        \\n# AVL tree class which supports insertion,\\n# deletion operations\\nclass AVL_Tree:\\n  \\n    def insert(self, root, key):\\n          \\n        # Step 1 - Perform normal BST\\n        if not root:\\n            return TreeNode(key)\\n        elif key < root.val:\\n            root.left = self.insert(root.left, key)\\n        else:\\n            root.right = self.insert(root.right, key)\\n  \\n        # Step 2 - Update the height of the \\n        # ancestor node\\n        root.height = 1 + max(self.getHeight(root.left),\\n                          self.getHeight(root.right))\\n  \\n        # Step 3 - Get the balance factor\\n        balance = self.getBalance(root)\\n  \\n        # Step 4 - If the node is unbalanced,\\n        # then try out the 4 cases\\n        # Case 1 - Left Left\\n        if balance > 1 and key < root.left.val:\\n            return self.rightRotate(root)\\n  \\n        # Case 2 - Right Right\\n        if balance < -1 and key > root.right.val:\\n            return self.leftRotate(root)\\n  \\n        # Case 3 - Left Right\\n        if balance > 1 and key > root.left.val:\\n            root.left = self.leftRotate(root.left)\\n            return self.rightRotate(root)\\n  \\n        # Case 4 - Right Left\\n        if balance < -1 and key < root.right.val:\\n            root.right = self.rightRotate(root.right)\\n            return self.leftRotate(root)\\n  \\n        return root\\n  \\n    # Recursive function to delete a node with\\n    # given key from subtree with given root.\\n    # It returns root of the modified subtree.\\n    def delete(self, root, key):\\n  \\n        # Step 1 - Perform standard BST delete\\n        if not root:\\n            return root\\n  \\n        elif key < root.val:\\n            root.left = self.delete(root.left, key)\\n  \\n        elif key > root.val:\\n            root.right = self.delete(root.right, key)\\n  \\n        else:\\n            if root.left is None:\\n                temp = root.right\\n                root = None\\n                return temp\\n  \\n            elif root.right is None:\\n                temp = root.left\\n                root = None\\n                return temp\\n  \\n            temp = self.getMinValueNode(root.right)\\n            root.val = temp.val\\n            root.right = self.delete(root.right,\\n                                      temp.val)\\n  \\n        # If the tree has only one node,\\n        # simply return it\\n        if root is None:\\n            return root\\n  \\n        # Step 2 - Update the height of the \\n        # ancestor node\\n        root.height = 1 + max(self.getHeight(root.left),\\n                            self.getHeight(root.right))\\n  \\n        # Step 3 - Get the balance factor\\n        balance = self.getBalance(root)\\n  \\n        # Step 4 - If the node is unbalanced, \\n        # then try out the 4 cases\\n        # Case 1 - Left Left\\n        if balance > 1 and self.getBalance(root.left) >= 0:\\n            return self.rightRotate(root)\\n  \\n        # Case 2 - Right Right\\n        if balance < -1 and self.getBalance(root.right) <= 0:\\n            return self.leftRotate(root)\\n  \\n        # Case 3 - Left Right\\n        if balance > 1 and self.getBalance(root.left) < 0:\\n            root.left = self.leftRotate(root.left)\\n            return self.rightRotate(root)\\n  \\n        # Case 4 - Right Left\\n        if balance < -1 and self.getBalance(root.right) > 0:\\n            root.right = self.rightRotate(root.right)\\n            return self.leftRotate(root)\\n  \\n        return root\\n  \\n    def leftRotate(self, z):\\n  \\n        y = z.right\\n        T2 = y.left\\n  \\n        # Perform rotation\\n        y.left = z\\n        z.right = T2\\n  \\n        # Update heights\\n        z.height = 1 + max(self.getHeight(z.left), \\n                         self.getHeight(z.right))\\n        y.height = 1 + max(self.getHeight(y.left), \\n                         self.getHeight(y.right))\\n  \\n        # Return the new root\\n        return y\\n  \\n    def rightRotate(self, z):\\n  \\n        y = z.left\\n        T3 = y.right\\n  \\n        # Perform rotation\\n        y.right = z\\n        z.left = T3\\n  \\n        # Update heights\\n        z.height = 1 + max(self.getHeight(z.left),\\n                          self.getHeight(z.right))\\n        y.height = 1 + max(self.getHeight(y.left),\\n                          self.getHeight(y.right))\\n  \\n        # Return the new root\\n        return y\\n  \\n    def getHeight(self, root):\\n        if not root:\\n            return 0\\n  \\n        return root.height\\n  \\n    def getBalance(self, root):\\n        if not root:\\n            return 0\\n  \\n        return self.getHeight(root.left) - self.getHeight(root.right)\\n  \\n    def getMinValueNode(self, root):\\n        if root is None or root.left is None:\\n            return root\\n  \\n        return self.getMinValueNode(root.left)\\n  \\n    def preOrder(self, root):\\n        if not root:\\n            return []\\n        ans=[]\\n        ans.extend(self.preOrder(root.left))\\n        ans.append(root.val)\\n        \\n        ans.extend(self.preOrder(root.right))\\n        return ans\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.stream=[]\\n        self.tree=AVL_Tree()\\n        self.root=None\\n        self.m=m\\n        self.k=k\\n\\n    def addElement(self, num: int) -> None:\\n        \\n        #maintain tree\\n        self.root=self.tree.insert(self.root,num)\\n        if len(self.stream)>self.m:\\n            self.root=self.tree.delete(self.root,self.stream[-self.m])\\n                \\n        #maintain stream\\n        self.stream.append(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.stream)<self.m:\\n            return -1\\n        orderlist=self.tree.preOrder(self.root)\\n        sellist=orderlist[self.k:-self.k]\\n        return int(sum(sellist)/len(sellist))\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```\\n![image](https://assets.leetcode.com/users/images/f5cfcb29-83b4-4708-8254-9dc0bd479e7c_1618114497.6006398.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n        \\n        \\n# AVL tree class which supports insertion,\\n# deletion operations\\nclass AVL_Tree:\\n  \\n    def insert(self, root, key):\\n          \\n        # Step 1 - Perform normal BST\\n        if not root:\\n            return TreeNode(key)\\n        elif key < root.val:\\n            root.left = self.insert(root.left, key)\\n        else:\\n            root.right = self.insert(root.right, key)\\n  \\n        # Step 2 - Update the height of the \\n        # ancestor node\\n        root.height = 1 + max(self.getHeight(root.left),\\n                          self.getHeight(root.right))\\n  \\n        # Step 3 - Get the balance factor\\n        balance = self.getBalance(root)\\n  \\n        # Step 4 - If the node is unbalanced,\\n        # then try out the 4 cases\\n        # Case 1 - Left Left\\n        if balance > 1 and key < root.left.val:\\n            return self.rightRotate(root)\\n  \\n        # Case 2 - Right Right\\n        if balance < -1 and key > root.right.val:\\n            return self.leftRotate(root)\\n  \\n        # Case 3 - Left Right\\n        if balance > 1 and key > root.left.val:\\n            root.left = self.leftRotate(root.left)\\n            return self.rightRotate(root)\\n  \\n        # Case 4 - Right Left\\n        if balance < -1 and key < root.right.val:\\n            root.right = self.rightRotate(root.right)\\n            return self.leftRotate(root)\\n  \\n        return root\\n  \\n    # Recursive function to delete a node with\\n    # given key from subtree with given root.\\n    # It returns root of the modified subtree.\\n    def delete(self, root, key):\\n  \\n        # Step 1 - Perform standard BST delete\\n        if not root:\\n            return root\\n  \\n        elif key < root.val:\\n            root.left = self.delete(root.left, key)\\n  \\n        elif key > root.val:\\n            root.right = self.delete(root.right, key)\\n  \\n        else:\\n            if root.left is None:\\n                temp = root.right\\n                root = None\\n                return temp\\n  \\n            elif root.right is None:\\n                temp = root.left\\n                root = None\\n                return temp\\n  \\n            temp = self.getMinValueNode(root.right)\\n            root.val = temp.val\\n            root.right = self.delete(root.right,\\n                                      temp.val)\\n  \\n        # If the tree has only one node,\\n        # simply return it\\n        if root is None:\\n            return root\\n  \\n        # Step 2 - Update the height of the \\n        # ancestor node\\n        root.height = 1 + max(self.getHeight(root.left),\\n                            self.getHeight(root.right))\\n  \\n        # Step 3 - Get the balance factor\\n        balance = self.getBalance(root)\\n  \\n        # Step 4 - If the node is unbalanced, \\n        # then try out the 4 cases\\n        # Case 1 - Left Left\\n        if balance > 1 and self.getBalance(root.left) >= 0:\\n            return self.rightRotate(root)\\n  \\n        # Case 2 - Right Right\\n        if balance < -1 and self.getBalance(root.right) <= 0:\\n            return self.leftRotate(root)\\n  \\n        # Case 3 - Left Right\\n        if balance > 1 and self.getBalance(root.left) < 0:\\n            root.left = self.leftRotate(root.left)\\n            return self.rightRotate(root)\\n  \\n        # Case 4 - Right Left\\n        if balance < -1 and self.getBalance(root.right) > 0:\\n            root.right = self.rightRotate(root.right)\\n            return self.leftRotate(root)\\n  \\n        return root\\n  \\n    def leftRotate(self, z):\\n  \\n        y = z.right\\n        T2 = y.left\\n  \\n        # Perform rotation\\n        y.left = z\\n        z.right = T2\\n  \\n        # Update heights\\n        z.height = 1 + max(self.getHeight(z.left), \\n                         self.getHeight(z.right))\\n        y.height = 1 + max(self.getHeight(y.left), \\n                         self.getHeight(y.right))\\n  \\n        # Return the new root\\n        return y\\n  \\n    def rightRotate(self, z):\\n  \\n        y = z.left\\n        T3 = y.right\\n  \\n        # Perform rotation\\n        y.right = z\\n        z.left = T3\\n  \\n        # Update heights\\n        z.height = 1 + max(self.getHeight(z.left),\\n                          self.getHeight(z.right))\\n        y.height = 1 + max(self.getHeight(y.left),\\n                          self.getHeight(y.right))\\n  \\n        # Return the new root\\n        return y\\n  \\n    def getHeight(self, root):\\n        if not root:\\n            return 0\\n  \\n        return root.height\\n  \\n    def getBalance(self, root):\\n        if not root:\\n            return 0\\n  \\n        return self.getHeight(root.left) - self.getHeight(root.right)\\n  \\n    def getMinValueNode(self, root):\\n        if root is None or root.left is None:\\n            return root\\n  \\n        return self.getMinValueNode(root.left)\\n  \\n    def preOrder(self, root):\\n        if not root:\\n            return []\\n        ans=[]\\n        ans.extend(self.preOrder(root.left))\\n        ans.append(root.val)\\n        \\n        ans.extend(self.preOrder(root.right))\\n        return ans\\n\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.stream=[]\\n        self.tree=AVL_Tree()\\n        self.root=None\\n        self.m=m\\n        self.k=k\\n\\n    def addElement(self, num: int) -> None:\\n        \\n        #maintain tree\\n        self.root=self.tree.insert(self.root,num)\\n        if len(self.stream)>self.m:\\n            self.root=self.tree.delete(self.root,self.stream[-self.m])\\n                \\n        #maintain stream\\n        self.stream.append(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.stream)<self.m:\\n            return -1\\n        orderlist=self.tree.preOrder(self.root)\\n        sellist=orderlist[self.k:-self.k]\\n        return int(sum(sellist)/len(sellist))\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079740,
                "title": "python-sortedlist-incremental-sum-upd",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m=m\\n        self.k=k\\n        self.sl=SortedList()\\n        self.xs=deque()\\n        self.s=-1\\n    def addElement(self, num: int) -> None:\\n        if len(self.xs)>=self.m:\\n            st,en=self.k,(len(self.sl)-self.k)-1\\n            l,r=self.sl[st],self.sl[en]\\n            if self.s!=-1:\\n                if self.xs[0]>=l and self.xs[0]<=r:self.s-=self.xs[0]\\n                elif self.xs[0]<l:self.s-=self.sl[st]\\n                else:self.s-=self.sl[en]\\n            self.sl.remove(self.xs[0])\\n            self.xs.popleft()\\n            self.sl.add(num)\\n            self.xs.append(num)\\n            l,r=self.sl[st],self.sl[en]\\n            if self.s!=-1:\\n                if num>=l and num<=r:self.s+=num\\n                elif num<l:self.s+=self.sl[st]\\n                else:self.s+=self.sl[en]\\n        else:\\n            self.xs.append(num)\\n            self.sl.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl)<self.m:return -1\\n        st,en=self.k,len(self.sl)-self.k\\n        if self.s==-1:\\n            self.s=0\\n            for i in range(st,en):self.s+=self.sl[i]\\n        return self.s//abs(en-st)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m=m\\n        self.k=k\\n        self.sl=SortedList()\\n        self.xs=deque()\\n        self.s=-1\\n    def addElement(self, num: int) -> None:\\n        if len(self.xs)>=self.m:\\n            st,en=self.k,(len(self.sl)-self.k)-1\\n            l,r=self.sl[st],self.sl[en]\\n            if self.s!=-1:\\n                if self.xs[0]>=l and self.xs[0]<=r:self.s-=self.xs[0]\\n                elif self.xs[0]<l:self.s-=self.sl[st]\\n                else:self.s-=self.sl[en]\\n            self.sl.remove(self.xs[0])\\n            self.xs.popleft()\\n            self.sl.add(num)\\n            self.xs.append(num)\\n            l,r=self.sl[st],self.sl[en]\\n            if self.s!=-1:\\n                if num>=l and num<=r:self.s+=num\\n                elif num<l:self.s+=self.sl[st]\\n                else:self.s+=self.sl[en]\\n        else:\\n            self.xs.append(num)\\n            self.sl.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sl)<self.m:return -1\\n        st,en=self.k,len(self.sl)-self.k\\n        if self.s==-1:\\n            self.s=0\\n            for i in range(st,en):self.s+=self.sl[i]\\n        return self.s//abs(en-st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047962,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MKAverage {\\n public:\\n  MKAverage(int m, int k) : m(m), k(k) {}\\n\\n  void addElement(int num) {\\n    q.push(num);\\n    add(mid, num);\\n    midSum += num;\\n\\n    if (q.size() > m) {\\n      const int removed = q.front();\\n      q.pop();\\n      if (top.count(removed)) {\\n        remove(top, removed);\\n        --topSize;\\n      } else if (mid.count(removed)) {\\n        remove(mid, removed);\\n        midSum -= removed;\\n      } else {\\n        remove(bot, removed);\\n        --botSize;\\n      }\\n    }\\n\\n    // Move item(s) from mid to top to fill k slots\\n    while (!mid.empty() && topSize < k) {\\n      midSum -= mid.rbegin()->first;\\n      add(top, remove(mid, mid.rbegin()->first));\\n      ++topSize;\\n    }\\n\\n    // Rebalance mid and top\\n    while (!mid.empty() && mid.rbegin()->first > top.begin()->first) {\\n      midSum -= mid.rbegin()->first;\\n      midSum += top.begin()->first;\\n      add(top, remove(mid, mid.rbegin()->first));\\n      add(mid, remove(top, top.begin()->first));\\n    }\\n\\n    // Move item(s) from mid to bot to fill k slots\\n    while (!mid.empty() && botSize < k) {\\n      midSum -= mid.begin()->first;\\n      add(bot, remove(mid, mid.begin()->first));\\n      ++botSize;\\n    }\\n\\n    // Move item(s) from mid to bot to fill k slots\\n    while (!mid.empty() && mid.begin()->first < bot.rbegin()->first) {\\n      midSum -= mid.begin()->first;\\n      midSum += bot.rbegin()->first;\\n      add(bot, remove(mid, mid.begin()->first));\\n      add(mid, remove(bot, bot.rbegin()->first));\\n    }\\n  }\\n\\n  int calculateMKAverage() {\\n    return q.size() == m ? midSum / (m - 2 * k) : -1;\\n  }\\n\\n private:\\n  const int m;\\n  const int k;\\n  queue<int> q;\\n  map<int, int> top;\\n  map<int, int> mid;\\n  map<int, int> bot;\\n  int topSize = 0;\\n  int botSize = 0;\\n  long midSum = 0;\\n\\n  void add(map<int, int>& map, int num) {\\n    ++map[num];\\n  }\\n\\n  int remove(map<int, int>& map, int num) {\\n    if (--map[num] == 0)\\n      map.erase(num);\\n    return num;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MKAverage {\\n public:\\n  MKAverage(int m, int k) : m(m), k(k) {}\\n\\n  void addElement(int num) {\\n    q.push(num);\\n    add(mid, num);\\n    midSum += num;\\n\\n    if (q.size() > m) {\\n      const int removed = q.front();\\n      q.pop();\\n      if (top.count(removed)) {\\n        remove(top, removed);\\n        --topSize;\\n      } else if (mid.count(removed)) {\\n        remove(mid, removed);\\n        midSum -= removed;\\n      } else {\\n        remove(bot, removed);\\n        --botSize;\\n      }\\n    }\\n\\n    // Move item(s) from mid to top to fill k slots\\n    while (!mid.empty() && topSize < k) {\\n      midSum -= mid.rbegin()->first;\\n      add(top, remove(mid, mid.rbegin()->first));\\n      ++topSize;\\n    }\\n\\n    // Rebalance mid and top\\n    while (!mid.empty() && mid.rbegin()->first > top.begin()->first) {\\n      midSum -= mid.rbegin()->first;\\n      midSum += top.begin()->first;\\n      add(top, remove(mid, mid.rbegin()->first));\\n      add(mid, remove(top, top.begin()->first));\\n    }\\n\\n    // Move item(s) from mid to bot to fill k slots\\n    while (!mid.empty() && botSize < k) {\\n      midSum -= mid.begin()->first;\\n      add(bot, remove(mid, mid.begin()->first));\\n      ++botSize;\\n    }\\n\\n    // Move item(s) from mid to bot to fill k slots\\n    while (!mid.empty() && mid.begin()->first < bot.rbegin()->first) {\\n      midSum -= mid.begin()->first;\\n      midSum += bot.rbegin()->first;\\n      add(bot, remove(mid, mid.begin()->first));\\n      add(mid, remove(bot, bot.rbegin()->first));\\n    }\\n  }\\n\\n  int calculateMKAverage() {\\n    return q.size() == m ? midSum / (m - 2 * k) : -1;\\n  }\\n\\n private:\\n  const int m;\\n  const int k;\\n  queue<int> q;\\n  map<int, int> top;\\n  map<int, int> mid;\\n  map<int, int> bot;\\n  int topSize = 0;\\n  int botSize = 0;\\n  long midSum = 0;\\n\\n  void add(map<int, int>& map, int num) {\\n    ++map[num];\\n  }\\n\\n  int remove(map<int, int>& map, int num) {\\n    if (--map[num] == 0)\\n      map.erase(num);\\n    return num;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037839,
                "title": "python3-sortedlist-deque-o-1-and-o-log-n",
                "content": "# Intuition\\nUse a queue to store the incoming elements, so we always know which one is the oldest\\nKeep 3 sorted lists, one for the leftmost $$k$$ elements, one for the central part (which is used to calculate the average) and one for the rightmost $$k$$ elements.\\n\\nIf you don\\'t have enough elements ($$length < m$$), then just keep the elements in the queue and when we first reach $$m$$ elements, initialize the sorted lists.\\n\\n# Approach\\n\\nMaintain the order invariance at every operation. The left array must have $$k$$ elements, the central array must have $$m-2*k$$ elements, the right array must have $$k$$ elements.\\n\\n# Complexity\\n- Time complexity:\\n**calculateMKAverage**: $$O(1)$$\\n**addElement**: $$O(log(M))$$, but because of the initialization it is $$O(M*log(M))$$ overall in the worst case. The initialization can easily be removed masking it $$O(log(M))$$, but the `_insert_element` method needs to be adjusted.\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.center_len = m - 2 * k\\n        self.q = deque([])\\n        self.left = SortedList()\\n        self.right = SortedList()\\n        self.center = SortedList()\\n        self.center_sum = 0\\n\\n    def _initialize_sorted_lists(self):\\n        sorted_elements = sorted(self.q)\\n        index = 0\\n        for num in sorted_elements:\\n            if index < self.k:\\n                self.left.add(num)\\n            elif index >= self.k and index < len(sorted_elements) - self.k:\\n                self.center.add(num)\\n                self.center_sum += num\\n            else:\\n                self.right.add(num)\\n            index += 1\\n\\n    def _remove_element(self, num: int) -> None:\\n        # Remove the element from the first box you can find it in, startig from left\\n        if num in self.left:\\n            self.left.remove(num)\\n        elif num in self.center:\\n            self.center.remove(num)\\n            self.center_sum -= num\\n        elif num in self.right:\\n            self.right.remove(num)\\n        else:\\n            raise Exception(f\\'{num} not found in any of the sorted lists\\')\\n\\n    def _insert_element(self, num: int) -> None:\\n        # Insert the element in the right \"box\" (left, center, right) while maintaining the order\\n        if (len(self.center) > 0 and num <= self.center[0]) or (len(self.left) > 0 and num <= self.left[-1]):\\n            self.left.add(num)\\n        elif (len(self.right) > 0 and num <= self.right[0]) or (len(self.center) > 0 and num <= self.center[-1]):\\n            self.center.add(num)\\n            self.center_sum += num\\n        else:\\n            self.right.add(num)\\n        \\n        # Case 1: the center is too big, move one element to either left or right\\n        if len(self.center) > self.center_len:\\n            assert len(self.left) < self.k or len(self.right) < self.k\\n            if len(self.left) < self.k:\\n                to_move = self.center.pop(0)\\n                self.center_sum -= to_move\\n                self.left.add(to_move)\\n            elif len(self.right) < self.k:\\n                to_move = self.center.pop(-1)\\n                self.center_sum -= to_move\\n                self.right.add(to_move)\\n        # Case 2: the center is too small, move one element from left or right to center\\n        elif len(self.center) < self.center_len:\\n            assert len(self.left) > self.k or len(self.right) > self.k\\n            if len(self.left) > self.k:\\n                to_move = self.left.pop(-1)\\n                self.center.add(to_move)\\n                self.center_sum += to_move\\n            elif len(self.right) > self.k:\\n                to_move = self.right.pop(0)\\n                self.center.add(to_move)\\n                self.center_sum += to_move\\n        # Case 3: the center is OK, but left is too small and right is too big\\n        elif len(self.left) < self.k:\\n            assert len(self.center) == self.center_len and len(self.right) > self.k\\n            # Move from right to center and from center to left\\n            to_move1 = self.right.pop(0)\\n            self.center.add(to_move1)\\n            self.center_sum += to_move1\\n            to_move2 = self.center.pop(0)\\n            self.center_sum -= to_move2\\n            self.left.add(to_move2)\\n        # Case 4: the center is OK, but right is too small, and left is too big\\n        elif len(self.right) < self.k:\\n            assert len(self.center) == self.center_len and len(self.left) > self.k\\n            # Move from left to center and from center to right\\n            to_move1 = self.left.pop(-1)\\n            self.center.add(to_move1)\\n            self.center_sum += to_move1\\n            to_move2 = self.center.pop(-1)\\n            self.center_sum -= to_move2\\n            self.right.add(to_move2)\\n        \\n        assert len(self.left) == self.k and len(self.right) == self.k and len(self.center) == self.center_len\\n\\n            \\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        if len(self.q) == self.m:\\n            # This will be called only once, when we first reach \"m\" elements\\n            self._initialize_sorted_lists()\\n        if len(self.q) > self.m:\\n            to_remove = self.q.popleft()\\n            self._remove_element(to_remove)\\n            self._insert_element(num)\\n\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n        return self.center_sum // self.center_len\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.center_len = m - 2 * k\\n        self.q = deque([])\\n        self.left = SortedList()\\n        self.right = SortedList()\\n        self.center = SortedList()\\n        self.center_sum = 0\\n\\n    def _initialize_sorted_lists(self):\\n        sorted_elements = sorted(self.q)\\n        index = 0\\n        for num in sorted_elements:\\n            if index < self.k:\\n                self.left.add(num)\\n            elif index >= self.k and index < len(sorted_elements) - self.k:\\n                self.center.add(num)\\n                self.center_sum += num\\n            else:\\n                self.right.add(num)\\n            index += 1\\n\\n    def _remove_element(self, num: int) -> None:\\n        # Remove the element from the first box you can find it in, startig from left\\n        if num in self.left:\\n            self.left.remove(num)\\n        elif num in self.center:\\n            self.center.remove(num)\\n            self.center_sum -= num\\n        elif num in self.right:\\n            self.right.remove(num)\\n        else:\\n            raise Exception(f\\'{num} not found in any of the sorted lists\\')\\n\\n    def _insert_element(self, num: int) -> None:\\n        # Insert the element in the right \"box\" (left, center, right) while maintaining the order\\n        if (len(self.center) > 0 and num <= self.center[0]) or (len(self.left) > 0 and num <= self.left[-1]):\\n            self.left.add(num)\\n        elif (len(self.right) > 0 and num <= self.right[0]) or (len(self.center) > 0 and num <= self.center[-1]):\\n            self.center.add(num)\\n            self.center_sum += num\\n        else:\\n            self.right.add(num)\\n        \\n        # Case 1: the center is too big, move one element to either left or right\\n        if len(self.center) > self.center_len:\\n            assert len(self.left) < self.k or len(self.right) < self.k\\n            if len(self.left) < self.k:\\n                to_move = self.center.pop(0)\\n                self.center_sum -= to_move\\n                self.left.add(to_move)\\n            elif len(self.right) < self.k:\\n                to_move = self.center.pop(-1)\\n                self.center_sum -= to_move\\n                self.right.add(to_move)\\n        # Case 2: the center is too small, move one element from left or right to center\\n        elif len(self.center) < self.center_len:\\n            assert len(self.left) > self.k or len(self.right) > self.k\\n            if len(self.left) > self.k:\\n                to_move = self.left.pop(-1)\\n                self.center.add(to_move)\\n                self.center_sum += to_move\\n            elif len(self.right) > self.k:\\n                to_move = self.right.pop(0)\\n                self.center.add(to_move)\\n                self.center_sum += to_move\\n        # Case 3: the center is OK, but left is too small and right is too big\\n        elif len(self.left) < self.k:\\n            assert len(self.center) == self.center_len and len(self.right) > self.k\\n            # Move from right to center and from center to left\\n            to_move1 = self.right.pop(0)\\n            self.center.add(to_move1)\\n            self.center_sum += to_move1\\n            to_move2 = self.center.pop(0)\\n            self.center_sum -= to_move2\\n            self.left.add(to_move2)\\n        # Case 4: the center is OK, but right is too small, and left is too big\\n        elif len(self.right) < self.k:\\n            assert len(self.center) == self.center_len and len(self.left) > self.k\\n            # Move from left to center and from center to right\\n            to_move1 = self.left.pop(-1)\\n            self.center.add(to_move1)\\n            self.center_sum += to_move1\\n            to_move2 = self.center.pop(-1)\\n            self.center_sum -= to_move2\\n            self.right.add(to_move2)\\n        \\n        assert len(self.left) == self.k and len(self.right) == self.k and len(self.center) == self.center_len\\n\\n            \\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        if len(self.q) == self.m:\\n            # This will be called only once, when we first reach \"m\" elements\\n            self._initialize_sorted_lists()\\n        if len(self.q) > self.m:\\n            to_remove = self.q.popleft()\\n            self._remove_element(to_remove)\\n            self._insert_element(num)\\n\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n        return self.center_sum // self.center_len\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992429,
                "title": "my-intuitive-c-solution-to-solve-most-of-streaming-data-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you have solved other streaming data related problem. You can build this solution based on the solution of other similar problems. One such problem is median in a streaming data. \\n\\n# Approach\\nFor this you have to keep in mind few things : \\n\\n1. Queue maintaining order of inputs, so that when the size of queue is m, you can easily remove the stale value.\\n2. Maintain three multiset to track the lowest K, top K and mid elements.\\n3. Balance the sizes of each multiset at every insertion.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MKAverage {\\n    int total;\\n    int m;\\n    int k;\\n    queue<int> recentData;\\n    multiset<int, greater<int>> smallestK;\\n    multiset<int> greatestK;\\n    multiset<int> midElements;\\n    long midSum;\\npublic:\\n    MKAverage(int m, int k) {\\n        total = 0;\\n        this->m = m;\\n        this->k = k;\\n        midSum = 0;\\n    }\\n\\n    //   1. < k elements;\\n    //   2. > k & < 2k elements;\\n    //   3. > 2k & < m elements;\\n    //   4. > m elements;\\n    void addElement(int num) {\\n        // If we have already m data in queue then remove the stale data\\n        if(total == m) {\\n            int stale = recentData.front();\\n\\n            recentData.pop();\\n            recentData.push(num);\\n\\n            // Remove the stale value from the appropriate set containing the value\\n            if(greatestK.find(stale) != greatestK.end()) {\\n                greatestK.erase(greatestK.find(stale));\\n            }\\n            else if(smallestK.find(stale) != smallestK.end()) {\\n                smallestK.erase(smallestK.find(stale));\\n            }\\n            else {\\n                // If the value in middle set, update midSum\\n                midElements.erase(midElements.find(stale));\\n                midSum -= stale;\\n            }\\n            total--;\\n        }\\n        else {\\n            recentData.push(num);\\n        }\\n\\n\\n        if(total < k) {\\n            greatestK.insert(num);\\n        }\\n        else if(total < 2*k) {\\n            greatestK.insert(num);\\n            int smaller = *greatestK.begin();\\n            smallestK.insert(smaller);\\n            greatestK.erase(greatestK.begin());\\n        }\\n        else if(total < m) {\\n            // Insert from Greater to Smaller\\n            greatestK.insert(num);\\n            int smaller = *greatestK.begin();\\n            greatestK.erase(greatestK.begin());\\n            midElements.insert(smaller);\\n\\n            // Add smaller value of top k to midSum\\n            midSum += smaller;\\n            smaller = *midElements.begin();\\n            midElements.erase(midElements.begin());\\n            // Remove the smaller value of mid elements to midSum\\n            midSum -= smaller;\\n            smallestK.insert(smaller);\\n\\n            // Now Balance the size\\n            if(smallestK.size() > k) {\\n                int greater = *smallestK.begin();\\n                smallestK.erase(smallestK.begin());\\n\\n                midElements.insert(greater);\\n                midSum += greater;\\n\\n                if(midElements.size() > m - 2*k) {\\n                    auto ptr = midElements.end();\\n                    greater = *(--ptr);\\n                    midElements.erase(ptr);\\n                    midSum -= greater;\\n                    greatestK.insert(greater);\\n                }\\n            }\\n        }\\n\\n        total++;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(total < m) {\\n            return -1;\\n        }\\n        else {\\n            return midSum/(m-2*k);\\n        }\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Data Stream",
                    "Ordered Set"
                ],
                "code": "```\\nclass MKAverage {\\n    int total;\\n    int m;\\n    int k;\\n    queue<int> recentData;\\n    multiset<int, greater<int>> smallestK;\\n    multiset<int> greatestK;\\n    multiset<int> midElements;\\n    long midSum;\\npublic:\\n    MKAverage(int m, int k) {\\n        total = 0;\\n        this->m = m;\\n        this->k = k;\\n        midSum = 0;\\n    }\\n\\n    //   1. < k elements;\\n    //   2. > k & < 2k elements;\\n    //   3. > 2k & < m elements;\\n    //   4. > m elements;\\n    void addElement(int num) {\\n        // If we have already m data in queue then remove the stale data\\n        if(total == m) {\\n            int stale = recentData.front();\\n\\n            recentData.pop();\\n            recentData.push(num);\\n\\n            // Remove the stale value from the appropriate set containing the value\\n            if(greatestK.find(stale) != greatestK.end()) {\\n                greatestK.erase(greatestK.find(stale));\\n            }\\n            else if(smallestK.find(stale) != smallestK.end()) {\\n                smallestK.erase(smallestK.find(stale));\\n            }\\n            else {\\n                // If the value in middle set, update midSum\\n                midElements.erase(midElements.find(stale));\\n                midSum -= stale;\\n            }\\n            total--;\\n        }\\n        else {\\n            recentData.push(num);\\n        }\\n\\n\\n        if(total < k) {\\n            greatestK.insert(num);\\n        }\\n        else if(total < 2*k) {\\n            greatestK.insert(num);\\n            int smaller = *greatestK.begin();\\n            smallestK.insert(smaller);\\n            greatestK.erase(greatestK.begin());\\n        }\\n        else if(total < m) {\\n            // Insert from Greater to Smaller\\n            greatestK.insert(num);\\n            int smaller = *greatestK.begin();\\n            greatestK.erase(greatestK.begin());\\n            midElements.insert(smaller);\\n\\n            // Add smaller value of top k to midSum\\n            midSum += smaller;\\n            smaller = *midElements.begin();\\n            midElements.erase(midElements.begin());\\n            // Remove the smaller value of mid elements to midSum\\n            midSum -= smaller;\\n            smallestK.insert(smaller);\\n\\n            // Now Balance the size\\n            if(smallestK.size() > k) {\\n                int greater = *smallestK.begin();\\n                smallestK.erase(smallestK.begin());\\n\\n                midElements.insert(greater);\\n                midSum += greater;\\n\\n                if(midElements.size() > m - 2*k) {\\n                    auto ptr = midElements.end();\\n                    greater = *(--ptr);\\n                    midElements.erase(ptr);\\n                    midSum -= greater;\\n                    greatestK.insert(greater);\\n                }\\n            }\\n        }\\n\\n        total++;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(total < m) {\\n            return -1;\\n        }\\n        else {\\n            return midSum/(m-2*k);\\n        }\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961557,
                "title": "python-sortedlist",
                "content": "The idea is simple: Keep track of the k smallest numbers, the k greatest numbers and the rest in the array `mid`.\\nIf you add a number, check to which of these 3 arrays it should belong and add it.\\nIf any of these arrays become too big (e.g. the array which tracks the k smallest numbers has more than k items), then rebalance the arrays.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.nums = deque()\\n        self.m = m\\n        self.k = k\\n        self.mid_target_size = m-2*k\\n        self.bottom_k = SortedList()\\n        self.top_k = SortedList()\\n        self.mid = SortedList()\\n        self.mid_sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if not self.bottom_k or self.bottom_k[-1] >= num:\\n            self.bottom_k.add(num)\\n        elif not self.mid or num <= self.mid[-1]:\\n            self.mid.add(num)\\n            self.mid_sum += num\\n        else:\\n            self.top_k.add(num)\\n            \\n        self.nums.append(num)\\n        if len(self.nums) > self.m:\\n            to_remove = self.nums.popleft()\\n            if self.bottom_k.count(to_remove) > 0:\\n                self.bottom_k.remove(to_remove)\\n            elif self.top_k.count(to_remove) > 0:\\n                self.top_k.remove(to_remove)\\n            else:\\n                self.mid.remove(to_remove)\\n                self.mid_sum -= to_remove\\n                \\n        if len(self.bottom_k) > self.k:\\n            popped = self.bottom_k.pop()\\n            self.mid.add(popped)\\n            self.mid_sum += popped\\n        elif len(self.top_k) > self.k:\\n            popped = self.top_k.pop(0)\\n            self.mid.add(popped)\\n            self.mid_sum += popped\\n        \\n        if len(self.mid) > self.mid_target_size:\\n            if len(self.bottom_k) < self.k:\\n                popped = self.mid.pop(0)\\n                self.bottom_k.add(popped)\\n                self.mid_sum -= popped\\n            else:\\n                popped = self.mid.pop()\\n                self.top_k.add(popped)\\n                self.mid_sum -= popped\\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.nums) < self.m:\\n            return -1\\n        return self.mid_sum // self.mid_target_size\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.nums = deque()\\n        self.m = m\\n        self.k = k\\n        self.mid_target_size = m-2*k\\n        self.bottom_k = SortedList()\\n        self.top_k = SortedList()\\n        self.mid = SortedList()\\n        self.mid_sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if not self.bottom_k or self.bottom_k[-1] >= num:\\n            self.bottom_k.add(num)\\n        elif not self.mid or num <= self.mid[-1]:\\n            self.mid.add(num)\\n            self.mid_sum += num\\n        else:\\n            self.top_k.add(num)\\n            \\n        self.nums.append(num)\\n        if len(self.nums) > self.m:\\n            to_remove = self.nums.popleft()\\n            if self.bottom_k.count(to_remove) > 0:\\n                self.bottom_k.remove(to_remove)\\n            elif self.top_k.count(to_remove) > 0:\\n                self.top_k.remove(to_remove)\\n            else:\\n                self.mid.remove(to_remove)\\n                self.mid_sum -= to_remove\\n                \\n        if len(self.bottom_k) > self.k:\\n            popped = self.bottom_k.pop()\\n            self.mid.add(popped)\\n            self.mid_sum += popped\\n        elif len(self.top_k) > self.k:\\n            popped = self.top_k.pop(0)\\n            self.mid.add(popped)\\n            self.mid_sum += popped\\n        \\n        if len(self.mid) > self.mid_target_size:\\n            if len(self.bottom_k) < self.k:\\n                popped = self.mid.pop(0)\\n                self.bottom_k.add(popped)\\n                self.mid_sum -= popped\\n            else:\\n                popped = self.mid.pop()\\n                self.top_k.add(popped)\\n                self.mid_sum -= popped\\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.nums) < self.m:\\n            return -1\\n        return self.mid_sum // self.mid_target_size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925362,
                "title": "o-logn-addelement-o-1-calculatemkaverage-python-sortedlist",
                "content": "The idea is to keep a sorted list of the most recent m elements. the first k elements and last k elements are the k smallest and k largest elements, respectively. Another twist is instead of calculating the sum every time we got an update, we keep a running sum on the two ends of the list (k largest and k smallest) and the sum of the list itself. To keep track of which element to be popped next when we have more than m elements in the list, we keep a separate queue to track the order.\\n# Time Complexity:\\n- `addElement`: $$O(log(n))$$\\n- `calculateMKAverage`: $$O(1)$$\\n# Code\\n```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m,k\\n        self.ss = SortedList()\\n        self.running_smallest, self.running_largest = 0, 0\\n        self.deck = deque()\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.ss) == 2*self.k: \\n            self.running_smallest, self.running_largest = sum(self.ss[:self.k]), sum(self.ss[-self.k:])\\n        if len(self.ss) >= self.m:\\n            rm = self.deck.popleft()\\n            i = self.ss.bisect_left(rm)\\n            if i < self.k: \\n                self.running_smallest -= rm\\n                self.running_smallest += self.ss[self.k]\\n            elif i>=len(self.ss)-self.k: \\n                self.running_largest -= rm\\n                self.running_largest += self.ss[-self.k-1]\\n            self.ss.pop(self.ss.index(rm))\\n            self.sum -= rm\\n        if len(self.ss) >= 2*self.k:\\n            max_of_smallest = self.ss[self.k-1]\\n            min_of_largest = self.ss[-self.k]\\n            if max_of_smallest <= num <= min_of_largest:\\n                pass\\n            elif num < max_of_smallest:\\n                self.running_smallest -= max_of_smallest - num\\n            elif num > min_of_largest:\\n                self.running_largest -= min_of_largest - num\\n        self.deck.append(num)\\n        self.ss.add(num)\\n        self.sum += num\\n    def calculateMKAverage(self) -> int:\\n        if len(self.ss) < self.m: return -1\\n        return (self.sum - self.running_smallest - self.running_largest)//(self.m-2*self.k)\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m, self.k = m,k\\n        self.ss = SortedList()\\n        self.running_smallest, self.running_largest = 0, 0\\n        self.deck = deque()\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.ss) == 2*self.k: \\n            self.running_smallest, self.running_largest = sum(self.ss[:self.k]), sum(self.ss[-self.k:])\\n        if len(self.ss) >= self.m:\\n            rm = self.deck.popleft()\\n            i = self.ss.bisect_left(rm)\\n            if i < self.k: \\n                self.running_smallest -= rm\\n                self.running_smallest += self.ss[self.k]\\n            elif i>=len(self.ss)-self.k: \\n                self.running_largest -= rm\\n                self.running_largest += self.ss[-self.k-1]\\n            self.ss.pop(self.ss.index(rm))\\n            self.sum -= rm\\n        if len(self.ss) >= 2*self.k:\\n            max_of_smallest = self.ss[self.k-1]\\n            min_of_largest = self.ss[-self.k]\\n            if max_of_smallest <= num <= min_of_largest:\\n                pass\\n            elif num < max_of_smallest:\\n                self.running_smallest -= max_of_smallest - num\\n            elif num > min_of_largest:\\n                self.running_largest -= min_of_largest - num\\n        self.deck.append(num)\\n        self.ss.add(num)\\n        self.sum += num\\n    def calculateMKAverage(self) -> int:\\n        if len(self.ss) < self.m: return -1\\n        return (self.sum - self.running_smallest - self.running_largest)//(self.m-2*self.k)\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901216,
                "title": "easy-to-understand-java-solution-1-treemap-and-1-queue",
                "content": "# Code\\n```\\nclass MKAverage {\\n\\n    Queue<Integer> q;\\n    int sum;\\n    TreeMap<Integer, Integer> map;\\n    int size;\\n    int k;\\n    public MKAverage(int m, int x) {\\n        size = m;\\n        k = x;\\n        q = new LinkedList<>();\\n        map = new TreeMap<>();\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        if(q.size()==size){\\n            int temp = q.poll();\\n            map.put(temp, map.getOrDefault(temp, 0)-1);\\n            if(map.get(temp)<=0) map.remove(temp);\\n            sum -= temp;\\n        }\\n        q.add(num);\\n        map.put(num, map.getOrDefault(num, 0)+1);\\n        sum += num;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(q.size() < size) return -1;\\n        int len = size - 2*k;\\n        int restSum = 0;\\n        int i = 0;\\n\\n        // remove first k element and update sum\\n        int key = map.firstEntry().getKey();\\n        while(true){\\n            int val = map.get(key);\\n            if(i+val >= k){\\n                restSum += key * (k-i);\\n                break;\\n            } else {\\n                restSum += key * val;\\n                i += val;\\n            }\\n            key = map.higherKey(key);\\n        }   \\n        \\n        // remove last k element and update sum\\n        key = map.lastEntry().getKey();\\n        i=0;\\n        while(true){\\n            int val = map.get(key);\\n            if(i+val >= k){\\n                restSum += key * (k-i);\\n                break;\\n            } else {\\n                restSum += key * val;\\n                i+=val;\\n            }\\n            key = map.lowerKey(key);\\n        }\\n        return (sum - restSum)/len;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MKAverage {\\n\\n    Queue<Integer> q;\\n    int sum;\\n    TreeMap<Integer, Integer> map;\\n    int size;\\n    int k;\\n    public MKAverage(int m, int x) {\\n        size = m;\\n        k = x;\\n        q = new LinkedList<>();\\n        map = new TreeMap<>();\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        if(q.size()==size){\\n            int temp = q.poll();\\n            map.put(temp, map.getOrDefault(temp, 0)-1);\\n            if(map.get(temp)<=0) map.remove(temp);\\n            sum -= temp;\\n        }\\n        q.add(num);\\n        map.put(num, map.getOrDefault(num, 0)+1);\\n        sum += num;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(q.size() < size) return -1;\\n        int len = size - 2*k;\\n        int restSum = 0;\\n        int i = 0;\\n\\n        // remove first k element and update sum\\n        int key = map.firstEntry().getKey();\\n        while(true){\\n            int val = map.get(key);\\n            if(i+val >= k){\\n                restSum += key * (k-i);\\n                break;\\n            } else {\\n                restSum += key * val;\\n                i += val;\\n            }\\n            key = map.higherKey(key);\\n        }   \\n        \\n        // remove last k element and update sum\\n        key = map.lastEntry().getKey();\\n        i=0;\\n        while(true){\\n            int val = map.get(key);\\n            if(i+val >= k){\\n                restSum += key * (k-i);\\n                break;\\n            } else {\\n                restSum += key * val;\\n                i+=val;\\n            }\\n            key = map.lowerKey(key);\\n        }\\n        return (sum - restSum)/len;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813038,
                "title": "python3-1-sortedlist-solution-c-3-set-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThis is a very nice problem to test your ability to analyze what data structure is needed, how to design a working system, what data structure different languages provides and their limitations.\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nIf you use Python, the sortedcontainer modules will do this very simplistically, because it can both bisect and arrive at element by index in log(N) time.\\r\\nI tried looking up documentation of C# sorted set, Microsoft so far does not support giving you the iterator inside a sorted set. So you cannot solve the problem in C#.\\r\\nFor C++, 3 std::set would suffice.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n log n)$$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n# Code\\r\\nPython3:\\r\\n```\\r\\nfrom collections import deque\\r\\nimport sortedcontainers\\r\\nclass MKAverage:\\r\\n    \\'\\'\\'\\r\\n    Break down the task in hand:\\r\\n    We want to keep m last numbers in check, have these numbers sorted, such that the top and bottom k elements can be accessed quickly. \\r\\n    But we also want to update the tree regularly. We cannot afford to calculate the largest and smallest k - sums every time a query is make, so we need to maintain the left and right sums. \\r\\n    When a new number nums[i] comes in, we first find where is nums[i - m]. This node we must remove. We identify if it is in the left and right k sums, and if so, deduct it from the sums. Note that we also need to add the kth smallest element and the m - k th smallest element. Also, we need to deduct it from the total sum.\\r\\n    Then we insert nums[i]. We first ask where the insertion position should be, and update the two k sums and totalSum in similar manner as before\\r\\n\\r\\n    When calculateMKAverage is called, we just return (totalSum - leftkSum - rightkSum) // (m - 2 * k)\\r\\n    \\'\\'\\'\\r\\n    def __init__(self, m: int, k: int):\\r\\n        self.tree = sortedcontainers.SortedList()\\r\\n        self.Total = 0\\r\\n        self.leftSum = 0\\r\\n        self.rightSum = 0\\r\\n        self.index = -1\\r\\n        self.m = m\\r\\n        self.k = k\\r\\n        self.dq = deque()\\r\\n    \\r\\n    def deleteNode(self, num, ind):\\r\\n        treeIndex = self.tree.index([num, ind])\\r\\n        if treeIndex < self.k:\\r\\n            self.leftSum -= num\\r\\n            self.leftSum += self.tree[self.k][0]\\r\\n        if len(self.dq) + 1 - treeIndex <= self.k:\\r\\n            self.rightSum -= num\\r\\n            self.rightSum += self.tree[len(self.dq) + 1 - self.k - 1][0]\\r\\n        self.tree.remove([num, ind])\\r\\n        self.Total -= num\\r\\n    \\r\\n    def insertNode(self, num, ind):\\r\\n        self.tree.add([num, ind])\\r\\n        treeIndex = self.tree.bisect_left([num, ind])\\r\\n        if treeIndex < self.k:\\r\\n            self.leftSum += num\\r\\n            if len(self.dq) > self.k:\\r\\n                self.leftSum -= self.tree[self.k][0]\\r\\n        if len(self.dq) - treeIndex <= self.k:\\r\\n            self.rightSum += num\\r\\n            if len(self.dq) > self.k:\\r\\n                self.rightSum -= self.tree[len(self.dq) - self.k - 1][0]\\r\\n        self.Total += num\\r\\n        \\r\\n    def addElement(self, num: int) -> None:\\r\\n        self.index += 1\\r\\n        if len(self.dq) == self.m:\\r\\n            value, index = self.dq.popleft()\\r\\n            self.deleteNode(value, index)\\r\\n        self.dq.append([num, self.index])\\r\\n        self.insertNode(num, self.index)\\r\\n\\r\\n    def calculateMKAverage(self) -> int:\\r\\n        return -1 if len(self.tree) < self.m else (self.Total - self.leftSum - self.rightSum) // (self.m - 2 * self.k)\\r\\n\\r\\n# Your MKAverage object will be instantiated and called as such:\\r\\n# obj = MKAverage(m, k)\\r\\n# obj.addElement(num)\\r\\n# param_2 = obj.calculateMKAverage()\\r\\n```\\r\\nC++:\\r\\n```\\r\\n#include <queue>\\r\\n#include <set>\\r\\nusing namespace std;\\r\\n\\r\\nclass MKAverage {\\r\\n/*\\r\\n    We use two sets of size k and one set of size m to store the nodes. When we delete a previous node, we first check if it is in the left and right trees. If so, update the trees.\\r\\n*/\\r\\nprivate:\\r\\n    set<pair<int, int>> tree;\\r\\n    set<pair<int, int>> left;\\r\\n    set<pair<int, int>> right;\\r\\n    long long Total;\\r\\n    long long leftSum;\\r\\n    long long rightSum;\\r\\n    int index;\\r\\n    int m;\\r\\n    int k;\\r\\n    queue<pair<int, int>> q;\\r\\n\\r\\n    void deleteNode(int num, int index)\\r\\n    {\\r\\n        pair<int, int> nodeToRemove = make_pair(num, index);\\r\\n        if (left.find(nodeToRemove) != left.end())\\r\\n        {\\r\\n            pair<int, int> nodeToInsert = *next(tree.find(*left.rbegin()), 1);\\r\\n            left.insert(nodeToInsert);\\r\\n            leftSum -= (long long)num;\\r\\n            leftSum += (long long)nodeToInsert.first;\\r\\n            left.erase(nodeToRemove);\\r\\n        }\\r\\n        if (right.find(nodeToRemove) != right.end())\\r\\n        {\\r\\n            pair<int, int> nodeToInsert = *prev(tree.find(*right.begin()), 1);\\r\\n            right.insert(nodeToInsert);\\r\\n            rightSum -= (long long)num;\\r\\n            rightSum += (long long)nodeToInsert.first;\\r\\n            right.erase(nodeToRemove);\\r\\n        }\\r\\n\\r\\n        tree.erase(nodeToRemove);\\r\\n        Total -= (long long)num;\\r\\n    }\\r\\n\\r\\n    void insertNode(int num, int index)\\r\\n    {\\r\\n        pair<int, int> nodeToInsert = make_pair(num, index);\\r\\n        if (left.size() < k || left.lower_bound(nodeToInsert) != left.end())\\r\\n        {\\r\\n            if (left.size() == k)\\r\\n            {\\r\\n                pair<int, int> nodeToRemove = *left.rbegin();\\r\\n                left.erase(nodeToRemove);\\r\\n                leftSum -= (long long)nodeToRemove.first;                                \\r\\n            }\\r\\n            left.insert(nodeToInsert);\\r\\n            leftSum += (long long)num;\\r\\n         \\r\\n        }\\r\\n        if (right.size() < k || right.upper_bound(nodeToInsert) != right.begin())\\r\\n        {\\r\\n            if (right.size() == k)\\r\\n            {\\r\\n                pair<int, int> nodeToRemove = *right.begin();\\r\\n                right.erase(nodeToRemove);\\r\\n                rightSum -= (long long)nodeToRemove.first;                             \\r\\n            }\\r\\n            right.insert(nodeToInsert);\\r\\n            rightSum += (long long)num;            \\r\\n        }\\r\\n\\r\\n        tree.insert(nodeToInsert);\\r\\n        Total += (long long)num;\\r\\n    }\\r\\n\\r\\npublic:\\r\\n    MKAverage(int m, int k) {\\r\\n        tree = set<pair<int, int>>{};\\r\\n        left = set<pair<int, int>>{};\\r\\n        right = set<pair<int, int>>{};\\r\\n        q = queue<pair<int, int>>{};\\r\\n        Total = (long long)0;\\r\\n        leftSum = (long long)0;\\r\\n        rightSum = (long long)0;\\r\\n        index = -1;\\r\\n        this->m = m;\\r\\n        this->k = k;\\r\\n    }\\r\\n\\r\\n    void addElement(int num) {\\r\\n        index++;\\r\\n        if (q.size() == m)\\r\\n        {\\r\\n            pair<int, int> element = q.front();\\r\\n            q.pop();\\r\\n            deleteNode(element.first, element.second);\\r\\n        }\\r\\n        q.push(make_pair(num, index));\\r\\n        insertNode(num, index);\\r\\n    }\\r\\n\\r\\n    int calculateMKAverage() {\\r\\n        return tree.size() < m ? -1 : (Total - leftSum - rightSum) / (long long)(m - 2 * k);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\r\\nfrom collections import deque\\r\\nimport sortedcontainers\\r\\nclass MKAverage:\\r\\n    \\'\\'\\'\\r\\n    Break down the task in hand:\\r\\n    We want to keep m last numbers in check, have these numbers sorted, such that the top and bottom k elements can be accessed quickly. \\r\\n    But we also want to update the tree regularly. We cannot afford to calculate the largest and smallest k - sums every time a query is make, so we need to maintain the left and right sums. \\r\\n    When a new number nums[i] comes in, we first find where is nums[i - m]. This node we must remove. We identify if it is in the left and right k sums, and if so, deduct it from the sums. Note that we also need to add the kth smallest element and the m - k th smallest element. Also, we need to deduct it from the total sum.\\r\\n    Then we insert nums[i]. We first ask where the insertion position should be, and update the two k sums and totalSum in similar manner as before\\r\\n\\r\\n    When calculateMKAverage is called, we just return (totalSum - leftkSum - rightkSum) // (m - 2 * k)\\r\\n    \\'\\'\\'\\r\\n    def __init__(self, m: int, k: int):\\r\\n        self.tree = sortedcontainers.SortedList()\\r\\n        self.Total = 0\\r\\n        self.leftSum = 0\\r\\n        self.rightSum = 0\\r\\n        self.index = -1\\r\\n        self.m = m\\r\\n        self.k = k\\r\\n        self.dq = deque()\\r\\n    \\r\\n    def deleteNode(self, num, ind):\\r\\n        treeIndex = self.tree.index([num, ind])\\r\\n        if treeIndex < self.k:\\r\\n            self.leftSum -= num\\r\\n            self.leftSum += self.tree[self.k][0]\\r\\n        if len(self.dq) + 1 - treeIndex <= self.k:\\r\\n            self.rightSum -= num\\r\\n            self.rightSum += self.tree[len(self.dq) + 1 - self.k - 1][0]\\r\\n        self.tree.remove([num, ind])\\r\\n        self.Total -= num\\r\\n    \\r\\n    def insertNode(self, num, ind):\\r\\n        self.tree.add([num, ind])\\r\\n        treeIndex = self.tree.bisect_left([num, ind])\\r\\n        if treeIndex < self.k:\\r\\n            self.leftSum += num\\r\\n            if len(self.dq) > self.k:\\r\\n                self.leftSum -= self.tree[self.k][0]\\r\\n        if len(self.dq) - treeIndex <= self.k:\\r\\n            self.rightSum += num\\r\\n            if len(self.dq) > self.k:\\r\\n                self.rightSum -= self.tree[len(self.dq) - self.k - 1][0]\\r\\n        self.Total += num\\r\\n        \\r\\n    def addElement(self, num: int) -> None:\\r\\n        self.index += 1\\r\\n        if len(self.dq) == self.m:\\r\\n            value, index = self.dq.popleft()\\r\\n            self.deleteNode(value, index)\\r\\n        self.dq.append([num, self.index])\\r\\n        self.insertNode(num, self.index)\\r\\n\\r\\n    def calculateMKAverage(self) -> int:\\r\\n        return -1 if len(self.tree) < self.m else (self.Total - self.leftSum - self.rightSum) // (self.m - 2 * self.k)\\r\\n\\r\\n# Your MKAverage object will be instantiated and called as such:\\r\\n# obj = MKAverage(m, k)\\r\\n# obj.addElement(num)\\r\\n# param_2 = obj.calculateMKAverage()\\r\\n```\n```\\r\\n#include <queue>\\r\\n#include <set>\\r\\nusing namespace std;\\r\\n\\r\\nclass MKAverage {\\r\\n/*\\r\\n    We use two sets of size k and one set of size m to store the nodes. When we delete a previous node, we first check if it is in the left and right trees. If so, update the trees.\\r\\n*/\\r\\nprivate:\\r\\n    set<pair<int, int>> tree;\\r\\n    set<pair<int, int>> left;\\r\\n    set<pair<int, int>> right;\\r\\n    long long Total;\\r\\n    long long leftSum;\\r\\n    long long rightSum;\\r\\n    int index;\\r\\n    int m;\\r\\n    int k;\\r\\n    queue<pair<int, int>> q;\\r\\n\\r\\n    void deleteNode(int num, int index)\\r\\n    {\\r\\n        pair<int, int> nodeToRemove = make_pair(num, index);\\r\\n        if (left.find(nodeToRemove) != left.end())\\r\\n        {\\r\\n            pair<int, int> nodeToInsert = *next(tree.find(*left.rbegin()), 1);\\r\\n            left.insert(nodeToInsert);\\r\\n            leftSum -= (long long)num;\\r\\n            leftSum += (long long)nodeToInsert.first;\\r\\n            left.erase(nodeToRemove);\\r\\n        }\\r\\n        if (right.find(nodeToRemove) != right.end())\\r\\n        {\\r\\n            pair<int, int> nodeToInsert = *prev(tree.find(*right.begin()), 1);\\r\\n            right.insert(nodeToInsert);\\r\\n            rightSum -= (long long)num;\\r\\n            rightSum += (long long)nodeToInsert.first;\\r\\n            right.erase(nodeToRemove);\\r\\n        }\\r\\n\\r\\n        tree.erase(nodeToRemove);\\r\\n        Total -= (long long)num;\\r\\n    }\\r\\n\\r\\n    void insertNode(int num, int index)\\r\\n    {\\r\\n        pair<int, int> nodeToInsert = make_pair(num, index);\\r\\n        if (left.size() < k || left.lower_bound(nodeToInsert) != left.end())\\r\\n        {\\r\\n            if (left.size() == k)\\r\\n            {\\r\\n                pair<int, int> nodeToRemove = *left.rbegin();\\r\\n                left.erase(nodeToRemove);\\r\\n                leftSum -= (long long)nodeToRemove.first;                                \\r\\n            }\\r\\n            left.insert(nodeToInsert);\\r\\n            leftSum += (long long)num;\\r\\n         \\r\\n        }\\r\\n        if (right.size() < k || right.upper_bound(nodeToInsert) != right.begin())\\r\\n        {\\r\\n            if (right.size() == k)\\r\\n            {\\r\\n                pair<int, int> nodeToRemove = *right.begin();\\r\\n                right.erase(nodeToRemove);\\r\\n                rightSum -= (long long)nodeToRemove.first;                             \\r\\n            }\\r\\n            right.insert(nodeToInsert);\\r\\n            rightSum += (long long)num;            \\r\\n        }\\r\\n\\r\\n        tree.insert(nodeToInsert);\\r\\n        Total += (long long)num;\\r\\n    }\\r\\n\\r\\npublic:\\r\\n    MKAverage(int m, int k) {\\r\\n        tree = set<pair<int, int>>{};\\r\\n        left = set<pair<int, int>>{};\\r\\n        right = set<pair<int, int>>{};\\r\\n        q = queue<pair<int, int>>{};\\r\\n        Total = (long long)0;\\r\\n        leftSum = (long long)0;\\r\\n        rightSum = (long long)0;\\r\\n        index = -1;\\r\\n        this->m = m;\\r\\n        this->k = k;\\r\\n    }\\r\\n\\r\\n    void addElement(int num) {\\r\\n        index++;\\r\\n        if (q.size() == m)\\r\\n        {\\r\\n            pair<int, int> element = q.front();\\r\\n            q.pop();\\r\\n            deleteNode(element.first, element.second);\\r\\n        }\\r\\n        q.push(make_pair(num, index));\\r\\n        insertNode(num, index);\\r\\n    }\\r\\n\\r\\n    int calculateMKAverage() {\\r\\n        return tree.size() < m ? -1 : (Total - leftSum - rightSum) / (long long)(m - 2 * k);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3562968,
                "title": "1825-finding-mk-average-mkaverage-calculation-for-stream-of-integers",
                "content": "# Intuition\\nThe problem requires implementing a data structure that calculates the MKAverage for a given stream of integers. The MKAverage is calculated by considering the last m elements of the stream, removing the smallest k elements and the largest k elements, and then calculating the average of the remaining elements rounded down to the nearest integer.\\n\\n# Approach\\nTo solve the problem, we can use a combination of a queue (stream) and a sorted list (sorted_stream). The stream will keep track of the last m elements in the stream, while the sorted_stream will maintain a sorted order of the elements in the stream.\\n\\n1/ Initialize the MKAverage class with the provided values of m and k.\\n\\n2/ Implement the addElement method to add a new element to the stream:\\n- If the length of the stream is equal to m, remove the oldest element from both the stream (using popleft()) and the sorted_stream (using pop() after finding the index with bisect_left()).\\n- Add the new element to the stream and insert it into the sorted_stream using insort() to maintain the sorted order.\\n\\n3/ Implement the calculateMKAverage method:\\n- If the length of the stream is less than m, return -1 since there are not enough elements to calculate the MKAverage.\\n- Remove the smallest k elements and the largest k elements from the sorted_stream by slicing it.\\n- Calculate the average of the remaining elements in the sorted_stream and return the rounded down value.\\n\\n# Complexity\\n- Time complexity:\\n-> The time complexity of adding an element to the stream is O(log m) due to the insort() operation, and the time complexity of calculating the MKAverage is O(m - 2k) since we need to remove the smallest and largest elements. Therefore, the overall time complexity is O(log m + m - 2k).\\n\\n- Space complexity:\\n-> The space complexity is O(m) to store the stream and sorted_stream containers.\\n\\n---\\n\\n# Code\\n```\\nfrom collections import deque\\nimport bisect\\n\\nclass MKAverage(object):\\n    def __init__(self, m, k):\\n        self.m = m\\n        self.k = k\\n        self.stream = deque()\\n        self.sorted_stream = []\\n    def addElement(self, num):\\n        if len(self.stream) == self.m:\\n            oldest = self.stream.popleft()\\n            index = bisect.bisect_left(self.sorted_stream, oldest)\\n            self.sorted_stream.pop(index)\\n        self.stream.append(num)\\n        bisect.insort(self.sorted_stream, num)\\n    def calculateMKAverage(self):\\n        if len(self.stream) < self.m:\\n            return -1\\n        trimmed_stream = self.sorted_stream[self.k:-self.k]\\n        avg = sum(trimmed_stream) // len(trimmed_stream)\\n        return avg\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Data Stream"
                ],
                "code": "```\\nfrom collections import deque\\nimport bisect\\n\\nclass MKAverage(object):\\n    def __init__(self, m, k):\\n        self.m = m\\n        self.k = k\\n        self.stream = deque()\\n        self.sorted_stream = []\\n    def addElement(self, num):\\n        if len(self.stream) == self.m:\\n            oldest = self.stream.popleft()\\n            index = bisect.bisect_left(self.sorted_stream, oldest)\\n            self.sorted_stream.pop(index)\\n        self.stream.append(num)\\n        bisect.insort(self.sorted_stream, num)\\n    def calculateMKAverage(self):\\n        if len(self.stream) < self.m:\\n            return -1\\n        trimmed_stream = self.sorted_stream[self.k:-self.k]\\n        avg = sum(trimmed_stream) // len(trimmed_stream)\\n        return avg\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448102,
                "title": "python-simple-deque-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MKAverage:\\n\\n    def __init__(self, m, k):\\n        from sortedcontainers import SortedList\\n        self.m = m\\n        self.k = k\\n        self.ans = deque()\\n        self.res = SortedList()\\n        self.total = 0\\n\\n    def addElement(self, num):\\n        self.ans.append(num)\\n        self.res.add(num)\\n        self.total += num\\n\\n        if len(self.ans) > self.m:\\n            x = self.ans.popleft()\\n            self.res.remove(x)\\n            self.total -= x\\n\\n    def calculateMKAverage(self):\\n        if len(self.ans) < self.m:\\n            return -1\\n        else:\\n            remove = sum(self.res[:self.k]) + sum(self.res[-self.k:])\\n\\n        return int((self.total-remove)/(self.m-2*self.k))\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MKAverage:\\n\\n    def __init__(self, m, k):\\n        from sortedcontainers import SortedList\\n        self.m = m\\n        self.k = k\\n        self.ans = deque()\\n        self.res = SortedList()\\n        self.total = 0\\n\\n    def addElement(self, num):\\n        self.ans.append(num)\\n        self.res.add(num)\\n        self.total += num\\n\\n        if len(self.ans) > self.m:\\n            x = self.ans.popleft()\\n            self.res.remove(x)\\n            self.total -= x\\n\\n    def calculateMKAverage(self):\\n        if len(self.ans) < self.m:\\n            return -1\\n        else:\\n            remove = sum(self.res[:self.k]) + sum(self.res[-self.k:])\\n\\n        return int((self.total-remove)/(self.m-2*self.k))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444129,
                "title": "my-solutions",
                "content": "**Solution `I`**\\n```\\nclass MKAverage {\\n private:\\n  static constexpr int n_parts = 3;\\n  static constexpr int part1_i = 0;\\n  static constexpr int part2_i = 1;\\n  static constexpr int part3_i = 2;\\n  \\n public:\\n  MKAverage(const int m, const int k) : m_(m), k_(k), sums_{} {\\n  }\\n\\n  void addElement(const int num) {\\n    q_.emplace(num);\\n    insert(num);\\n    if (q_.size() > m_) {\\n      remove(q_.front());\\n      q_.pop();\\n    }\\n  }\\n\\n  int calculateMKAverage() {\\n    if (q_.size() < m_) {\\n      return -1;\\n    }\\n    return sums_[part2_i] / part_size(part2_i);\\n  }\\n  \\n private:\\n  int part_size(const int i_part) const {\\n    if (i_part == 0 || i_part == 2) {\\n      return k_;\\n    }\\n    return m_ - 2 * k_;\\n  }\\n  \\n  void insert(const int num) {\\n    insert_part(part1_i, num);\\n    for (int i_part = part1_i;\\n         i_part + 1 < n_parts && parts_[i_part].size() > part_size(i_part);\\n         ++i_part) {\\n      move(i_part, i_part + 1);\\n    }\\n  }\\n  \\n  void remove(const int num) {\\n    for (int i_part = part3_i; i_part > -1; --i_part) {\\n      if (remove_part(i_part, num)) {\\n        for (; i_part + 1 < n_parts; ++i_part) {\\n          move(i_part + 1, i_part);\\n        }\\n        break;\\n      }\\n    }\\n  }\\n  \\n  void insert_part(const int i_part, const int num) {\\n    parts_[i_part].emplace(num);\\n    sums_[i_part] += num;\\n  }\\n  \\n  bool remove_part(const int i_part, const int num) {\\n    auto itr = parts_[i_part].find(num);\\n    if (itr == parts_[i_part].end()) {\\n      return false;\\n    }\\n    \\n    parts_[i_part].erase(itr);\\n    sums_[i_part] -= num;\\n    return true;\\n  }\\n  \\n  void move(const int i_part_from, const int i_part_to) {\\n    const bool forward = i_part_from < i_part_to;\\n    multiset<int> &from = parts_[i_part_from];\\n    multiset<int> &to = parts_[i_part_to];\\n    const int moved = forward ? *from.rbegin() : *from.begin();\\n    auto moved_itr = forward ? from.find(moved) : from.begin();\\n    from.erase(moved_itr);\\n    sums_[i_part_from] -= moved;\\n    to.emplace(moved);\\n    sums_[i_part_to] += moved;\\n  }\\n  \\n  const int m_;\\n  const int k_;\\n  queue<int> q_;\\n  multiset<int> parts_[n_parts];\\n  long long sums_[n_parts];\\n};\\n```\\n**Solution `II`**\\n```\\nclass MKAverage {\\n private:\\n  static constexpr int n_parts = 3;\\n  static constexpr int part1_i = 0;\\n  static constexpr int part2_i = 1;\\n  static constexpr int part3_i = 2;\\n  \\n public:\\n  MKAverage(const int m, const int k) : m_(m), k_(k), part2_sum_(0) {\\n  }\\n    \\n  void addElement(const int num) {\\n    if (dq_.size() < m_) {\\n      dq_.emplace_back(num);\\n      if (dq_.size() == m_) {\\n        vector<int> nums(dq_.begin(), dq_.end());\\n        sort(nums.begin(), nums.end());\\n        parts_[part1_i].insert(nums.begin(), nums.begin() + k_);\\n        parts_[part2_i].insert(nums.begin() + k_, nums.end() - k_);\\n        parts_[part3_i].insert(nums.end() - k_, nums.end());\\n        part2_sum_ = accumulate(nums.begin() + k_, nums.end() - k_, 0);\\n      }\\n      return;\\n    }\\n    \\n    // dq_.size() >= m_\\n    dq_.emplace_back(num);\\n    if (num <= *parts_[part1_i].rbegin()) {\\n      parts_[part1_i].emplace(num);\\n    } else if (num >= *parts_[part3_i].begin()) {\\n      parts_[part3_i].emplace(num);\\n    } else {\\n      parts_[part2_i].emplace(num);\\n      part2_sum_ += num;\\n    }\\n    \\n    const int to_erase = dq_.front();\\n    dq_.pop_front();\\n    if (to_erase <= *parts_[part1_i].rbegin()) {\\n      parts_[part1_i].erase(parts_[part1_i].find(to_erase));\\n    } else if (to_erase >= *parts_[part3_i].begin()) {\\n      parts_[part3_i].erase(parts_[part3_i].find(to_erase));\\n    } else {\\n      parts_[part2_i].erase(parts_[part2_i].find(to_erase));\\n      part2_sum_ -= to_erase;\\n    }\\n    \\n    while (parts_[part1_i].size() > k_) {\\n      move_forward(part1_i);\\n    }\\n    while (parts_[part3_i].size() > k_) {\\n      move_backward(part3_i);\\n    }\\n    while (parts_[part1_i].size() < k_) {\\n      move_backward(part2_i);\\n    }\\n    while (parts_[part3_i].size() < k_) {\\n      move_forward(part2_i);\\n    }\\n  }\\n    \\n  int calculateMKAverage() {\\n    if (dq_.size() < m_) {\\n      return -1;\\n    }\\n\\n    return part2_sum_ / (m_ - 2 * k_);\\n  }\\n  \\n private:\\n  void move_forward(const int source_part) {\\n    const int target_part = source_part + 1;\\n    const int to_move = *parts_[source_part].rbegin();\\n    update_part2_sum(source_part, target_part, to_move);\\n    auto itr = prev(parts_[source_part].end());\\n    auto node = parts_[source_part].extract(itr);\\n    parts_[target_part].insert(move(node));\\n  }\\n  \\n  void move_backward(const int source_part) {\\n    const int target_part = source_part - 1;\\n    const int to_move = *parts_[source_part].begin();\\n    update_part2_sum(source_part, target_part, to_move);\\n    auto node = parts_[source_part].extract(parts_[source_part].begin());\\n    parts_[target_part].insert(move(node));\\n  }\\n  \\n  void update_part2_sum(const int source_part, const int target_part, const int to_move) {\\n    if (source_part == part2_i) {\\n      part2_sum_ -= to_move;\\n    } else if (target_part == part2_i) {\\n      part2_sum_ += to_move;\\n    }\\n  }\\n  \\n  const int m_;\\n  const int k_;\\n  int part2_sum_;\\n  deque<int> dq_;\\n  multiset<int> parts_[n_parts];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n private:\\n  static constexpr int n_parts = 3;\\n  static constexpr int part1_i = 0;\\n  static constexpr int part2_i = 1;\\n  static constexpr int part3_i = 2;\\n  \\n public:\\n  MKAverage(const int m, const int k) : m_(m), k_(k), sums_{} {\\n  }\\n\\n  void addElement(const int num) {\\n    q_.emplace(num);\\n    insert(num);\\n    if (q_.size() > m_) {\\n      remove(q_.front());\\n      q_.pop();\\n    }\\n  }\\n\\n  int calculateMKAverage() {\\n    if (q_.size() < m_) {\\n      return -1;\\n    }\\n    return sums_[part2_i] / part_size(part2_i);\\n  }\\n  \\n private:\\n  int part_size(const int i_part) const {\\n    if (i_part == 0 || i_part == 2) {\\n      return k_;\\n    }\\n    return m_ - 2 * k_;\\n  }\\n  \\n  void insert(const int num) {\\n    insert_part(part1_i, num);\\n    for (int i_part = part1_i;\\n         i_part + 1 < n_parts && parts_[i_part].size() > part_size(i_part);\\n         ++i_part) {\\n      move(i_part, i_part + 1);\\n    }\\n  }\\n  \\n  void remove(const int num) {\\n    for (int i_part = part3_i; i_part > -1; --i_part) {\\n      if (remove_part(i_part, num)) {\\n        for (; i_part + 1 < n_parts; ++i_part) {\\n          move(i_part + 1, i_part);\\n        }\\n        break;\\n      }\\n    }\\n  }\\n  \\n  void insert_part(const int i_part, const int num) {\\n    parts_[i_part].emplace(num);\\n    sums_[i_part] += num;\\n  }\\n  \\n  bool remove_part(const int i_part, const int num) {\\n    auto itr = parts_[i_part].find(num);\\n    if (itr == parts_[i_part].end()) {\\n      return false;\\n    }\\n    \\n    parts_[i_part].erase(itr);\\n    sums_[i_part] -= num;\\n    return true;\\n  }\\n  \\n  void move(const int i_part_from, const int i_part_to) {\\n    const bool forward = i_part_from < i_part_to;\\n    multiset<int> &from = parts_[i_part_from];\\n    multiset<int> &to = parts_[i_part_to];\\n    const int moved = forward ? *from.rbegin() : *from.begin();\\n    auto moved_itr = forward ? from.find(moved) : from.begin();\\n    from.erase(moved_itr);\\n    sums_[i_part_from] -= moved;\\n    to.emplace(moved);\\n    sums_[i_part_to] += moved;\\n  }\\n  \\n  const int m_;\\n  const int k_;\\n  queue<int> q_;\\n  multiset<int> parts_[n_parts];\\n  long long sums_[n_parts];\\n};\\n```\n```\\nclass MKAverage {\\n private:\\n  static constexpr int n_parts = 3;\\n  static constexpr int part1_i = 0;\\n  static constexpr int part2_i = 1;\\n  static constexpr int part3_i = 2;\\n  \\n public:\\n  MKAverage(const int m, const int k) : m_(m), k_(k), part2_sum_(0) {\\n  }\\n    \\n  void addElement(const int num) {\\n    if (dq_.size() < m_) {\\n      dq_.emplace_back(num);\\n      if (dq_.size() == m_) {\\n        vector<int> nums(dq_.begin(), dq_.end());\\n        sort(nums.begin(), nums.end());\\n        parts_[part1_i].insert(nums.begin(), nums.begin() + k_);\\n        parts_[part2_i].insert(nums.begin() + k_, nums.end() - k_);\\n        parts_[part3_i].insert(nums.end() - k_, nums.end());\\n        part2_sum_ = accumulate(nums.begin() + k_, nums.end() - k_, 0);\\n      }\\n      return;\\n    }\\n    \\n    // dq_.size() >= m_\\n    dq_.emplace_back(num);\\n    if (num <= *parts_[part1_i].rbegin()) {\\n      parts_[part1_i].emplace(num);\\n    } else if (num >= *parts_[part3_i].begin()) {\\n      parts_[part3_i].emplace(num);\\n    } else {\\n      parts_[part2_i].emplace(num);\\n      part2_sum_ += num;\\n    }\\n    \\n    const int to_erase = dq_.front();\\n    dq_.pop_front();\\n    if (to_erase <= *parts_[part1_i].rbegin()) {\\n      parts_[part1_i].erase(parts_[part1_i].find(to_erase));\\n    } else if (to_erase >= *parts_[part3_i].begin()) {\\n      parts_[part3_i].erase(parts_[part3_i].find(to_erase));\\n    } else {\\n      parts_[part2_i].erase(parts_[part2_i].find(to_erase));\\n      part2_sum_ -= to_erase;\\n    }\\n    \\n    while (parts_[part1_i].size() > k_) {\\n      move_forward(part1_i);\\n    }\\n    while (parts_[part3_i].size() > k_) {\\n      move_backward(part3_i);\\n    }\\n    while (parts_[part1_i].size() < k_) {\\n      move_backward(part2_i);\\n    }\\n    while (parts_[part3_i].size() < k_) {\\n      move_forward(part2_i);\\n    }\\n  }\\n    \\n  int calculateMKAverage() {\\n    if (dq_.size() < m_) {\\n      return -1;\\n    }\\n\\n    return part2_sum_ / (m_ - 2 * k_);\\n  }\\n  \\n private:\\n  void move_forward(const int source_part) {\\n    const int target_part = source_part + 1;\\n    const int to_move = *parts_[source_part].rbegin();\\n    update_part2_sum(source_part, target_part, to_move);\\n    auto itr = prev(parts_[source_part].end());\\n    auto node = parts_[source_part].extract(itr);\\n    parts_[target_part].insert(move(node));\\n  }\\n  \\n  void move_backward(const int source_part) {\\n    const int target_part = source_part - 1;\\n    const int to_move = *parts_[source_part].begin();\\n    update_part2_sum(source_part, target_part, to_move);\\n    auto node = parts_[source_part].extract(parts_[source_part].begin());\\n    parts_[target_part].insert(move(node));\\n  }\\n  \\n  void update_part2_sum(const int source_part, const int target_part, const int to_move) {\\n    if (source_part == part2_i) {\\n      part2_sum_ -= to_move;\\n    } else if (target_part == part2_i) {\\n      part2_sum_ += to_move;\\n    }\\n  }\\n  \\n  const int m_;\\n  const int k_;\\n  int part2_sum_;\\n  deque<int> dq_;\\n  multiset<int> parts_[n_parts];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284107,
                "title": "solution-in-go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MKAverage struct {\\n    L, M, R   Range\\n    m, k      int\\n    q         []int\\n}\\n\\ntype Range struct {\\n    s   []int\\n    sum int\\n}\\n\\nfunc (r *Range) insert(x int) {\\n    i := sort.SearchInts(r.s, x)\\n    r.s = append(r.s, 0)\\n    copy(r.s[i+1:], r.s[i:])\\n    r.s[i] = x\\n    r.sum += x\\n}\\n\\nfunc (r *Range) remove(x int) {\\n    i := sort.SearchInts(r.s, x)\\n    r.s = append(r.s[:i], r.s[i+1:]...)\\n    r.sum -= x\\n}\\n\\nfunc Constructor(m int, k int) MKAverage {\\n    return MKAverage{\\n        m: m,\\n        k: k,\\n    }\\n}\\n\\nfunc (mk *MKAverage) AddElement(num int) {\\n    mk.q = append(mk.q, num)\\n    n := len(mk.q)\\n    if n < mk.m {\\n        return\\n    }\\n    if n == mk.m {\\n        qq := make([]int, mk.m)\\n        copy(qq, mk.q)\\n        sort.Ints(qq)\\n        for i := 0; i < mk.k; i++ {\\n            mk.L.insert(qq[i])\\n        }\\n        for i := mk.k; i < mk.m-mk.k; i++ {\\n            mk.M.insert(qq[i])\\n        }\\n        for i := mk.m - mk.k; i < mk.m; i++ {\\n            mk.R.insert(qq[i])\\n        }\\n    }\\n    if n > mk.m {\\n        mk.M.insert(num)\\n        x := mk.L.s[len(mk.L.s)-1]\\n        y := mk.M.s[0]\\n        if x > y {\\n            mk.L.remove(x)\\n            mk.M.remove(y)\\n            mk.L.insert(y)\\n            mk.M.insert(x)\\n        }\\n        x = mk.M.s[len(mk.M.s)-1]\\n        y = mk.R.s[0]\\n        if x > y {\\n            mk.M.remove(x)\\n            mk.R.remove(y)\\n            mk.M.insert(y)\\n            mk.R.insert(x)\\n        }\\n        invalid := mk.q[n-mk.m-1]\\n        if i := sort.SearchInts(mk.M.s, invalid); i < len(mk.M.s) && mk.M.s[i] == invalid {\\n            mk.M.remove(invalid)\\n        } else if i := sort.SearchInts(mk.L.s, invalid); i < len(mk.L.s) && mk.L.s[i] == invalid {\\n            mk.L.remove(invalid)\\n            x := mk.M.s[0]\\n            mk.L.insert(x)\\n            mk.M.remove(x)\\n        } else {\\n            mk.R.remove(invalid)\\n            x := mk.M.s[len(mk.M.s)-1]\\n            mk.R.insert(x)\\n            mk.M.remove(x)\\n        }\\n    }\\n}\\n\\nfunc (mk *MKAverage) CalculateMKAverage() int {\\n    if len(mk.q) < mk.m {\\n        return -1\\n    }\\n    return mk.M.sum / len(mk.M.s)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype MKAverage struct {\\n    L, M, R   Range\\n    m, k      int\\n    q         []int\\n}\\n\\ntype Range struct {\\n    s   []int\\n    sum int\\n}\\n\\nfunc (r *Range) insert(x int) {\\n    i := sort.SearchInts(r.s, x)\\n    r.s = append(r.s, 0)\\n    copy(r.s[i+1:], r.s[i:])\\n    r.s[i] = x\\n    r.sum += x\\n}\\n\\nfunc (r *Range) remove(x int) {\\n    i := sort.SearchInts(r.s, x)\\n    r.s = append(r.s[:i], r.s[i+1:]...)\\n    r.sum -= x\\n}\\n\\nfunc Constructor(m int, k int) MKAverage {\\n    return MKAverage{\\n        m: m,\\n        k: k,\\n    }\\n}\\n\\nfunc (mk *MKAverage) AddElement(num int) {\\n    mk.q = append(mk.q, num)\\n    n := len(mk.q)\\n    if n < mk.m {\\n        return\\n    }\\n    if n == mk.m {\\n        qq := make([]int, mk.m)\\n        copy(qq, mk.q)\\n        sort.Ints(qq)\\n        for i := 0; i < mk.k; i++ {\\n            mk.L.insert(qq[i])\\n        }\\n        for i := mk.k; i < mk.m-mk.k; i++ {\\n            mk.M.insert(qq[i])\\n        }\\n        for i := mk.m - mk.k; i < mk.m; i++ {\\n            mk.R.insert(qq[i])\\n        }\\n    }\\n    if n > mk.m {\\n        mk.M.insert(num)\\n        x := mk.L.s[len(mk.L.s)-1]\\n        y := mk.M.s[0]\\n        if x > y {\\n            mk.L.remove(x)\\n            mk.M.remove(y)\\n            mk.L.insert(y)\\n            mk.M.insert(x)\\n        }\\n        x = mk.M.s[len(mk.M.s)-1]\\n        y = mk.R.s[0]\\n        if x > y {\\n            mk.M.remove(x)\\n            mk.R.remove(y)\\n            mk.M.insert(y)\\n            mk.R.insert(x)\\n        }\\n        invalid := mk.q[n-mk.m-1]\\n        if i := sort.SearchInts(mk.M.s, invalid); i < len(mk.M.s) && mk.M.s[i] == invalid {\\n            mk.M.remove(invalid)\\n        } else if i := sort.SearchInts(mk.L.s, invalid); i < len(mk.L.s) && mk.L.s[i] == invalid {\\n            mk.L.remove(invalid)\\n            x := mk.M.s[0]\\n            mk.L.insert(x)\\n            mk.M.remove(x)\\n        } else {\\n            mk.R.remove(invalid)\\n            x := mk.M.s[len(mk.M.s)-1]\\n            mk.R.insert(x)\\n            mk.M.remove(x)\\n        }\\n    }\\n}\\n\\nfunc (mk *MKAverage) CalculateMKAverage() int {\\n    if len(mk.q) < mk.m {\\n        return -1\\n    }\\n    return mk.M.sum / len(mk.M.s)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3275752,
                "title": "348-ms",
                "content": "```ruby\\nclass MKAverage\\n\\n    def initialize(m, k) = (@a, @z, @k = [], m, k)\\n\\n    def add_element v\\n        @a << v\\n        if @a.size == @z\\n            @l, @m, @r = *3.times.map { CRBTreeMap.new }\\n            @mz, b = @z - @k * 2, @a.sort\\n            @ms = b[@k, @mz].tally.sum do\\n                @m[_1] = _2; _1 * _2\\n            end\\n            [[@l, 0...@k], [@r, -@k...@z]].each do | p |\\n                t, r = *p\\n                b[r].tally.each { t[_1] = _2 }\\n            end\\n        elsif @a.size > @z\\n            @l[v] ||= 0; @l[v] += 1\\n            @l.delete_max if (@l[x = @l.max_key] -= 1).zero?\\n            @m[x] ||= 0; @m[x] += 1\\n            @m.delete_max if (@m[y = @m.max_key] -= 1).zero?\\n            @ms += x - y\\n            @r[y] ||= 0; @r[y] += 1\\n            if (x = @a.shift) >= @r.min_key\\n                @r.delete x if (@r[x] -= 1).zero?\\n            elsif x >= @m.min_key\\n                @m.delete x if (@m[x] -= 1).zero?\\n                @r.delete_min if (@r[y = @r.min_key] -= 1).zero?\\n                @m[y] ||= 0; @m[y] += 1\\n                @ms += y - x\\n            else\\n                @l.delete x if (@l[x] -= 1).zero?\\n                x = @m.min_key\\n                @l[x] ||= 0; @l[x] += 1\\n                @m.delete x if (@m[x] -= 1).zero?\\n                @r.delete_min if (@r[y = @r.min_key] -= 1).zero?\\n                @m[y] ||= 0; @m[y] += 1\\n                @ms += y - x\\n            end\\n        end\\n    end\\n\\n    def calculate_mk_average = @ms&./(@mz) || -1\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass MKAverage\\n\\n    def initialize(m, k) = (@a, @z, @k = [], m, k)\\n\\n    def add_element v\\n        @a << v\\n        if @a.size == @z\\n            @l, @m, @r = *3.times.map { CRBTreeMap.new }\\n            @mz, b = @z - @k * 2, @a.sort\\n            @ms = b[@k, @mz].tally.sum do\\n                @m[_1] = _2; _1 * _2\\n            end\\n            [[@l, 0...@k], [@r, -@k...@z]].each do | p |\\n                t, r = *p\\n                b[r].tally.each { t[_1] = _2 }\\n            end\\n        elsif @a.size > @z\\n            @l[v] ||= 0; @l[v] += 1\\n            @l.delete_max if (@l[x = @l.max_key] -= 1).zero?\\n            @m[x] ||= 0; @m[x] += 1\\n            @m.delete_max if (@m[y = @m.max_key] -= 1).zero?\\n            @ms += x - y\\n            @r[y] ||= 0; @r[y] += 1\\n            if (x = @a.shift) >= @r.min_key\\n                @r.delete x if (@r[x] -= 1).zero?\\n            elsif x >= @m.min_key\\n                @m.delete x if (@m[x] -= 1).zero?\\n                @r.delete_min if (@r[y = @r.min_key] -= 1).zero?\\n                @m[y] ||= 0; @m[y] += 1\\n                @ms += y - x\\n            else\\n                @l.delete x if (@l[x] -= 1).zero?\\n                x = @m.min_key\\n                @l[x] ||= 0; @l[x] += 1\\n                @m.delete x if (@m[x] -= 1).zero?\\n                @r.delete_min if (@r[y = @r.min_key] -= 1).zero?\\n                @m[y] ||= 0; @m[y] += 1\\n                @ms += y - x\\n            end\\n        end\\n    end\\n\\n    def calculate_mk_average = @ms&./(@mz) || -1\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164466,
                "title": "balance-3-sortedlist-python",
                "content": "Use 3 sorted containers to maintain k smallest, k largest, and middle values.\\nUse a queue to keep track of last m elements\\nAlso keep track of sum of the middle container to calculate average in O(1)\\n\\nThere exists a better solution when all elements belong in 1 sorted container and you keep track of sum k smallest and m-k smallest elements.\\n\\n**Time: O(|Q| * log m), |Q| = no of add queries\\nSpace: O(m)**\\n```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.n = self.m - self.k - self.k\\n        self.que = deque()\\n        self.left = SortedList()\\n        self.right = SortedList()\\n        self.vals = []\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.que) < self.m:\\n            self.que.append(num)\\n            self.vals.append(num)\\n\\n            if len(self.que) == self.m:\\n                self.vals.sort()\\n                self.left = SortedList(self.vals[:self.k])\\n                self.right = SortedList(self.vals[-self.k:])\\n                self.vals = SortedList(self.vals[self.k:-self.k])\\n                self.sum = sum(self.vals)\\n        else:\\n            self.que.append(num)\\n            el = self.que.popleft()\\n            \\n            if self.left[-1] >= el:\\n                self.left.remove(el)\\n            elif self.right[0] <= el:\\n                self.right.remove(el)\\n            else:\\n                self.vals.remove(el)\\n                self.sum -= el\\n            \\n            self.left.add(num)\\n            if len(self.left) > self.k or self.left[-1] > self.vals[0]:\\n                self.sum += self.left[-1]\\n                self.vals.add(self.left.pop(-1))\\n            if len(self.vals) > self.n or self.vals[-1] > self.right[0]:\\n                self.sum -= self.vals[-1]\\n                self.right.add(self.vals.pop(-1))\\n            if len(self.right) > self.k:\\n                self.sum += self.right[0]\\n                self.vals.add(self.right.pop(0))\\n            if len(self.vals) > self.n:\\n                self.sum -= self.vals[0]\\n                self.left.add(self.vals.pop(0))\\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.que) < self.m:\\n            return -1\\n        return self.sum//self.n\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.n = self.m - self.k - self.k\\n        self.que = deque()\\n        self.left = SortedList()\\n        self.right = SortedList()\\n        self.vals = []\\n        self.sum = 0\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.que) < self.m:\\n            self.que.append(num)\\n            self.vals.append(num)\\n\\n            if len(self.que) == self.m:\\n                self.vals.sort()\\n                self.left = SortedList(self.vals[:self.k])\\n                self.right = SortedList(self.vals[-self.k:])\\n                self.vals = SortedList(self.vals[self.k:-self.k])\\n                self.sum = sum(self.vals)\\n        else:\\n            self.que.append(num)\\n            el = self.que.popleft()\\n            \\n            if self.left[-1] >= el:\\n                self.left.remove(el)\\n            elif self.right[0] <= el:\\n                self.right.remove(el)\\n            else:\\n                self.vals.remove(el)\\n                self.sum -= el\\n            \\n            self.left.add(num)\\n            if len(self.left) > self.k or self.left[-1] > self.vals[0]:\\n                self.sum += self.left[-1]\\n                self.vals.add(self.left.pop(-1))\\n            if len(self.vals) > self.n or self.vals[-1] > self.right[0]:\\n                self.sum -= self.vals[-1]\\n                self.right.add(self.vals.pop(-1))\\n            if len(self.right) > self.k:\\n                self.sum += self.right[0]\\n                self.vals.add(self.right.pop(0))\\n            if len(self.vals) > self.n:\\n                self.sum -= self.vals[0]\\n                self.left.add(self.vals.pop(0))\\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.que) < self.m:\\n            return -1\\n        return self.sum//self.n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070115,
                "title": "javascript-splay-tree-780ms",
                "content": "```\\n////////////////////////// Template ////////////////////////////\\nclass SplayNode {\\n    constructor(value) {\\n        this.parent = null;\\n        this.left = null;\\n        this.right = null;\\n        this.val = value;\\n        this.sum = value;\\n        this.sz = 1;\\n    }\\n    update() {\\n        this.sz = (this.left != null ? this.left.sz : 0) + (this.right != null ? this.right.sz : 0) + 1;\\n        this.sum = (this.left != null ? this.left.sum : 0) + (this.right != null ? this.right.sum : 0) + this.val;\\n    }\\n    isLeft() {\\n        return this.parent != null && this.parent.left == this;\\n    }\\n    isRight() {\\n        return this.parent != null && this.parent.right == this;\\n    }\\n    isRoot(guard = null) {\\n        return this.parent == guard;\\n    }\\n}\\n\\n// MultiSet\\nclass SplayTree {\\n    constructor() {\\n        this.root = null;\\n        this.cmp = (x, y) => x >= y ? 0 : 1;\\n    }\\n    zig(x) { // right rotation\\n        let y = x.parent;\\n        if (x.right != null) x.right.parent = y;\\n        y.left = x.right;\\n        x.right = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }       \\n    zag(x) { // left rotation\\n        let y = x.parent;\\n        if (x.left != null) x.left.parent = y;\\n        y.right = x.left;\\n        x.left = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }\\n    zigzig(x) { // RR\\n        this.zig(x.parent);\\n        this.zig(x);\\n    }\\n    zigzag(x) { // RL\\n        this.zig(x);\\n        this.zag(x);\\n    }\\n    zagzag(x) { // LL\\n        this.zag(x.parent);\\n        this.zag(x);\\n    }\\n    zagzig(x) { // LR\\n        this.zag(x);\\n        this.zig(x);\\n    }\\n    splay(node, guard = null) { // splay a \"node\" just under a \"guard\", which is default to splay to the \"root\".\\n        while (!node.isRoot(guard)) {\\n            if (node.parent.isRoot(guard)) {\\n                if (node.isLeft()) {\\n                    this.zig(node);\\n                } else {\\n                    this.zag(node);\\n                }\\n            } else {\\n                if (node.parent.isLeft()) {\\n                    if (node.isLeft()) {\\n                        this.zigzig(node);\\n                    } else {\\n                        this.zagzig(node);\\n                    }\\n                } else {\\n                    if (node.isRight()) {\\n                        this.zagzag(node);\\n                    } else {\\n                        this.zigzag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root = node; // reset \"root\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.splay(x);\\n        let node = x.left;\\n        if (node == null) return null;\\n        while (node.right != null) node = node.right;\\n        this.splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.splay(x);\\n        let node = x.right;\\n        if (node == null) return null;\\n        while (node.left != null) node = node.left;\\n        this.splay(node);\\n        return node;\\n    }\\n    find(value) {\\n        return this.findFirstOf(value);\\n    }\\n    findFirstOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findLastOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findRankOf(node) {\\n        this.splay(node);\\n        return node.left == null ? 0 : node.left.sz;\\n    }\\n    findSuccessorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findPrecursorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(node.val, value)) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findKthNode(rank) {\\n        if (rank < 0 || rank >= this.size()) return null;\\n        let node = this.root;\\n        while (node != null) {\\n            let leftsize = node.left == null ? 0 : node.left.sz;\\n            if (leftsize == rank) break;\\n            if (leftsize > rank) {\\n                node = node.left;\\n            } else {\\n                rank -= leftsize + 1;\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    make(value) {\\n        return new SplayNode(value);\\n    }\\n    removeNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    insert(value) { // allow duplicates, tree nodes allow same value O(logN)\\n        if (this.root == null) {\\n            this.root = this.make(value);\\n            return this.root;\\n        }\\n        let node = this.root;\\n        while (node != null) {\\n            if (this.cmp(value, node.val)) {\\n                if (node.left == null) {\\n                    node.left = this.make(value);\\n                    node.left.parent = node;\\n                    node = node.left;\\n                    break;\\n                }\\n                node = node.left;\\n            } else {\\n                if (node.right == null) {\\n                    node.right = this.make(value);\\n                    node.right.parent = node;\\n                    node = node.right;\\n                    break;\\n                }\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    remove(value) { // remove one node, not remove all O(logN)\\n        let node = this.find(value);\\n        if (node == null) return false;\\n        this.splay(node);\\n        if (node.left == null) {\\n            this.root = node.right;\\n            if (node.right != null) node.right.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        if (node.right == null) {\\n            this.root = node.left;\\n            if (node.left != null) node.left.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.splay(last_node);\\n        this.splay(next_node, last_node);\\n        this.removeNode(next_node.left);\\n        next_node.left = null;\\n        next_node.update();\\n        last_node.update();\\n        return true;\\n    }\\n    has(value) { // O(logN)\\n        return this.count(value) > 0;\\n    }\\n    count(value) { // O(logN)\\n        let x = this.findFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.findRankOf(x);\\n        let y = this.findLastOf(value);\\n        let rank_y = this.findRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n    rankOf(value) { // The number of elements strictly less than value O(logN)\\n        let x = this.findPrecursorOf(value);\\n        return x == null ? 0 : this.findRankOf(x) + 1;\\n    }\\n    findKth(rank) { // (0-indexed) O(logN)\\n        let x = this.findKthNode(rank);\\n        return x == null ? null : (x.val);\\n    }\\n    higher(value) { // > upper_bound  O(logN)\\n        let node = this.findSuccessorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    lower(value) { // <  O(logN)\\n        let node = this.findPrecursorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    first() {\\n        return this.findKth(0);\\n    }\\n    last() {\\n        return this.findKth(this.size() - 1);\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    size() {\\n        return this.root == null ? 0 : this.root.sz;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() {  // Get sorted values in the splay tree O(n).\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nfunction MKAverage(m, k) {\\n    let a = [], tree = new SplayTree();\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        a.push(x);\\n        tree.insert(x);\\n        if (a.length > m) tree.remove(a[a.length - m - 1]);\\n    }\\n    function calculateMKAverage() {\\n        if (a.length < m) return -1;\\n        let res = tree.root.sum;\\n        let node = tree.findKthNode(k);\\n        if (node.left) res -= node.left.sum;\\n        node = tree.findKthNode(m - k - 1);\\n        if (node.right) res -= node.right.sum;\\n        return res / (m - 2 * k) >> 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n////////////////////////// Template ////////////////////////////\\nclass SplayNode {\\n    constructor(value) {\\n        this.parent = null;\\n        this.left = null;\\n        this.right = null;\\n        this.val = value;\\n        this.sum = value;\\n        this.sz = 1;\\n    }\\n    update() {\\n        this.sz = (this.left != null ? this.left.sz : 0) + (this.right != null ? this.right.sz : 0) + 1;\\n        this.sum = (this.left != null ? this.left.sum : 0) + (this.right != null ? this.right.sum : 0) + this.val;\\n    }\\n    isLeft() {\\n        return this.parent != null && this.parent.left == this;\\n    }\\n    isRight() {\\n        return this.parent != null && this.parent.right == this;\\n    }\\n    isRoot(guard = null) {\\n        return this.parent == guard;\\n    }\\n}\\n\\n// MultiSet\\nclass SplayTree {\\n    constructor() {\\n        this.root = null;\\n        this.cmp = (x, y) => x >= y ? 0 : 1;\\n    }\\n    zig(x) { // right rotation\\n        let y = x.parent;\\n        if (x.right != null) x.right.parent = y;\\n        y.left = x.right;\\n        x.right = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }       \\n    zag(x) { // left rotation\\n        let y = x.parent;\\n        if (x.left != null) x.left.parent = y;\\n        y.right = x.left;\\n        x.left = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }\\n    zigzig(x) { // RR\\n        this.zig(x.parent);\\n        this.zig(x);\\n    }\\n    zigzag(x) { // RL\\n        this.zig(x);\\n        this.zag(x);\\n    }\\n    zagzag(x) { // LL\\n        this.zag(x.parent);\\n        this.zag(x);\\n    }\\n    zagzig(x) { // LR\\n        this.zag(x);\\n        this.zig(x);\\n    }\\n    splay(node, guard = null) { // splay a \"node\" just under a \"guard\", which is default to splay to the \"root\".\\n        while (!node.isRoot(guard)) {\\n            if (node.parent.isRoot(guard)) {\\n                if (node.isLeft()) {\\n                    this.zig(node);\\n                } else {\\n                    this.zag(node);\\n                }\\n            } else {\\n                if (node.parent.isLeft()) {\\n                    if (node.isLeft()) {\\n                        this.zigzig(node);\\n                    } else {\\n                        this.zagzig(node);\\n                    }\\n                } else {\\n                    if (node.isRight()) {\\n                        this.zagzag(node);\\n                    } else {\\n                        this.zigzag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root = node; // reset \"root\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.splay(x);\\n        let node = x.left;\\n        if (node == null) return null;\\n        while (node.right != null) node = node.right;\\n        this.splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.splay(x);\\n        let node = x.right;\\n        if (node == null) return null;\\n        while (node.left != null) node = node.left;\\n        this.splay(node);\\n        return node;\\n    }\\n    find(value) {\\n        return this.findFirstOf(value);\\n    }\\n    findFirstOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findLastOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findRankOf(node) {\\n        this.splay(node);\\n        return node.left == null ? 0 : node.left.sz;\\n    }\\n    findSuccessorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findPrecursorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(node.val, value)) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findKthNode(rank) {\\n        if (rank < 0 || rank >= this.size()) return null;\\n        let node = this.root;\\n        while (node != null) {\\n            let leftsize = node.left == null ? 0 : node.left.sz;\\n            if (leftsize == rank) break;\\n            if (leftsize > rank) {\\n                node = node.left;\\n            } else {\\n                rank -= leftsize + 1;\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    make(value) {\\n        return new SplayNode(value);\\n    }\\n    removeNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    insert(value) { // allow duplicates, tree nodes allow same value O(logN)\\n        if (this.root == null) {\\n            this.root = this.make(value);\\n            return this.root;\\n        }\\n        let node = this.root;\\n        while (node != null) {\\n            if (this.cmp(value, node.val)) {\\n                if (node.left == null) {\\n                    node.left = this.make(value);\\n                    node.left.parent = node;\\n                    node = node.left;\\n                    break;\\n                }\\n                node = node.left;\\n            } else {\\n                if (node.right == null) {\\n                    node.right = this.make(value);\\n                    node.right.parent = node;\\n                    node = node.right;\\n                    break;\\n                }\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    remove(value) { // remove one node, not remove all O(logN)\\n        let node = this.find(value);\\n        if (node == null) return false;\\n        this.splay(node);\\n        if (node.left == null) {\\n            this.root = node.right;\\n            if (node.right != null) node.right.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        if (node.right == null) {\\n            this.root = node.left;\\n            if (node.left != null) node.left.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.splay(last_node);\\n        this.splay(next_node, last_node);\\n        this.removeNode(next_node.left);\\n        next_node.left = null;\\n        next_node.update();\\n        last_node.update();\\n        return true;\\n    }\\n    has(value) { // O(logN)\\n        return this.count(value) > 0;\\n    }\\n    count(value) { // O(logN)\\n        let x = this.findFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.findRankOf(x);\\n        let y = this.findLastOf(value);\\n        let rank_y = this.findRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n    rankOf(value) { // The number of elements strictly less than value O(logN)\\n        let x = this.findPrecursorOf(value);\\n        return x == null ? 0 : this.findRankOf(x) + 1;\\n    }\\n    findKth(rank) { // (0-indexed) O(logN)\\n        let x = this.findKthNode(rank);\\n        return x == null ? null : (x.val);\\n    }\\n    higher(value) { // > upper_bound  O(logN)\\n        let node = this.findSuccessorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    lower(value) { // <  O(logN)\\n        let node = this.findPrecursorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    first() {\\n        return this.findKth(0);\\n    }\\n    last() {\\n        return this.findKth(this.size() - 1);\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    size() {\\n        return this.root == null ? 0 : this.root.sz;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() {  // Get sorted values in the splay tree O(n).\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n}\\n///////////////////////////////////////////////////////////////\\n\\nfunction MKAverage(m, k) {\\n    let a = [], tree = new SplayTree();\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        a.push(x);\\n        tree.insert(x);\\n        if (a.length > m) tree.remove(a[a.length - m - 1]);\\n    }\\n    function calculateMKAverage() {\\n        if (a.length < m) return -1;\\n        let res = tree.root.sum;\\n        let node = tree.findKthNode(k);\\n        if (node.left) res -= node.left.sum;\\n        node = tree.findKthNode(m - k - 1);\\n        if (node.right) res -= node.right.sum;\\n        return res / (m - 2 * k) >> 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067705,
                "title": "use-sorted-containers-to-help-solving-this-problem",
                "content": "# Intuition & Approach\\nDivide array into 3 sorted arrays: `s1`, `s2` and `s3`; `s1` contains smallest k number, and `s3` contains largest k elements. Use `nums` to remember last m numbers.\\n\\n# Code\\n```\\nimport sortedcontainers\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.s1 = SortedList()\\n        self.s2 = SortedList()\\n        self.s3 = SortedList()\\n        self.nums = deque()\\n        self.sum = 0 # update sum of s2\\n        self.den = m - 2*k\\n\\n    def addElement(self, n: int) -> None:\\n        if len(self.nums) < self.m:\\n            self.s2.add(n)\\n            self.sum += n\\n            if len(self.s2) == self.m: # only enter this branch once, first time when length of nums up to m\\n                for i in range(self.k):\\n                    head = self.s2.pop(0)\\n                    tail = self.s2.pop()\\n                    self.s1.add(head)\\n                    self.s3.add(tail)\\n                    self.sum -= (head + tail)\\n        else: # move extra number to s2, keep s1 and s3 length == k\\n            if n <= self.s1[-1]:\\n                p = self.s1.pop()\\n                self.s2.add(p)\\n                self.sum += p\\n                self.s1.add(n)\\n            elif n >= self.s3[0]:\\n                p = self.s3.pop(0)\\n                self.s2.add(p)\\n                self.sum += p\\n                self.s3.add(n)\\n            else:\\n                self.s2.add(n)\\n                self.sum += n\\n            # delete the oldest number in self.nums\\n            d = self.nums.popleft()\\n            if d <= self.s1[-1]:\\n                self.s1.discard(d)\\n                p = self.s2.pop(0)\\n                self.sum -= p\\n                self.s1.add(p)\\n            elif d >= self.s3[0]:\\n                self.s3.discard(d)\\n                p = self.s2.pop()\\n                self.sum -= p\\n                self.s3.add(p)\\n            else:\\n                self.s2.discard(d)\\n                self.sum -= d\\n\\n        # add new number to self.nums\\n        self.nums.append(n)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.nums) < self.m:\\n            return -1\\n        return self.sum // self.den\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nimport sortedcontainers\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.s1 = SortedList()\\n        self.s2 = SortedList()\\n        self.s3 = SortedList()\\n        self.nums = deque()\\n        self.sum = 0 # update sum of s2\\n        self.den = m - 2*k\\n\\n    def addElement(self, n: int) -> None:\\n        if len(self.nums) < self.m:\\n            self.s2.add(n)\\n            self.sum += n\\n            if len(self.s2) == self.m: # only enter this branch once, first time when length of nums up to m\\n                for i in range(self.k):\\n                    head = self.s2.pop(0)\\n                    tail = self.s2.pop()\\n                    self.s1.add(head)\\n                    self.s3.add(tail)\\n                    self.sum -= (head + tail)\\n        else: # move extra number to s2, keep s1 and s3 length == k\\n            if n <= self.s1[-1]:\\n                p = self.s1.pop()\\n                self.s2.add(p)\\n                self.sum += p\\n                self.s1.add(n)\\n            elif n >= self.s3[0]:\\n                p = self.s3.pop(0)\\n                self.s2.add(p)\\n                self.sum += p\\n                self.s3.add(n)\\n            else:\\n                self.s2.add(n)\\n                self.sum += n\\n            # delete the oldest number in self.nums\\n            d = self.nums.popleft()\\n            if d <= self.s1[-1]:\\n                self.s1.discard(d)\\n                p = self.s2.pop(0)\\n                self.sum -= p\\n                self.s1.add(p)\\n            elif d >= self.s3[0]:\\n                self.s3.discard(d)\\n                p = self.s2.pop()\\n                self.sum -= p\\n                self.s3.add(p)\\n            else:\\n                self.s2.discard(d)\\n                self.sum -= d\\n\\n        # add new number to self.nums\\n        self.nums.append(n)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.nums) < self.m:\\n            return -1\\n        return self.sum // self.den\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067031,
                "title": "one-java-solution-follows-the-official-one",
                "content": "\\n# Complexity\\n- Time complexity: O\\uFF08n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MKAverage {\\n\\n    private int m;\\n    private int k;\\n    private int size = 0;\\n    private long sum = 0L;\\n\\n    private Queue<Integer> q = new ArrayDeque<>(m);\\n    private TreeMap<Integer, Integer> left = new TreeMap<>();\\n    private TreeMap<Integer, Integer> middle = new TreeMap<>();\\n    private TreeMap<Integer, Integer> right = new TreeMap<>();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n\\n    private void removeOne(TreeMap<Integer, Integer> map, int num) {\\n        Integer rmCount = map.get(num);\\n        if (rmCount.equals(1)) {\\n            map.remove(num);\\n        } else {\\n            map.put(num, rmCount - 1);\\n        }\\n    }\\n\\n    private void edgeFix(TreeMap<Integer, Integer> prev, TreeMap<Integer, Integer> next) {\\n        if (next.firstKey() < prev.lastKey()) {\\n            Integer nextKey = next.firstKey();\\n            Integer nextCount = next.get(nextKey);\\n            Integer prevKey = prev.lastKey();\\n            Integer prevCount = prev.get(prevKey);\\n            if (prevCount.equals(1)) {\\n                prev.remove(prevKey);\\n            } else {\\n                prev.put(prevKey, prevCount - 1);\\n            }\\n            prev.put(nextKey, prev.getOrDefault(nextKey, 0) + 1);\\n            if (nextCount.equals(1)) {\\n                next.remove(nextKey);\\n            } else {\\n                next.put(nextKey, nextCount - 1);\\n            }\\n            next.put(prevKey, next.getOrDefault(prevKey, 0) + 1);\\n            if (prev == middle) {\\n                sum = sum - prevKey + nextKey;\\n            }\\n            if (next == middle) {\\n                sum = sum - nextKey + prevKey;\\n            }\\n        }\\n    }\\n\\n    public void addElement(int num) {\\n        q.offer(num);\\n        // all full\\n        if (size == m) {\\n            Integer rm = q.poll();\\n            // remove and add the same value, no need to change\\n            if (rm == num) {\\n                return;\\n            }\\n            // the position of the value removed\\n            boolean removeLeft = false;\\n            boolean removeRight = false;\\n            TreeMap<Integer, Integer> rmMap = null;\\n            if (rm >= middle.firstKey() && rm <= middle.lastKey()) {\\n                removeOne(middle, rm);\\n                sum = sum - rm;\\n            } else if (rm <= left.lastKey()) {\\n                removeLeft = true;\\n                removeOne(left, rm);\\n            } else if (rm >= right.firstKey()) {\\n                removeRight = true;\\n                removeOne(right, rm);\\n            }\\n            // insert new value into middle first \\n            middle.put(num, middle.getOrDefault(num, 0) + 1);\\n            sum = sum + num;\\n            // update values\\n            if (removeLeft) {\\n                Integer moveKey = middle.firstKey();\\n                removeOne(middle, moveKey);\\n                sum = sum - moveKey;\\n                left.put(moveKey, left.getOrDefault(moveKey, 0) + 1);\\n                } else if (removeRight) {\\n                Integer moveKey = middle.lastKey();\\n                removeOne(middle, moveKey);\\n                sum = sum - moveKey;\\n                right.put(moveKey, right.getOrDefault(moveKey, 0) + 1);\\n            }\\n            edgeFix(middle, right);\\n            edgeFix(left, middle);\\n            return;\\n        }\\n        // if not full\\n        // left not full\\n        if (size < k) {\\n            left.put(num, left.getOrDefault(num, 0) + 1);\\n        } else {\\n            // left is full\\n            Integer maxLeft = left.lastKey();\\n            // num is in left\\n            if (num < maxLeft) {\\n                left.put(num, left.getOrDefault(num, 0) + 1);\\n                Integer maxLeftCount = left.get(maxLeft);\\n                if (maxLeftCount == 1) {\\n                    left.remove(maxLeft);\\n                } else {\\n                    left.put(maxLeft, maxLeftCount - 1);\\n                }\\n                num = maxLeft;\\n            }\\n            // right not full\\n            if (size < k + k) {\\n                right.put(num, right.getOrDefault(num, 0) + 1);\\n            } else {\\n                // num is in right\\n                Integer minRight = right.firstKey();\\n                if (num > minRight) {\\n                    right.put(num, right.getOrDefault(num, 0) + 1);\\n                    Integer minRightCount = right.get(minRight);\\n                    if (minRightCount == 1) {\\n                        right.remove(minRight);\\n                    } else {\\n                        right.put(minRight, minRightCount - 1);\\n                    }\\n                    num = minRight;\\n                }\\n                // middle is not full\\n                middle.put(num, middle.getOrDefault(num, 0) + 1);\\n                sum += num;\\n            }\\n        }\\n        size++;\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (size < m) {\\n            return -1;\\n        }\\n        return (int) (sum / (size - k - k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MKAverage {\\n\\n    private int m;\\n    private int k;\\n    private int size = 0;\\n    private long sum = 0L;\\n\\n    private Queue<Integer> q = new ArrayDeque<>(m);\\n    private TreeMap<Integer, Integer> left = new TreeMap<>();\\n    private TreeMap<Integer, Integer> middle = new TreeMap<>();\\n    private TreeMap<Integer, Integer> right = new TreeMap<>();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n\\n    private void removeOne(TreeMap<Integer, Integer> map, int num) {\\n        Integer rmCount = map.get(num);\\n        if (rmCount.equals(1)) {\\n            map.remove(num);\\n        } else {\\n            map.put(num, rmCount - 1);\\n        }\\n    }\\n\\n    private void edgeFix(TreeMap<Integer, Integer> prev, TreeMap<Integer, Integer> next) {\\n        if (next.firstKey() < prev.lastKey()) {\\n            Integer nextKey = next.firstKey();\\n            Integer nextCount = next.get(nextKey);\\n            Integer prevKey = prev.lastKey();\\n            Integer prevCount = prev.get(prevKey);\\n            if (prevCount.equals(1)) {\\n                prev.remove(prevKey);\\n            } else {\\n                prev.put(prevKey, prevCount - 1);\\n            }\\n            prev.put(nextKey, prev.getOrDefault(nextKey, 0) + 1);\\n            if (nextCount.equals(1)) {\\n                next.remove(nextKey);\\n            } else {\\n                next.put(nextKey, nextCount - 1);\\n            }\\n            next.put(prevKey, next.getOrDefault(prevKey, 0) + 1);\\n            if (prev == middle) {\\n                sum = sum - prevKey + nextKey;\\n            }\\n            if (next == middle) {\\n                sum = sum - nextKey + prevKey;\\n            }\\n        }\\n    }\\n\\n    public void addElement(int num) {\\n        q.offer(num);\\n        // all full\\n        if (size == m) {\\n            Integer rm = q.poll();\\n            // remove and add the same value, no need to change\\n            if (rm == num) {\\n                return;\\n            }\\n            // the position of the value removed\\n            boolean removeLeft = false;\\n            boolean removeRight = false;\\n            TreeMap<Integer, Integer> rmMap = null;\\n            if (rm >= middle.firstKey() && rm <= middle.lastKey()) {\\n                removeOne(middle, rm);\\n                sum = sum - rm;\\n            } else if (rm <= left.lastKey()) {\\n                removeLeft = true;\\n                removeOne(left, rm);\\n            } else if (rm >= right.firstKey()) {\\n                removeRight = true;\\n                removeOne(right, rm);\\n            }\\n            // insert new value into middle first \\n            middle.put(num, middle.getOrDefault(num, 0) + 1);\\n            sum = sum + num;\\n            // update values\\n            if (removeLeft) {\\n                Integer moveKey = middle.firstKey();\\n                removeOne(middle, moveKey);\\n                sum = sum - moveKey;\\n                left.put(moveKey, left.getOrDefault(moveKey, 0) + 1);\\n                } else if (removeRight) {\\n                Integer moveKey = middle.lastKey();\\n                removeOne(middle, moveKey);\\n                sum = sum - moveKey;\\n                right.put(moveKey, right.getOrDefault(moveKey, 0) + 1);\\n            }\\n            edgeFix(middle, right);\\n            edgeFix(left, middle);\\n            return;\\n        }\\n        // if not full\\n        // left not full\\n        if (size < k) {\\n            left.put(num, left.getOrDefault(num, 0) + 1);\\n        } else {\\n            // left is full\\n            Integer maxLeft = left.lastKey();\\n            // num is in left\\n            if (num < maxLeft) {\\n                left.put(num, left.getOrDefault(num, 0) + 1);\\n                Integer maxLeftCount = left.get(maxLeft);\\n                if (maxLeftCount == 1) {\\n                    left.remove(maxLeft);\\n                } else {\\n                    left.put(maxLeft, maxLeftCount - 1);\\n                }\\n                num = maxLeft;\\n            }\\n            // right not full\\n            if (size < k + k) {\\n                right.put(num, right.getOrDefault(num, 0) + 1);\\n            } else {\\n                // num is in right\\n                Integer minRight = right.firstKey();\\n                if (num > minRight) {\\n                    right.put(num, right.getOrDefault(num, 0) + 1);\\n                    Integer minRightCount = right.get(minRight);\\n                    if (minRightCount == 1) {\\n                        right.remove(minRight);\\n                    } else {\\n                        right.put(minRight, minRightCount - 1);\\n                    }\\n                    num = minRight;\\n                }\\n                // middle is not full\\n                middle.put(num, middle.getOrDefault(num, 0) + 1);\\n                sum += num;\\n            }\\n        }\\n        size++;\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (size < m) {\\n            return -1;\\n        }\\n        return (int) (sum / (size - k - k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061205,
                "title": "javascript-three-multiset-2721ms-splaytree-1063ms",
                "content": "reference:\\nhttps://leetcode.com/problems/finding-mk-average/solutions/1152724/c-balance-3-multisets/\\n```\\n/////////////////////// Template ////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction MultiSet(elements) {\\n    let a = [], m = new Map(), bi = new Bisect();\\n    initialize();\\n    return { insert, first, last, get, poll, pollLast, lower_bound, upper_bound, findKth, remove, removeAll, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const x of elements) {\\n                bi.insort_right(a, x);\\n                m.set(x, m.get(x) + 1 || 1);\\n            }\\n        }\\n    }\\n    function insert(x) {\\n        bi.insort_right(a, x);\\n        m.set(x, m.get(x) + 1 || 1);\\n    }\\n    function first() {\\n        return a[0];\\n    }\\n    function last() {\\n        return a[a.length - 1];\\n    }\\n    function get(i) {\\n        return a[i];\\n    }\\n    function poll() {\\n        let res = a[0];\\n        a.splice(0, 1);\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = a.pop();\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function lower_bound(x) {\\n        return bi.bisect_left(a, x);\\n    }\\n    function upper_bound(x) {\\n        return bi.bisect_right(a, x);\\n    }\\n    function findKth(k) {\\n        return a[k - 1];\\n    }\\n    function remove(x) {\\n        let idx = lower_bound(x);\\n        if (a[idx] == x) a.splice(idx, 1);\\n        removeOneOrManyMap(m, x);\\n    }\\n    function removeAll(x) {\\n        if (contains(x)) {\\n            let idx = search(x), occ = m.get(x);\\n            while (occ--) a.splice(idx, 1);\\n            m.delete(x);\\n        }\\n    }\\n    function removeOneOrManyMap(m, x, cnt = 1) {\\n        let occ = m.get(x);\\n        occ > cnt ? m.set(x, occ - cnt) : m.delete(x);\\n    }\\n    function contains(x) {\\n        return m.has(x);\\n    }\\n    function size() {\\n        return a.length;\\n    }\\n    function clear() {\\n        a = [];\\n        m.clear();\\n    }\\n    function show() {\\n        return a;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////\\nfunction MKAverage(m, k) {\\n    let L = new MultiSet(), R = new MultiSet(), M = new MultiSet(), a = [], sum = 0, pos = 0, sz = m - 2 * k;\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        add(x);\\n        if (pos >= m) remove(a[pos % m]);\\n        a[pos++ % m] = x;\\n    }\\n    function calculateMKAverage() {\\n        if (pos < m) return -1;\\n        return sum / sz >> 0;\\n    }\\n    function add(x) {\\n        L.insert(x);\\n        if (L.size() > k) {\\n            let v = L.last();\\n            M.insert(v);\\n            sum += v;\\n            L.remove(v);\\n        }\\n        if (M.size() > sz) {\\n            let v = M.last();\\n            sum -= v;\\n            R.insert(v);\\n            M.remove(v);\\n        }\\n    }\\n    function remove(x) {\\n        if (x <= L.last()) {\\n            L.remove(x);\\n        } else if (x <= M.last()) {\\n            sum -= x;\\n            M.remove(x);\\n        } else {\\n            R.remove(x);\\n        }\\n        if (L.size() < k) {\\n            let v = M.first();\\n            L.insert(v);\\n            sum -= v;\\n            M.poll();\\n        }\\n        if (M.size() < sz) {\\n            let v = R.first();\\n            M.insert(v);\\n            sum += v;\\n            R.poll();\\n        }\\n    }\\n}\\n```\\nuse splaytree instead of multiset\\n```\\nclass SplayNode {\\n    constructor(value) {\\n        this.parent = null;\\n        this.left = null;\\n        this.right = null;\\n        this.val = value;\\n        this.sum = value;\\n        this.sz = 1;\\n    }\\n    update() {\\n        this.sz = (this.left != null ? this.left.sz : 0) + (this.right != null ? this.right.sz : 0) + 1;\\n        this.sum = (this.left != null ? this.left.sum : 0) + (this.right != null ? this.right.sum : 0) + this.val;\\n    }\\n    isLeft() {\\n        return this.parent != null && this.parent.left == this;\\n    }\\n    isRight() {\\n        return this.parent != null && this.parent.right == this;\\n    }\\n    isRoot(guard = null) {\\n        return this.parent == guard;\\n    }\\n}\\n\\n// MultiSet\\nclass SplayTree {\\n    constructor() {\\n        this.root = null;\\n        this.cmp = (x, y) => x >= y ? 0 : 1;\\n    }\\n    zig(x) { // right rotation\\n        let y = x.parent;\\n        if (x.right != null) x.right.parent = y;\\n        y.left = x.right;\\n        x.right = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }       \\n    zag(x) { // left rotation\\n        let y = x.parent;\\n        if (x.left != null) x.left.parent = y;\\n        y.right = x.left;\\n        x.left = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }\\n    zigzig(x) { // RR\\n        this.zig(x.parent);\\n        this.zig(x);\\n    }\\n    zigzag(x) { // RL\\n        this.zig(x);\\n        this.zag(x);\\n    }\\n    zagzag(x) { // LL\\n        this.zag(x.parent);\\n        this.zag(x);\\n    }\\n    zagzig(x) { // LR\\n        this.zag(x);\\n        this.zig(x);\\n    }\\n    splay(node, guard = null) { // splay a \"node\" just under a \"guard\", which is default to splay to the \"root\".\\n        while (!node.isRoot(guard)) {\\n            if (node.parent.isRoot(guard)) {\\n                if (node.isLeft()) {\\n                    this.zig(node);\\n                } else {\\n                    this.zag(node);\\n                }\\n            } else {\\n                if (node.parent.isLeft()) {\\n                    if (node.isLeft()) {\\n                        this.zigzig(node);\\n                    } else {\\n                        this.zagzig(node);\\n                    }\\n                } else {\\n                    if (node.isRight()) {\\n                        this.zagzag(node);\\n                    } else {\\n                        this.zigzag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root = node; // reset \"root\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.splay(x);\\n        let node = x.left;\\n        if (node == null) return null;\\n        while (node.right != null) node = node.right;\\n        this.splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.splay(x);\\n        let node = x.right;\\n        if (node == null) return null;\\n        while (node.left != null) node = node.left;\\n        this.splay(node);\\n        return node;\\n    }\\n    find(value) {\\n        return this.findFirstOf(value);\\n    }\\n    findFirstOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findLastOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findRankOf(node) {\\n        this.splay(node);\\n        return node.left == null ? 0 : node.left.sz;\\n    }\\n    findSuccessorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findPrecursorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(node.val, value)) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findKthNode(rank) {\\n        if (rank < 0 || rank >= this.size()) return null;\\n        let node = this.root;\\n        while (node != null) {\\n            let leftsize = node.left == null ? 0 : node.left.sz;\\n            if (leftsize == rank) break;\\n            if (leftsize > rank) {\\n                node = node.left;\\n            } else {\\n                rank -= leftsize + 1;\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    make(value) {\\n        return new SplayNode(value);\\n    }\\n    removeNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    insert(value) { // allow duplicates, tree nodes allow same value O(logN)\\n        if (this.root == null) {\\n            this.root = this.make(value);\\n            return this.root;\\n        }\\n        let node = this.root;\\n        while (node != null) {\\n            if (this.cmp(value, node.val)) {\\n                if (node.left == null) {\\n                    node.left = this.make(value);\\n                    node.left.parent = node;\\n                    node = node.left;\\n                    break;\\n                }\\n                node = node.left;\\n            } else {\\n                if (node.right == null) {\\n                    node.right = this.make(value);\\n                    node.right.parent = node;\\n                    node = node.right;\\n                    break;\\n                }\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    remove(value) { // remove one node, not remove all O(logN)\\n        let node = this.find(value);\\n        if (node == null) return false;\\n        this.splay(node);\\n        if (node.left == null) {\\n            this.root = node.right;\\n            if (node.right != null) node.right.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        if (node.right == null) {\\n            this.root = node.left;\\n            if (node.left != null) node.left.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.splay(last_node);\\n        this.splay(next_node, last_node);\\n        this.removeNode(next_node.left);\\n        next_node.left = null;\\n        next_node.update();\\n        last_node.update();\\n        return true;\\n    }\\n    has(value) { // O(logN)\\n        return this.count(value) > 0;\\n    }\\n    count(value) { // O(logN)\\n        let x = this.findFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.findRankOf(x);\\n        let y = this.findLastOf(value);\\n        let rank_y = this.findRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n    rankOf(value) { // The number of elements strictly less than value O(logN)\\n        let x = this.findPrecursorOf(value);\\n        return x == null ? 0 : this.findRankOf(x) + 1;\\n    }\\n    findKth(rank) { // (0-indexed) O(logN)\\n        let x = this.findKthNode(rank);\\n        return x == null ? null : (x.val);\\n    }\\n    higher(value) { // > upper_bound  O(logN)\\n        let node = this.findSuccessorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    lower(value) { // <  O(logN)\\n        let node = this.findPrecursorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    first() {\\n        return this.findKth(0);\\n    }\\n    last() {\\n        return this.findKth(this.size() - 1);\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    size() {\\n        return this.root == null ? 0 : this.root.sz;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() {  // Get sorted values in the splay tree O(n).\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n}\\n\\nfunction MKAverage(m, k) {\\n    let L = new SplayTree(), R = new SplayTree(), M = new SplayTree(), a = [], sum = 0, pos = 0, sz = m - 2 * k;\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        add(x);\\n        if (pos >= m) remove(a[pos % m]);\\n        a[pos++ % m] = x;\\n    }\\n    function calculateMKAverage() {\\n        if (pos < m) return -1;\\n        return sum / sz >> 0;\\n    }\\n    function add(x) {\\n        L.insert(x);\\n        if (L.size() > k) {\\n            let v = L.last();\\n            M.insert(v);\\n            sum += v;\\n            L.remove(v);\\n        }\\n        if (M.size() > sz) {\\n            let v = M.last();\\n            sum -= v;\\n            R.insert(v);\\n            M.remove(v);\\n        }\\n    }\\n    function remove(x) {\\n        if (x <= L.last()) {\\n            L.remove(x);\\n        } else if (x <= M.last()) {\\n            sum -= x;\\n            M.remove(x);\\n        } else {\\n            R.remove(x);\\n        }\\n        if (L.size() < k) {\\n            let v = M.first();\\n            L.insert(v);\\n            sum -= v;\\n            M.poll();\\n        }\\n        if (M.size() < sz) {\\n            let v = R.first();\\n            M.insert(v);\\n            sum += v;\\n            R.poll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/////////////////////// Template ////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction MultiSet(elements) {\\n    let a = [], m = new Map(), bi = new Bisect();\\n    initialize();\\n    return { insert, first, last, get, poll, pollLast, lower_bound, upper_bound, findKth, remove, removeAll, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const x of elements) {\\n                bi.insort_right(a, x);\\n                m.set(x, m.get(x) + 1 || 1);\\n            }\\n        }\\n    }\\n    function insert(x) {\\n        bi.insort_right(a, x);\\n        m.set(x, m.get(x) + 1 || 1);\\n    }\\n    function first() {\\n        return a[0];\\n    }\\n    function last() {\\n        return a[a.length - 1];\\n    }\\n    function get(i) {\\n        return a[i];\\n    }\\n    function poll() {\\n        let res = a[0];\\n        a.splice(0, 1);\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = a.pop();\\n        removeOneOrManyMap(m, res);\\n        return res;\\n    }\\n    function lower_bound(x) {\\n        return bi.bisect_left(a, x);\\n    }\\n    function upper_bound(x) {\\n        return bi.bisect_right(a, x);\\n    }\\n    function findKth(k) {\\n        return a[k - 1];\\n    }\\n    function remove(x) {\\n        let idx = lower_bound(x);\\n        if (a[idx] == x) a.splice(idx, 1);\\n        removeOneOrManyMap(m, x);\\n    }\\n    function removeAll(x) {\\n        if (contains(x)) {\\n            let idx = search(x), occ = m.get(x);\\n            while (occ--) a.splice(idx, 1);\\n            m.delete(x);\\n        }\\n    }\\n    function removeOneOrManyMap(m, x, cnt = 1) {\\n        let occ = m.get(x);\\n        occ > cnt ? m.set(x, occ - cnt) : m.delete(x);\\n    }\\n    function contains(x) {\\n        return m.has(x);\\n    }\\n    function size() {\\n        return a.length;\\n    }\\n    function clear() {\\n        a = [];\\n        m.clear();\\n    }\\n    function show() {\\n        return a;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////\\nfunction MKAverage(m, k) {\\n    let L = new MultiSet(), R = new MultiSet(), M = new MultiSet(), a = [], sum = 0, pos = 0, sz = m - 2 * k;\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        add(x);\\n        if (pos >= m) remove(a[pos % m]);\\n        a[pos++ % m] = x;\\n    }\\n    function calculateMKAverage() {\\n        if (pos < m) return -1;\\n        return sum / sz >> 0;\\n    }\\n    function add(x) {\\n        L.insert(x);\\n        if (L.size() > k) {\\n            let v = L.last();\\n            M.insert(v);\\n            sum += v;\\n            L.remove(v);\\n        }\\n        if (M.size() > sz) {\\n            let v = M.last();\\n            sum -= v;\\n            R.insert(v);\\n            M.remove(v);\\n        }\\n    }\\n    function remove(x) {\\n        if (x <= L.last()) {\\n            L.remove(x);\\n        } else if (x <= M.last()) {\\n            sum -= x;\\n            M.remove(x);\\n        } else {\\n            R.remove(x);\\n        }\\n        if (L.size() < k) {\\n            let v = M.first();\\n            L.insert(v);\\n            sum -= v;\\n            M.poll();\\n        }\\n        if (M.size() < sz) {\\n            let v = R.first();\\n            M.insert(v);\\n            sum += v;\\n            R.poll();\\n        }\\n    }\\n}\\n```\n```\\nclass SplayNode {\\n    constructor(value) {\\n        this.parent = null;\\n        this.left = null;\\n        this.right = null;\\n        this.val = value;\\n        this.sum = value;\\n        this.sz = 1;\\n    }\\n    update() {\\n        this.sz = (this.left != null ? this.left.sz : 0) + (this.right != null ? this.right.sz : 0) + 1;\\n        this.sum = (this.left != null ? this.left.sum : 0) + (this.right != null ? this.right.sum : 0) + this.val;\\n    }\\n    isLeft() {\\n        return this.parent != null && this.parent.left == this;\\n    }\\n    isRight() {\\n        return this.parent != null && this.parent.right == this;\\n    }\\n    isRoot(guard = null) {\\n        return this.parent == guard;\\n    }\\n}\\n\\n// MultiSet\\nclass SplayTree {\\n    constructor() {\\n        this.root = null;\\n        this.cmp = (x, y) => x >= y ? 0 : 1;\\n    }\\n    zig(x) { // right rotation\\n        let y = x.parent;\\n        if (x.right != null) x.right.parent = y;\\n        y.left = x.right;\\n        x.right = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }       \\n    zag(x) { // left rotation\\n        let y = x.parent;\\n        if (x.left != null) x.left.parent = y;\\n        y.right = x.left;\\n        x.left = y;\\n        if (y.isLeft()) {\\n            y.parent.left = x;\\n        } else if (y.isRight()) {\\n            y.parent.right = x;\\n        }\\n        x.parent = y.parent;\\n        y.parent = x;\\n        y.update();\\n        x.update();\\n    }\\n    zigzig(x) { // RR\\n        this.zig(x.parent);\\n        this.zig(x);\\n    }\\n    zigzag(x) { // RL\\n        this.zig(x);\\n        this.zag(x);\\n    }\\n    zagzag(x) { // LL\\n        this.zag(x.parent);\\n        this.zag(x);\\n    }\\n    zagzig(x) { // LR\\n        this.zag(x);\\n        this.zig(x);\\n    }\\n    splay(node, guard = null) { // splay a \"node\" just under a \"guard\", which is default to splay to the \"root\".\\n        while (!node.isRoot(guard)) {\\n            if (node.parent.isRoot(guard)) {\\n                if (node.isLeft()) {\\n                    this.zig(node);\\n                } else {\\n                    this.zag(node);\\n                }\\n            } else {\\n                if (node.parent.isLeft()) {\\n                    if (node.isLeft()) {\\n                        this.zigzig(node);\\n                    } else {\\n                        this.zagzig(node);\\n                    }\\n                } else {\\n                    if (node.isRight()) {\\n                        this.zagzag(node);\\n                    } else {\\n                        this.zigzag(node);\\n                    }\\n                }\\n            }\\n        }\\n        if (guard == null) this.root = node; // reset \"root\" to \"node\".\\n    }\\n    LastNode(x) {\\n        this.splay(x);\\n        let node = x.left;\\n        if (node == null) return null;\\n        while (node.right != null) node = node.right;\\n        this.splay(node);\\n        return node;\\n    }\\n    NextNode(x) {\\n        this.splay(x);\\n        let node = x.right;\\n        if (node == null) return null;\\n        while (node.left != null) node = node.left;\\n        this.splay(node);\\n        return node;\\n    }\\n    find(value) {\\n        return this.findFirstOf(value);\\n    }\\n    findFirstOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findLastOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                node = node.left;\\n            } else if (this.cmp(node.val, value)) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findRankOf(node) {\\n        this.splay(node);\\n        return node.left == null ? 0 : node.left.sz;\\n    }\\n    findSuccessorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(value, node.val)) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findPrecursorOf(value) {\\n        let node = this.root, res = null, last_visited = null;\\n        while (node != null) {\\n            last_visited = node;\\n            if (this.cmp(node.val, value)) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        if (last_visited != null) this.splay(last_visited);\\n        return res;\\n    }\\n    findKthNode(rank) {\\n        if (rank < 0 || rank >= this.size()) return null;\\n        let node = this.root;\\n        while (node != null) {\\n            let leftsize = node.left == null ? 0 : node.left.sz;\\n            if (leftsize == rank) break;\\n            if (leftsize > rank) {\\n                node = node.left;\\n            } else {\\n                rank -= leftsize + 1;\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    make(value) {\\n        return new SplayNode(value);\\n    }\\n    removeNode(node) {\\n        node = null;\\n    }\\n\\n    // -------------------------------- Public Usage --------------------------------------\\n    insert(value) { // allow duplicates, tree nodes allow same value O(logN)\\n        if (this.root == null) {\\n            this.root = this.make(value);\\n            return this.root;\\n        }\\n        let node = this.root;\\n        while (node != null) {\\n            if (this.cmp(value, node.val)) {\\n                if (node.left == null) {\\n                    node.left = this.make(value);\\n                    node.left.parent = node;\\n                    node = node.left;\\n                    break;\\n                }\\n                node = node.left;\\n            } else {\\n                if (node.right == null) {\\n                    node.right = this.make(value);\\n                    node.right.parent = node;\\n                    node = node.right;\\n                    break;\\n                }\\n                node = node.right;\\n            }\\n        }\\n        this.splay(node);\\n        return node;\\n    }\\n    remove(value) { // remove one node, not remove all O(logN)\\n        let node = this.find(value);\\n        if (node == null) return false;\\n        this.splay(node);\\n        if (node.left == null) {\\n            this.root = node.right;\\n            if (node.right != null) node.right.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        if (node.right == null) {\\n            this.root = node.left;\\n            if (node.left != null) node.left.parent = null;\\n            this.removeNode(node);\\n            return true;\\n        }\\n        let last_node = this.LastNode(node);\\n        let next_node = this.NextNode(node);\\n        this.splay(last_node);\\n        this.splay(next_node, last_node);\\n        this.removeNode(next_node.left);\\n        next_node.left = null;\\n        next_node.update();\\n        last_node.update();\\n        return true;\\n    }\\n    has(value) { // O(logN)\\n        return this.count(value) > 0;\\n    }\\n    count(value) { // O(logN)\\n        let x = this.findFirstOf(value);\\n        if (x == null) return 0;\\n        let rank_x = this.findRankOf(x);\\n        let y = this.findLastOf(value);\\n        let rank_y = this.findRankOf(y);\\n        return rank_y - rank_x + 1;\\n    }\\n    rankOf(value) { // The number of elements strictly less than value O(logN)\\n        let x = this.findPrecursorOf(value);\\n        return x == null ? 0 : this.findRankOf(x) + 1;\\n    }\\n    findKth(rank) { // (0-indexed) O(logN)\\n        let x = this.findKthNode(rank);\\n        return x == null ? null : (x.val);\\n    }\\n    higher(value) { // > upper_bound  O(logN)\\n        let node = this.findSuccessorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    lower(value) { // <  O(logN)\\n        let node = this.findPrecursorOf(value);\\n        return node == null ? null : (node.val);\\n    }\\n    first() {\\n        return this.findKth(0);\\n    }\\n    last() {\\n        return this.findKth(this.size() - 1);\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    size() {\\n        return this.root == null ? 0 : this.root.sz;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() {  // Get sorted values in the splay tree O(n).\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n}\\n\\nfunction MKAverage(m, k) {\\n    let L = new SplayTree(), R = new SplayTree(), M = new SplayTree(), a = [], sum = 0, pos = 0, sz = m - 2 * k;\\n    return { addElement, calculateMKAverage }\\n    function addElement(x) {\\n        add(x);\\n        if (pos >= m) remove(a[pos % m]);\\n        a[pos++ % m] = x;\\n    }\\n    function calculateMKAverage() {\\n        if (pos < m) return -1;\\n        return sum / sz >> 0;\\n    }\\n    function add(x) {\\n        L.insert(x);\\n        if (L.size() > k) {\\n            let v = L.last();\\n            M.insert(v);\\n            sum += v;\\n            L.remove(v);\\n        }\\n        if (M.size() > sz) {\\n            let v = M.last();\\n            sum -= v;\\n            R.insert(v);\\n            M.remove(v);\\n        }\\n    }\\n    function remove(x) {\\n        if (x <= L.last()) {\\n            L.remove(x);\\n        } else if (x <= M.last()) {\\n            sum -= x;\\n            M.remove(x);\\n        } else {\\n            R.remove(x);\\n        }\\n        if (L.size() < k) {\\n            let v = M.first();\\n            L.insert(v);\\n            sum -= v;\\n            M.poll();\\n        }\\n        if (M.size() < sz) {\\n            let v = R.first();\\n            M.insert(v);\\n            sum += v;\\n            R.poll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019890,
                "title": "rust-btreemap-vecdeque",
                "content": "\\n# Approach\\nA deque (VecDeque) is used to keep track of the last m elements.\\nA BTreeMap stores the elements in the deque as keys and as value it has the number of occurences. \\n\\n# Complexity\\nFor the add_element method, the time complexity is O(1) since all operations are constant time. The space complexity is O(n) where n is the number of elements in the stream and sort data structures.\\n\\nFor the calculate_mk_average method, the time complexity is O(k) where k is the number of elements removed from the sorted copy of the stream. The space complexity is O(1) since no new data structures are created.\\n\\n# Code\\n```\\nuse std::collections::{VecDeque, BTreeMap};\\n#[allow(unused)]\\nstruct MKAverage {\\n\\n   // NOTE:\\n   // m -> number of elements of which to calcolate the average\\n   // k -> number of smaller and bigger elements to remove before averaging\\n   m: usize,\\n   k: usize,\\n   m_sum: i32,\\n   stream: VecDeque<i32>,\\n   sort: BTreeMap<i32, i32>, // if it was counting sort, K: index (num), V: occurrences\\n}\\n\\n/** \\n* `&self` means the method takes an immutable reference.\\n* If you need a mutable reference, change it to `&mut self` instead.\\n*/\\n#[allow(unused)]\\nimpl MKAverage {    \\n\\n    fn new(m: i32, k: i32) -> Self {\\n        \\n        MKAverage { \\n            m: m as usize, \\n            k: k as usize, \\n            m_sum: 0,\\n            stream: VecDeque::new(),\\n            sort: BTreeMap::new()\\n        }\\n    }\\n   \\n    fn add_element(&mut self, num: i32) {  // O(1)\\n        \\n        self.stream.push_back(num);\\n        *self.sort.entry(num).or_insert(0) += 1;\\n        self.m_sum += num;\\n        if self.stream.len() > self.m {\\n\\n            let rem = self.stream.pop_front().unwrap();\\n            *self.sort.get_mut(&rem).unwrap() -= 1;\\n            if self.sort.get(&rem).unwrap() == &0 { self.sort.remove(&rem); }\\n            self.m_sum -= rem;\\n        }\\n    }\\n    \\n    fn calculate_mk_average(& self) -> i32 {\\n        \\n        if self.stream.len() < self.m { return -1; }\\n\\n        // k smallest\\n        let mut k_sum = 0;\\n        let mut k_times = self.k;\\n        \\'label: for (num, count) in self.sort.iter().take(self.k) {\\n            for _ in 0..*count {\\n                k_sum += num;\\n                k_times -= 1;\\n                if k_times < 1 { break \\'label; }\\n            }\\n        }\\n    \\n        // Remove the largest k elements from the sorted copy\\n        k_times = self.k;\\n        \\'label2: for (num, count) in self.sort.iter().rev().take(self.k) {\\n            for _ in 0..*count {\\n                k_sum += num;\\n                k_times -= 1;\\n                if k_times < 1 { break \\'label2; }\\n            }\\n        }\\n\\n        // calc average\\n        let sum = self.m_sum - k_sum as i32;\\n        sum / (self.m - 2*self.k) as i32\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{VecDeque, BTreeMap};\\n#[allow(unused)]\\nstruct MKAverage {\\n\\n   // NOTE:\\n   // m -> number of elements of which to calcolate the average\\n   // k -> number of smaller and bigger elements to remove before averaging\\n   m: usize,\\n   k: usize,\\n   m_sum: i32,\\n   stream: VecDeque<i32>,\\n   sort: BTreeMap<i32, i32>, // if it was counting sort, K: index (num), V: occurrences\\n}\\n\\n/** \\n* `&self` means the method takes an immutable reference.\\n* If you need a mutable reference, change it to `&mut self` instead.\\n*/\\n#[allow(unused)]\\nimpl MKAverage {    \\n\\n    fn new(m: i32, k: i32) -> Self {\\n        \\n        MKAverage { \\n            m: m as usize, \\n            k: k as usize, \\n            m_sum: 0,\\n            stream: VecDeque::new(),\\n            sort: BTreeMap::new()\\n        }\\n    }\\n   \\n    fn add_element(&mut self, num: i32) {  // O(1)\\n        \\n        self.stream.push_back(num);\\n        *self.sort.entry(num).or_insert(0) += 1;\\n        self.m_sum += num;\\n        if self.stream.len() > self.m {\\n\\n            let rem = self.stream.pop_front().unwrap();\\n            *self.sort.get_mut(&rem).unwrap() -= 1;\\n            if self.sort.get(&rem).unwrap() == &0 { self.sort.remove(&rem); }\\n            self.m_sum -= rem;\\n        }\\n    }\\n    \\n    fn calculate_mk_average(& self) -> i32 {\\n        \\n        if self.stream.len() < self.m { return -1; }\\n\\n        // k smallest\\n        let mut k_sum = 0;\\n        let mut k_times = self.k;\\n        \\'label: for (num, count) in self.sort.iter().take(self.k) {\\n            for _ in 0..*count {\\n                k_sum += num;\\n                k_times -= 1;\\n                if k_times < 1 { break \\'label; }\\n            }\\n        }\\n    \\n        // Remove the largest k elements from the sorted copy\\n        k_times = self.k;\\n        \\'label2: for (num, count) in self.sort.iter().rev().take(self.k) {\\n            for _ in 0..*count {\\n                k_sum += num;\\n                k_times -= 1;\\n                if k_times < 1 { break \\'label2; }\\n            }\\n        }\\n\\n        // calc average\\n        let sum = self.m_sum - k_sum as i32;\\n        sum / (self.m - 2*self.k) as i32\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2916350,
                "title": "easy-c-solution-using-map-and-vector-97-faster",
                "content": "```\\nclass MKAverage {\\npublic:\\n    int m,k,c=0;\\n    vector<int> a;\\n    map<int,int> mm;\\n    MKAverage(int mm, int kk) {\\n        m=mm;\\n        k=kk;\\n        vector<int> aa(100001);\\n        a=aa;\\n    }\\n    \\n    void addElement(int num) {\\n        a[c]=num;\\n        mm[a[c]]++;\\n        if(c>m-1)                 // deleting the left out element\\n        {\\n            mm[a[c-m]]--;\\n            if(!mm[a[c-m]])\\n                mm.erase(mm.find(a[c-m]));\\n        }\\n        c++;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(c<m)\\n            return -1;\\n        int d=m-2*k;\\n        int s=0,ss=0;\\n        for(auto t: mm)\\n        {\\n\\t\\t    //adding for witing range [k,d+k] \\n            if(ss<k && ss+t.second>k+d)\\n                s+=(t.second-(k-ss)-(ss+t.second-(k+d)))*t.first;\\n            else if(ss>=k && ss+t.second>k+d)\\n                s+=(t.second-(ss+t.second-(k+d)))*t.first;\\n            else if(ss>=k && ss+t.second<=k+d)\\n                s+=t.second*t.first;\\n            else if(ss<k && ss+t.second>=k)\\n                s+=(t.second-(k-ss))*t.first;\\n            ss+=t.second;\\n            if(ss>=k+d)\\n                break;\\n        }\\n        return s/d;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MKAverage {\\npublic:\\n    int m,k,c=0;\\n    vector<int> a;\\n    map<int,int> mm;\\n    MKAverage(int mm, int kk) {\\n        m=mm;\\n        k=kk;\\n        vector<int> aa(100001);\\n        a=aa;\\n    }\\n    \\n    void addElement(int num) {\\n        a[c]=num;\\n        mm[a[c]]++;\\n        if(c>m-1)                 // deleting the left out element\\n        {\\n            mm[a[c-m]]--;\\n            if(!mm[a[c-m]])\\n                mm.erase(mm.find(a[c-m]));\\n        }\\n        c++;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(c<m)\\n            return -1;\\n        int d=m-2*k;\\n        int s=0,ss=0;\\n        for(auto t: mm)\\n        {\\n\\t\\t    //adding for witing range [k,d+k] \\n            if(ss<k && ss+t.second>k+d)\\n                s+=(t.second-(k-ss)-(ss+t.second-(k+d)))*t.first;\\n            else if(ss>=k && ss+t.second>k+d)\\n                s+=(t.second-(ss+t.second-(k+d)))*t.first;\\n            else if(ss>=k && ss+t.second<=k+d)\\n                s+=t.second*t.first;\\n            else if(ss<k && ss+t.second>=k)\\n                s+=(t.second-(k-ss))*t.first;\\n            ss+=t.second;\\n            if(ss>=k+d)\\n                break;\\n        }\\n        return s/d;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2851654,
                "title": "java-queue-treemap-explained-example",
                "content": "Haven\\'t seen this in the comments so I\\'ll just go ahead with some bullet points.\\n\\n* We need to be able to access the first and last k elements (of the last m elements) of the stream. If there was something as a SortedQueue in Java it would be cool, but there isn\\'t, so **TreeMap** was all I could come up with, in order to manage the repeated elements correctly. This TreeMap will preserve the natural order of the last m elements of the stream.\\n\\n\\n* We\\'re gonna keep track of the **totalSum** of the last m elements of the stream.\\n\\n* We need to keep the last m elements of the Stream. We\\'ll use a **queue** to do this. As soon as the queue has more than m elements, we push the first one out and subtract it from the total sum. We also reduce its count from the TreeMap (and delete the key if its count becomes 0).\\n\\n\\n* In order to subtract the first and last k elements, we literally just have to get that info from the TreeMap. In a SortedList, we would do an iteration for the first k and one for the last k, subtract the sum of those from the totalSum. Here we have to be more careful with how we advance through the keys, since they\\'re grouped by counts.\\n\\n* Next, just take the average, which is **(totalSum - sumOfExtremes) / (m - 2 * k)**\\n\\nExample:\\n\\n```\\nM = 5, K = 2\\nStream:\\n[17612, 74607, 8272, 33433, 8272, 64938, [Takes average], 99741]\\n\\nObserve, when the average is taken, our q is like\\nQ = [ 8272, 33433, 8272, 64938, 99741 ]\\n\\nOur Tree Map is (, in order):\\n[ 8272 --> 2, 33433 -> 1, 64938 --> 1, 99741 --> 1 ]\\n\\nGetting the sum of\\n* The first two elements: 8272 + 8272 = 16544\\n* The last two elements: 64938 + 99741 = 164679\\n\\nFinally getting the average:\\n\\n(totalSum - sumOfExtremes) / (m - 2*k) = (214656 - 181223) / (5 - 2 * 2) = 33433 / 1 = 33433\\n```\\n\\n\\nThis is not the fastest implementation but the one I first came up with. It\\'s giving me something between top 45% and top 80% regarding times.\\n\\n**Time Complexity:** **`O(NlogN)`**, N being the size of the stream.\\n**Space Complexity:** **`O(M)`**\\n\\n```\\nclass MKAverage {\\n\\n    private TreeMap<Integer, Integer> counts;\\n    private Deque<Integer> stream;\\n    private int m;\\n    private int k;\\n    private int totalSum = 0;\\n    private int totalSize = 0;\\n    \\n    \\n    public MKAverage(int m, int k) {\\n        counts = new TreeMap<>();\\n        stream = new LinkedList<>();\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        totalSum += num;\\n        totalSize++;\\n        stream.add(num);\\n        if (stream.size() > m) {\\n            Integer key = stream.removeFirst();\\n            counts.put(key, counts.get(key) - 1);\\n            totalSum -= key;\\n            if (counts.get(key) == 0) counts.remove(key);\\n        }\\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (totalSize < m) return -1;\\n        \\n        int key = counts.firstKey();\\n        int lastKey = counts.lastKey();\\n        int kSmall = k, kLarge = k;\\n\\n        int extremeSum = 0;\\n\\n        System.out.println(counts.toString());\\n        \\n        while (kSmall > 0) {\\n            int toSubtractSmall = Math.min(kSmall, counts.get(key));\\n            kSmall -= toSubtractSmall;\\n            extremeSum += key * toSubtractSmall;\\n            System.out.println(key + toSubtractSmall);\\n            if (toSubtractSmall == counts.get(key)) key = counts.higherKey(key);\\n        }\\n\\n        while (kLarge > 0) {\\n            int toSubtractLarge = Math.min(kLarge, counts.get(lastKey));\\n            kLarge -= toSubtractLarge;\\n            extremeSum += lastKey * toSubtractLarge;\\n            System.out.println(lastKey + toSubtractLarge);\\n            if (toSubtractLarge == counts.get(lastKey)) lastKey = counts.lowerKey(lastKey);\\n        }\\n        \\n        int ret = (totalSum - extremeSum) / (m - 2 * k);\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\nM = 5, K = 2\\nStream:\\n[17612, 74607, 8272, 33433, 8272, 64938, [Takes average], 99741]\\n\\nObserve, when the average is taken, our q is like\\nQ = [ 8272, 33433, 8272, 64938, 99741 ]\\n\\nOur Tree Map is (, in order):\\n[ 8272 --> 2, 33433 -> 1, 64938 --> 1, 99741 --> 1 ]\\n\\nGetting the sum of\\n* The first two elements: 8272 + 8272 = 16544\\n* The last two elements: 64938 + 99741 = 164679\\n\\nFinally getting the average:\\n\\n(totalSum - sumOfExtremes) / (m - 2*k) = (214656 - 181223) / (5 - 2 * 2) = 33433 / 1 = 33433\\n```\n```\\nclass MKAverage {\\n\\n    private TreeMap<Integer, Integer> counts;\\n    private Deque<Integer> stream;\\n    private int m;\\n    private int k;\\n    private int totalSum = 0;\\n    private int totalSize = 0;\\n    \\n    \\n    public MKAverage(int m, int k) {\\n        counts = new TreeMap<>();\\n        stream = new LinkedList<>();\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        totalSum += num;\\n        totalSize++;\\n        stream.add(num);\\n        if (stream.size() > m) {\\n            Integer key = stream.removeFirst();\\n            counts.put(key, counts.get(key) - 1);\\n            totalSum -= key;\\n            if (counts.get(key) == 0) counts.remove(key);\\n        }\\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (totalSize < m) return -1;\\n        \\n        int key = counts.firstKey();\\n        int lastKey = counts.lastKey();\\n        int kSmall = k, kLarge = k;\\n\\n        int extremeSum = 0;\\n\\n        System.out.println(counts.toString());\\n        \\n        while (kSmall > 0) {\\n            int toSubtractSmall = Math.min(kSmall, counts.get(key));\\n            kSmall -= toSubtractSmall;\\n            extremeSum += key * toSubtractSmall;\\n            System.out.println(key + toSubtractSmall);\\n            if (toSubtractSmall == counts.get(key)) key = counts.higherKey(key);\\n        }\\n\\n        while (kLarge > 0) {\\n            int toSubtractLarge = Math.min(kLarge, counts.get(lastKey));\\n            kLarge -= toSubtractLarge;\\n            extremeSum += lastKey * toSubtractLarge;\\n            System.out.println(lastKey + toSubtractLarge);\\n            if (toSubtractLarge == counts.get(lastKey)) lastKey = counts.lowerKey(lastKey);\\n        }\\n        \\n        int ret = (totalSum - extremeSum) / (m - 2 * k);\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849289,
                "title": "python-sortedlist-deque-explained",
                "content": "Deque just maintains order of elements coming in.\\nSortedList always keeps m latest elements.\\nWhile adding an element , while length of SortedList<m just keep adding.When first time length is m, take sum from k till m-k-1 indices of SortedList and store it in self.sum.\\nAt times when length of deque>=m , check indices of element to be removed (x) and to be added (num). If element to be removed lies in our required range (k, m-k-1) remove that element from sum, else if it lies to left side of range remove SortedList[l-1] else remove SortedList[r] from sum . Now while adding num again check index where it will be added , if that index is in our range add num to self.sum , else if index lies to left of l add  SortedList[l-1] else add SortedList[r] to sum.\\nFinally return self.sum divied by our range i.e. m-2*k if self.sum!=-1 else return -1.\\n\\nTime Complexity - O(op*log(n)) , where n is length of SortedList and op is total number of operations performed.\\n\\nCode (Python3) -> \\n\\n```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m=m\\n        self.k=k\\n        self.sl=SortedList()\\n        self.dq=deque()\\n        self.sum=-1\\n        \\n    def addElement(self, num: int) -> None:\\n        if len(self.dq)>=self.m:\\n            x=self.dq.popleft()\\n            idx_x=self.sl.bisect_left(x)\\n            self.sl.discard(x)\\n            idx_num=self.sl.bisect_left(num)\\n            l,r=self.k,self.m-self.k-1\\n            if l<=idx_x<=r:\\n                self.sum -= x\\n            elif idx_x<l:\\n                self.sum -= self.sl[l-1]\\n            else:\\n                self.sum -= self.sl[r]\\n            if l<=idx_num<=r:\\n                    self.sum += num\\n            elif idx_num<l:\\n                self.sum += self.sl[l-1]\\n            else:\\n                self.sum += self.sl[r]\\n        self.dq.append(num)\\n        self.sl.add(num)\\n        if self.sum==-1 and len(self.dq)==self.m:\\n            a,b=int(self.k),int(self.m-self.k)\\n            self.sum=0\\n            for i in range(a,b):\\n                self.sum+=self.sl[i]\\n\\n    def calculateMKAverage(self) -> int:\\n        return self.sum//(self.m-2*self.k) if self.sum>0 else -1\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m=m\\n        self.k=k\\n        self.sl=SortedList()\\n        self.dq=deque()\\n        self.sum=-1\\n        \\n    def addElement(self, num: int) -> None:\\n        if len(self.dq)>=self.m:\\n            x=self.dq.popleft()\\n            idx_x=self.sl.bisect_left(x)\\n            self.sl.discard(x)\\n            idx_num=self.sl.bisect_left(num)\\n            l,r=self.k,self.m-self.k-1\\n            if l<=idx_x<=r:\\n                self.sum -= x\\n            elif idx_x<l:\\n                self.sum -= self.sl[l-1]\\n            else:\\n                self.sum -= self.sl[r]\\n            if l<=idx_num<=r:\\n                    self.sum += num\\n            elif idx_num<l:\\n                self.sum += self.sl[l-1]\\n            else:\\n                self.sum += self.sl[r]\\n        self.dq.append(num)\\n        self.sl.add(num)\\n        if self.sum==-1 and len(self.dq)==self.m:\\n            a,b=int(self.k),int(self.m-self.k)\\n            self.sum=0\\n            for i in range(a,b):\\n                self.sum+=self.sl[i]\\n\\n    def calculateMKAverage(self) -> int:\\n        return self.sum//(self.m-2*self.k) if self.sum>0 else -1\\n\\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834688,
                "title": "clean-java-with-1-treemap",
                "content": "```List<Integer> stream``` to track the stream item in a list\\n```TreeMap<Integer,Integer>``` used as a multiset to handle duplicate\\n```size```  manage real size of the TreeMap container\\n\\n```\\nclass MKAverage {\\n    List<Integer> stream;\\n    TreeMap<Integer,Integer> container;\\n    int size;\\n    int m;\\n    int k;\\n\\n    public MKAverage(int m, int k) {\\n        stream = new ArrayList<>();\\n        container = new TreeMap<>();\\n        this.m = m;\\n        this.k = k;\\n        this.size = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        stream.add(num);\\n        if (size == m) {\\n            int item = stream.get(stream.size()-m);\\n            if (container.get(item) > 1) {\\n                container.put(item, container.get(item) - 1);\\n            } else {\\n                container.remove(item);\\n            }\\n            size--;\\n        }\\n        container.put(num, container.getOrDefault(num,0) + 1);\\n        size++;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (size < m) return -1;\\n        Iterator<Map.Entry<Integer,Integer>> itr = container.entrySet().iterator();\\n        int count = 0;\\n        Map.Entry<Integer,Integer> tmp = null;\\n        while(count < k) {\\n            tmp = itr.next();\\n            count += tmp.getValue();\\n        }\\n        \\n        int avgCount = m - (2*k);        \\n        int sum = 0;\\n        \\n        if (count > k) {    // add the excess item to the sum\\n            count -= k;\\n            sum = count * tmp.getKey();\\n            avgCount -= count;\\n        }\\n        \\n        count = 0;\\n        while (count < avgCount) {\\n            tmp = itr.next();\\n            sum += tmp.getKey() * tmp.getValue();\\n            count += tmp.getValue();\\n        }\\n        \\n        if (count > avgCount) {\\n            count -= avgCount;\\n            sum -= count * tmp.getKey(); // remove the excess item from the sum\\n        }\\n        \\n        return sum / (m - (2*k));        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```List<Integer> stream```\n```TreeMap<Integer,Integer>```\n```size```\n```\\nclass MKAverage {\\n    List<Integer> stream;\\n    TreeMap<Integer,Integer> container;\\n    int size;\\n    int m;\\n    int k;\\n\\n    public MKAverage(int m, int k) {\\n        stream = new ArrayList<>();\\n        container = new TreeMap<>();\\n        this.m = m;\\n        this.k = k;\\n        this.size = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        stream.add(num);\\n        if (size == m) {\\n            int item = stream.get(stream.size()-m);\\n            if (container.get(item) > 1) {\\n                container.put(item, container.get(item) - 1);\\n            } else {\\n                container.remove(item);\\n            }\\n            size--;\\n        }\\n        container.put(num, container.getOrDefault(num,0) + 1);\\n        size++;\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (size < m) return -1;\\n        Iterator<Map.Entry<Integer,Integer>> itr = container.entrySet().iterator();\\n        int count = 0;\\n        Map.Entry<Integer,Integer> tmp = null;\\n        while(count < k) {\\n            tmp = itr.next();\\n            count += tmp.getValue();\\n        }\\n        \\n        int avgCount = m - (2*k);        \\n        int sum = 0;\\n        \\n        if (count > k) {    // add the excess item to the sum\\n            count -= k;\\n            sum = count * tmp.getKey();\\n            avgCount -= count;\\n        }\\n        \\n        count = 0;\\n        while (count < avgCount) {\\n            tmp = itr.next();\\n            sum += tmp.getKey() * tmp.getValue();\\n            count += tmp.getValue();\\n        }\\n        \\n        if (count > avgCount) {\\n            count -= avgCount;\\n            sum -= count * tmp.getKey(); // remove the excess item from the sum\\n        }\\n        \\n        return sum / (m - (2*k));        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830600,
                "title": "c-ordered-set-queue",
                "content": "# Complexity\\n- Time complexity:\\n    - MKAverage(int m, int k): $$O(1)$$\\n\\n    - AddElement(int num):\\n        - count < m: $$O(1)$$\\n        - count == m: $$O(k + mlogm)$$\\n        - count > m: $$O(logm)$$\\n    - CalculateMKAverage(): $$O(1)$$\\n\\n- Space complexity: $$O(m)$$\\n\\n# Code\\n```\\npublic class MKAverage\\n{\\n    private readonly int m;\\n    private readonly int k;\\n\\n    private readonly Queue<int> q;\\n    private readonly List<int> stream;\\n\\n    private long sum;\\n    private long s1;\\n    private long s2;\\n\\n    public MKAverage(int m, int k)\\n    {\\n        this.m = m;\\n        this.k = k;\\n\\n        q = new Queue<int>();\\n        stream = new List<int>();\\n\\n        sum = 0;\\n        s1 = 0;\\n        s2 = 0;\\n    }\\n\\n    public void AddElement(int num)\\n    {\\n        q.Enqueue(num);\\n\\n        if (stream.Count < m)\\n        {\\n            stream.Add(num);\\n\\n            if (stream.Count == m)\\n            {\\n                stream.Sort();\\n\\n                for (int i = 0; i < k; i++)\\n                {\\n                    s1 += stream[i];\\n                    s2 += stream[m - 1 - i];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            InsertElement(num);\\n            DeleteElement();\\n        }\\n\\n        sum += num;\\n    }\\n\\n    private void InsertElement(int num)\\n    {\\n        int index = stream.BinarySearch(num);\\n        if (index < 0)\\n        {\\n            index = ~index;\\n        }\\n\\n        stream.Insert(index, num);\\n\\n        if (index < k)\\n        {\\n            s1 -= stream[k];\\n            s1 += num;\\n        }\\n        if (index > m - k)\\n        {\\n            s2 -= stream[m - k];\\n            s2 += num;\\n        }\\n    }\\n\\n    private void DeleteElement()\\n    {\\n        int num = q.Dequeue();\\n        int index = stream.BinarySearch(num);\\n\\n        if (index < k)\\n        {\\n            s1 += stream[k];\\n            s1 -= num;\\n        }\\n        if (index > m - k)\\n        {\\n            s2 += stream[m - k];\\n            s2 -= num;\\n        }\\n\\n        stream.RemoveAt(index);\\n        sum -= num;\\n    }\\n\\n    public int CalculateMKAverage()\\n    {\\n        if (stream.Count < m)\\n        {\\n            return -1;\\n        }\\n\\n        return (int)((sum - s1 - s2) / (m - 2 * k));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\npublic class MKAverage\\n{\\n    private readonly int m;\\n    private readonly int k;\\n\\n    private readonly Queue<int> q;\\n    private readonly List<int> stream;\\n\\n    private long sum;\\n    private long s1;\\n    private long s2;\\n\\n    public MKAverage(int m, int k)\\n    {\\n        this.m = m;\\n        this.k = k;\\n\\n        q = new Queue<int>();\\n        stream = new List<int>();\\n\\n        sum = 0;\\n        s1 = 0;\\n        s2 = 0;\\n    }\\n\\n    public void AddElement(int num)\\n    {\\n        q.Enqueue(num);\\n\\n        if (stream.Count < m)\\n        {\\n            stream.Add(num);\\n\\n            if (stream.Count == m)\\n            {\\n                stream.Sort();\\n\\n                for (int i = 0; i < k; i++)\\n                {\\n                    s1 += stream[i];\\n                    s2 += stream[m - 1 - i];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            InsertElement(num);\\n            DeleteElement();\\n        }\\n\\n        sum += num;\\n    }\\n\\n    private void InsertElement(int num)\\n    {\\n        int index = stream.BinarySearch(num);\\n        if (index < 0)\\n        {\\n            index = ~index;\\n        }\\n\\n        stream.Insert(index, num);\\n\\n        if (index < k)\\n        {\\n            s1 -= stream[k];\\n            s1 += num;\\n        }\\n        if (index > m - k)\\n        {\\n            s2 -= stream[m - k];\\n            s2 += num;\\n        }\\n    }\\n\\n    private void DeleteElement()\\n    {\\n        int num = q.Dequeue();\\n        int index = stream.BinarySearch(num);\\n\\n        if (index < k)\\n        {\\n            s1 += stream[k];\\n            s1 -= num;\\n        }\\n        if (index > m - k)\\n        {\\n            s2 += stream[m - k];\\n            s2 -= num;\\n        }\\n\\n        stream.RemoveAt(index);\\n        sum -= num;\\n    }\\n\\n    public int CalculateMKAverage()\\n    {\\n        if (stream.Count < m)\\n        {\\n            return -1;\\n        }\\n\\n        return (int)((sum - s1 - s2) / (m - 2 * k));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626938,
                "title": "python-2-approaches-using-segment-tree-accepted-using-sortedlist-tle",
                "content": "Using Segment Tree ( Accepted)\\n```\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.y=[]\\n        self.su=defaultdict(int)\\n        self.c=defaultdict(int)\\n        self.m=m\\n        self.k=k\\n    def addElement(self, num: int) -> None:\\n        self.y.append(num)\\n        m=self.m\\n        k=self.k\\n        def f(i=0,j=10**5):\\n            if abs(val)<i or abs(val)>j:return\\n            self.c[i,j]+=val_c\\n            self.su[i,j]+=val\\n            if i==j:return\\n            m=(i+j)//2\\n            f(i,m)\\n            f(m+1,j)\\n        val=num\\n        val_c=1\\n        f()\\n        if len(self.y)>=m+1:\\n            val=-self.y[-m-1]\\n            val_c=-1\\n            f()\\n    def calculateMKAverage(self) -> int:\\n        if len(self.y)<self.m:return -1\\n        m=self.m\\n        k=self.k\\n        def find(q,i=0,j=10**5):\\n            nonlocal ans\\n            #print(i,j,q,self.c[i,j])\\n            if self.c[i,j]==q:\\n                ans+=self.su[i,j]\\n                return\\n            if i==j:\\n                ans+=q*i\\n                return\\n            m=(i+j)//2\\n            a=self.c[i,m]\\n            if a!=0:\\n                find(min(q,a),i,m)\\n            if a<q:\\n                find(q-a,m+1,j)\\n        ans=0\\n        find(k)\\n        sum_k=ans\\n        ans=0\\n        find(m-k)\\n        return (ans - sum_k)//(m-2*k)\\n```\\n\\nUsing SortedList ( TLE ) \\n```\\nfrom sortedcontainers import SortedList as sl\\nclass MKAverage:\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.y=[]\\n        self.x=sl([])\\n        self.m=m\\n        self.k=k\\n        self.lk=self.rk=self.s=0\\n    def addElement(self, num: int) -> None:\\n        def binse(e):\\n            i=0\\n            j=len(x)-1\\n            while i<=j:\\n                m=(i+j)//2\\n                if x[m]==e:return m\\n                elif x[m]<e:\\n                    i=m+1\\n                else:\\n                    j=m-1\\n        x=self.x\\n        m=self.m\\n        k=self.k\\n        y=self.y\\n        y.append(num)\\n        self.s+=num\\n        if len(y)<m:return\\n        \\n        if len(y)==m:\\n            for i in range(m):\\n                self.x.add((y[i],i))\\n            self.lk=sum(x[i][0] for i in range(k))\\n            self.rk=sum(x[i][0] for i in range(len(y)-k,len(y)))\\n            \\n            #print(self.x,self.lk,self.rk)\\n            return \\n        \\n        a=y[-m-1]\\n        self.s-=a\\n        ind=binse((a,len(y)-m-1))\\n        #print(ind,len(x)-k)\\n        del self.x[ind]\\n        if ind<k:\\n            self.lk-=a\\n            self.lk+=x[k-1][0]\\n        elif ind>=len(x)+1-k:\\n            self.rk-=a\\n            self.rk+=x[len(x)-k][0]\\n#            print(\\'yes\\'end=\\' r \\')\\n        self.x.add((num,len(y)-1))\\n        ind=binse((num,len(y)-1))\\n        #print(ind,len(x)-k)\\n        if ind<k:\\n            self.lk-=x[k][0]\\n            self.lk+=num\\n        elif ind>=len(x)-k:\\n            self.rk-=x[len(x)-k-1][0]\\n            #print(\\'yes\\',end=\\' r \\')\\n            self.rk+=num\\n        #print(self.x,self.lk,self.rk,num)\\n            \\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.y)<self.m:return -1\\n        return (self.s-self.lk-self.rk)//(self.m-2*self.k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.y=[]\\n        self.su=defaultdict(int)\\n        self.c=defaultdict(int)\\n        self.m=m\\n        self.k=k\\n    def addElement(self, num: int) -> None:\\n        self.y.append(num)\\n        m=self.m\\n        k=self.k\\n        def f(i=0,j=10**5):\\n            if abs(val)<i or abs(val)>j:return\\n            self.c[i,j]+=val_c\\n            self.su[i,j]+=val\\n            if i==j:return\\n            m=(i+j)//2\\n            f(i,m)\\n            f(m+1,j)\\n        val=num\\n        val_c=1\\n        f()\\n        if len(self.y)>=m+1:\\n            val=-self.y[-m-1]\\n            val_c=-1\\n            f()\\n    def calculateMKAverage(self) -> int:\\n        if len(self.y)<self.m:return -1\\n        m=self.m\\n        k=self.k\\n        def find(q,i=0,j=10**5):\\n            nonlocal ans\\n            #print(i,j,q,self.c[i,j])\\n            if self.c[i,j]==q:\\n                ans+=self.su[i,j]\\n                return\\n            if i==j:\\n                ans+=q*i\\n                return\\n            m=(i+j)//2\\n            a=self.c[i,m]\\n            if a!=0:\\n                find(min(q,a),i,m)\\n            if a<q:\\n                find(q-a,m+1,j)\\n        ans=0\\n        find(k)\\n        sum_k=ans\\n        ans=0\\n        find(m-k)\\n        return (ans - sum_k)//(m-2*k)\\n```\n```\\nfrom sortedcontainers import SortedList as sl\\nclass MKAverage:\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.y=[]\\n        self.x=sl([])\\n        self.m=m\\n        self.k=k\\n        self.lk=self.rk=self.s=0\\n    def addElement(self, num: int) -> None:\\n        def binse(e):\\n            i=0\\n            j=len(x)-1\\n            while i<=j:\\n                m=(i+j)//2\\n                if x[m]==e:return m\\n                elif x[m]<e:\\n                    i=m+1\\n                else:\\n                    j=m-1\\n        x=self.x\\n        m=self.m\\n        k=self.k\\n        y=self.y\\n        y.append(num)\\n        self.s+=num\\n        if len(y)<m:return\\n        \\n        if len(y)==m:\\n            for i in range(m):\\n                self.x.add((y[i],i))\\n            self.lk=sum(x[i][0] for i in range(k))\\n            self.rk=sum(x[i][0] for i in range(len(y)-k,len(y)))\\n            \\n            #print(self.x,self.lk,self.rk)\\n            return \\n        \\n        a=y[-m-1]\\n        self.s-=a\\n        ind=binse((a,len(y)-m-1))\\n        #print(ind,len(x)-k)\\n        del self.x[ind]\\n        if ind<k:\\n            self.lk-=a\\n            self.lk+=x[k-1][0]\\n        elif ind>=len(x)+1-k:\\n            self.rk-=a\\n            self.rk+=x[len(x)-k][0]\\n#            print(\\'yes\\'end=\\' r \\')\\n        self.x.add((num,len(y)-1))\\n        ind=binse((num,len(y)-1))\\n        #print(ind,len(x)-k)\\n        if ind<k:\\n            self.lk-=x[k][0]\\n            self.lk+=num\\n        elif ind>=len(x)-k:\\n            self.rk-=x[len(x)-k-1][0]\\n            #print(\\'yes\\',end=\\' r \\')\\n            self.rk+=num\\n        #print(self.x,self.lk,self.rk,num)\\n            \\n            \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.y)<self.m:return -1\\n        return (self.s-self.lk-self.rk)//(self.m-2*self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612261,
                "title": "readable-java-clean-solution-with-treemaps-and-inline-comments",
                "content": "Modularized to prevent cursor manipulation mistakes.\\n\\n```\\nclass MKAverage {\\n    private final int M;\\n    private final int K;\\n\\n    private Queue<Integer> queue;\\n    private TreeMap<Integer, Integer> smallestK;\\n    private TreeMap<Integer, Integer> largestK;\\n    private TreeMap<Integer, Integer> middle;\\n    private int smallestKCount;\\n    private int largestKCount;\\n    private int middleSum;\\n\\n    public MKAverage(int m, int k) {\\n      this.M = m;\\n      this.K = k;\\n      this.queue = new LinkedList<>();\\n      this.smallestK = new TreeMap<>();\\n      this.largestK = new TreeMap<>();\\n      this.middle = new TreeMap<>();\\n    }\\n\\n    // O(log n)\\n    public void addElement(int num) {\\n      // Maintain size M\\n      // Remove first, since adding requires rebalancing anyway; safes extra rebalancing during deletion!\\n      if (queue.size() == M) {\\n        var evictNum = queue.poll();\\n\\n        if (smallestK.containsKey(evictNum)) {\\n          removeFromSmallestPile(evictNum);\\n        } else if (largestK.containsKey(evictNum)) {\\n          removeFromLargestPile(evictNum);\\n        } else {\\n          removeFromMiddle(evictNum);\\n        }\\n      }\\n\\n      queue.add(num);\\n      addToSmallestPile(num);\\n\\n      // smallest -> middle\\n      // Trade elements, so not smallest=[largest new], middle=[smaller], top=[larger]\\n      var tradeElem = smallestK.lastKey();\\n      removeFromSmallestPile(tradeElem);\\n      addToMiddle(tradeElem);\\n\\n      // If under sized, get it back from middle; otherwise stays, middle reservoir\\n      if (smallestKCount < K) {\\n        var smallest = middle.firstKey();\\n        removeFromMiddle(smallest);\\n        addToSmallestPile(smallest);\\n      }\\n\\n      // middle -> largest everytime\\n      // So new largest element can shift from middle to largest pile\\n      if (!middle.isEmpty()) {\\n        var largest = middle.lastKey();\\n        removeFromMiddle(largest);\\n        addToLargestPile(largest);\\n      }\\n\\n      // largest -> middle\\n      // Put back element to keep largest K size.\\n      if (largestKCount > K) {\\n        var smallest = largestK.firstKey();\\n        removeFromLargestPile(smallest);\\n        addToMiddle(smallest);\\n      }\\n    }\\n\\n    // O(1)\\n    public int calculateMKAverage() {\\n      if (queue.size() < M) {\\n        return -1;\\n      }\\n      return middleSum / (M - smallestKCount - largestKCount);\\n    }\\n\\n    private void addToSmallestPile(int num) {\\n      addElement(smallestK, num);\\n      smallestKCount++;\\n    }\\n\\n    private void addToLargestPile(int num) {\\n      addElement(largestK, num);\\n      largestKCount++;\\n    }\\n\\n    private void addToMiddle(int num) {\\n      addElement(middle, num);\\n      middleSum += num;\\n    }\\n\\n    private void removeFromSmallestPile(int evictNum) {\\n      removeElement(smallestK, evictNum);\\n      smallestKCount--;\\n    }\\n\\n    private void removeFromLargestPile(int evictNum) {\\n      removeElement(largestK, evictNum);\\n      largestKCount--;\\n    }\\n\\n    private void removeFromMiddle(int evictNum) {\\n      removeElement(middle, evictNum);\\n      middleSum -= evictNum;\\n    }\\n\\n    private void addElement(TreeMap<Integer, Integer> treeMap, int num) {\\n      var count = treeMap.getOrDefault(num, 0);\\n      treeMap.put(num, count + 1);\\n    }\\n\\n    private void removeElement(TreeMap<Integer, Integer> treeMap, int num) {\\n      var decremCount = treeMap.get(num) - 1;\\n\\n      if (decremCount == 0) {\\n        treeMap.remove(num);\\n      } else {\\n        treeMap.put(num, decremCount);\\n      }\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    private final int M;\\n    private final int K;\\n\\n    private Queue<Integer> queue;\\n    private TreeMap<Integer, Integer> smallestK;\\n    private TreeMap<Integer, Integer> largestK;\\n    private TreeMap<Integer, Integer> middle;\\n    private int smallestKCount;\\n    private int largestKCount;\\n    private int middleSum;\\n\\n    public MKAverage(int m, int k) {\\n      this.M = m;\\n      this.K = k;\\n      this.queue = new LinkedList<>();\\n      this.smallestK = new TreeMap<>();\\n      this.largestK = new TreeMap<>();\\n      this.middle = new TreeMap<>();\\n    }\\n\\n    // O(log n)\\n    public void addElement(int num) {\\n      // Maintain size M\\n      // Remove first, since adding requires rebalancing anyway; safes extra rebalancing during deletion!\\n      if (queue.size() == M) {\\n        var evictNum = queue.poll();\\n\\n        if (smallestK.containsKey(evictNum)) {\\n          removeFromSmallestPile(evictNum);\\n        } else if (largestK.containsKey(evictNum)) {\\n          removeFromLargestPile(evictNum);\\n        } else {\\n          removeFromMiddle(evictNum);\\n        }\\n      }\\n\\n      queue.add(num);\\n      addToSmallestPile(num);\\n\\n      // smallest -> middle\\n      // Trade elements, so not smallest=[largest new], middle=[smaller], top=[larger]\\n      var tradeElem = smallestK.lastKey();\\n      removeFromSmallestPile(tradeElem);\\n      addToMiddle(tradeElem);\\n\\n      // If under sized, get it back from middle; otherwise stays, middle reservoir\\n      if (smallestKCount < K) {\\n        var smallest = middle.firstKey();\\n        removeFromMiddle(smallest);\\n        addToSmallestPile(smallest);\\n      }\\n\\n      // middle -> largest everytime\\n      // So new largest element can shift from middle to largest pile\\n      if (!middle.isEmpty()) {\\n        var largest = middle.lastKey();\\n        removeFromMiddle(largest);\\n        addToLargestPile(largest);\\n      }\\n\\n      // largest -> middle\\n      // Put back element to keep largest K size.\\n      if (largestKCount > K) {\\n        var smallest = largestK.firstKey();\\n        removeFromLargestPile(smallest);\\n        addToMiddle(smallest);\\n      }\\n    }\\n\\n    // O(1)\\n    public int calculateMKAverage() {\\n      if (queue.size() < M) {\\n        return -1;\\n      }\\n      return middleSum / (M - smallestKCount - largestKCount);\\n    }\\n\\n    private void addToSmallestPile(int num) {\\n      addElement(smallestK, num);\\n      smallestKCount++;\\n    }\\n\\n    private void addToLargestPile(int num) {\\n      addElement(largestK, num);\\n      largestKCount++;\\n    }\\n\\n    private void addToMiddle(int num) {\\n      addElement(middle, num);\\n      middleSum += num;\\n    }\\n\\n    private void removeFromSmallestPile(int evictNum) {\\n      removeElement(smallestK, evictNum);\\n      smallestKCount--;\\n    }\\n\\n    private void removeFromLargestPile(int evictNum) {\\n      removeElement(largestK, evictNum);\\n      largestKCount--;\\n    }\\n\\n    private void removeFromMiddle(int evictNum) {\\n      removeElement(middle, evictNum);\\n      middleSum -= evictNum;\\n    }\\n\\n    private void addElement(TreeMap<Integer, Integer> treeMap, int num) {\\n      var count = treeMap.getOrDefault(num, 0);\\n      treeMap.put(num, count + 1);\\n    }\\n\\n    private void removeElement(TreeMap<Integer, Integer> treeMap, int num) {\\n      var decremCount = treeMap.get(num) - 1;\\n\\n      if (decremCount == 0) {\\n        treeMap.remove(num);\\n      } else {\\n        treeMap.put(num, decremCount);\\n      }\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418577,
                "title": "java-bit-tree-binary-search",
                "content": "```\\nclass MKAverage {\\n    long[] bit;\\n    int[] cnt;\\n    \\n    \\n    Queue<Integer> q = new LinkedList<>();\\n\\n    int M, K;\\n    \\n    private void add(int x, int delta) {\\n        for(; x < 100001; x = (x | (x + 1))) bit[x] += delta;\\n    }\\n    \\n    private long sum(int x) {\\n        long res = 0;\\n        for(; x >= 0; x = (x & (x + 1)) - 1) res += bit[x];\\n        return res;\\n    }\\n    \\n    private void add2(int x, int delta) {\\n        for(; x < 100001; x = (x | (x + 1))) cnt[x] += delta;\\n    }\\n    \\n    private int sum2(int x) {\\n        int res = 0;\\n        for(; x >= 0; x = (x & (x + 1)) - 1) res += cnt[x];\\n        return res;\\n    }\\n    \\n    public MKAverage(int m, int k) {\\n        M = m;\\n        K = k;\\n        bit = new long[100001];\\n        cnt = new int[100001];\\n    }\\n    \\n    public void addElement(int num) {\\n        if(q.size() == M) {\\n            int el = q.poll();\\n            add(el, -el);\\n            add2(el, -1);\\n        }\\n        q.add(num);\\n        add(num, num);\\n        add2(num, 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        int l = 1, r = 100000, mid = -1;\\n        if(q.size() < M) return -1;\\n        if(sum2(l) >= M - K) {\\n            return 1;\\n        }\\n        while(r - l > 1) {\\n            mid = r - (r - l) / 2;\\n            if(sum2(mid) >= M - K) {\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n        }\\n        int ll = l, rr = r;\\n        long minus = (long)(sum2(rr) - (M - K)) * rr;\\n        l = 1; r = 100000; mid = -1;\\n        if(sum2(l) >= K) {\\n            \\n            return (int)((sum(rr) - K * l - minus) / (M - 2 * K));\\n        }\\n        else {\\n            while(r - l > 1) {\\n                mid = r - (r - l) / 2;\\n                if(sum2(mid) >= K) {\\n                    r = mid;\\n                }\\n                else {\\n                    l = mid;\\n                }\\n            }\\n            long minus2 = (long)(K - sum2(l)) * r + sum(l);\\n            return (int)((sum(rr) - minus - minus2) / (M - 2 * K));\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    long[] bit;\\n    int[] cnt;\\n    \\n    \\n    Queue<Integer> q = new LinkedList<>();\\n\\n    int M, K;\\n    \\n    private void add(int x, int delta) {\\n        for(; x < 100001; x = (x | (x + 1))) bit[x] += delta;\\n    }\\n    \\n    private long sum(int x) {\\n        long res = 0;\\n        for(; x >= 0; x = (x & (x + 1)) - 1) res += bit[x];\\n        return res;\\n    }\\n    \\n    private void add2(int x, int delta) {\\n        for(; x < 100001; x = (x | (x + 1))) cnt[x] += delta;\\n    }\\n    \\n    private int sum2(int x) {\\n        int res = 0;\\n        for(; x >= 0; x = (x & (x + 1)) - 1) res += cnt[x];\\n        return res;\\n    }\\n    \\n    public MKAverage(int m, int k) {\\n        M = m;\\n        K = k;\\n        bit = new long[100001];\\n        cnt = new int[100001];\\n    }\\n    \\n    public void addElement(int num) {\\n        if(q.size() == M) {\\n            int el = q.poll();\\n            add(el, -el);\\n            add2(el, -1);\\n        }\\n        q.add(num);\\n        add(num, num);\\n        add2(num, 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        int l = 1, r = 100000, mid = -1;\\n        if(q.size() < M) return -1;\\n        if(sum2(l) >= M - K) {\\n            return 1;\\n        }\\n        while(r - l > 1) {\\n            mid = r - (r - l) / 2;\\n            if(sum2(mid) >= M - K) {\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n        }\\n        int ll = l, rr = r;\\n        long minus = (long)(sum2(rr) - (M - K)) * rr;\\n        l = 1; r = 100000; mid = -1;\\n        if(sum2(l) >= K) {\\n            \\n            return (int)((sum(rr) - K * l - minus) / (M - 2 * K));\\n        }\\n        else {\\n            while(r - l > 1) {\\n                mid = r - (r - l) / 2;\\n                if(sum2(mid) >= K) {\\n                    r = mid;\\n                }\\n                else {\\n                    l = mid;\\n                }\\n            }\\n            long minus2 = (long)(K - sum2(l)) * r + sum(l);\\n            return (int)((sum(rr) - minus - minus2) / (M - 2 * K));\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2377829,
                "title": "java-three-sets-and-a-map-faced-weird-hash-collision-problem",
                "content": "I ran into a weird problem while solving this. I wanted to use Pairs to store value and index. I ran into an issue where pairs having different hash values (but same keys) would collide and overwrite one another in a set. So I created a custom class. This likely slowed down the code. Anyone faced a similar issue.\\n\\nTry saving more than one Pair(x, y) in Tree where x > 127?\\n\\nAlgorithm:\\n1. We have three sorted sets, kLargest, kSmallest, remaining\\n2. We also use a map that will help us remove the oldest item\\n3. Since items of the same value can be repeated, we use the value in combination with an index (the order of items)\\n4. During Add we \\n\\n```\\nclass Item implements Comparable<Item> {\\n    private int key;\\n    private int val;\\n    \\n    public Item(int key, int val){\\n        this.key = key;\\n        this.val = val;\\n    }\\n    \\n    public int getKey(){\\n        return key;\\n    }\\n    \\n    public int getValue(){\\n        return val;\\n    }\\n    @Override \\n    public int compareTo(Item other){\\n        if (this.getKey() == other.getKey()) return this.getValue()-other.getValue();\\n        else return this.getKey() - other.getKey();\\n    }\\n    @Override\\n    public int hashCode() {\\n        return key*Integer.MAX_VALUE + val;\\n\\n    }\\n}\\nclass MKAverage {\\n    int k;\\n    int m;\\n    int i;\\n    int sum;\\n    \\n    TreeSet<Item> kSmallest = new TreeSet();\\n    TreeSet<Item> kLargest = new TreeSet();\\n    TreeSet<Item> q = new TreeSet();\\n    Map<Integer, Item> map = new HashMap();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        i++;\\n        Item item = new Item(num, i);\\n        map.put(i, item);\\n        \\n        if(i > m){\\n            Item oldestItem = map.remove(i-m);\\n            if (kLargest.contains(oldestItem)) kLargest.remove(oldestItem);\\n            if (kSmallest.contains(oldestItem)) kSmallest.remove(oldestItem);\\n            if (q.contains(oldestItem)) {\\n                q.remove(oldestItem);\\n                sum -= oldestItem.getKey();\\n            }\\n        }\\n        addElement(item);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (i < m) return -1;\\n        if (q.size() == 0) return 0;\\n        return sum/q.size();\\n    }\\n    \\n    private void addElement(Item item){\\n        q.add(item);\\n        sum += item.getKey();\\n        Item largest = null, smallest = null, p1 = null, p2 = null;\\n        \\n        largest = q.pollLast();\\n        sum -= largest.getKey();\\n        \\n        if(q.size() == 0) smallest = largest;\\n        else {\\n            smallest = q.pollFirst();\\n            sum -= smallest.getKey();\\n        }\\n        kLargest.add(largest);\\n        kSmallest.add(smallest);\\n        \\n        if (kLargest.size() > k) p1 = kLargest.pollFirst();\\n        if (kSmallest.size() > k) p2 = kSmallest.pollLast();\\n        \\n        if(p1 != null && !kSmallest.contains(p1)) {\\n            q.add(p1);\\n            sum += p1.getKey();\\n        }\\n        \\n        if(p2 != null && !kLargest.contains(p2) && p1 != p2) {\\n            q.add(p2);\\n            sum += p2.getKey();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Item implements Comparable<Item> {\\n    private int key;\\n    private int val;\\n    \\n    public Item(int key, int val){\\n        this.key = key;\\n        this.val = val;\\n    }\\n    \\n    public int getKey(){\\n        return key;\\n    }\\n    \\n    public int getValue(){\\n        return val;\\n    }\\n    @Override \\n    public int compareTo(Item other){\\n        if (this.getKey() == other.getKey()) return this.getValue()-other.getValue();\\n        else return this.getKey() - other.getKey();\\n    }\\n    @Override\\n    public int hashCode() {\\n        return key*Integer.MAX_VALUE + val;\\n\\n    }\\n}\\nclass MKAverage {\\n    int k;\\n    int m;\\n    int i;\\n    int sum;\\n    \\n    TreeSet<Item> kSmallest = new TreeSet();\\n    TreeSet<Item> kLargest = new TreeSet();\\n    TreeSet<Item> q = new TreeSet();\\n    Map<Integer, Item> map = new HashMap();\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        i++;\\n        Item item = new Item(num, i);\\n        map.put(i, item);\\n        \\n        if(i > m){\\n            Item oldestItem = map.remove(i-m);\\n            if (kLargest.contains(oldestItem)) kLargest.remove(oldestItem);\\n            if (kSmallest.contains(oldestItem)) kSmallest.remove(oldestItem);\\n            if (q.contains(oldestItem)) {\\n                q.remove(oldestItem);\\n                sum -= oldestItem.getKey();\\n            }\\n        }\\n        addElement(item);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (i < m) return -1;\\n        if (q.size() == 0) return 0;\\n        return sum/q.size();\\n    }\\n    \\n    private void addElement(Item item){\\n        q.add(item);\\n        sum += item.getKey();\\n        Item largest = null, smallest = null, p1 = null, p2 = null;\\n        \\n        largest = q.pollLast();\\n        sum -= largest.getKey();\\n        \\n        if(q.size() == 0) smallest = largest;\\n        else {\\n            smallest = q.pollFirst();\\n            sum -= smallest.getKey();\\n        }\\n        kLargest.add(largest);\\n        kSmallest.add(smallest);\\n        \\n        if (kLargest.size() > k) p1 = kLargest.pollFirst();\\n        if (kSmallest.size() > k) p2 = kSmallest.pollLast();\\n        \\n        if(p1 != null && !kSmallest.contains(p1)) {\\n            q.add(p1);\\n            sum += p1.getKey();\\n        }\\n        \\n        if(p2 != null && !kLargest.contains(p2) && p1 != p2) {\\n            q.add(p2);\\n            sum += p2.getKey();\\n        }\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376918,
                "title": "java-clean-solution-o-nlogn-fully-commented",
                "content": "```Java\\nclass MKAverage {\\n\\n    TreeMap<Integer, Integer>[] map = new TreeMap[3];\\n    Queue<Integer> queue = new ArrayDeque<>();\\n    int[] sum = new int[3];\\n    int[] cnt = new int[3];\\n    int m, k, L = 0, M = 1, R = 2, UP = 1, DOWN = -1;\\n    int[] store; // note that we can also use only 1 circular array of this instead of a queue + array\\n    public MKAverage(int m, int k) { // but I am leaving queue here for readability\\'s sake.\\n        this.m=m;\\n        this.k=k;\\n        store = new int[m];\\n        Arrays.setAll(map, o -> new TreeMap<>());\\n    }\\n\\n    public void addElement(int num) {\\n        if (queue.size() < m){ // initiate processing\\n            store[queue.size()]=num;\\n            queue.offer(num);\\n            if (queue.size()==m){\\n                Arrays.sort(store); // just sort it and put them into treemap\\n                for (int i = 0; i < m; i++){\\n                    int idx = i < k? L : i < m-k? M : R;\\n                    map[idx].merge(store[i], 1, Integer::sum);\\n                    cnt[idx]++;\\n                    sum[idx]+=store[i];\\n                }\\n            }\\n            return;\\n        } // everything below is when queue.size() >= m\\n        int del = queue.poll();\\n        int idx = pos(del), tmp = idx; // get delete element position and update sum & cnt array\\n        sum[idx] -= del;\\n        cnt[idx]--;\\n        idx = pos(num);\\n        queue.offer(num); // get insert element position and update sum & cnt array\\n        cnt[idx]++;\\n        sum[idx]+=num;\\n        map[idx].merge(num, 1, Integer::sum);\\n        if (cnt[R]>k) move(R, M, DOWN); // move all 4 directions to make sure they are balance\\n        if (cnt[L]<k) move(M, L, DOWN);\\n        if (cnt[R]<k) move(M, R, UP);\\n        if (cnt[L]>k) move(L, M, UP);\\n        if (map[tmp].merge(del, -1, Integer::sum) == 0){ // now remove the delete element.\\n            map[tmp].remove(del);\\n        }\\n    }\\n\\n    private void move(int F, int T, int D){ // F -> from, T -> to, D -> direction.\\n        int n = D == UP? map[F].lastKey() : map[F].firstKey();\\n        map[T].merge(n, 1, Integer::sum);\\n        if (map[F].merge(n, -1, Integer::sum) == 0){\\n            map[F].remove(n);\\n        }\\n        sum[F]-=n;\\n        sum[T]+=n;\\n        cnt[F]--;\\n        cnt[T]++;\\n    }\\n\\n    private int pos(int num){\\n        return  map[L].lastKey() >= num? L\\n            :   map[M].lastKey() >= num? M\\n            :   R;\\n    }\\n\\n    public int calculateMKAverage() {\\n        return queue.size() < m? -1 : sum[M]/cnt[M];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```Java\\nclass MKAverage {\\n\\n    TreeMap<Integer, Integer>[] map = new TreeMap[3];\\n    Queue<Integer> queue = new ArrayDeque<>();\\n    int[] sum = new int[3];\\n    int[] cnt = new int[3];\\n    int m, k, L = 0, M = 1, R = 2, UP = 1, DOWN = -1;\\n    int[] store; // note that we can also use only 1 circular array of this instead of a queue + array\\n    public MKAverage(int m, int k) { // but I am leaving queue here for readability\\'s sake.\\n        this.m=m;\\n        this.k=k;\\n        store = new int[m];\\n        Arrays.setAll(map, o -> new TreeMap<>());\\n    }\\n\\n    public void addElement(int num) {\\n        if (queue.size() < m){ // initiate processing\\n            store[queue.size()]=num;\\n            queue.offer(num);\\n            if (queue.size()==m){\\n                Arrays.sort(store); // just sort it and put them into treemap\\n                for (int i = 0; i < m; i++){\\n                    int idx = i < k? L : i < m-k? M : R;\\n                    map[idx].merge(store[i], 1, Integer::sum);\\n                    cnt[idx]++;\\n                    sum[idx]+=store[i];\\n                }\\n            }\\n            return;\\n        } // everything below is when queue.size() >= m\\n        int del = queue.poll();\\n        int idx = pos(del), tmp = idx; // get delete element position and update sum & cnt array\\n        sum[idx] -= del;\\n        cnt[idx]--;\\n        idx = pos(num);\\n        queue.offer(num); // get insert element position and update sum & cnt array\\n        cnt[idx]++;\\n        sum[idx]+=num;\\n        map[idx].merge(num, 1, Integer::sum);\\n        if (cnt[R]>k) move(R, M, DOWN); // move all 4 directions to make sure they are balance\\n        if (cnt[L]<k) move(M, L, DOWN);\\n        if (cnt[R]<k) move(M, R, UP);\\n        if (cnt[L]>k) move(L, M, UP);\\n        if (map[tmp].merge(del, -1, Integer::sum) == 0){ // now remove the delete element.\\n            map[tmp].remove(del);\\n        }\\n    }\\n\\n    private void move(int F, int T, int D){ // F -> from, T -> to, D -> direction.\\n        int n = D == UP? map[F].lastKey() : map[F].firstKey();\\n        map[T].merge(n, 1, Integer::sum);\\n        if (map[F].merge(n, -1, Integer::sum) == 0){\\n            map[F].remove(n);\\n        }\\n        sum[F]-=n;\\n        sum[T]+=n;\\n        cnt[F]--;\\n        cnt[T]++;\\n    }\\n\\n    private int pos(int num){\\n        return  map[L].lastKey() >= num? L\\n            :   map[M].lastKey() >= num? M\\n            :   R;\\n    }\\n\\n    public int calculateMKAverage() {\\n        return queue.size() < m? -1 : sum[M]/cnt[M];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357190,
                "title": "java-treemap-solution",
                "content": "```\\nclass MKAverage {\\n    int sum;\\n    int m;\\n    int k;\\n    Deque<Integer> queue;\\n    TreeMap<Integer, Integer> streamOrder;\\n    int total;\\n    \\n    public MKAverage(int m, int k) {\\n        streamOrder = new TreeMap<>();\\n        queue = new ArrayDeque();\\n        this.m = m;\\n        this.k = k;\\n        this.sum = 0;\\n        this.total = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        sum += num;\\n        queue.addLast(num);\\n        total++;\\n        streamOrder.put(num, streamOrder.getOrDefault(num, 0) + 1);\\n        \\n        if (total > m) {\\n            int last = queue.pollFirst();\\n            sum -= last;\\n            total--;\\n            streamOrder.put(last, streamOrder.get(last) - 1);\\n            \\n            if (streamOrder.get(last) == 0) {\\n                streamOrder.remove(last);\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (k > m || total < m) {\\n            return -1;\\n        }\\n            \\n        int toRemoveCount = k;\\n        int curTotal = sum;\\n        \\n        for (Map.Entry<Integer, Integer> entry : streamOrder.entrySet()) {\\n            int curRemoveCount = Math.min(entry.getValue(), toRemoveCount);\\n            curTotal -= curRemoveCount * entry.getKey();\\n            toRemoveCount -= curRemoveCount;\\n            \\n            if (toRemoveCount == 0)\\n                break;\\n        }\\n        \\n        toRemoveCount = k;\\n        \\n        for (Map.Entry<Integer, Integer> entry : streamOrder.descendingMap().entrySet()) {\\n            int curRemoveCount = Math.min(entry.getValue(), toRemoveCount);\\n            curTotal -= curRemoveCount * entry.getKey();\\n            toRemoveCount -= curRemoveCount;\\n            \\n            if (toRemoveCount == 0)\\n                break;\\n        }\\n        \\n        return curTotal/(total - 2 * k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    int sum;\\n    int m;\\n    int k;\\n    Deque<Integer> queue;\\n    TreeMap<Integer, Integer> streamOrder;\\n    int total;\\n    \\n    public MKAverage(int m, int k) {\\n        streamOrder = new TreeMap<>();\\n        queue = new ArrayDeque();\\n        this.m = m;\\n        this.k = k;\\n        this.sum = 0;\\n        this.total = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        sum += num;\\n        queue.addLast(num);\\n        total++;\\n        streamOrder.put(num, streamOrder.getOrDefault(num, 0) + 1);\\n        \\n        if (total > m) {\\n            int last = queue.pollFirst();\\n            sum -= last;\\n            total--;\\n            streamOrder.put(last, streamOrder.get(last) - 1);\\n            \\n            if (streamOrder.get(last) == 0) {\\n                streamOrder.remove(last);\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (k > m || total < m) {\\n            return -1;\\n        }\\n            \\n        int toRemoveCount = k;\\n        int curTotal = sum;\\n        \\n        for (Map.Entry<Integer, Integer> entry : streamOrder.entrySet()) {\\n            int curRemoveCount = Math.min(entry.getValue(), toRemoveCount);\\n            curTotal -= curRemoveCount * entry.getKey();\\n            toRemoveCount -= curRemoveCount;\\n            \\n            if (toRemoveCount == 0)\\n                break;\\n        }\\n        \\n        toRemoveCount = k;\\n        \\n        for (Map.Entry<Integer, Integer> entry : streamOrder.descendingMap().entrySet()) {\\n            int curRemoveCount = Math.min(entry.getValue(), toRemoveCount);\\n            curTotal -= curRemoveCount * entry.getKey();\\n            toRemoveCount -= curRemoveCount;\\n            \\n            if (toRemoveCount == 0)\\n                break;\\n        }\\n        \\n        return curTotal/(total - 2 * k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335432,
                "title": "python-segmenttree-solution-with-o-logn-complexity-for-updates-and-queries",
                "content": "This solution uses a deque (for O(1) operations for the moving average buffer) and a segment tree. The segment tree tracks the following two quantities:\\n* count[node] = number of active elements in the subtree rooted in node\\n* sum[node] = the sum of the active elements in the subtree rooted in node\\n\\nTo keep the values up to date, after each add/remove operation we apply the following recusion formulas on the way back from the recursive calls:\\n\\n```\\nself.count[node] = self.count[node*2] + self.count[node*2+1]\\nself.sum[node] = self.sum[node*2] + self.sum[node*2+1]\\n```\\n\\nThis makes sense since the count / sum of each subtree should be equal to the sum of the counts/subtrees in its children.\\n\\nFor the query operations, we need to compute (the sum of the first m-k elements) - (the sum of the first k elements). To compute each quantity we perform a depth search in the tree and decide to go left if there are sufficient active elements in the left subtree or add the sum of the left subtree to our solution and move down in the right subtree (after subtracting the elements found on the left).\\n\\n```\\nclass SegmentTree:\\n    def __init__(self, max_value: int):\\n        self.max_value = 1\\n        while max_value > 0:\\n            max_value //= 2\\n            self.max_value *= 2\\n            \\n        self.count = [0] * (2*self.max_value)\\n        self.sum = [0] * (2*self.max_value)\\n        \\n    def _update(self, left: int, right: int, node: int, num: int, cnt: int) -> None:\\n        if left == right:\\n            self.count[node] += cnt\\n            self.sum[node] += cnt * num\\n            return\\n        \\n        middle = (left + right) // 2\\n        if num <= middle:\\n            self._update(left, middle, node*2, num, cnt)\\n        else:\\n            self._update(middle+1, right, node*2+1, num, cnt)\\n            \\n        self.count[node] = self.count[node*2] + self.count[node*2+1]\\n        self.sum[node] = self.sum[node*2] + self.sum[node*2+1]\\n        \\n    def add(self, num: int) -> None:\\n        self._update(left=1, right=self.max_value, node=1, num=num, cnt=1)\\n        \\n    def remove(self, num: int) -> None:\\n        self._update(left=1, right=self.max_value, node=1, num=num, cnt=-1)\\n        \\n    def _query(self, left: int, right: int, node: int, target: int) -> int:\\n        if left == right:\\n            return self.sum[node] // self.count[node] * target\\n        \\n        middle = (left + right) // 2\\n        if target <= self.count[node*2]:\\n            return self._query(left, middle, node*2, target)\\n        else:\\n            return self.sum[node*2] + self._query(middle+1, right, node*2+1, target-self.count[node*2])\\n        \\n    def query(self, target: int) -> int:\\n        if target == 0:\\n            return 0\\n        \\n        return self._query(left=1, right=self.max_value, node=1, target=target)\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.buffer_size = m\\n        self.offset = k\\n        self.buffer = collections.deque()\\n        self.tree = SegmentTree(100_000)\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.buffer) == self.buffer_size:\\n            value = self.buffer.popleft()\\n            self.tree.remove(value)\\n            \\n        self.buffer.append(num)\\n        self.tree.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.buffer) < self.buffer_size:\\n            return -1\\n        \\n        return (self.tree.query(self.buffer_size - self.offset) - self.tree.query(self.offset)) // (self.buffer_size - 2*self.offset)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nself.count[node] = self.count[node*2] + self.count[node*2+1]\\nself.sum[node] = self.sum[node*2] + self.sum[node*2+1]\\n```\n```\\nclass SegmentTree:\\n    def __init__(self, max_value: int):\\n        self.max_value = 1\\n        while max_value > 0:\\n            max_value //= 2\\n            self.max_value *= 2\\n            \\n        self.count = [0] * (2*self.max_value)\\n        self.sum = [0] * (2*self.max_value)\\n        \\n    def _update(self, left: int, right: int, node: int, num: int, cnt: int) -> None:\\n        if left == right:\\n            self.count[node] += cnt\\n            self.sum[node] += cnt * num\\n            return\\n        \\n        middle = (left + right) // 2\\n        if num <= middle:\\n            self._update(left, middle, node*2, num, cnt)\\n        else:\\n            self._update(middle+1, right, node*2+1, num, cnt)\\n            \\n        self.count[node] = self.count[node*2] + self.count[node*2+1]\\n        self.sum[node] = self.sum[node*2] + self.sum[node*2+1]\\n        \\n    def add(self, num: int) -> None:\\n        self._update(left=1, right=self.max_value, node=1, num=num, cnt=1)\\n        \\n    def remove(self, num: int) -> None:\\n        self._update(left=1, right=self.max_value, node=1, num=num, cnt=-1)\\n        \\n    def _query(self, left: int, right: int, node: int, target: int) -> int:\\n        if left == right:\\n            return self.sum[node] // self.count[node] * target\\n        \\n        middle = (left + right) // 2\\n        if target <= self.count[node*2]:\\n            return self._query(left, middle, node*2, target)\\n        else:\\n            return self.sum[node*2] + self._query(middle+1, right, node*2+1, target-self.count[node*2])\\n        \\n    def query(self, target: int) -> int:\\n        if target == 0:\\n            return 0\\n        \\n        return self._query(left=1, right=self.max_value, node=1, target=target)\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.buffer_size = m\\n        self.offset = k\\n        self.buffer = collections.deque()\\n        self.tree = SegmentTree(100_000)\\n\\n    def addElement(self, num: int) -> None:\\n        if len(self.buffer) == self.buffer_size:\\n            value = self.buffer.popleft()\\n            self.tree.remove(value)\\n            \\n        self.buffer.append(num)\\n        self.tree.add(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.buffer) < self.buffer_size:\\n            return -1\\n        \\n        return (self.tree.query(self.buffer_size - self.offset) - self.tree.query(self.offset)) // (self.buffer_size - 2*self.offset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328925,
                "title": "c-3xmultiset-and-queue",
                "content": "Not ideal (too many lines of code)... \\n\\n```\\nclass MKAverage {\\npublic:\\n    const int M, K;\\n\\n    queue<int> last;\\n    multiset<int> smallest;\\n    multiset<int> middle;\\n    multiset<int> largest;\\n    long long S;\\n    \\n    \\n    MKAverage(int m, int k) : M(m), K(k), S(0) {\\n        \\n    }\\n    \\n    void balance() {\\n        while (largest.size() > K) {\\n            int val = *largest.begin();\\n            largest.erase(largest.begin());\\n            middle.insert(val);\\n            S += val;\\n        }\\n        while (smallest.size() > K) {\\n            auto it = prev(smallest.end());\\n            int val = *it;\\n            smallest.erase(it);\\n            middle.insert(val);\\n            S += val;\\n        }        \\n        while (smallest.size() < K) {\\n            int val = *middle.begin();\\n            middle.erase(middle.begin());\\n            S -= val;\\n            smallest.insert(val);\\n        }\\n        while (largest.size() < K) {\\n            int val = *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n            S -= val;\\n            largest.insert(val);\\n        }\\n    }\\n    \\n    void removeElement(int num) {\\n        if (auto it = largest.find(num); it != largest.end())\\n            largest.erase(it);\\n        else if (auto it = middle.find(num); it != middle.end()) \\n            middle.erase(it), S -= num;\\n         else if (auto it = smallest.find(num); it != smallest.end())\\n             smallest.erase(it);\\n    }\\n    \\n    void addElement(int num) {\\n        last.push(num);\\n        \\n        if (largest.empty() || num >= *largest.begin()) {\\n            largest.insert(num);\\n        } else if (middle.empty() || num >= *middle.begin()) {\\n            middle.insert(num);\\n            S += num;\\n        } else\\n            smallest.insert(num);\\n        \\n        if (last.size() > M) {\\n            int rval = last.front();\\n            last.pop();\\n            removeElement(rval);\\n        }\\n        \\n        if (last.size() >= M)\\n            balance();\\n    }\\n    \\n    int calculateMKAverage() {\\n        return last.size() < M ? -1 : S/middle.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n    const int M, K;\\n\\n    queue<int> last;\\n    multiset<int> smallest;\\n    multiset<int> middle;\\n    multiset<int> largest;\\n    long long S;\\n    \\n    \\n    MKAverage(int m, int k) : M(m), K(k), S(0) {\\n        \\n    }\\n    \\n    void balance() {\\n        while (largest.size() > K) {\\n            int val = *largest.begin();\\n            largest.erase(largest.begin());\\n            middle.insert(val);\\n            S += val;\\n        }\\n        while (smallest.size() > K) {\\n            auto it = prev(smallest.end());\\n            int val = *it;\\n            smallest.erase(it);\\n            middle.insert(val);\\n            S += val;\\n        }        \\n        while (smallest.size() < K) {\\n            int val = *middle.begin();\\n            middle.erase(middle.begin());\\n            S -= val;\\n            smallest.insert(val);\\n        }\\n        while (largest.size() < K) {\\n            int val = *prev(middle.end());\\n            middle.erase(prev(middle.end()));\\n            S -= val;\\n            largest.insert(val);\\n        }\\n    }\\n    \\n    void removeElement(int num) {\\n        if (auto it = largest.find(num); it != largest.end())\\n            largest.erase(it);\\n        else if (auto it = middle.find(num); it != middle.end()) \\n            middle.erase(it), S -= num;\\n         else if (auto it = smallest.find(num); it != smallest.end())\\n             smallest.erase(it);\\n    }\\n    \\n    void addElement(int num) {\\n        last.push(num);\\n        \\n        if (largest.empty() || num >= *largest.begin()) {\\n            largest.insert(num);\\n        } else if (middle.empty() || num >= *middle.begin()) {\\n            middle.insert(num);\\n            S += num;\\n        } else\\n            smallest.insert(num);\\n        \\n        if (last.size() > M) {\\n            int rval = last.front();\\n            last.pop();\\n            removeElement(rval);\\n        }\\n        \\n        if (last.size() >= M)\\n            balance();\\n    }\\n    \\n    int calculateMKAverage() {\\n        return last.size() < M ? -1 : S/middle.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285138,
                "title": "python3-without-sortedlist-module",
                "content": "```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.stream = collections.deque()\\n        self.sorted = []\\n        \\n        self.m = m\\n        self.k = k\\n        self.denom = m-2*k\\n        \\n        self.S = self.ksmallest = self.klargest = 0\\n        self.first_m = 1\\n        \\n    def addElement(self, num: int) -> None:\\n        \\n        m = self.m; k = self.k\\n        flag = -1\\n        if len(self.sorted) == m:\\n            popped = self.stream.popleft()\\n            index1 = bisect.bisect_left(self.sorted, popped)\\n            if index1 < k:\\n                flag = 0\\n                self.ksmallest += -popped\\n            elif k <= index1 <m-k:\\n                flag = 1\\n                pass\\n            elif m-k <= index1:\\n                flag = 2\\n                self.klargest += -popped\\n            self.sorted.pop(index1)\\n            self.S += -popped\\n            \\n            index2 = bisect.bisect_right(self.sorted, num)\\n            self.sorted.insert(index2, num)\\n            if flag == 0:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2]\\n                elif k <= index2 < m-k:\\n                    self.ksmallest += self.sorted[k-1]\\n                elif m-k <= index2:\\n                    self.ksmallest += self.sorted[k-1]\\n                    self.klargest += self.sorted[index2] - self.sorted[m-k-1]\\n            elif flag == 1:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2] - self.sorted[k]\\n                elif k <= index2 < m-k:\\n                    pass\\n                elif m-k <= index2:\\n                    self.klargest += self.sorted[index2] - self.sorted[m-k-1]\\n            elif flag == 2:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2] - self.sorted[k]\\n                    self.klargest += self.sorted[m-k]\\n                elif k <= index2 < m-k:\\n                    self.klargest += self.sorted[m-k]\\n                elif m-k <= index2:\\n                    self.klargest += self.sorted[index2]\\n            #self.sorted.pop(index)\\n        \\n        self.stream.append(num)\\n        self.S += num\\n        if flag == -1:\\n            bisect.insort_left(self.sorted, num)\\n        \\n        \\n        if len(self.sorted) == m and self.first_m:\\n            self.first_m = 0\\n            self.ksmallest = sum(self.sorted[:k])\\n            self.klargest = sum(self.sorted[m-k:])\\n        \\n    def calculateMKAverage(self) -> int:\\n        if len(self.sorted) < self.m:\\n            return -1\\n        return (self.S - self.ksmallest - self.klargest)//self.denom\\n    \\n\"\"\"\\na a b b b c c c\\n          k     m-k\\n          v     v\\n    * a a b b b c c c\\n    a * a b b b c c c\\n    a a * b b b c c c\\n\\n    a a b * b b c c c\\n    a a b b * b c c c\\n    a a b b b * c c c\\n    \\n    a a b b b c * c c\\n    a a b b b c c * c\\n    a a b b b c c c *\\n\\na a a b b c c c\\n    * a a a b b c c c\\n    a * a a b b c c c\\n    a a * a b b c c c\\n    \\n    a a a * b b c c c\\n    a a a b * b c c c\\n    a a a b b * c c c\\n    \\n    a a a b b c * c c\\n    a a a b b c c * c\\n    a a a b b c c c *\\n\\na a a b b b c c\\n    * a a a b b b c c\\n    a * a a b b b c c\\n    a a * a b b b c c\\n    \\n    a a a * b b b c c\\n    a a a b * b b c c\\n    a a a b b * b c c\\n    \\n    a a a b b b * c c\\n    a a a b b b c * c\\n    a a a b b b c c *\\n\"\"\"",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.stream = collections.deque()\\n        self.sorted = []\\n        \\n        self.m = m\\n        self.k = k\\n        self.denom = m-2*k\\n        \\n        self.S = self.ksmallest = self.klargest = 0\\n        self.first_m = 1\\n        \\n    def addElement(self, num: int) -> None:\\n        \\n        m = self.m; k = self.k\\n        flag = -1\\n        if len(self.sorted) == m:\\n            popped = self.stream.popleft()\\n            index1 = bisect.bisect_left(self.sorted, popped)\\n            if index1 < k:\\n                flag = 0\\n                self.ksmallest += -popped\\n            elif k <= index1 <m-k:\\n                flag = 1\\n                pass\\n            elif m-k <= index1:\\n                flag = 2\\n                self.klargest += -popped\\n            self.sorted.pop(index1)\\n            self.S += -popped\\n            \\n            index2 = bisect.bisect_right(self.sorted, num)\\n            self.sorted.insert(index2, num)\\n            if flag == 0:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2]\\n                elif k <= index2 < m-k:\\n                    self.ksmallest += self.sorted[k-1]\\n                elif m-k <= index2:\\n                    self.ksmallest += self.sorted[k-1]\\n                    self.klargest += self.sorted[index2] - self.sorted[m-k-1]\\n            elif flag == 1:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2] - self.sorted[k]\\n                elif k <= index2 < m-k:\\n                    pass\\n                elif m-k <= index2:\\n                    self.klargest += self.sorted[index2] - self.sorted[m-k-1]\\n            elif flag == 2:\\n                if index2 < k:\\n                    self.ksmallest += self.sorted[index2] - self.sorted[k]\\n                    self.klargest += self.sorted[m-k]\\n                elif k <= index2 < m-k:\\n                    self.klargest += self.sorted[m-k]\\n                elif m-k <= index2:\\n                    self.klargest += self.sorted[index2]\\n            #self.sorted.pop(index)\\n        \\n        self.stream.append(num)\\n        self.S += num\\n        if flag == -1:\\n            bisect.insort_left(self.sorted, num)\\n        \\n        \\n        if len(self.sorted) == m and self.first_m:\\n            self.first_m = 0\\n            self.ksmallest = sum(self.sorted[:k])\\n            self.klargest = sum(self.sorted[m-k:])\\n        \\n    def calculateMKAverage(self) -> int:\\n        if len(self.sorted) < self.m:\\n            return -1\\n        return (self.S - self.ksmallest - self.klargest)//self.denom\\n    \\n\"\"\"\\na a b b b c c c\\n          k     m-k\\n          v     v\\n    * a a b b b c c c\\n    a * a b b b c c c\\n    a a * b b b c c c\\n\\n    a a b * b b c c c\\n    a a b b * b c c c\\n    a a b b b * c c c\\n    \\n    a a b b b c * c c\\n    a a b b b c c * c\\n    a a b b b c c c *\\n\\na a a b b c c c\\n    * a a a b b c c c\\n    a * a a b b c c c\\n    a a * a b b c c c\\n    \\n    a a a * b b c c c\\n    a a a b * b c c c\\n    a a a b b * c c c\\n    \\n    a a a b b c * c c\\n    a a a b b c c * c\\n    a a a b b c c c *\\n\\na a a b b b c c\\n    * a a a b b b c c\\n    a * a a b b b c c\\n    a a * a b b b c c\\n    \\n    a a a * b b b c c\\n    a a a b * b b c c\\n    a a a b b * b c c\\n    \\n    a a a b b b * c c\\n    a a a b b b c * c\\n    a a a b b b c c *\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2265548,
                "title": "java-treemap-deque-99-fast-low-memory-messy-code",
                "content": "```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    int sum;\\n    int count;\\n    TreeMap<Integer, Integer> treeMap;\\n    int left; // value of kth smallest num \\n    int leftPtr; // count of `left` equivalent nums in the k smallest nums \\n    int right;\\n    int rightPtr;\\n    Deque<Integer> dq;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n        this.sum=0;\\n        this.count=0;\\n        treeMap = new TreeMap<>();\\n        left=0;\\n        leftPtr=k;\\n        right=0;\\n        rightPtr=k;\\n        dq=new LinkedList<>();\\n    }\\n    \\n    public void addElement(int num) {\\n        if(count<m){\\n            sum+=num;\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n            dq.add(num);\\n            count++;\\n            \\n            if(count==m){\\n                for(Map.Entry<Integer, Integer> entry: treeMap.entrySet()){\\n                    if(leftPtr-entry.getValue()<=0){\\n                        left = entry.getKey();\\n                        sum-=entry.getKey()*leftPtr;\\n                        break;\\n                    } else {\\n                        leftPtr-=entry.getValue();\\n                        sum-=entry.getKey()*entry.getValue();\\n                    }\\n                }\\n                \\n                for(Map.Entry<Integer, Integer> entry: treeMap.descendingMap().entrySet()){\\n                    if(rightPtr-entry.getValue()<=0){\\n                        right = entry.getKey();\\n                        sum-=entry.getKey()*rightPtr;\\n                        break;\\n                    } else {\\n                        rightPtr-=entry.getValue();\\n                        sum-=entry.getKey()*entry.getValue();\\n                    }\\n                }\\n            }\\n        } else {\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n            dq.add(num);\\n            if(num<left){\\n                leftPtr--;\\n                sum+=left;\\n                if(leftPtr==0){\\n                    left=treeMap.lowerKey(left);\\n                    leftPtr=treeMap.get(left);\\n                }\\n            }else if(num>right){\\n                rightPtr--;\\n                sum+=right;\\n                if(rightPtr==0){\\n                    right=treeMap.higherKey(right);\\n                    rightPtr=treeMap.get(right);\\n                }\\n            } else {\\n                sum+=num;\\n            }\\n            \\n            int prevNum = dq.pollFirst();\\n            if(treeMap.get(prevNum)==1) treeMap.remove(prevNum);\\n            else treeMap.put(prevNum, treeMap.get(prevNum)-1);\\n            \\n            if(prevNum==left){\\n                if(!treeMap.containsKey(prevNum)||treeMap.get(left)<leftPtr){\\n                    left=treeMap.higherKey(left);\\n                    leftPtr=1;\\n                }\\n                sum-=left;\\n            } else if(prevNum<left){\\n                leftPtr++;\\n                if(treeMap.get(left)<leftPtr){\\n                    left=treeMap.higherKey(left);\\n                    leftPtr=1;\\n                }\\n                sum-=left;\\n            } else if(prevNum==right){\\n                if(!treeMap.containsKey(prevNum)||treeMap.get(right)<leftPtr){\\n                    right=treeMap.lowerKey(right);\\n                    rightPtr=1;\\n                }\\n                sum-=right;\\n            } else if(prevNum>right){\\n                rightPtr++;\\n                if(treeMap.get(right)<rightPtr){\\n                    right=treeMap.lowerKey(right);\\n                    rightPtr=1;\\n                }\\n                sum-=right;\\n            } else {\\n                sum-=prevNum;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(count<m)return -1;\\n        return sum/(m-2*k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    int sum;\\n    int count;\\n    TreeMap<Integer, Integer> treeMap;\\n    int left; // value of kth smallest num \\n    int leftPtr; // count of `left` equivalent nums in the k smallest nums \\n    int right;\\n    int rightPtr;\\n    Deque<Integer> dq;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m=m;\\n        this.k=k;\\n        this.sum=0;\\n        this.count=0;\\n        treeMap = new TreeMap<>();\\n        left=0;\\n        leftPtr=k;\\n        right=0;\\n        rightPtr=k;\\n        dq=new LinkedList<>();\\n    }\\n    \\n    public void addElement(int num) {\\n        if(count<m){\\n            sum+=num;\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n            dq.add(num);\\n            count++;\\n            \\n            if(count==m){\\n                for(Map.Entry<Integer, Integer> entry: treeMap.entrySet()){\\n                    if(leftPtr-entry.getValue()<=0){\\n                        left = entry.getKey();\\n                        sum-=entry.getKey()*leftPtr;\\n                        break;\\n                    } else {\\n                        leftPtr-=entry.getValue();\\n                        sum-=entry.getKey()*entry.getValue();\\n                    }\\n                }\\n                \\n                for(Map.Entry<Integer, Integer> entry: treeMap.descendingMap().entrySet()){\\n                    if(rightPtr-entry.getValue()<=0){\\n                        right = entry.getKey();\\n                        sum-=entry.getKey()*rightPtr;\\n                        break;\\n                    } else {\\n                        rightPtr-=entry.getValue();\\n                        sum-=entry.getKey()*entry.getValue();\\n                    }\\n                }\\n            }\\n        } else {\\n            treeMap.put(num, treeMap.getOrDefault(num, 0)+1);\\n            dq.add(num);\\n            if(num<left){\\n                leftPtr--;\\n                sum+=left;\\n                if(leftPtr==0){\\n                    left=treeMap.lowerKey(left);\\n                    leftPtr=treeMap.get(left);\\n                }\\n            }else if(num>right){\\n                rightPtr--;\\n                sum+=right;\\n                if(rightPtr==0){\\n                    right=treeMap.higherKey(right);\\n                    rightPtr=treeMap.get(right);\\n                }\\n            } else {\\n                sum+=num;\\n            }\\n            \\n            int prevNum = dq.pollFirst();\\n            if(treeMap.get(prevNum)==1) treeMap.remove(prevNum);\\n            else treeMap.put(prevNum, treeMap.get(prevNum)-1);\\n            \\n            if(prevNum==left){\\n                if(!treeMap.containsKey(prevNum)||treeMap.get(left)<leftPtr){\\n                    left=treeMap.higherKey(left);\\n                    leftPtr=1;\\n                }\\n                sum-=left;\\n            } else if(prevNum<left){\\n                leftPtr++;\\n                if(treeMap.get(left)<leftPtr){\\n                    left=treeMap.higherKey(left);\\n                    leftPtr=1;\\n                }\\n                sum-=left;\\n            } else if(prevNum==right){\\n                if(!treeMap.containsKey(prevNum)||treeMap.get(right)<leftPtr){\\n                    right=treeMap.lowerKey(right);\\n                    rightPtr=1;\\n                }\\n                sum-=right;\\n            } else if(prevNum>right){\\n                rightPtr++;\\n                if(treeMap.get(right)<rightPtr){\\n                    right=treeMap.lowerKey(right);\\n                    rightPtr=1;\\n                }\\n                sum-=right;\\n            } else {\\n                sum-=prevNum;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(count<m)return -1;\\n        return sum/(m-2*k);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210906,
                "title": "is-there-a-problem-with-test-case-or-my-code",
                "content": "```\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\"]\\n[[3,1],[17612],[74607],[],[8272],[33433],[],[15456],[64938],[],[99741]]\\n\\n[null,null,null,-1,null,null,33433,null,null,33433,null]\\n\\n```\\nWhen the last m values in stream is [15456],[64938],[],[99741], why the expected answer has the average 33433\\nCan anyone help me understand?",
                "solutionTags": [],
                "code": "```\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\"]\\n[[3,1],[17612],[74607],[],[8272],[33433],[],[15456],[64938],[],[99741]]\\n\\n[null,null,null,-1,null,null,33433,null,null,33433,null]\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181159,
                "title": "c-bst-with-subtree-sum-and-size-update",
                "content": "we need a data structure that performs the following operations efficiently:\\n1. insertion and deletion of any element\\n2. finding the sum of elements up to the kth largest element\\n\\nA Self-balancing BST (RB tree, AVL, etc.) is a good candidate. If we maintain subtree sum and size at each node, we can also do the second operation in log(n) time.\\nHere is an implementation using C++ PBDS (a bit slow due to large constant factor)\\n``` cpp\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate<typename Node_CItr, typename Node_Itr, typename Cmp_Fn, typename _Alloc>\\nclass updator : detail::branch_policy<Node_CItr, Node_Itr, _Alloc> {\\npublic:\\n    typedef detail::branch_policy<Node_CItr, Node_Itr, _Alloc> base_type;\\n    typedef Cmp_Fn                                      cmp_fn;\\n    typedef std::pair<int, int>                         key_type;\\n    typedef std::pair<int, long long>                   metadata_type;   // pair of subtree size and subtree sum\\n    typedef Node_CItr                                   node_const_iterator;\\n    typedef Node_Itr                                    node_iterator;\\n    typedef typename node_iterator::value_type          iterator;\\n    \\n    virtual node_iterator node_end() = 0;\\n    virtual node_iterator node_begin() = 0;\\n\\npublic:\\n    long long get_sum(size_t order) {\\n        long long ret = 0;\\n        node_iterator it = node_begin();\\n        node_iterator end_it = node_end();\\n        while (it != end_it) {\\n            node_iterator l_it = it.get_l_child();\\n            int val = (*it)->first;\\n            size_t lsz = 0;\\n            long long lsum = 0;\\n            if(l_it != end_it) {\\n                tie(lsz, lsum) = l_it.get_metadata();\\n            }\\n            if (order == lsz) {\\n                ret += lsum;\\n                return ret;\\n            }\\n            else if (order < lsz)\\n                it = l_it;\\n            else {\\n                order -= lsz + 1;\\n                ret += lsum + val;\\n                it = it.get_r_child();\\n            }\\n        }\\n        assert(false);\\n        return 0;\\n    }\\nprotected:\\n    void operator()(node_iterator it, node_const_iterator eit) const {\\n        node_iterator l_it = it.get_l_child();\\n        node_iterator r_it = it.get_r_child();\\n        int val = (**it).first;\\n        metadata_type dt { 1, val };\\n        if(l_it != eit)\\n            dt.first += l_it.get_metadata().first, dt.second += l_it.get_metadata().second;\\n        if(r_it != eit)\\n            dt.first += r_it.get_metadata().first, dt.second += r_it.get_metadata().second;\\n\\n        const_cast<metadata_type&>(it.get_metadata()) = dt;\\n    }\\n};\\n\\nusing set_t = tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, updator>;\\n\\nclass MKAverage {\\n    set_t tr;\\n    queue<int> q;\\n    unordered_map<int,int> tm;\\n    int m,k;\\npublic:\\n    MKAverage(int m, int k):m(m),k(k) {\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        int t = tm[num] ++;\\n        tr.insert(make_pair(num, t));\\n\\n        if(q.size() > m) {\\n            int del = q.front();\\n            q.pop();\\n            \\n            t = -- tm[del];\\n            tr.erase(make_pair(del, t));\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(q.size() < m)\\n            return -1;\\n        return (tr.get_sum(m-k) - tr.get_sum(k)) / (m-2*k);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "``` cpp\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate<typename Node_CItr, typename Node_Itr, typename Cmp_Fn, typename _Alloc>\\nclass updator : detail::branch_policy<Node_CItr, Node_Itr, _Alloc> {\\npublic:\\n    typedef detail::branch_policy<Node_CItr, Node_Itr, _Alloc> base_type;\\n    typedef Cmp_Fn                                      cmp_fn;\\n    typedef std::pair<int, int>                         key_type;\\n    typedef std::pair<int, long long>                   metadata_type;   // pair of subtree size and subtree sum\\n    typedef Node_CItr                                   node_const_iterator;\\n    typedef Node_Itr                                    node_iterator;\\n    typedef typename node_iterator::value_type          iterator;\\n    \\n    virtual node_iterator node_end() = 0;\\n    virtual node_iterator node_begin() = 0;\\n\\npublic:\\n    long long get_sum(size_t order) {\\n        long long ret = 0;\\n        node_iterator it = node_begin();\\n        node_iterator end_it = node_end();\\n        while (it != end_it) {\\n            node_iterator l_it = it.get_l_child();\\n            int val = (*it)->first;\\n            size_t lsz = 0;\\n            long long lsum = 0;\\n            if(l_it != end_it) {\\n                tie(lsz, lsum) = l_it.get_metadata();\\n            }\\n            if (order == lsz) {\\n                ret += lsum;\\n                return ret;\\n            }\\n            else if (order < lsz)\\n                it = l_it;\\n            else {\\n                order -= lsz + 1;\\n                ret += lsum + val;\\n                it = it.get_r_child();\\n            }\\n        }\\n        assert(false);\\n        return 0;\\n    }\\nprotected:\\n    void operator()(node_iterator it, node_const_iterator eit) const {\\n        node_iterator l_it = it.get_l_child();\\n        node_iterator r_it = it.get_r_child();\\n        int val = (**it).first;\\n        metadata_type dt { 1, val };\\n        if(l_it != eit)\\n            dt.first += l_it.get_metadata().first, dt.second += l_it.get_metadata().second;\\n        if(r_it != eit)\\n            dt.first += r_it.get_metadata().first, dt.second += r_it.get_metadata().second;\\n\\n        const_cast<metadata_type&>(it.get_metadata()) = dt;\\n    }\\n};\\n\\nusing set_t = tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, updator>;\\n\\nclass MKAverage {\\n    set_t tr;\\n    queue<int> q;\\n    unordered_map<int,int> tm;\\n    int m,k;\\npublic:\\n    MKAverage(int m, int k):m(m),k(k) {\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        int t = tm[num] ++;\\n        tr.insert(make_pair(num, t));\\n\\n        if(q.size() > m) {\\n            int del = q.front();\\n            q.pop();\\n            \\n            t = -- tm[del];\\n            tr.erase(make_pair(del, t));\\n        }\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(q.size() < m)\\n            return -1;\\n        return (tr.get_sum(m-k) - tr.get_sum(k)) / (m-2*k);\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1943411,
                "title": "c-3-balance-set-solution",
                "content": "Runtime: 593 ms, faster than 53.49% of C++ online submissions for Finding MK Average.\\nMemory Usage: 167.1 MB, less than 5.12% of C++ online submissions for Finding MK Average.\\n\\n\\n```\\nWe keep 3 Balanced Set for lower K values in MaxHeap, upper K values in MinHeap and\\nmid range values in MidHeap. Also we store the values in a queue so that we can remove\\nprevious element of latest M elements from those Set. Track the count of added elements\\nand also track the sum of mid range elements in MidHeap.\\n\\nWe store the lower K values in MaxHeap and as soon as MaxHeap size > K we remove\\ntop element and insert in to MinHeap which contains upper K values. If MinHeap size > K\\nthen the top value of MinHeap is obviously in the mid range and so we add it to the\\nMidHeap and add its value to running sum.\\n\\nIncase of removing previous element, we search it in MaxHeap and MinHeap.\\nIf target is in MaxHeap then we remove it from MaxHeap and insert the smaller element\\nfrom MidHeap, means the smallest mid range value which can be a lower K element\\nand also update running sum and MidHeap. Incase of MinHeap we insert the largest \\nvalue from MidHeap which can be a higher K element and update the running sum and\\nMidHeap. Otherwise, the target element is in MidHeap and we just remove it from\\nMidHeap and update running sum.\\n```\\n\\n```\\nclass MKAverage {\\npublic:\\n\\n    // store lower K elements\\n    set<pair<int, int>, greater<>>MaxHeap;\\n    \\n    // store upper K elements\\n    set<pair<int, int>>MinHeap;\\n    \\n    // store mid range elements\\n    set<pair<int, int>>MidHeap;\\n    \\n    // store all previous values\\n    queue<int>vals;\\n\\n    int M, K;\\n    int count;\\n    long long Sum;\\n    int midLength;\\n\\n    MKAverage(int m, int k) {\\n\\n        M = m;\\n        K = k;\\n        Sum = 0L;\\n        count = 0;\\n        midLength = M - 2 * K;\\n    }\\n\\n    void addElement(int num) {\\n\\n        count++;\\n        vals.push(num);\\n\\n        // stream has more than M element and so need to remove previous element\\n        if (count > M)\\n        {\\n            // get previous target element\\n            pair<int, int> target = { vals.front(),count - M };\\n            vals.pop();\\n            \\n            // if target is in MaxHeap then remove it and insert min value from MidHeap\\n            if (MaxHeap.find(target) != MaxHeap.end())\\n            {\\n                MaxHeap.erase(target);\\n                MaxHeap.insert(*MidHeap.begin());\\n                Sum -= (*MidHeap.begin()).first;\\n                MidHeap.erase(MidHeap.begin());\\n            }\\n            \\n            // if target is in MinHeap then remove it and insert max value from MidHeap            \\n            else if (MinHeap.find(target) != MinHeap.end())\\n            {\\n                MinHeap.erase(target);\\n                MinHeap.insert(*MidHeap.rbegin());\\n                Sum -= (*MidHeap.rbegin()).first;\\n                MidHeap.erase(*MidHeap.rbegin());\\n            }\\n            // if target is in MidHeap then remove it             \\n            else\\n            {\\n                Sum -= target.first;\\n                MidHeap.erase(MidHeap.find(target));\\n            }\\n        }\\n\\n        // insert current element in to MaxHeap \\n        MaxHeap.insert({ num,count });\\n        \\n        // if MaxHeap size > K then insert max element in to MinHeap\\n        if (MaxHeap.size() > K)\\n        {\\n            auto maxVal = *MaxHeap.begin();\\n            MaxHeap.erase(MaxHeap.begin());\\n\\n            MinHeap.insert(maxVal);\\n\\n            // if MinHeap size > K then insert min element in to MidHeap            \\n            if (MinHeap.size() > K)\\n            {\\n                auto minVal = *MinHeap.begin();\\n                MinHeap.erase(MinHeap.begin());\\n\\n                // update running sum\\n                MidHeap.insert(minVal);\\n                Sum += minVal.first;\\n            }\\n        }\\n\\n    }\\n\\n    int calculateMKAverage() {\\n\\n        // return -1 for less than M elements and otherwise return running sum / range\\n        if (count < M) return -1;\\n        else return Sum / midLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nWe keep 3 Balanced Set for lower K values in MaxHeap, upper K values in MinHeap and\\nmid range values in MidHeap. Also we store the values in a queue so that we can remove\\nprevious element of latest M elements from those Set. Track the count of added elements\\nand also track the sum of mid range elements in MidHeap.\\n\\nWe store the lower K values in MaxHeap and as soon as MaxHeap size > K we remove\\ntop element and insert in to MinHeap which contains upper K values. If MinHeap size > K\\nthen the top value of MinHeap is obviously in the mid range and so we add it to the\\nMidHeap and add its value to running sum.\\n\\nIncase of removing previous element, we search it in MaxHeap and MinHeap.\\nIf target is in MaxHeap then we remove it from MaxHeap and insert the smaller element\\nfrom MidHeap, means the smallest mid range value which can be a lower K element\\nand also update running sum and MidHeap. Incase of MinHeap we insert the largest \\nvalue from MidHeap which can be a higher K element and update the running sum and\\nMidHeap. Otherwise, the target element is in MidHeap and we just remove it from\\nMidHeap and update running sum.\\n```\n```\\nclass MKAverage {\\npublic:\\n\\n    // store lower K elements\\n    set<pair<int, int>, greater<>>MaxHeap;\\n    \\n    // store upper K elements\\n    set<pair<int, int>>MinHeap;\\n    \\n    // store mid range elements\\n    set<pair<int, int>>MidHeap;\\n    \\n    // store all previous values\\n    queue<int>vals;\\n\\n    int M, K;\\n    int count;\\n    long long Sum;\\n    int midLength;\\n\\n    MKAverage(int m, int k) {\\n\\n        M = m;\\n        K = k;\\n        Sum = 0L;\\n        count = 0;\\n        midLength = M - 2 * K;\\n    }\\n\\n    void addElement(int num) {\\n\\n        count++;\\n        vals.push(num);\\n\\n        // stream has more than M element and so need to remove previous element\\n        if (count > M)\\n        {\\n            // get previous target element\\n            pair<int, int> target = { vals.front(),count - M };\\n            vals.pop();\\n            \\n            // if target is in MaxHeap then remove it and insert min value from MidHeap\\n            if (MaxHeap.find(target) != MaxHeap.end())\\n            {\\n                MaxHeap.erase(target);\\n                MaxHeap.insert(*MidHeap.begin());\\n                Sum -= (*MidHeap.begin()).first;\\n                MidHeap.erase(MidHeap.begin());\\n            }\\n            \\n            // if target is in MinHeap then remove it and insert max value from MidHeap            \\n            else if (MinHeap.find(target) != MinHeap.end())\\n            {\\n                MinHeap.erase(target);\\n                MinHeap.insert(*MidHeap.rbegin());\\n                Sum -= (*MidHeap.rbegin()).first;\\n                MidHeap.erase(*MidHeap.rbegin());\\n            }\\n            // if target is in MidHeap then remove it             \\n            else\\n            {\\n                Sum -= target.first;\\n                MidHeap.erase(MidHeap.find(target));\\n            }\\n        }\\n\\n        // insert current element in to MaxHeap \\n        MaxHeap.insert({ num,count });\\n        \\n        // if MaxHeap size > K then insert max element in to MinHeap\\n        if (MaxHeap.size() > K)\\n        {\\n            auto maxVal = *MaxHeap.begin();\\n            MaxHeap.erase(MaxHeap.begin());\\n\\n            MinHeap.insert(maxVal);\\n\\n            // if MinHeap size > K then insert min element in to MidHeap            \\n            if (MinHeap.size() > K)\\n            {\\n                auto minVal = *MinHeap.begin();\\n                MinHeap.erase(MinHeap.begin());\\n\\n                // update running sum\\n                MidHeap.insert(minVal);\\n                Sum += minVal.first;\\n            }\\n        }\\n\\n    }\\n\\n    int calculateMKAverage() {\\n\\n        // return -1 for less than M elements and otherwise return running sum / range\\n        if (count < M) return -1;\\n        else return Sum / midLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927215,
                "title": "python3-sortedlist-beats-100",
                "content": "Similar to the solutions from others, but we defer initializing the range sums until we\\'ve added m elements. In practice this wouldn\\'t be acceptable as adding the m\\'th element would take O(m) time vs the O(logM) time of the other calls.\\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.averageLen = m - 2*k\\n        self.elements = SortedList()\\n        self.history = deque()\\n        \\n    def addElement(self, num: int) -> None:\\n        if len(self.elements) < self.m:\\n            self.history.append(num)\\n            self.elements.add(num)\\n            if len(self.elements) == self.m:\\n                self.sum = sum(self.elements)\\n                self.leftSum = sum(self.elements[:self.k])\\n                self.rightSum = sum(self.elements[-self.k:])\\n        else:\\n            elementToRemove = self.history.popleft()\\n            if elementToRemove <= self.elements[self.k-1]:\\n                self.leftSum += self.elements[self.k] - elementToRemove\\n            elif elementToRemove >= self.elements[-self.k]:\\n                self.rightSum += self.elements[-(self.k+1)] - elementToRemove\\n            self.elements.remove(elementToRemove)\\n            self.history.append(num)\\n            self.elements.add(num)\\n            self.sum += num - elementToRemove\\n            if num <= self.elements[self.k-1]:\\n                self.leftSum += num - self.elements[self.k]\\n            elif num >= self.elements[-self.k]:\\n                self.rightSum += num - self.elements[-(self.k+1)]\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.elements) < self.m:\\n            return -1\\n        return int((self.sum - self.leftSum - self.rightSum) / self.averageLen)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.averageLen = m - 2*k\\n        self.elements = SortedList()\\n        self.history = deque()\\n        \\n    def addElement(self, num: int) -> None:\\n        if len(self.elements) < self.m:\\n            self.history.append(num)\\n            self.elements.add(num)\\n            if len(self.elements) == self.m:\\n                self.sum = sum(self.elements)\\n                self.leftSum = sum(self.elements[:self.k])\\n                self.rightSum = sum(self.elements[-self.k:])\\n        else:\\n            elementToRemove = self.history.popleft()\\n            if elementToRemove <= self.elements[self.k-1]:\\n                self.leftSum += self.elements[self.k] - elementToRemove\\n            elif elementToRemove >= self.elements[-self.k]:\\n                self.rightSum += self.elements[-(self.k+1)] - elementToRemove\\n            self.elements.remove(elementToRemove)\\n            self.history.append(num)\\n            self.elements.add(num)\\n            self.sum += num - elementToRemove\\n            if num <= self.elements[self.k-1]:\\n                self.leftSum += num - self.elements[self.k]\\n            elif num >= self.elements[-self.k]:\\n                self.rightSum += num - self.elements[-(self.k+1)]\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.elements) < self.m:\\n            return -1\\n        return int((self.sum - self.leftSum - self.rightSum) / self.averageLen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926737,
                "title": "kth-largest-element-approach-java-collections-simple-10-lines-of-code-commented-explanation",
                "content": "class KthLargest {\\n    int kth_element; // to store the index of element you want to return\\n    ArrayList<Integer> elements; // Maintaing arraylist of element\\n    public KthLargest(int k, int[] nums) {\\n    kth_element=k;\\n    elements = new ArrayList<Integer>();\\n    Collections.addAll(elements, Arrays.stream(nums).boxed().toArray(Integer[]::new)); // Coz Beauty of Collections \\n    }\\n    \\n    public int add(int val) {\\n    elements.add(val); // value is added to the last index of element array\\n\\tif(val <= elements.get(elements.size()-1)) //Sort only if the value added is less than the last element\\n    Collections.sort(elements);\\n    return elements.get(elements.size()-1-kth_element+1); // return the kth_largest by subtracting indec\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class KthLargest {\\n    int kth_element; // to store the index of element you want to return\\n    ArrayList<Integer> elements; // Maintaing arraylist of element\\n    public KthLargest(int k, int[] nums) {\\n    kth_element=k;\\n    elements = new ArrayList<Integer>();\\n    Collections.addAll(elements, Arrays.stream(nums).boxed().toArray(Integer[]::new)); // Coz Beauty of Collections \\n    }\\n    \\n    public int add(int val) {\\n    elements.add(val); // value is added to the last index of element array\\n\\tif(val <= elements.get(elements.size()-1)) //Sort only if the value added is less than the last element\\n    Collections.sort(elements);\\n    return elements.get(elements.size()-1-kth_element+1); // return the kth_largest by subtracting indec\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1925294,
                "title": "this-is-the-easiest-solution-in-python3-how-can-i-optimize-this-code-more-to-get-accepted",
                "content": "**Give Me suggestion **\\n\\n```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        self.arr.append(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        else:\\n            modifiedarr = sorted(self.arr[len(self.arr)-self.m:len(self.arr)])\\n            modifiedarr = modifiedarr[self.k:len(modifiedarr)-self.k]\\n            return (sum(modifiedarr))//(len(modifiedarr))\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        self.arr.append(num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        else:\\n            modifiedarr = sorted(self.arr[len(self.arr)-self.m:len(self.arr)])\\n            modifiedarr = modifiedarr[self.k:len(modifiedarr)-self.k]\\n            return (sum(modifiedarr))//(len(modifiedarr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806767,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass MKAverage {\\npublic:\\n    const int nax = 1e5 + 1;\\n    vector<int> arr;\\n    vector<pair<long long, long long>> tree;\\n    long long total = 0;\\n    int size;\\n    int m, k;\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        size = 1;\\n        while (size < nax) {\\n            size *= 2;\\n        }\\n        tree = vector<pair<long long, long long>> (2 * size - 1);\\n    }\\n    void operation(int pos, bool flag) {\\n        if (flag) {\\n            tree[pos + size - 1].first -= pos;\\n            --tree[pos + size - 1].second;\\n        }\\n        else {\\n            tree[pos + size - 1].first += pos;\\n            ++tree[pos + size - 1].second;\\n        }\\n        for (int i = (size - 1 + pos - 1) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i].first = tree[2 * i + 1].first + tree[2 * i + 2].first;\\n            tree[i].second = tree[2 * i + 1].second + tree[2 * i + 2].second;\\n        }\\n        if (size != 1) {\\n            tree[0].first = tree[1].first + tree[2].first;\\n            tree[0].second = tree[1].second + tree[2].second;\\n        }\\n    }\\n   int sum(int root, int l, int r, int left, int right, bool flag) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) {\\n            if (flag) {\\n                return tree[root].second;\\n            }\\n            else {\\n                return tree[root].first;\\n            }\\n        }\\n        int mid = (left + right) / 2;\\n        return sum(2 * root + 1, l, r, left, mid, flag) + sum(2 * root + 2, l, r, mid + 1, right, flag);\\n    }\\n    int getValue(int total, bool flag) {\\n        int low = 0;\\n        int high = nax;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int val = 0;\\n            if (flag) {\\n                val = sum(0, 0, mid, 0, size - 1, true);\\n            }\\n            else {\\n                val = sum(0, mid, size - 1, 0, size - 1, true);\\n            }\\n            if (val >= total) {\\n                sol = mid;\\n                if (flag) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            else {\\n                if (flag) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n    void addElement(int num) {\\n        arr.push_back(num);\\n        if ((int) arr.size() > m) {\\n            operation(arr.end()[-m - 1], true);\\n        }\\n        operation(arr.end()[-1], false);\\n    }\\n    int getFreq(int value) {\\n        return tree[value + size - 1].second;\\n    }\\n    int calculateMKAverage() {\\n        if ((int) arr.size() < m) return -1;\\n        int v1 = getValue(k, true);\\n        int v2 = getValue(k, false);\\n        long long total = sum(0, v1, v2, 0, size - 1, false);\\n        int l = k - sum(0, 0, v1 - 1, 0, size - 1, true);\\n        int r = k - sum(0, v2 + 1, size - 1, 0, size - 1, true);\\n        long long div = m - 2 * k;\\n        total -= v1 * l;\\n        total -= v2 * r;\\n        return total / div;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n    const int nax = 1e5 + 1;\\n    vector<int> arr;\\n    vector<pair<long long, long long>> tree;\\n    long long total = 0;\\n    int size;\\n    int m, k;\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        size = 1;\\n        while (size < nax) {\\n            size *= 2;\\n        }\\n        tree = vector<pair<long long, long long>> (2 * size - 1);\\n    }\\n    void operation(int pos, bool flag) {\\n        if (flag) {\\n            tree[pos + size - 1].first -= pos;\\n            --tree[pos + size - 1].second;\\n        }\\n        else {\\n            tree[pos + size - 1].first += pos;\\n            ++tree[pos + size - 1].second;\\n        }\\n        for (int i = (size - 1 + pos - 1) / 2; i > 0; i = (i - 1) / 2) {\\n            tree[i].first = tree[2 * i + 1].first + tree[2 * i + 2].first;\\n            tree[i].second = tree[2 * i + 1].second + tree[2 * i + 2].second;\\n        }\\n        if (size != 1) {\\n            tree[0].first = tree[1].first + tree[2].first;\\n            tree[0].second = tree[1].second + tree[2].second;\\n        }\\n    }\\n   int sum(int root, int l, int r, int left, int right, bool flag) {\\n        if (right < l || left > r) return 0;\\n        if (left >= l && right <= r) {\\n            if (flag) {\\n                return tree[root].second;\\n            }\\n            else {\\n                return tree[root].first;\\n            }\\n        }\\n        int mid = (left + right) / 2;\\n        return sum(2 * root + 1, l, r, left, mid, flag) + sum(2 * root + 2, l, r, mid + 1, right, flag);\\n    }\\n    int getValue(int total, bool flag) {\\n        int low = 0;\\n        int high = nax;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int val = 0;\\n            if (flag) {\\n                val = sum(0, 0, mid, 0, size - 1, true);\\n            }\\n            else {\\n                val = sum(0, mid, size - 1, 0, size - 1, true);\\n            }\\n            if (val >= total) {\\n                sol = mid;\\n                if (flag) {\\n                    high = mid - 1;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n            else {\\n                if (flag) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n    void addElement(int num) {\\n        arr.push_back(num);\\n        if ((int) arr.size() > m) {\\n            operation(arr.end()[-m - 1], true);\\n        }\\n        operation(arr.end()[-1], false);\\n    }\\n    int getFreq(int value) {\\n        return tree[value + size - 1].second;\\n    }\\n    int calculateMKAverage() {\\n        if ((int) arr.size() < m) return -1;\\n        int v1 = getValue(k, true);\\n        int v2 = getValue(k, false);\\n        long long total = sum(0, v1, v2, 0, size - 1, false);\\n        int l = k - sum(0, 0, v1 - 1, 0, size - 1, true);\\n        int r = k - sum(0, v2 + 1, size - 1, 0, size - 1, true);\\n        long long div = m - 2 * k;\\n        total -= v1 * l;\\n        total -= v2 * r;\\n        return total / div;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1798468,
                "title": "how-can-i-accelerate-this-code",
                "content": "I have a problem with this code, I wanted to submit this code but I got an error message that the interval time has been exceeded.\\nHow can I shorten it to make it work?\\n\\n```\\n     public class MKAverage\\n        {\\n            private int K;\\n            private int M;\\n            public List<int> d;\\n\\n            public MKAverage(int m, int k)\\n            {\\n                K = k;\\n                M = m;\\n                d = new List<int>();\\n            }\\n\\n            public void AddElement(int num)\\n            {\\n                d.Add(num);\\n            }\\n\\n            public int CalculateMKAverage()\\n            {\\n            List<int> list = new List<int>();\\n            if (d.Count()<M)\\n            {\\n                return -1;\\n            }\\n            for (int i = 0;i<M;i++)\\n            {\\n                list.Add(d[d.Count-1-i]);\\n            }\\n            list.Sort();\\n            for (int i = 0;i<K;i++)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(list.Count()-1);\\n            }\\n            int temp = 0;\\n            double avg = 0;\\n            for(int i = 0;i<list.Count();i++){\\n                temp+=list[i];\\n                avg = temp/list.Count();\\n            }\\n            return (int)Math.Round(avg, MidpointRounding.AwayFromZero);\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n     public class MKAverage\\n        {\\n            private int K;\\n            private int M;\\n            public List<int> d;\\n\\n            public MKAverage(int m, int k)\\n            {\\n                K = k;\\n                M = m;\\n                d = new List<int>();\\n            }\\n\\n            public void AddElement(int num)\\n            {\\n                d.Add(num);\\n            }\\n\\n            public int CalculateMKAverage()\\n            {\\n            List<int> list = new List<int>();\\n            if (d.Count()<M)\\n            {\\n                return -1;\\n            }\\n            for (int i = 0;i<M;i++)\\n            {\\n                list.Add(d[d.Count-1-i]);\\n            }\\n            list.Sort();\\n            for (int i = 0;i<K;i++)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(list.Count()-1);\\n            }\\n            int temp = 0;\\n            double avg = 0;\\n            for(int i = 0;i<list.Count();i++){\\n                temp+=list[i];\\n                avg = temp/list.Count();\\n            }\\n            return (int)Math.Round(avg, MidpointRounding.AwayFromZero);\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507437,
                "title": "java-1-queue-3-treemap-commented-formatted",
                "content": "```java\\nclass MKAverage {\\n    // idea - one queue to track the \"stream\"\\n    // 3 TreeMap keep track the k largest and smallest and middle ones\\n    private int m, k;\\n    private TreeMap<Integer, Integer> top, mid, bot;\\n    private int lenTop, lenBot;\\n    private Queue<Integer> que;\\n    private long sum;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        \\n        top = new TreeMap<>();\\n        mid = new TreeMap<>();\\n        bot = new TreeMap<>();\\n        lenTop = 0;\\n        lenBot = 0;\\n        \\n        que = new LinkedList<>();\\n        \\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        que.offer(num);\\n        \\n        // if more than m, we need to shrink - poll out the first element in que\\n        // while keep 3 maps updated\\n        if (que.size() > m) {\\n            shrink();\\n        }\\n       \\n        // ensure top contains the k largest, so on..\\n        balance(num);\\n    }\\n    \\n    private void shrink() {\\n        if (que.size() <= m) { return; }\\n        int num = que.poll();\\n        // check 3 cases - if in the map, remove it and shift the\\n        // proper num into it\\n        if (top.containsKey(num)) {\\n            remove(top, num);\\n            // as remove from top, we add one \"backup\"\\n            // from the end of middle parts\\n            int last = mid.lastKey();\\n            remove(mid, last);\\n            sum -= last;\\n            add(top, last);\\n        } else if (bot.containsKey(num)) {\\n            remove(bot, num);\\n            // smiliarly here, use first in mid as \"backup\"\\n            int first = mid.firstKey();\\n            remove(mid, first);\\n            sum -= first;\\n            add(bot, first);\\n        } else if (mid.containsKey(num)) {\\n            remove(mid, num);\\n            sum -= num;\\n        }\\n    }\\n    \\n    private void balance(int num) {\\n        // add the num from top to mid to bot\\n        // if top <= k, just add it\\n        top.put(num, top.getOrDefault(num, 0) + 1);\\n        lenTop++;\\n        if (lenTop <= k) { return; }\\n        \\n        // if top is \"full\", pop the first/smallest in top out\\n        // add into bot for a try\\n        int first = top.firstKey();\\n        remove(top, first);\\n        lenTop--;\\n        \\n        add(bot, first);\\n        lenBot++;\\n        // if bot also full\\n        // pop the largest of bot into middle part\\n        if (lenBot > k) {\\n            int last = bot.lastKey();\\n            remove(bot, last);\\n            lenBot--;\\n            \\n            add(mid, last);\\n            sum += last;\\n        }\\n    }\\n    \\n    private void remove(TreeMap<Integer, Integer> map, int num) {\\n        if (map.containsKey(num)) {\\n            map.put(num, map.get(num) - 1);\\n            if (map.get(num) == 0) {\\n                map.remove(num);\\n            }\\n        }\\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> map, int num) {\\n        map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return que.size() < m ? -1 : (int) (sum / (m - 2 * k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n ```",
                "solutionTags": [],
                "code": "```java\\nclass MKAverage {\\n    // idea - one queue to track the \"stream\"\\n    // 3 TreeMap keep track the k largest and smallest and middle ones\\n    private int m, k;\\n    private TreeMap<Integer, Integer> top, mid, bot;\\n    private int lenTop, lenBot;\\n    private Queue<Integer> que;\\n    private long sum;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        \\n        top = new TreeMap<>();\\n        mid = new TreeMap<>();\\n        bot = new TreeMap<>();\\n        lenTop = 0;\\n        lenBot = 0;\\n        \\n        que = new LinkedList<>();\\n        \\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        que.offer(num);\\n        \\n        // if more than m, we need to shrink - poll out the first element in que\\n        // while keep 3 maps updated\\n        if (que.size() > m) {\\n            shrink();\\n        }\\n       \\n        // ensure top contains the k largest, so on..\\n        balance(num);\\n    }\\n    \\n    private void shrink() {\\n        if (que.size() <= m) { return; }\\n        int num = que.poll();\\n        // check 3 cases - if in the map, remove it and shift the\\n        // proper num into it\\n        if (top.containsKey(num)) {\\n            remove(top, num);\\n            // as remove from top, we add one \"backup\"\\n            // from the end of middle parts\\n            int last = mid.lastKey();\\n            remove(mid, last);\\n            sum -= last;\\n            add(top, last);\\n        } else if (bot.containsKey(num)) {\\n            remove(bot, num);\\n            // smiliarly here, use first in mid as \"backup\"\\n            int first = mid.firstKey();\\n            remove(mid, first);\\n            sum -= first;\\n            add(bot, first);\\n        } else if (mid.containsKey(num)) {\\n            remove(mid, num);\\n            sum -= num;\\n        }\\n    }\\n    \\n    private void balance(int num) {\\n        // add the num from top to mid to bot\\n        // if top <= k, just add it\\n        top.put(num, top.getOrDefault(num, 0) + 1);\\n        lenTop++;\\n        if (lenTop <= k) { return; }\\n        \\n        // if top is \"full\", pop the first/smallest in top out\\n        // add into bot for a try\\n        int first = top.firstKey();\\n        remove(top, first);\\n        lenTop--;\\n        \\n        add(bot, first);\\n        lenBot++;\\n        // if bot also full\\n        // pop the largest of bot into middle part\\n        if (lenBot > k) {\\n            int last = bot.lastKey();\\n            remove(bot, last);\\n            lenBot--;\\n            \\n            add(mid, last);\\n            sum += last;\\n        }\\n    }\\n    \\n    private void remove(TreeMap<Integer, Integer> map, int num) {\\n        if (map.containsKey(num)) {\\n            map.put(num, map.get(num) - 1);\\n            if (map.get(num) == 0) {\\n                map.remove(num);\\n            }\\n        }\\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> map, int num) {\\n        map.put(num, map.getOrDefault(num, 0) + 1);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        return que.size() < m ? -1 : (int) (sum / (m - 2 * k));\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1448591,
                "title": "using-interval-tree-c",
                "content": "```\\n#define NMAX 100000\\n\\nclass MKAverage {\\nprivate:\\n    vector<long long> itCnt, pos;\\n    vector<long long> itSum;\\n    deque<int> nums;\\n    int m, k;\\npublic:\\n    void initIT(int i, int l, int r){\\n        if (l == r){\\n            pos[l] = i;\\n            return;\\n        }    \\n        int mid = (l + r) / 2;\\n        initIT(i * 2, l, mid);\\n        initIT(i * 2 + 1, mid + 1, r);\\n    }\\n    \\n    void update(int i, int valSum, int valCnt){\\n        while (i != 0){\\n            itSum[i] += valSum;\\n            itCnt[i] += valCnt;\\n            i = i / 2;\\n        }    \\n    }\\n    \\n    MKAverage(int m, int k) {\\n        itCnt.resize(4 * NMAX + 9);\\n        pos.resize(NMAX + 9);\\n        itSum.resize(4 * NMAX + 9);\\n        initIT(1, 1, NMAX);\\n        this->m = m;\\n        this->k = k;\\n    }\\n    \\n    int findPosOfKthLargest(int i, int l, int r, int K){\\n        if (l == r){\\n            return l;\\n        }\\n        int mid = (l + r) / 2;\\n        if (itCnt[i * 2] >= K){\\n            return findPosOfKthLargest(i * 2, l, mid, K);\\n        } else {\\n            K = K - itCnt[i * 2];\\n            return findPosOfKthLargest(i * 2 + 1, mid + 1, r, K);\\n        }\\n    }\\n    \\n    void getSum(int i, int l, int r, int u, int v, long long &sum, vector<long long> &itSum){\\n        if (u > v) return;\\n        if (l > v || r < u) return;\\n        int mid = (l + r) / 2;\\n        if (u <= l && r <= v){\\n            sum = sum + itSum[i];\\n            return;\\n        }\\n        getSum(i * 2, l, mid, u, v, sum, itSum);\\n        getSum(i * 2 + 1, mid + 1, r, u, v, sum, itSum);\\n    }\\n    \\n    void addElement(int num) {\\n        int valPop = -1;\\n        if (nums.size() < m){\\n            nums.push_back(num);\\n        } else {\\n            nums.push_back(num);\\n            valPop = nums.front();\\n            nums.pop_front();\\n        }\\n        if (valPop != -1){\\n            update(pos[valPop], -valPop, -1);\\n        }\\n        update(pos[num], num, 1);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (nums.size() < m) return -1;\\n        int l = findPosOfKthLargest(1, 1, NMAX, k + 1);\\n        int r = findPosOfKthLargest(1, 1, NMAX, m - k);\\n        long long sum = 0;\\n        long long cntElementLeft = 0;\\n        long long cntElementRight = 0;\\n        getSum(1, 1, NMAX, l, r, sum, this->itSum);\\n        getSum(1, 1, NMAX, 1, l - 1, cntElementLeft, this->itCnt);\\n        getSum(1, 1, NMAX, r + 1, NMAX, cntElementRight, this->itCnt);\\n        sum = sum - (k - cntElementLeft) * l;\\n        sum = sum - (k - cntElementRight) * r;\\n        int res = sum / (m - 2 * k);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n#define NMAX 100000\\n\\nclass MKAverage {\\nprivate:\\n    vector<long long> itCnt, pos;\\n    vector<long long> itSum;\\n    deque<int> nums;\\n    int m, k;\\npublic:\\n    void initIT(int i, int l, int r){\\n        if (l == r){\\n            pos[l] = i;\\n            return;\\n        }    \\n        int mid = (l + r) / 2;\\n        initIT(i * 2, l, mid);\\n        initIT(i * 2 + 1, mid + 1, r);\\n    }\\n    \\n    void update(int i, int valSum, int valCnt){\\n        while (i != 0){\\n            itSum[i] += valSum;\\n            itCnt[i] += valCnt;\\n            i = i / 2;\\n        }    \\n    }\\n    \\n    MKAverage(int m, int k) {\\n        itCnt.resize(4 * NMAX + 9);\\n        pos.resize(NMAX + 9);\\n        itSum.resize(4 * NMAX + 9);\\n        initIT(1, 1, NMAX);\\n        this->m = m;\\n        this->k = k;\\n    }\\n    \\n    int findPosOfKthLargest(int i, int l, int r, int K){\\n        if (l == r){\\n            return l;\\n        }\\n        int mid = (l + r) / 2;\\n        if (itCnt[i * 2] >= K){\\n            return findPosOfKthLargest(i * 2, l, mid, K);\\n        } else {\\n            K = K - itCnt[i * 2];\\n            return findPosOfKthLargest(i * 2 + 1, mid + 1, r, K);\\n        }\\n    }\\n    \\n    void getSum(int i, int l, int r, int u, int v, long long &sum, vector<long long> &itSum){\\n        if (u > v) return;\\n        if (l > v || r < u) return;\\n        int mid = (l + r) / 2;\\n        if (u <= l && r <= v){\\n            sum = sum + itSum[i];\\n            return;\\n        }\\n        getSum(i * 2, l, mid, u, v, sum, itSum);\\n        getSum(i * 2 + 1, mid + 1, r, u, v, sum, itSum);\\n    }\\n    \\n    void addElement(int num) {\\n        int valPop = -1;\\n        if (nums.size() < m){\\n            nums.push_back(num);\\n        } else {\\n            nums.push_back(num);\\n            valPop = nums.front();\\n            nums.pop_front();\\n        }\\n        if (valPop != -1){\\n            update(pos[valPop], -valPop, -1);\\n        }\\n        update(pos[num], num, 1);\\n    }\\n    \\n    int calculateMKAverage() {\\n        if (nums.size() < m) return -1;\\n        int l = findPosOfKthLargest(1, 1, NMAX, k + 1);\\n        int r = findPosOfKthLargest(1, 1, NMAX, m - k);\\n        long long sum = 0;\\n        long long cntElementLeft = 0;\\n        long long cntElementRight = 0;\\n        getSum(1, 1, NMAX, l, r, sum, this->itSum);\\n        getSum(1, 1, NMAX, 1, l - 1, cntElementLeft, this->itCnt);\\n        getSum(1, 1, NMAX, r + 1, NMAX, cntElementRight, this->itCnt);\\n        sum = sum - (k - cntElementLeft) * l;\\n        sum = sum - (k - cntElementRight) * r;\\n        int res = sum / (m - 2 * k);\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390802,
                "title": "use-coarse-to-fine-histogram-o-n-2-x",
                "content": "The basic idea is from the so-called `O(64) \\u2248 O(1)`  median filter algorithm on 8-bit image from [OpenCV](https://github.com/opencv/opencv/blob/ad6e82942b37be8ee2c71c1d9bc7fe79cd16f7ab/modules/imgproc/src/median_blur.simd.hpp#L84).\\n\\nHaving `1 <= num <= 10^5`,  and the fine grain is `1` (`1<<17 = 131072` bins), we choose the coarse grain just the near square root `1<<8` (`1<<9` bins) to simplify code. Thus, one bin (cell) on coarse level contains `1<<8` elements on fine level.\\n\\nThe idea of function `addElement` is foward: just add (and delete when `connt > m`) the count and sum on the bins, meanwhile `lo, hi, hs` only contains the information of last `m` number.\\n\\nWhen we want the sum of midium `m-k-k` number, what we need to do is just find the sum of first `k` and first `m-k` number and subtract them. Here the complexity of `get` is `(O(1<<9) + O(1<<8) \\u2248 O(2\\u221Ax) \\u2248 O(\\u221Ax)`, where `x` is the number of bins (i.e. the maximum value in problem).\\n\\nIn fact, we can build 3 or more levels, but the code will be tedious and complexity will also be harder to calculate.\\n\\n``` cpp\\nclass MKAverage\\n{\\n  static constexpr int lb = 17;\\n  static constexpr int hb = 9;\\n\\n  vector<int> lo, hi, A;\\n  vector<int64_t> hs;\\n  int m, k, count;\\n\\n  int64_t get(int idx)\\n  {\\n    int64_t sum = 0;\\n    int j = 0;\\n    for (; j < (1 << hb); ++j)\\n    {\\n      if (hi[j] > idx)\\n        break;\\n      idx -= hi[j];\\n      sum += hs[j];\\n    }\\n    // this loop will run at most (1 << (lb - hb))\\n    for (j <<= (lb - hb); j < (1 << lb); ++j)\\n    {\\n      if (idx == 0)\\n        break;\\n      int need = min(idx, lo[j]);\\n      sum += static_cast<int64_t>(j) * need;\\n      idx -= need;\\n    }\\n    return sum;\\n  }\\n\\npublic:\\n  MKAverage(int _m, int _k)\\n    : m(_m), k(_k), count(0)\\n  {\\n    lo.resize(1 << lb);\\n    hi.resize(1 << hb);\\n    hs.resize(1 << hb);\\n  }\\n\\n  void addElement(int x)\\n  {\\n    A.push_back(x);\\n    lo[x] += 1;\\n    hi[x >> (lb - hb)] += 1;\\n    hs[x >> (lb - hb)] += x;\\n    if (count >= m)\\n    {\\n      x = A[count - m];\\n      lo[x] -= 1;\\n      hi[x >> (lb - hb)] -= 1;\\n      hs[x >> (lb - hb)] -= x;\\n    }\\n    ++count;\\n  }\\n\\n  int calculateMKAverage()\\n  {\\n    if (count < m)\\n      return -1;\\n    int64_t a = get(k);\\n    int64_t b = get(m - k);\\n    int64_t c = (b - a) / (m - k - k);\\n    return static_cast<int>(c);\\n  }\\n};\\n```\\n\\n> Runtime: 324 ms, faster than 90.49% of C++ online submissions for Finding MK Average.\\n> Memory Usage: 135.6 MB, less than 73.77% of C++ online submissions for Finding MK Average.",
                "solutionTags": [],
                "code": "``` cpp\\nclass MKAverage\\n{\\n  static constexpr int lb = 17;\\n  static constexpr int hb = 9;\\n\\n  vector<int> lo, hi, A;\\n  vector<int64_t> hs;\\n  int m, k, count;\\n\\n  int64_t get(int idx)\\n  {\\n    int64_t sum = 0;\\n    int j = 0;\\n    for (; j < (1 << hb); ++j)\\n    {\\n      if (hi[j] > idx)\\n        break;\\n      idx -= hi[j];\\n      sum += hs[j];\\n    }\\n    // this loop will run at most (1 << (lb - hb))\\n    for (j <<= (lb - hb); j < (1 << lb); ++j)\\n    {\\n      if (idx == 0)\\n        break;\\n      int need = min(idx, lo[j]);\\n      sum += static_cast<int64_t>(j) * need;\\n      idx -= need;\\n    }\\n    return sum;\\n  }\\n\\npublic:\\n  MKAverage(int _m, int _k)\\n    : m(_m), k(_k), count(0)\\n  {\\n    lo.resize(1 << lb);\\n    hi.resize(1 << hb);\\n    hs.resize(1 << hb);\\n  }\\n\\n  void addElement(int x)\\n  {\\n    A.push_back(x);\\n    lo[x] += 1;\\n    hi[x >> (lb - hb)] += 1;\\n    hs[x >> (lb - hb)] += x;\\n    if (count >= m)\\n    {\\n      x = A[count - m];\\n      lo[x] -= 1;\\n      hi[x >> (lb - hb)] -= 1;\\n      hs[x >> (lb - hb)] -= x;\\n    }\\n    ++count;\\n  }\\n\\n  int calculateMKAverage()\\n  {\\n    if (count < m)\\n      return -1;\\n    int64_t a = get(k);\\n    int64_t b = get(m - k);\\n    int64_t c = (b - a) / (m - k - k);\\n    return static_cast<int>(c);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386140,
                "title": "c-3-red-black-trees-using-set-queue",
                "content": "Basic idea is to keep 3 sorted arrays *kleft, avg, kright* with sizes *k, m-2k, k*  and *max(kleft) <= min(avg),  max(avg) <= min(kright)* (implemented via trees for fast insert/delete), after adding new element just restore arrays sizes. \\n\\nadd - O(log(m)), calc - O(1).\\n\\n```\\nclass MKAverage\\n{\\n    int _m, _k;\\n    \\n    queue<int> _q;\\n    \\n    multiset<int> _kleft;\\n    multiset<int> _avg;\\n    multiset<int> _kright;\\n    \\n    long _sum;\\n\\npublic:\\n    MKAverage(int m, int k)\\n    {\\n        _m = m;\\n        _k = k;\\n        _sum = 0;\\n    }\\n\\n    void addElement(int num)\\n    {\\n        auto value = num;\\n\\n        _q.push(value);\\n\\n        if (_q.size() > _m)\\n        {\\n            // remove value\\n            auto leaving = _q.front();\\n            _q.pop();\\n\\n            if (_kleft.size() > 0 && (*_kleft.rbegin()) >= leaving)\\n                _kleft.erase(_kleft.find(leaving));\\n            else if (_kright.size() > 0 && (*_kright.begin()) <= leaving)\\n                _kright.erase(_kright.find(leaving));\\n            else\\n            {\\n                _avg.erase(_avg.find(leaving));\\n                _sum -= leaving;\\n            }\\n        }\\n\\n        // add value\\n        if (_kleft.size() > 0 && (*_kleft.rbegin()) >= value)\\n            _kleft.insert(value);\\n        else if (_kright.size() > 0 && (*_kright.begin()) < value)\\n            _kright.insert(value);\\n        else\\n        {\\n            _avg.insert(value);\\n            _sum += value;\\n        }\\n\\n        // balance trees size after adding\\n        if (_kleft.size() > _k)\\n        {\\n            auto moving = removeLargest(_kleft);\\n            _avg.insert(moving);\\n            _sum += moving;\\n        }\\n        else if (_kright.size() > _k)\\n        {\\n            auto moving = removeSmallest(_kright);\\n            _avg.insert(moving);\\n            _sum += moving;\\n        }\\n\\n        if (_avg.size() > _m - 2 * _k)\\n        {\\n            if (_kleft.size() < _k)\\n            {\\n                 auto moving = removeSmallest(_avg);\\n                _sum -= moving;\\n                _kleft.insert(moving);\\n            }\\n            else if (_kright.size() < _k)\\n            {\\n                auto moving = removeLargest(_avg);\\n                _sum -= moving;\\n                _kright.insert(moving);\\n            }\\n            else\\n                assert(false);\\n        }\\n    }\\n\\n    int calculateMKAverage()\\n    {\\n        if (_q.size() < _m)\\n            return -1;\\n        \\n        return _sum / _avg.size();\\n    }\\n\\nprivate:\\n    int removeSmallest(multiset<int>& set)\\n    {\\n        auto smallest = set.begin();\\n        auto result = *smallest;\\n        set.erase(smallest);\\n        return result;\\n    }\\n\\n    int removeLargest(multiset<int>& set)\\n    {\\n        auto largest = --set.end();\\n        auto result = *largest;\\n        set.erase(largest);\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass MKAverage\\n{\\n    int _m, _k;\\n    \\n    queue<int> _q;\\n    \\n    multiset<int> _kleft;\\n    multiset<int> _avg;\\n    multiset<int> _kright;\\n    \\n    long _sum;\\n\\npublic:\\n    MKAverage(int m, int k)\\n    {\\n        _m = m;\\n        _k = k;\\n        _sum = 0;\\n    }\\n\\n    void addElement(int num)\\n    {\\n        auto value = num;\\n\\n        _q.push(value);\\n\\n        if (_q.size() > _m)\\n        {\\n            // remove value\\n            auto leaving = _q.front();\\n            _q.pop();\\n\\n            if (_kleft.size() > 0 && (*_kleft.rbegin()) >= leaving)\\n                _kleft.erase(_kleft.find(leaving));\\n            else if (_kright.size() > 0 && (*_kright.begin()) <= leaving)\\n                _kright.erase(_kright.find(leaving));\\n            else\\n            {\\n                _avg.erase(_avg.find(leaving));\\n                _sum -= leaving;\\n            }\\n        }\\n\\n        // add value\\n        if (_kleft.size() > 0 && (*_kleft.rbegin()) >= value)\\n            _kleft.insert(value);\\n        else if (_kright.size() > 0 && (*_kright.begin()) < value)\\n            _kright.insert(value);\\n        else\\n        {\\n            _avg.insert(value);\\n            _sum += value;\\n        }\\n\\n        // balance trees size after adding\\n        if (_kleft.size() > _k)\\n        {\\n            auto moving = removeLargest(_kleft);\\n            _avg.insert(moving);\\n            _sum += moving;\\n        }\\n        else if (_kright.size() > _k)\\n        {\\n            auto moving = removeSmallest(_kright);\\n            _avg.insert(moving);\\n            _sum += moving;\\n        }\\n\\n        if (_avg.size() > _m - 2 * _k)\\n        {\\n            if (_kleft.size() < _k)\\n            {\\n                 auto moving = removeSmallest(_avg);\\n                _sum -= moving;\\n                _kleft.insert(moving);\\n            }\\n            else if (_kright.size() < _k)\\n            {\\n                auto moving = removeLargest(_avg);\\n                _sum -= moving;\\n                _kright.insert(moving);\\n            }\\n            else\\n                assert(false);\\n        }\\n    }\\n\\n    int calculateMKAverage()\\n    {\\n        if (_q.size() < _m)\\n            return -1;\\n        \\n        return _sum / _avg.size();\\n    }\\n\\nprivate:\\n    int removeSmallest(multiset<int>& set)\\n    {\\n        auto smallest = set.begin();\\n        auto result = *smallest;\\n        set.erase(smallest);\\n        return result;\\n    }\\n\\n    int removeLargest(multiset<int>& set)\\n    {\\n        auto largest = --set.end();\\n        auto result = *largest;\\n        set.erase(largest);\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344520,
                "title": "golang-3-sorted-arrays-1-circular-array",
                "content": "```\\n// Similar to https://leetcode.com/problems/finding-mk-average/discuss/1152724/C%2B%2B-Balance-3-Multisets\\n// Instead uses 1 circular array, 3 sorted arrays for left,mid,right\\ntype MKAverage struct {\\n    m, k, sz, pos, sum int\\n    circArr []int\\n    left, mid, right *sortedArr\\n}\\n\\nfunc Constructor(m int, k int) MKAverage {\\n    mka := MKAverage{m, k, m - 2*k, 0, 0, make([]int, m), &sortedArr{}, &sortedArr{}, &sortedArr{}}\\n    return mka\\n}\\n\\nfunc (this *MKAverage) AddElement(num int)  {\\n    if this.pos >= this.m {\\n        this.remove(this.circArr[this.pos % this.m])\\n    }\\n    this.add(num)\\n    this.circArr[this.pos % this.m] = num\\n    this.pos += 1  \\n}\\n\\n\\nfunc (this *MKAverage) CalculateMKAverage() int {\\n    if this.pos < this.m {\\n        return -1\\n    }\\n    return this.sum / this.sz\\n}\\n\\nfunc (this *MKAverage) add(num int) {\\n    this.left.insert(num)\\n    if this.left.length() > this.k {\\n        val := this.left.removeLast()\\n        this.mid.insert(val)\\n        this.sum += val\\n    }\\n    \\n    if this.mid.length() > this.sz {\\n        val := this.mid.removeLast()\\n        this.right.insert(val)\\n        this.sum -= val\\n    }\\n}\\n\\nfunc (this *MKAverage) remove(n int) {\\n    if !this.left.remove(n) && !this.right.remove(n) {\\n        this.mid.remove(n)\\n        this.sum -= n\\n    }\\n    \\n    if this.left.length() < this.k {\\n        val := this.mid.removeFirst()\\n        this.left.insert(val)\\n        this.sum -= val\\n    }\\n    \\n    if this.mid.length() < this.sz {\\n        val := this.right.removeFirst() \\n        this.mid.insert(val)\\n        this.sum += val\\n    }\\n}\\n\\n\\ntype sortedArr struct {\\n    buf []int\\n}\\n\\nfunc (bs *sortedArr) length() int {\\n    return len(bs.buf)\\n}\\n\\nfunc (bs *sortedArr) insert(val int) {\\n    idx := bs.searchAsc(val)  \\n    \\n    bs.buf = append(bs.buf, 0)\\n    copy(bs.buf[idx+1:], bs.buf[idx:])\\n    bs.buf[idx]=val\\n}\\n\\nfunc (bs *sortedArr) remove(val int) bool {\\n    idx := bs.searchAsc(val) \\n    if idx < len(bs.buf) && bs.buf[idx] == val{\\n        bs.buf = append(bs.buf[:idx], bs.buf[idx+1:]...)\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc (bs *sortedArr) removeLast() int {\\n    val := bs.buf[len(bs.buf)-1]\\n    bs.buf = bs.buf[:len(bs.buf)-1]\\n    return val\\n}\\n\\nfunc (bs *sortedArr) removeFirst() int {\\n    val := bs.buf[0]\\n    bs.buf = bs.buf[1:]\\n    return val\\n}\\n\\nfunc (bs *sortedArr) searchAsc(val int) int{\\n    idx := sort.Search(len(bs.buf), func(i int) bool {\\n        return bs.buf[i] >= val\\n    }) \\n    \\n    return idx\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Similar to https://leetcode.com/problems/finding-mk-average/discuss/1152724/C%2B%2B-Balance-3-Multisets\\n// Instead uses 1 circular array, 3 sorted arrays for left,mid,right\\ntype MKAverage struct {\\n    m, k, sz, pos, sum int\\n    circArr []int\\n    left, mid, right *sortedArr\\n}\\n\\nfunc Constructor(m int, k int) MKAverage {\\n    mka := MKAverage{m, k, m - 2*k, 0, 0, make([]int, m), &sortedArr{}, &sortedArr{}, &sortedArr{}}\\n    return mka\\n}\\n\\nfunc (this *MKAverage) AddElement(num int)  {\\n    if this.pos >= this.m {\\n        this.remove(this.circArr[this.pos % this.m])\\n    }\\n    this.add(num)\\n    this.circArr[this.pos % this.m] = num\\n    this.pos += 1  \\n}\\n\\n\\nfunc (this *MKAverage) CalculateMKAverage() int {\\n    if this.pos < this.m {\\n        return -1\\n    }\\n    return this.sum / this.sz\\n}\\n\\nfunc (this *MKAverage) add(num int) {\\n    this.left.insert(num)\\n    if this.left.length() > this.k {\\n        val := this.left.removeLast()\\n        this.mid.insert(val)\\n        this.sum += val\\n    }\\n    \\n    if this.mid.length() > this.sz {\\n        val := this.mid.removeLast()\\n        this.right.insert(val)\\n        this.sum -= val\\n    }\\n}\\n\\nfunc (this *MKAverage) remove(n int) {\\n    if !this.left.remove(n) && !this.right.remove(n) {\\n        this.mid.remove(n)\\n        this.sum -= n\\n    }\\n    \\n    if this.left.length() < this.k {\\n        val := this.mid.removeFirst()\\n        this.left.insert(val)\\n        this.sum -= val\\n    }\\n    \\n    if this.mid.length() < this.sz {\\n        val := this.right.removeFirst() \\n        this.mid.insert(val)\\n        this.sum += val\\n    }\\n}\\n\\n\\ntype sortedArr struct {\\n    buf []int\\n}\\n\\nfunc (bs *sortedArr) length() int {\\n    return len(bs.buf)\\n}\\n\\nfunc (bs *sortedArr) insert(val int) {\\n    idx := bs.searchAsc(val)  \\n    \\n    bs.buf = append(bs.buf, 0)\\n    copy(bs.buf[idx+1:], bs.buf[idx:])\\n    bs.buf[idx]=val\\n}\\n\\nfunc (bs *sortedArr) remove(val int) bool {\\n    idx := bs.searchAsc(val) \\n    if idx < len(bs.buf) && bs.buf[idx] == val{\\n        bs.buf = append(bs.buf[:idx], bs.buf[idx+1:]...)\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc (bs *sortedArr) removeLast() int {\\n    val := bs.buf[len(bs.buf)-1]\\n    bs.buf = bs.buf[:len(bs.buf)-1]\\n    return val\\n}\\n\\nfunc (bs *sortedArr) removeFirst() int {\\n    val := bs.buf[0]\\n    bs.buf = bs.buf[1:]\\n    return val\\n}\\n\\nfunc (bs *sortedArr) searchAsc(val int) int{\\n    idx := sort.Search(len(bs.buf), func(i int) bool {\\n        return bs.buf[i] >= val\\n    }) \\n    \\n    return idx\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331597,
                "title": "python3-easy-solution-maintain-a-sorted-list",
                "content": "```\\nclass MKAverage:\\n    \"\"\"\\n    Use bisect module to keep a sorted list\\n    \"\"\"\\n\\n    def __init__(self, m: int, k: int):\\n        self.latest_m = collections.deque()\\n        self.sorted_list = []\\n        self.m = m\\n        self.k = k\\n        # sum of smallest k elements\\n        self.sum_k = 0\\n        # sum of smallest m - k elements\\n        self.sum_m_k = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.latest_m.append(num)\\n        insert_index = bisect.bisect_left(self.sorted_list, num)\\n        \\n        if len(self.latest_m) > self.m:\\n            old = self.latest_m.popleft()\\n            # since it is guaranteed that the old number\\n            # will be in the sorted_list, use bisect_left to\\n            # get it\\'s index\\n            remove_index = bisect.bisect_left(self.sorted_list, old)\\n            if remove_index <= self.k:\\n                self.sum_k -= self.sorted_list[remove_index]\\n                self.sum_k += self.sorted_list[self.k]\\n            if remove_index <= self.m - self.k:\\n                self.sum_m_k -= self.sorted_list[remove_index]\\n                self.sum_m_k += self.sorted_list[self.m - self.k]\\n                \\n            self.sorted_list.pop(remove_index)\\n            \\n        bisect.insort_left(self.sorted_list, num)\\n        if insert_index <= self.k:\\n            self.sum_k += num\\n            if self.k < len(self.sorted_list):\\n                self.sum_k -= self.sorted_list[self.k]\\n        if insert_index <= self.m - self.k:\\n            self.sum_m_k += num\\n            if self.m-self.k < len(self.sorted_list):\\n                self.sum_m_k -= self.sorted_list[self.m - self.k]\\n            \\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.latest_m) < self.m:\\n            return -1\\n        else:\\n            return (self.sum_m_k - self.sum_k) // (self.m - 2 * self.k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n    \"\"\"\\n    Use bisect module to keep a sorted list\\n    \"\"\"\\n\\n    def __init__(self, m: int, k: int):\\n        self.latest_m = collections.deque()\\n        self.sorted_list = []\\n        self.m = m\\n        self.k = k\\n        # sum of smallest k elements\\n        self.sum_k = 0\\n        # sum of smallest m - k elements\\n        self.sum_m_k = 0\\n\\n    def addElement(self, num: int) -> None:\\n        self.latest_m.append(num)\\n        insert_index = bisect.bisect_left(self.sorted_list, num)\\n        \\n        if len(self.latest_m) > self.m:\\n            old = self.latest_m.popleft()\\n            # since it is guaranteed that the old number\\n            # will be in the sorted_list, use bisect_left to\\n            # get it\\'s index\\n            remove_index = bisect.bisect_left(self.sorted_list, old)\\n            if remove_index <= self.k:\\n                self.sum_k -= self.sorted_list[remove_index]\\n                self.sum_k += self.sorted_list[self.k]\\n            if remove_index <= self.m - self.k:\\n                self.sum_m_k -= self.sorted_list[remove_index]\\n                self.sum_m_k += self.sorted_list[self.m - self.k]\\n                \\n            self.sorted_list.pop(remove_index)\\n            \\n        bisect.insort_left(self.sorted_list, num)\\n        if insert_index <= self.k:\\n            self.sum_k += num\\n            if self.k < len(self.sorted_list):\\n                self.sum_k -= self.sorted_list[self.k]\\n        if insert_index <= self.m - self.k:\\n            self.sum_m_k += num\\n            if self.m-self.k < len(self.sorted_list):\\n                self.sum_m_k -= self.sorted_list[self.m - self.k]\\n            \\n            \\n    def calculateMKAverage(self) -> int:\\n        if len(self.latest_m) < self.m:\\n            return -1\\n        else:\\n            return (self.sum_m_k - self.sum_k) // (self.m - 2 * self.k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316293,
                "title": "straightforward-java-solution-3-treesets-detailed-comments",
                "content": "```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    List<Integer> stream; // a list to store all incoming elements\\n    TreeSet<int[]> smallestKContainer;  // store smallest k elements of the m\\n    TreeSet<int[]> middleContainer;  // store middle elements of the m\\n    TreeSet<int[]> largestKContainer;  // store largest k elements of the m\\n    int middleSum; // sum of the middle elements of the m\\n    int middleSize;  // size upper bound of the middleContainer\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.stream = new ArrayList<>();\\n        Comparator<int[]> comparator = new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0]) {\\n                    return a[1] - b[1];\\n                }\\n                return a[0] - b[0]; // [value, index]\\n            }\\n        };\\n        this.smallestKContainer = new TreeSet<>(comparator);\\n        this.middleContainer = new TreeSet<>(comparator);\\n        this.largestKContainer = new TreeSet<>(comparator);\\n        this.middleSum = 0;\\n        this.middleSize = m - 2 * k;\\n    }\\n    \\n    // First-time with rearrange: O(logm + klogk)\\n    // Following add with rearrange: O(logm + logk)\\n    public void addElement(int num) {\\n        stream.add(num);\\n        middleSum += num;\\n        // step 1. insert to middleContainer firstly so that we can easily rearrange later\\n        middleContainer.add(new int[]{num, stream.size() - 1}); \\n        int totalSize = smallestKContainer.size() + middleContainer.size() + largestKContainer.size();\\n        if (totalSize >= m) {\\n            if (totalSize > m) {\\n                // step 2. remove the element with least index among the m and reduce middleSum\\n                int rIdx = stream.size() - 1 - m;\\n                int rVal = stream.get(rIdx);\\n                int[] rEle = new int[]{rVal, rIdx};\\n                smallestKContainer.remove(rEle);\\n                largestKContainer.remove(rEle);\\n                if (middleContainer.remove(rEle)) {\\n                    middleSum -= rVal;\\n                }\\n            }\\n            // step 3. rearrange the three containers to make sure the smallest k and largest k are stored in the proper container\\n            rearrangeContainers(); \\n        }\\n    }\\n    \\n    private void rearrangeContainers() {\\n        // action 1. move extra elements out of middleContainer\\n        if (middleContainer.size() > middleSize) {\\n            while (largestKContainer.size() < k) {\\n                int[] rMid = middleContainer.pollLast();\\n                largestKContainer.add(rMid);\\n                middleSum -= rMid[0];\\n            }\\n            while (smallestKContainer.size() < k) {\\n                int[] rMid = middleContainer.pollFirst();\\n                smallestKContainer.add(rMid);\\n                middleSum -= rMid[0];\\n            }\\n        }\\n        // action 2. swap unsorted element to the proper container\\n        if (middleContainer.last()[0] > largestKContainer.first()[0]) {\\n            int[] temp = middleContainer.pollLast();\\n            int[] largestKContainerFirst = largestKContainer.pollFirst();\\n            middleContainer.add(largestKContainerFirst);\\n            largestKContainer.add(temp);\\n            middleSum -= temp[0];\\n            middleSum += largestKContainerFirst[0];\\n        }\\n        if (middleContainer.first()[0] < smallestKContainer.last()[0]) {\\n            int[] temp = middleContainer.pollFirst();\\n            int[] smallestKContainerLast = smallestKContainer.pollLast();\\n            middleContainer.add(smallestKContainerLast);\\n            smallestKContainer.add(temp);\\n            middleSum -= temp[0];\\n            middleSum += smallestKContainerLast[0];\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (stream.size() < m) {\\n            return -1;\\n        }\\n        return middleSum / middleSize;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    int m;\\n    int k;\\n    List<Integer> stream; // a list to store all incoming elements\\n    TreeSet<int[]> smallestKContainer;  // store smallest k elements of the m\\n    TreeSet<int[]> middleContainer;  // store middle elements of the m\\n    TreeSet<int[]> largestKContainer;  // store largest k elements of the m\\n    int middleSum; // sum of the middle elements of the m\\n    int middleSize;  // size upper bound of the middleContainer\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.stream = new ArrayList<>();\\n        Comparator<int[]> comparator = new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] == b[0]) {\\n                    return a[1] - b[1];\\n                }\\n                return a[0] - b[0]; // [value, index]\\n            }\\n        };\\n        this.smallestKContainer = new TreeSet<>(comparator);\\n        this.middleContainer = new TreeSet<>(comparator);\\n        this.largestKContainer = new TreeSet<>(comparator);\\n        this.middleSum = 0;\\n        this.middleSize = m - 2 * k;\\n    }\\n    \\n    // First-time with rearrange: O(logm + klogk)\\n    // Following add with rearrange: O(logm + logk)\\n    public void addElement(int num) {\\n        stream.add(num);\\n        middleSum += num;\\n        // step 1. insert to middleContainer firstly so that we can easily rearrange later\\n        middleContainer.add(new int[]{num, stream.size() - 1}); \\n        int totalSize = smallestKContainer.size() + middleContainer.size() + largestKContainer.size();\\n        if (totalSize >= m) {\\n            if (totalSize > m) {\\n                // step 2. remove the element with least index among the m and reduce middleSum\\n                int rIdx = stream.size() - 1 - m;\\n                int rVal = stream.get(rIdx);\\n                int[] rEle = new int[]{rVal, rIdx};\\n                smallestKContainer.remove(rEle);\\n                largestKContainer.remove(rEle);\\n                if (middleContainer.remove(rEle)) {\\n                    middleSum -= rVal;\\n                }\\n            }\\n            // step 3. rearrange the three containers to make sure the smallest k and largest k are stored in the proper container\\n            rearrangeContainers(); \\n        }\\n    }\\n    \\n    private void rearrangeContainers() {\\n        // action 1. move extra elements out of middleContainer\\n        if (middleContainer.size() > middleSize) {\\n            while (largestKContainer.size() < k) {\\n                int[] rMid = middleContainer.pollLast();\\n                largestKContainer.add(rMid);\\n                middleSum -= rMid[0];\\n            }\\n            while (smallestKContainer.size() < k) {\\n                int[] rMid = middleContainer.pollFirst();\\n                smallestKContainer.add(rMid);\\n                middleSum -= rMid[0];\\n            }\\n        }\\n        // action 2. swap unsorted element to the proper container\\n        if (middleContainer.last()[0] > largestKContainer.first()[0]) {\\n            int[] temp = middleContainer.pollLast();\\n            int[] largestKContainerFirst = largestKContainer.pollFirst();\\n            middleContainer.add(largestKContainerFirst);\\n            largestKContainer.add(temp);\\n            middleSum -= temp[0];\\n            middleSum += largestKContainerFirst[0];\\n        }\\n        if (middleContainer.first()[0] < smallestKContainer.last()[0]) {\\n            int[] temp = middleContainer.pollFirst();\\n            int[] smallestKContainerLast = smallestKContainer.pollLast();\\n            middleContainer.add(smallestKContainerLast);\\n            smallestKContainer.add(temp);\\n            middleSum -= temp[0];\\n            middleSum += smallestKContainerLast[0];\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (stream.size() < m) {\\n            return -1;\\n        }\\n        return middleSum / middleSize;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303878,
                "title": "3-sorted-sets-and-a-queue",
                "content": "Heavily inspired by - https://leetcode.com/problems/finding-mk-average/discuss/1152915/Java-O(logN)-O(1)-time.-beat-100.-SortedList-implementation.\\n```\\npublic class MKAverage {\\n    Queue<(int val, int idx)> _q = null;\\n    int _i=0;\\n    int _m = 0;\\n    int _k = 0;\\n    int _runningSum = 0;\\n    SortedSet<(int val, int idx)> _left = null; //k-Smallest\\n    SortedSet<(int val, int idx)> _middle = null;//Elements that are not the k-largest or smallest. (m-2k) size\\n    SortedSet<(int val, int idx)> _right = null;//k-Largest\\n    \\n    public MKAverage(int m, int k) {\\n        _m = m;\\n        _k = k;\\n        _q = new Queue<(int val, int idx)>();\\n        _left = new SortedSet<(int val, int idx)>();\\n        _middle = new SortedSet<(int val, int idx)>();\\n        _right = new SortedSet<(int val, int idx)>();\\n    }\\n    \\n    public void AddElement(int num) {\\n        (int val, int idx) newElem = (num, _i++);\\n        _q.Enqueue(newElem);\\n        \\n\\t\\tAddToSortedSets(newElem);\\n\\n\\t\\tif(_q.Count > _m){\\n            var rem = _q.Dequeue();\\n            RemoveFromSortedSets(rem);\\n        }\\n        \\n        RebalanceSortedSets();\\n    }\\n    \\n    void AddToSortedSets((int val, int idx) newElem){\\n        if(_left.Count==0 || newElem.val<= _left.Max.val)\\n            _left.Add(newElem);\\n        else if(_middle.Count==0 || newElem.val<= _middle.Max.val){\\n            _runningSum+=newElem.val;\\n            _middle.Add(newElem);\\n        }\\n        else \\n            _right.Add(newElem);\\n    }\\n    \\n    void RemoveFromSortedSets((int val, int idx) rem){\\n        if(_left.Contains(rem)) \\n\\t\\t\\t_left.Remove(rem);\\n        else if(_right.Contains(rem)) \\n\\t\\t\\t_right.Remove(rem);\\n        else if(_middle.Contains(rem)){\\n            _runningSum-=rem.val;\\n            _middle.Remove(rem);\\n        }\\n    }\\n    \\n    void RebalanceSortedSets(){\\n        if(_left.Count>_k){\\n            _runningSum+=_left.Max.val;\\n            Move(_left, _middle, _left.Max);\\n        }\\n        else if (_left.Count<_k && _middle.Count>0){\\n            _runningSum-=_middle.Min.val;\\n            Move(_middle, _left, _middle.Min);\\n        }\\n        \\n        if(_middle.Count> (_m - 2*_k)){\\n            _runningSum-=_middle.Max.val;\\n            Move(_middle, _right, _middle.Max);\\n        }\\n        else if (_middle.Count< (_m - 2*_k) && _right.Count>0){\\n            _runningSum+=_right.Min.val;\\n            Move(_right, _middle, _right.Min);\\n        }\\n    }\\n    \\n    void Move (SortedSet<(int val, int idx)> fromSet, SortedSet<(int val, int idx)> toSet, (int val, int idx) valToMove){\\n        fromSet.Remove(valToMove);\\n        toSet.Add(valToMove);\\n    }\\n    \\n    public int CalculateMKAverage() {\\n        if(_left.Count + _middle.Count + _right.Count < _m) return -1;\\n        else{\\n            var avg = _runningSum*1.0/(_m-2*_k);\\n            return (int)Math.Floor(avg);\\n        }\\n    }\\n}\\n```\\nAddElement is O(log M), since the middle set can have m-2k elements.\\nCalculateMKAverage is constant time.",
                "solutionTags": [],
                "code": "```\\npublic class MKAverage {\\n    Queue<(int val, int idx)> _q = null;\\n    int _i=0;\\n    int _m = 0;\\n    int _k = 0;\\n    int _runningSum = 0;\\n    SortedSet<(int val, int idx)> _left = null; //k-Smallest\\n    SortedSet<(int val, int idx)> _middle = null;//Elements that are not the k-largest or smallest. (m-2k) size\\n    SortedSet<(int val, int idx)> _right = null;//k-Largest\\n    \\n    public MKAverage(int m, int k) {\\n        _m = m;\\n        _k = k;\\n        _q = new Queue<(int val, int idx)>();\\n        _left = new SortedSet<(int val, int idx)>();\\n        _middle = new SortedSet<(int val, int idx)>();\\n        _right = new SortedSet<(int val, int idx)>();\\n    }\\n    \\n    public void AddElement(int num) {\\n        (int val, int idx) newElem = (num, _i++);\\n        _q.Enqueue(newElem);\\n        \\n\\t\\tAddToSortedSets(newElem);\\n\\n\\t\\tif(_q.Count > _m){\\n            var rem = _q.Dequeue();\\n            RemoveFromSortedSets(rem);\\n        }\\n        \\n        RebalanceSortedSets();\\n    }\\n    \\n    void AddToSortedSets((int val, int idx) newElem){\\n        if(_left.Count==0 || newElem.val<= _left.Max.val)\\n            _left.Add(newElem);\\n        else if(_middle.Count==0 || newElem.val<= _middle.Max.val){\\n            _runningSum+=newElem.val;\\n            _middle.Add(newElem);\\n        }\\n        else \\n            _right.Add(newElem);\\n    }\\n    \\n    void RemoveFromSortedSets((int val, int idx) rem){\\n        if(_left.Contains(rem)) \\n\\t\\t\\t_left.Remove(rem);\\n        else if(_right.Contains(rem)) \\n\\t\\t\\t_right.Remove(rem);\\n        else if(_middle.Contains(rem)){\\n            _runningSum-=rem.val;\\n            _middle.Remove(rem);\\n        }\\n    }\\n    \\n    void RebalanceSortedSets(){\\n        if(_left.Count>_k){\\n            _runningSum+=_left.Max.val;\\n            Move(_left, _middle, _left.Max);\\n        }\\n        else if (_left.Count<_k && _middle.Count>0){\\n            _runningSum-=_middle.Min.val;\\n            Move(_middle, _left, _middle.Min);\\n        }\\n        \\n        if(_middle.Count> (_m - 2*_k)){\\n            _runningSum-=_middle.Max.val;\\n            Move(_middle, _right, _middle.Max);\\n        }\\n        else if (_middle.Count< (_m - 2*_k) && _right.Count>0){\\n            _runningSum+=_right.Min.val;\\n            Move(_right, _middle, _right.Min);\\n        }\\n    }\\n    \\n    void Move (SortedSet<(int val, int idx)> fromSet, SortedSet<(int val, int idx)> toSet, (int val, int idx) valToMove){\\n        fromSet.Remove(valToMove);\\n        toSet.Add(valToMove);\\n    }\\n    \\n    public int CalculateMKAverage() {\\n        if(_left.Count + _middle.Count + _right.Count < _m) return -1;\\n        else{\\n            var avg = _runningSum*1.0/(_m-2*_k);\\n            return (int)Math.Floor(avg);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286453,
                "title": "simple-but-slower-using-sortedlist-and-deque-without-tracking-lef-k-or-right-k-total",
                "content": "Many people saying this is misleading but for a 45 minutes interview, this make sense as it\\'s a lot of code and does thorough testing of your DS understanding. I love it\\n```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.sorted_list = SortedList({})\\n        self.m_elements_queue = deque([])\\n        self.k = k\\n        self.m = m\\n        self.total = 0\\n        \\n    def addElement(self, num: int) -> None:\\n        index = self.sorted_list.bisect_left(num)\\n        self.m_elements_queue.append(num)\\n        self.total += num\\n        self.sorted_list.add(num)\\n        \\n        if len(self.sorted_list) > self.m:\\n            popped_num = self.m_elements_queue.popleft()\\n            index = self.sorted_list.index(popped_num)\\n            self.total -= popped_num\\n            self.sorted_list.remove(popped_num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sorted_list) < self.m:\\n            return -1\\n        left_k = sum(self.sorted_list[:self.k])\\n        right_k = sum(self.sorted_list[len(self.sorted_list) - self.k:])\\n        return (self.total - left_k - right_k) // (self.m - 2*self.k)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.sorted_list = SortedList({})\\n        self.m_elements_queue = deque([])\\n        self.k = k\\n        self.m = m\\n        self.total = 0\\n        \\n    def addElement(self, num: int) -> None:\\n        index = self.sorted_list.bisect_left(num)\\n        self.m_elements_queue.append(num)\\n        self.total += num\\n        self.sorted_list.add(num)\\n        \\n        if len(self.sorted_list) > self.m:\\n            popped_num = self.m_elements_queue.popleft()\\n            index = self.sorted_list.index(popped_num)\\n            self.total -= popped_num\\n            self.sorted_list.remove(popped_num)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.sorted_list) < self.m:\\n            return -1\\n        left_k = sum(self.sorted_list[:self.k])\\n        right_k = sum(self.sorted_list[len(self.sorted_list) - self.k:])\\n        return (self.total - left_k - right_k) // (self.m - 2*self.k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283724,
                "title": "getting-wa-though-logic-is-preety-straigh-forward",
                "content": "Can someone pls help me , what I\\'m missing in my code is simple approah\\nIt is giving WA wondering how come it is possible??.\\n\\n\\nclass MKAverage {\\n    PriorityQueue<Integer> maxHeap;\\n\\tPriorityQueue<Integer> minHeap;\\n\\tList<Integer> lastMElements;\\n\\t long m, k, sumMaxHeap = 0, sumMinHeap = 0, totalSum=0l;\\n\\tdouble avg;\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tavg = -1.0;\\n\\t\\tmaxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tminHeap = new PriorityQueue<>();\\n\\t\\tlastMElements = new LinkedList<Integer>();\\n\\t}\\n\\n\\tpublic void addElement(int num) {\\n\\t\\tif (lastMElements.size() < m) {\\n\\t\\t\\tlastMElements.add(num);\\n\\t\\t\\ttotalSum += num;\\n\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\tminHeap.add(num);\\n            if(lastMElements.size()==m){\\n            int i = 0;\\n\\t\\t\\tlong temp = totalSum;\\n            System.out.println(totalSum);\\n\\t\\t    Iterator<Integer>iterator = maxHeap.iterator();  \\n\\t\\t    while(iterator.hasNext()){  \\n\\t\\t    \\ttemp -= iterator.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t    i = 0;\\n\\t\\t\\tIterator<Integer>iterator2 = minHeap.iterator();  \\n\\t\\t    while(iterator2.hasNext()){  \\n\\t\\t    \\ttemp -= iterator2.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t\\t\\n\\t\\t\\tavg = (temp /  (m - (2 * k)));\\n                System.out.println(avg);\\n            }\\n\\t\\t}\\n\\t\\telse if (lastMElements.size() >= m) {\\n\\t\\t\\tint elementToRemoved = lastMElements.get(0);\\n\\t\\t\\tlastMElements.remove(0);\\n\\t\\t\\tmaxHeap.remove(elementToRemoved);\\n\\t\\t\\tminHeap.remove(elementToRemoved);\\n\\t\\t\\ttotalSum += num;\\n\\t\\t\\ttotalSum -= elementToRemoved;\\n\\t\\t\\tlastMElements.add(num);\\n\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\tminHeap.add(num);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tlong temp = totalSum;\\n\\t\\t    Iterator<Integer>iterator = maxHeap.iterator();  \\n\\t\\t    while(iterator.hasNext()){  \\n\\t\\t    \\ttemp -= iterator.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t    i = 0;\\n\\t\\t\\tIterator<Integer>iterator2 = minHeap.iterator();  \\n\\t\\t    while(iterator2.hasNext()){  \\n\\t\\t    \\ttemp -= iterator2.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t\\t\\n\\t\\t\\tavg = (temp / (m - (2 * k)));\\n            System.out.println(avg);\\n\\t\\t} \\n\\n\\t}\\n\\n\\tpublic int calculateMKAverage() {\\n\\t\\treturn (int) Math.floor(avg);\\n\\t}\\n}\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */",
                "solutionTags": [],
                "code": "Can someone pls help me , what I\\'m missing in my code is simple approah\\nIt is giving WA wondering how come it is possible??.\\n\\n\\nclass MKAverage {\\n    PriorityQueue<Integer> maxHeap;\\n\\tPriorityQueue<Integer> minHeap;\\n\\tList<Integer> lastMElements;\\n\\t long m, k, sumMaxHeap = 0, sumMinHeap = 0, totalSum=0l;\\n\\tdouble avg;\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tavg = -1.0;\\n\\t\\tmaxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tminHeap = new PriorityQueue<>();\\n\\t\\tlastMElements = new LinkedList<Integer>();\\n\\t}\\n\\n\\tpublic void addElement(int num) {\\n\\t\\tif (lastMElements.size() < m) {\\n\\t\\t\\tlastMElements.add(num);\\n\\t\\t\\ttotalSum += num;\\n\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\tminHeap.add(num);\\n            if(lastMElements.size()==m){\\n            int i = 0;\\n\\t\\t\\tlong temp = totalSum;\\n            System.out.println(totalSum);\\n\\t\\t    Iterator<Integer>iterator = maxHeap.iterator();  \\n\\t\\t    while(iterator.hasNext()){  \\n\\t\\t    \\ttemp -= iterator.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t    i = 0;\\n\\t\\t\\tIterator<Integer>iterator2 = minHeap.iterator();  \\n\\t\\t    while(iterator2.hasNext()){  \\n\\t\\t    \\ttemp -= iterator2.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t\\t\\n\\t\\t\\tavg = (temp /  (m - (2 * k)));\\n                System.out.println(avg);\\n            }\\n\\t\\t}\\n\\t\\telse if (lastMElements.size() >= m) {\\n\\t\\t\\tint elementToRemoved = lastMElements.get(0);\\n\\t\\t\\tlastMElements.remove(0);\\n\\t\\t\\tmaxHeap.remove(elementToRemoved);\\n\\t\\t\\tminHeap.remove(elementToRemoved);\\n\\t\\t\\ttotalSum += num;\\n\\t\\t\\ttotalSum -= elementToRemoved;\\n\\t\\t\\tlastMElements.add(num);\\n\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\tminHeap.add(num);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tlong temp = totalSum;\\n\\t\\t    Iterator<Integer>iterator = maxHeap.iterator();  \\n\\t\\t    while(iterator.hasNext()){  \\n\\t\\t    \\ttemp -= iterator.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t    i = 0;\\n\\t\\t\\tIterator<Integer>iterator2 = minHeap.iterator();  \\n\\t\\t    while(iterator2.hasNext()){  \\n\\t\\t    \\ttemp -= iterator2.next();\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (i == k) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t     }  \\n\\t\\t\\t\\n\\t\\t\\tavg = (temp / (m - (2 * k)));\\n            System.out.println(avg);\\n\\t\\t} \\n\\n\\t}\\n\\n\\tpublic int calculateMKAverage() {\\n\\t\\treturn (int) Math.floor(avg);\\n\\t}\\n}\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1228835,
                "title": "python-segment-tree-solution",
                "content": "```\\nclass MKAverage:\\n\\n    # Based on Segment Tree\\n\\t\\n\\t# Since m, k, number of calls are all in the same order, 10^5. Denote them n.\\n\\t# Time Complexity:\\n\\t# - addElement(): O(logn)\\n\\t# - calculateMKAverage(): O(logn * logn)\\n\\t# Space Complexity: O(n)\\n\\t\\n    MAX_NUM = 10 ** 5 + 1\\n    def __init__(self, m: int, k: int):\\n        \\n        self.m = m\\n        self.k = k\\n        \\n        # segment trees for counts and sums\\n\\t\\t# nodes are 1-indexed, so parent -> children is i -> 2i, 2i+1\\n        # use a dict for the tree. node-id: range_sum\\n        self.count = defaultdict(int)\\n        self.presum = defaultdict(int)\\n        \\n        # queue for the last m elements in the stream\\n        self.q = deque()\\n        self.qsum = 0\\n\\n\\n    def seg_tree_update(self, tree, index, val):\\n        # add val to an index in a seg tree, inplace\\n        index += MKAverage.MAX_NUM\\n        \\n        while index:\\n            tree[index] += val\\n            index >>= 1\\n            \\n        return \\n        \\n    def seg_tree_query(self, tree, l, r):\\n        # interval [l, r)\\n        l += MKAverage.MAX_NUM\\n        r += MKAverage.MAX_NUM\\n        \\n        res = 0\\n        while l < r:\\n            \\n            if l & 1:\\n                res += tree[l]\\n                l += 1\\n                \\n            if r & 1:\\n                res += tree[r-1]\\n                r -= 1\\n                \\n            l >>= 1\\n            r >>= 1\\n            \\n        return res\\n        \\n    def search_kth_num(self, k):\\n        # find the k-th smallest number in q\\n        # Equivalently, \\n        # find num which makes the interval sum of self.count in [1,num) equals k.\\n        # or the smallest num making the count greater than k\\n\\n        lo, hi = 1, MKAverage.MAX_NUM\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            cnt = self.seg_tree_query(self.count, 1, mid)\\n            if cnt < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        # return lo - 1 since the interval is right exclusive\\n        return lo - 1\\n        \\n    def addElement(self, num: int) -> None:\\n\\n        # Time: O(logn)\\n        \\n        m, k = self.m, self.k\\n        update = self.seg_tree_update\\n        \\n        # update q and q_sum\\n        self.q.append(num)\\n        self.qsum += num\\n            \\n        # update count\\n        update(self.count, num, 1)\\n        \\n        # update presum\\n        update(self.presum, num, num)\\n        \\n        # remove element \\n        if len(self.q) > m:\\n            old_num = self.q.popleft()\\n            self.qsum -= old_num\\n            update(self.count, old_num, -1)\\n            update(self.presum, old_num, -old_num)\\n            \\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n        # Time: O(logn * logn)\\n        \\n        m, k, q, qsum = self.m, self.k, self.q, self.qsum\\n        query = self.seg_tree_query\\n        \\n        if len(q) < m:\\n            return -1\\n\\n        # find the k-th smallest num\\n        num = self.search_kth_num(k)\\n        # get the sum \\n        left_sum = query(self.presum, 1, num+1) - (query(self.count, 1, num+1) - k) * num\\n        \\n        # find the k-th largest num, namely the (m - k + 1) -th smallest num\\n        num = self.search_kth_num(m - k + 1)\\n        # get the sum\\n        right_sum = query(self.presum, num, self.MAX_NUM) - (query(self.count, num, self.MAX_NUM) - k) * num\\n        \\n        return int((qsum - left_sum - right_sum) / (m - 2 * k))\\n        \\n        \\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n\\n    # Based on Segment Tree\\n\\t\\n\\t# Since m, k, number of calls are all in the same order, 10^5. Denote them n.\\n\\t# Time Complexity:\\n\\t# - addElement(): O(logn)\\n\\t# - calculateMKAverage(): O(logn * logn)\\n\\t# Space Complexity: O(n)\\n\\t\\n    MAX_NUM = 10 ** 5 + 1\\n    def __init__(self, m: int, k: int):\\n        \\n        self.m = m\\n        self.k = k\\n        \\n        # segment trees for counts and sums\\n\\t\\t# nodes are 1-indexed, so parent -> children is i -> 2i, 2i+1\\n        # use a dict for the tree. node-id: range_sum\\n        self.count = defaultdict(int)\\n        self.presum = defaultdict(int)\\n        \\n        # queue for the last m elements in the stream\\n        self.q = deque()\\n        self.qsum = 0\\n\\n\\n    def seg_tree_update(self, tree, index, val):\\n        # add val to an index in a seg tree, inplace\\n        index += MKAverage.MAX_NUM\\n        \\n        while index:\\n            tree[index] += val\\n            index >>= 1\\n            \\n        return \\n        \\n    def seg_tree_query(self, tree, l, r):\\n        # interval [l, r)\\n        l += MKAverage.MAX_NUM\\n        r += MKAverage.MAX_NUM\\n        \\n        res = 0\\n        while l < r:\\n            \\n            if l & 1:\\n                res += tree[l]\\n                l += 1\\n                \\n            if r & 1:\\n                res += tree[r-1]\\n                r -= 1\\n                \\n            l >>= 1\\n            r >>= 1\\n            \\n        return res\\n        \\n    def search_kth_num(self, k):\\n        # find the k-th smallest number in q\\n        # Equivalently, \\n        # find num which makes the interval sum of self.count in [1,num) equals k.\\n        # or the smallest num making the count greater than k\\n\\n        lo, hi = 1, MKAverage.MAX_NUM\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            cnt = self.seg_tree_query(self.count, 1, mid)\\n            if cnt < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        \\n        # return lo - 1 since the interval is right exclusive\\n        return lo - 1\\n        \\n    def addElement(self, num: int) -> None:\\n\\n        # Time: O(logn)\\n        \\n        m, k = self.m, self.k\\n        update = self.seg_tree_update\\n        \\n        # update q and q_sum\\n        self.q.append(num)\\n        self.qsum += num\\n            \\n        # update count\\n        update(self.count, num, 1)\\n        \\n        # update presum\\n        update(self.presum, num, num)\\n        \\n        # remove element \\n        if len(self.q) > m:\\n            old_num = self.q.popleft()\\n            self.qsum -= old_num\\n            update(self.count, old_num, -1)\\n            update(self.presum, old_num, -old_num)\\n            \\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n        # Time: O(logn * logn)\\n        \\n        m, k, q, qsum = self.m, self.k, self.q, self.qsum\\n        query = self.seg_tree_query\\n        \\n        if len(q) < m:\\n            return -1\\n\\n        # find the k-th smallest num\\n        num = self.search_kth_num(k)\\n        # get the sum \\n        left_sum = query(self.presum, 1, num+1) - (query(self.count, 1, num+1) - k) * num\\n        \\n        # find the k-th largest num, namely the (m - k + 1) -th smallest num\\n        num = self.search_kth_num(m - k + 1)\\n        # get the sum\\n        right_sum = query(self.presum, num, self.MAX_NUM) - (query(self.count, num, self.MAX_NUM) - k) * num\\n        \\n        return int((qsum - left_sum - right_sum) / (m - 2 * k))\\n        \\n        \\n\\n# Your MKAverage object will be instantiated and called as such:\\n# obj = MKAverage(m, k)\\n# obj.addElement(num)\\n# param_2 = obj.calculateMKAverage()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188544,
                "title": "c-balancing-three-lists-a-queue-and-using-binarysearch",
                "content": "The solution is basically a C# variation of several proposals here. Again, I have leaned heavily on votrubac\\'s solution in C++ ([LINK](https://leetcode.com/problems/finding-mk-average/discuss/1152724/C%2B%2B-Balance-3-Multisets)).\\n\\nA `Queue<int>` tis used to o track last `m` items added, and three `List<int>` objects are used to track left, middle and right part of the range. The `BinarySearch` method of the `List<T>` is used to speed up inserting of an item to each one of the lists and maintain order, keeping all lists sorted at any time.\\n\\n```\\npublic class MKAverage {      \\n    private int m;\\n    private int k;\\n    private int sz;\\n    private int counter;\\n    \\n    private List<int> left;\\n    private List<int> middle;\\n    private List<int> right;\\n    private Queue<int> range;\\n    \\n    private int sum;\\n    \\n    private void Insert(List<int> list, int item) {  \\n        \\n        int index = list.BinarySearch(item);\\n        \\n        if (index < 0) index = ~index;\\n        \\n        list.Insert(index, item);\\n    }\\n    \\n    private void Add(int num) {\\n        int mov;\\n        \\n        this.Remove();\\n        \\n        this.Insert(this.left, num);\\n        \\n        if (this.left.Count > this.k) {\\n            mov = this.left[this.left.Count - 1];\\n\\n            this.Insert(this.middle, mov);            \\n            this.sum += mov;            \\n            this.TakeOut(this.left, mov);\\n        }\\n        \\n        if (this.middle.Count > this.sz) {\\n            mov = this.middle[this.middle.Count - 1];\\n            \\n            this.Insert(this.right, mov);\\n            this.sum -= mov;            \\n            this.TakeOut(this.middle, mov);\\n        }\\n        \\n        this.range.Enqueue(num);\\n        \\n    }\\n    \\n    private bool TakeOut(List<int> list, int item) {\\n        \\n        int index = list.BinarySearch(item);\\n        \\n        if (index >= 0) {\\n            list.RemoveAt(index);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void Remove() {\\n        int mov;\\n        \\n        while (this.range.Count >= this.m) {\\n            mov = range.Dequeue();\\n            \\n            if (this.TakeOut(this.left, mov)) {\\n                mov = this.middle[0];\\n                this.sum -= mov;\\n                this.Insert(this.left, mov);\\n                this.TakeOut(this.middle, mov);\\n                \\n                mov = this.right[0];\\n                this.sum += mov;\\n                this.Insert(this.middle, mov);\\n                this.TakeOut(this.right, mov);\\n                \\n            } else if (this.TakeOut(this.middle, mov)) {\\n                this.sum -= mov;\\n                \\n                mov = this.right[0];\\n                this.sum += mov;\\n                this.Insert(this.middle, mov);\\n                this.TakeOut(this.right, mov);\\n            } else  {\\n                this.TakeOut(this.right, mov);\\n            }\\n        }        \\n    }\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.sz = m - 2*k;\\n        this.counter = 0;\\n        \\n        this.left = new List<int>();\\n        this.middle = new List<int>();\\n        this.right = new List<int>();\\n        this.range = new Queue<int>();\\n    }\\n    \\n    public void AddElement(int num) {                  \\n        this.Add(num);      \\n    }\\n    \\n    public int CalculateMKAverage() {        \\n        if (range.Count < m || this.m < 1) return -1;      \\n        int avg = 0;\\n                \\n        if (sz > 0) {\\n            avg = this.sum / this.sz;\\n        }\\n        \\n        return avg;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.AddElement(num);\\n * int param_2 = obj.CalculateMKAverage();\\n */\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class MKAverage {      \\n    private int m;\\n    private int k;\\n    private int sz;\\n    private int counter;\\n    \\n    private List<int> left;\\n    private List<int> middle;\\n    private List<int> right;\\n    private Queue<int> range;\\n    \\n    private int sum;\\n    \\n    private void Insert(List<int> list, int item) {  \\n        \\n        int index = list.BinarySearch(item);\\n        \\n        if (index < 0) index = ~index;\\n        \\n        list.Insert(index, item);\\n    }\\n    \\n    private void Add(int num) {\\n        int mov;\\n        \\n        this.Remove();\\n        \\n        this.Insert(this.left, num);\\n        \\n        if (this.left.Count > this.k) {\\n            mov = this.left[this.left.Count - 1];\\n\\n            this.Insert(this.middle, mov);            \\n            this.sum += mov;            \\n            this.TakeOut(this.left, mov);\\n        }\\n        \\n        if (this.middle.Count > this.sz) {\\n            mov = this.middle[this.middle.Count - 1];\\n            \\n            this.Insert(this.right, mov);\\n            this.sum -= mov;            \\n            this.TakeOut(this.middle, mov);\\n        }\\n        \\n        this.range.Enqueue(num);\\n        \\n    }\\n    \\n    private bool TakeOut(List<int> list, int item) {\\n        \\n        int index = list.BinarySearch(item);\\n        \\n        if (index >= 0) {\\n            list.RemoveAt(index);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void Remove() {\\n        int mov;\\n        \\n        while (this.range.Count >= this.m) {\\n            mov = range.Dequeue();\\n            \\n            if (this.TakeOut(this.left, mov)) {\\n                mov = this.middle[0];\\n                this.sum -= mov;\\n                this.Insert(this.left, mov);\\n                this.TakeOut(this.middle, mov);\\n                \\n                mov = this.right[0];\\n                this.sum += mov;\\n                this.Insert(this.middle, mov);\\n                this.TakeOut(this.right, mov);\\n                \\n            } else if (this.TakeOut(this.middle, mov)) {\\n                this.sum -= mov;\\n                \\n                mov = this.right[0];\\n                this.sum += mov;\\n                this.Insert(this.middle, mov);\\n                this.TakeOut(this.right, mov);\\n            } else  {\\n                this.TakeOut(this.right, mov);\\n            }\\n        }        \\n    }\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.sz = m - 2*k;\\n        this.counter = 0;\\n        \\n        this.left = new List<int>();\\n        this.middle = new List<int>();\\n        this.right = new List<int>();\\n        this.range = new Queue<int>();\\n    }\\n    \\n    public void AddElement(int num) {                  \\n        this.Add(num);      \\n    }\\n    \\n    public int CalculateMKAverage() {        \\n        if (range.Count < m || this.m < 1) return -1;      \\n        int avg = 0;\\n                \\n        if (sz > 0) {\\n            avg = this.sum / this.sz;\\n        }\\n        \\n        return avg;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.AddElement(num);\\n * int param_2 = obj.CalculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187493,
                "title": "python-solution-using-sortedlist-and-deque",
                "content": "```python\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.queue = deque()\\n        self.k = k           # first index of the mid range\\n        self.k2 = m - k - 1  # last index of the mid range\\n        self._list = SortedList()\\n        self.sum = 0\\n        self.valid = self.m - 2 * self.k  # no of elements in a valid range\\n        \\n    def _remove(self, num: int) -> None:\\n        index = self._list.index(num)\\n        if index < self.k:\\n            # if num is being removed form first-k,\\n            # then smallest element from the mid will be absorbed by the first-k\\n            self.sum -= self._list[self.k]\\n        elif index > self.k2:\\n            # if num is being removed form last-k,\\n            # then largest element from the mid will be absorbed by the last-k\\n            self.sum -= self._list[self.k2]\\n        else:\\n            # num directly removed from the mid\\n            self.sum -= num\\n        self._list.remove(num)\\n\\n    def _add(self, num: int, size: int) -> None:\\n        self._list.add(num)\\n        index = self._list.index(num)\\n        if index < self.k:\\n            # if num is added to first-k\\n            # the prev largest element from first-k will become part of mid\\n            self.sum += self._list[self.k]\\n        elif index >= size - self.k:\\n            # if num is added to last-k\\n            # the prev smallest element from last-k will become part of mid\\n            self.sum += self._list[size - self.k - 1]\\n        else:\\n            # num directly added to mid\\n            self.sum += num\\n\\n    def addElement(self, num: int) -> None:\\n        self.queue.append(num)\\n        popped = None\\n        if len(self.queue) > self.m:\\n            popped = self.queue.popleft()\\n        if popped is None:\\n            size = len(self.queue)\\n            if size > 2 * self.k:\\n                # if the first-k and last-k have been filled, start adding to sum\\n                self._add(num, size)\\n            else:\\n                self._list.add(num)\\n        else:\\n            self._remove(popped)\\n            self._add(num, self.m)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue) != self.m:\\n            return -1\\n        return self.sum // self.valid\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\nfrom collections import deque\\n\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.queue = deque()\\n        self.k = k           # first index of the mid range\\n        self.k2 = m - k - 1  # last index of the mid range\\n        self._list = SortedList()\\n        self.sum = 0\\n        self.valid = self.m - 2 * self.k  # no of elements in a valid range\\n        \\n    def _remove(self, num: int) -> None:\\n        index = self._list.index(num)\\n        if index < self.k:\\n            # if num is being removed form first-k,\\n            # then smallest element from the mid will be absorbed by the first-k\\n            self.sum -= self._list[self.k]\\n        elif index > self.k2:\\n            # if num is being removed form last-k,\\n            # then largest element from the mid will be absorbed by the last-k\\n            self.sum -= self._list[self.k2]\\n        else:\\n            # num directly removed from the mid\\n            self.sum -= num\\n        self._list.remove(num)\\n\\n    def _add(self, num: int, size: int) -> None:\\n        self._list.add(num)\\n        index = self._list.index(num)\\n        if index < self.k:\\n            # if num is added to first-k\\n            # the prev largest element from first-k will become part of mid\\n            self.sum += self._list[self.k]\\n        elif index >= size - self.k:\\n            # if num is added to last-k\\n            # the prev smallest element from last-k will become part of mid\\n            self.sum += self._list[size - self.k - 1]\\n        else:\\n            # num directly added to mid\\n            self.sum += num\\n\\n    def addElement(self, num: int) -> None:\\n        self.queue.append(num)\\n        popped = None\\n        if len(self.queue) > self.m:\\n            popped = self.queue.popleft()\\n        if popped is None:\\n            size = len(self.queue)\\n            if size > 2 * self.k:\\n                # if the first-k and last-k have been filled, start adding to sum\\n                self._add(num, size)\\n            else:\\n                self._list.add(num)\\n        else:\\n            self._remove(popped)\\n            self._add(num, self.m)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.queue) != self.m:\\n            return -1\\n        return self.sum // self.valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181300,
                "title": "java-3-treemaps-object-oriented-solution-beats-98",
                "content": "Sharing my code, I find it to be cleaner when compared to the other Java solutions.\\n\\nTime complexity:\\n`addElement`: `O(log m)`\\n`calculateMKAverage`: `O(1)`\\n\\nSpace complexity: `O(m)`\\n\\n```\\nclass MKAverage {\\n    double m, k, c;\\n    double avg;\\n    Bst middle, min, max;\\n    Deque<Integer> q;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.c = m - k * 2;\\n        this.avg = 0;\\n        this.middle = new Bst();\\n        this.min = new Bst();\\n        this.max = new Bst();\\n        this.q = new ArrayDeque<>();\\n    }\\n\\n    public void addElement(int num) {        \\n        if (min.size < k) {\\n            min.add(num);\\n            q.offer(num);\\n            return;\\n        }\\n        if (max.size < k) {\\n            min.add(num);\\n            max.add(min.removeMax());\\n            q.offer(num);\\n            return;\\n        }\\n        \\n        if (num >= min.lastKey() && num <= max.firstKey()) {\\n            middle.add(num);\\n            avg += (double) num / c;\\n        } else if (num < min.lastKey()) {\\n            min.add(num);\\n            int val = min.removeMax();\\n            middle.add(val);\\n            avg += (double) val / c;\\n        } else if (num > max.firstKey()) {\\n            max.add(num);\\n            int val = max.removeMin();\\n            middle.add(val);\\n            avg += (double) val / c;\\n        }\\n\\n        q.offer(num);\\n\\n        if (q.size() > m) {\\n            num = q.poll();\\n            if (middle.containsKey(num)) {\\n                avg -= (double) num / c;\\n                middle.remove(num);\\n            } else if (min.containsKey(num)) {\\n                min.remove(num);\\n                int val = middle.removeMin();\\n                avg -= (double) val / c;\\n                min.add(val);\\n            } else if (max.containsKey(num)) {\\n                max.remove(num);\\n                int val = middle.removeMax();\\n                avg -= (double) val / c;\\n                max.add(val);\\n            }\\n        }\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        return (int) avg;\\n    }\\n\\n    class Bst {\\n        TreeMap<Integer, Integer> bst;\\n        int size;\\n        \\n        public Bst() {\\n            this.bst = new TreeMap<>();\\n            this.size = 0;\\n        }\\n\\n        void add(int num) {\\n            int count = bst.getOrDefault(num, 0) + 1;\\n            bst.put(num, count);\\n            size++;\\n        }\\n\\n        void remove(int num) {\\n            int count = bst.getOrDefault(num, 1) - 1;\\n            if (count > 0) {\\n                bst.put(num, count);\\n            } else {\\n                bst.remove(num);\\n            }\\n            size--;\\n        }\\n\\n        int removeMin() {\\n            int key = bst.firstKey();\\n\\n            remove(key);\\n\\n            return key;\\n        }\\n\\n        int removeMax() {\\n            int key = bst.lastKey();\\n\\n            remove(key);\\n\\n            return key;\\n        }\\n        \\n        boolean containsKey(int key) {\\n            return bst.containsKey(key);\\n        }\\n        \\n        int firstKey() {\\n            return bst.firstKey();\\n        }\\n        \\n        int lastKey() {\\n            return bst.lastKey();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    double m, k, c;\\n    double avg;\\n    Bst middle, min, max;\\n    Deque<Integer> q;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.c = m - k * 2;\\n        this.avg = 0;\\n        this.middle = new Bst();\\n        this.min = new Bst();\\n        this.max = new Bst();\\n        this.q = new ArrayDeque<>();\\n    }\\n\\n    public void addElement(int num) {        \\n        if (min.size < k) {\\n            min.add(num);\\n            q.offer(num);\\n            return;\\n        }\\n        if (max.size < k) {\\n            min.add(num);\\n            max.add(min.removeMax());\\n            q.offer(num);\\n            return;\\n        }\\n        \\n        if (num >= min.lastKey() && num <= max.firstKey()) {\\n            middle.add(num);\\n            avg += (double) num / c;\\n        } else if (num < min.lastKey()) {\\n            min.add(num);\\n            int val = min.removeMax();\\n            middle.add(val);\\n            avg += (double) val / c;\\n        } else if (num > max.firstKey()) {\\n            max.add(num);\\n            int val = max.removeMin();\\n            middle.add(val);\\n            avg += (double) val / c;\\n        }\\n\\n        q.offer(num);\\n\\n        if (q.size() > m) {\\n            num = q.poll();\\n            if (middle.containsKey(num)) {\\n                avg -= (double) num / c;\\n                middle.remove(num);\\n            } else if (min.containsKey(num)) {\\n                min.remove(num);\\n                int val = middle.removeMin();\\n                avg -= (double) val / c;\\n                min.add(val);\\n            } else if (max.containsKey(num)) {\\n                max.remove(num);\\n                int val = middle.removeMax();\\n                avg -= (double) val / c;\\n                max.add(val);\\n            }\\n        }\\n    }\\n\\n    public int calculateMKAverage() {\\n        if (q.size() < m) return -1;\\n        return (int) avg;\\n    }\\n\\n    class Bst {\\n        TreeMap<Integer, Integer> bst;\\n        int size;\\n        \\n        public Bst() {\\n            this.bst = new TreeMap<>();\\n            this.size = 0;\\n        }\\n\\n        void add(int num) {\\n            int count = bst.getOrDefault(num, 0) + 1;\\n            bst.put(num, count);\\n            size++;\\n        }\\n\\n        void remove(int num) {\\n            int count = bst.getOrDefault(num, 1) - 1;\\n            if (count > 0) {\\n                bst.put(num, count);\\n            } else {\\n                bst.remove(num);\\n            }\\n            size--;\\n        }\\n\\n        int removeMin() {\\n            int key = bst.firstKey();\\n\\n            remove(key);\\n\\n            return key;\\n        }\\n\\n        int removeMax() {\\n            int key = bst.lastKey();\\n\\n            remove(key);\\n\\n            return key;\\n        }\\n        \\n        boolean containsKey(int key) {\\n            return bst.containsKey(key);\\n        }\\n        \\n        int firstKey() {\\n            return bst.firstKey();\\n        }\\n        \\n        int lastKey() {\\n            return bst.lastKey();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173779,
                "title": "c-segment-tree-get-the-solution-from-the-accepted-answer",
                "content": "when I use the solution of https://leetcode.com/problems/finding-mk-average/discuss/1152724/C%2B%2B-Balance-3-Multisets to solve the problem. I learn someone use the following solution, I post it here and add some comments for easy understanding. If I obey the copyright, Please let me know, I will delete it.\\n```\\n// #define DEBUG\\nclass MKAverage {\\n    static const int N = 100001;\\n    int m, k;\\n    std::deque<int> q;\\n    long fw0[N] = {}, fw1[N] = {};\\npublic:\\n    void add(long i, long v) {\\n        #ifdef DEBUG\\n        std::cout << __func__ <<\" add : \" << v << \"\\\\n\";\\n        #endif\\n        long u = v > 0 ? 1 : -1; // to judge we do a plus or minus operation\\n        for (; i < N; i |= i+1) {\\n            fw0[i] += u; // the cnt of the numbers add u, \\u7EBF\\u6BB5\\u6811\\u7ED3\\u6784\\uFF0C\\u5B58\\u50A8\\u67D0\\u4E00\\u7279\\u5B9A\\u533A\\u95F4\\u4E2D\\u5143\\u7D20\\u4E2A\\u6570\\n            fw1[i] += v; // the sum of the numbers for a special interval \\u7EBF\\u6BB5\\u6811\\u7ED3\\u6784\\n            #ifdef DEBUG\\n            std::cout << \"index: \" << i << \", cnt: \" << fw0[i] << \", sum: \" << fw1[i] << \"; \";\\n            #endif\\n        }\\n    }\\n\\n    std::tuple<long, long, long> kth(int k) {\\n        #ifdef DEBUG\\n        std::cout << __func__ << \"\\\\n\";\\n        #endif\\n        long ans = 0, c = 0, s = 0;\\n        #ifdef DEBUG\\n        // get the left most bit set number for the maximum number;\\n        // which means get the mostest significant bit(1) for N - 1;\\n        std::cout << \"bits: \" << __builtin_clz(N - 1) << \" bitShift: \" << (1 << (31 - __builtin_clz(N - 1))) << \"\\\\n\";\\n        #endif\\n        for (long i = 1 << (31 - __builtin_clz(N - 1)); i; i >>= 1) {\\n            #ifdef DEBUG\\n            std::cout << i << \", \";\\n            #endif\\n            if (ans + i < N && c + fw0[ans + i - 1] <= k) {\\n                // we count the sum at 1, 11, 111, 1111, ..., 111...11, so we need minus 1\\n                // ans is the next element that we need visit\\n                ans += i, c += fw0[ans - 1], s += fw1[ans - 1];\\n                #ifdef DEBUG\\n                std::cout << \"ans: \" << ans << \", c: \" << c << \", s: \" << s << \"; \";\\n                #endif\\n            }\\n        }\\n        // c <= k must be true. and if c != k, it means that there are too many ans that make c + number of (ans) > k and c < k\\n        return {ans, c, s};\\n    }\\n\\n    long sum(long a[], long i) {\\n        long s = 0;\\n        for (; i; i &= i-1) {\\n            s += a[i-1];\\n        }\\n        return s;\\n    }\\n    MKAverage(int m, int k) : m(m), k(k) {\\n        #ifdef DEBUG\\n        std::bitset<32> nBin(N);\\n        std::cout << N << \", hex: \" << std::hex << N << std::dec << \", bin: \" << nBin << \"\\\\n\";\\n        #endif\\n        \\n    }\\n\\n    void addElement(int num) {\\n        if (q.size() == m) {\\n            // we have storage m elements, to add a new element, we must remove the front element\\n            // to keep the sliding window\\n            int v = q.front();\\n            q.pop_front();\\n            // the base data structure also need remove the most front element\\n            add(v, -v);\\n        }\\n        // add the new element to queue to record the input order\\n        q.push_back(num);\\n        // add the new element into storage\\n        add(num, num);\\n    }\\n\\n    int calculateMKAverage() {\\n        if (q.size() < m) {\\n            return -1;\\n        }\\n        auto [l, c0, s0] = kth(k);\\n        auto [r, c1, s1] = kth(m-k);\\n        // c0 < k and we can\\'t add all the l, because the appearence times of l plusing c0 is larger than k\\n        // we just need k - c0 which is less than cnt[l];\\n        s0 += (k - c0) * l;\\n        \\n        // same to k - c0;\\n        s1 += (m - k - c1) * r;\\n        \\n        return (s1 - s0) / (m - 2 * k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// #define DEBUG\\nclass MKAverage {\\n    static const int N = 100001;\\n    int m, k;\\n    std::deque<int> q;\\n    long fw0[N] = {}, fw1[N] = {};\\npublic:\\n    void add(long i, long v) {\\n        #ifdef DEBUG\\n        std::cout << __func__ <<\" add : \" << v << \"\\\\n\";\\n        #endif\\n        long u = v > 0 ? 1 : -1; // to judge we do a plus or minus operation\\n        for (; i < N; i |= i+1) {\\n            fw0[i] += u; // the cnt of the numbers add u, \\u7EBF\\u6BB5\\u6811\\u7ED3\\u6784\\uFF0C\\u5B58\\u50A8\\u67D0\\u4E00\\u7279\\u5B9A\\u533A\\u95F4\\u4E2D\\u5143\\u7D20\\u4E2A\\u6570\\n            fw1[i] += v; // the sum of the numbers for a special interval \\u7EBF\\u6BB5\\u6811\\u7ED3\\u6784\\n            #ifdef DEBUG\\n            std::cout << \"index: \" << i << \", cnt: \" << fw0[i] << \", sum: \" << fw1[i] << \"; \";\\n            #endif\\n        }\\n    }\\n\\n    std::tuple<long, long, long> kth(int k) {\\n        #ifdef DEBUG\\n        std::cout << __func__ << \"\\\\n\";\\n        #endif\\n        long ans = 0, c = 0, s = 0;\\n        #ifdef DEBUG\\n        // get the left most bit set number for the maximum number;\\n        // which means get the mostest significant bit(1) for N - 1;\\n        std::cout << \"bits: \" << __builtin_clz(N - 1) << \" bitShift: \" << (1 << (31 - __builtin_clz(N - 1))) << \"\\\\n\";\\n        #endif\\n        for (long i = 1 << (31 - __builtin_clz(N - 1)); i; i >>= 1) {\\n            #ifdef DEBUG\\n            std::cout << i << \", \";\\n            #endif\\n            if (ans + i < N && c + fw0[ans + i - 1] <= k) {\\n                // we count the sum at 1, 11, 111, 1111, ..., 111...11, so we need minus 1\\n                // ans is the next element that we need visit\\n                ans += i, c += fw0[ans - 1], s += fw1[ans - 1];\\n                #ifdef DEBUG\\n                std::cout << \"ans: \" << ans << \", c: \" << c << \", s: \" << s << \"; \";\\n                #endif\\n            }\\n        }\\n        // c <= k must be true. and if c != k, it means that there are too many ans that make c + number of (ans) > k and c < k\\n        return {ans, c, s};\\n    }\\n\\n    long sum(long a[], long i) {\\n        long s = 0;\\n        for (; i; i &= i-1) {\\n            s += a[i-1];\\n        }\\n        return s;\\n    }\\n    MKAverage(int m, int k) : m(m), k(k) {\\n        #ifdef DEBUG\\n        std::bitset<32> nBin(N);\\n        std::cout << N << \", hex: \" << std::hex << N << std::dec << \", bin: \" << nBin << \"\\\\n\";\\n        #endif\\n        \\n    }\\n\\n    void addElement(int num) {\\n        if (q.size() == m) {\\n            // we have storage m elements, to add a new element, we must remove the front element\\n            // to keep the sliding window\\n            int v = q.front();\\n            q.pop_front();\\n            // the base data structure also need remove the most front element\\n            add(v, -v);\\n        }\\n        // add the new element to queue to record the input order\\n        q.push_back(num);\\n        // add the new element into storage\\n        add(num, num);\\n    }\\n\\n    int calculateMKAverage() {\\n        if (q.size() < m) {\\n            return -1;\\n        }\\n        auto [l, c0, s0] = kth(k);\\n        auto [r, c1, s1] = kth(m-k);\\n        // c0 < k and we can\\'t add all the l, because the appearence times of l plusing c0 is larger than k\\n        // we just need k - c0 which is less than cnt[l];\\n        s0 += (k - c0) * l;\\n        \\n        // same to k - c0;\\n        s1 += (m - k - c1) * r;\\n        \\n        return (s1 - s0) / (m - 2 * k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1162193,
                "title": "java-treeset-mimics-c-multiset-16-17-passed-please-help",
                "content": "```\\nclass Range {\\n    TreeSet<Long> set = new TreeSet();\\n    long sum = 0;\\n    public void insert(long x) {\\n        set.add(x);\\n        sum += x;\\n    }\\n    public void remove(long x) {\\n        set.remove(x);\\n        sum -= x;\\n    }\\n}\\n\\nclass MKAverage {\\n    Queue<Long> window;\\n    long sum = 0;\\n    int m, k, range;\\n    int index = 0;\\n    Range L, M, R;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        L = new Range();\\n        M = new Range();\\n        R = new Range();\\n        window = new ArrayDeque<>();\\n        range = m - 2 * k;\\n    }\\n    \\n    public void addElement(int _num) {\\n        index++;\\n        long num = _num * 1000000L + index; // to differentiate the same value\\n        window.offer(num);\\n        if (window.size() < m) return;\\n        if (window.size() == m) { // one time operation\\n            List<Long> w = new ArrayList<>(window);\\n            Collections.sort(w);\\n            for (int i = 0; i < k; i++) L.insert(w.get(i));\\n            for (int i = k; i < m - k; i++) M.insert(w.get(i));\\n            for (int i = m - k; i < m; i++) R.insert(w.get(i));\\n        }\\n        else {\\n            M.insert(num);\\n            if (L.set.last() > M.set.first()) {\\n                long x = M.set.first();\\n                long y = L.set.last();\\n                M.remove(x);\\n                L.insert(x);\\n                L.remove(y);\\n                M.insert(y);\\n            }\\n            if (R.set.first() < M.set.last()) {\\n                long x = M.set.last();\\n                long y = R.set.first();\\n                M.remove(x);\\n                R.insert(x);\\n                R.remove(y);\\n                M.insert(y);\\n            }\\n           \\n            long toRemove = window.poll();\\n            if (M.set.contains(toRemove)) {\\n                M.remove(toRemove);\\n            }\\n            else if (L.set.contains(toRemove)) {\\n                L.remove(toRemove);\\n                long Mmin = M.set.first();\\n                M.remove(Mmin);\\n                L.insert(Mmin);\\n            }\\n            else { \\n                R.remove(toRemove);\\n                long Mmax = M.set.last();\\n                M.remove(Mmax);\\n                R.insert(Mmax);\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (window.size() < m) {\\n            return -1;\\n        }\\n        return (int)(M.sum / (1000000L * range));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Range {\\n    TreeSet<Long> set = new TreeSet();\\n    long sum = 0;\\n    public void insert(long x) {\\n        set.add(x);\\n        sum += x;\\n    }\\n    public void remove(long x) {\\n        set.remove(x);\\n        sum -= x;\\n    }\\n}\\n\\nclass MKAverage {\\n    Queue<Long> window;\\n    long sum = 0;\\n    int m, k, range;\\n    int index = 0;\\n    Range L, M, R;\\n    \\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        L = new Range();\\n        M = new Range();\\n        R = new Range();\\n        window = new ArrayDeque<>();\\n        range = m - 2 * k;\\n    }\\n    \\n    public void addElement(int _num) {\\n        index++;\\n        long num = _num * 1000000L + index; // to differentiate the same value\\n        window.offer(num);\\n        if (window.size() < m) return;\\n        if (window.size() == m) { // one time operation\\n            List<Long> w = new ArrayList<>(window);\\n            Collections.sort(w);\\n            for (int i = 0; i < k; i++) L.insert(w.get(i));\\n            for (int i = k; i < m - k; i++) M.insert(w.get(i));\\n            for (int i = m - k; i < m; i++) R.insert(w.get(i));\\n        }\\n        else {\\n            M.insert(num);\\n            if (L.set.last() > M.set.first()) {\\n                long x = M.set.first();\\n                long y = L.set.last();\\n                M.remove(x);\\n                L.insert(x);\\n                L.remove(y);\\n                M.insert(y);\\n            }\\n            if (R.set.first() < M.set.last()) {\\n                long x = M.set.last();\\n                long y = R.set.first();\\n                M.remove(x);\\n                R.insert(x);\\n                R.remove(y);\\n                M.insert(y);\\n            }\\n           \\n            long toRemove = window.poll();\\n            if (M.set.contains(toRemove)) {\\n                M.remove(toRemove);\\n            }\\n            else if (L.set.contains(toRemove)) {\\n                L.remove(toRemove);\\n                long Mmin = M.set.first();\\n                M.remove(Mmin);\\n                L.insert(Mmin);\\n            }\\n            else { \\n                R.remove(toRemove);\\n                long Mmax = M.set.last();\\n                M.remove(Mmax);\\n                R.insert(Mmax);\\n            }\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (window.size() < m) {\\n            return -1;\\n        }\\n        return (int)(M.sum / (1000000L * range));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157770,
                "title": "tle-for-2-lists-solution-in-java-please-help",
                "content": "```\\nclass MKAverage {\\n    List<Integer> list, sortedList;\\n    int M, K;\\n    int sum;\\n    public MKAverage(int m, int k) {\\n        list = new ArrayList<>();\\n        sortedList = new ArrayList<>();\\n        M = m;\\n        K = k;\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (list.size() == M) {\\n            Integer rem = list.get(0);\\n            if (rem < sortedList.get(K)) {\\n                sum = sum - sortedList.get(K) + sortedList.get(M-K);\\n            } else if (rem < sortedList.get(M - K)) {\\n                sum = sum - rem + sortedList.get(M-K);\\n            }\\n            sortedList.remove(rem);\\n            list.remove(0);\\n        } else if (list.size() == M-1) {\\n            sum = 0;\\n            for (int i = K; i < M - K; i++) {\\n                sum += sortedList.get(i);\\n            }\\n        }\\n        list.add(num);\\n        insert(num);\\n    }\\n    public int calculateMKAverage() {\\n        if (list.size() < M) return -1;\\n        int count = M - K - K;\\n        return sum / count;\\n    }\\n    \\n    private void insert(int n) {\\n        int start = 0;\\n        int end = sortedList.size()-1;\\n        int pos = -1;\\n        while (start <= end) {\\n            int mid = (end - start) / 2 + start;\\n            int val = sortedList.get(mid);\\n            if (val == n) {\\n                pos = mid;\\n                break;\\n            }\\n            if (val < n) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        if (pos == -1) {\\n            pos = start;\\n        }\\n        \\n        if (list.size() == M) {\\n            if (pos < K) {\\n                sum = sum + sortedList.get(K-1) - sortedList.get(M-K-1);\\n            } else if (pos < M - K) {\\n                sum = sum + n - sortedList.get(M-K-1);\\n            }\\n        }\\n        sortedList.add(pos, n);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    List<Integer> list, sortedList;\\n    int M, K;\\n    int sum;\\n    public MKAverage(int m, int k) {\\n        list = new ArrayList<>();\\n        sortedList = new ArrayList<>();\\n        M = m;\\n        K = k;\\n        sum = 0;\\n    }\\n    \\n    public void addElement(int num) {\\n        if (list.size() == M) {\\n            Integer rem = list.get(0);\\n            if (rem < sortedList.get(K)) {\\n                sum = sum - sortedList.get(K) + sortedList.get(M-K);\\n            } else if (rem < sortedList.get(M - K)) {\\n                sum = sum - rem + sortedList.get(M-K);\\n            }\\n            sortedList.remove(rem);\\n            list.remove(0);\\n        } else if (list.size() == M-1) {\\n            sum = 0;\\n            for (int i = K; i < M - K; i++) {\\n                sum += sortedList.get(i);\\n            }\\n        }\\n        list.add(num);\\n        insert(num);\\n    }\\n    public int calculateMKAverage() {\\n        if (list.size() < M) return -1;\\n        int count = M - K - K;\\n        return sum / count;\\n    }\\n    \\n    private void insert(int n) {\\n        int start = 0;\\n        int end = sortedList.size()-1;\\n        int pos = -1;\\n        while (start <= end) {\\n            int mid = (end - start) / 2 + start;\\n            int val = sortedList.get(mid);\\n            if (val == n) {\\n                pos = mid;\\n                break;\\n            }\\n            if (val < n) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        if (pos == -1) {\\n            pos = start;\\n        }\\n        \\n        if (list.size() == M) {\\n            if (pos < K) {\\n                sum = sum + sortedList.get(K-1) - sortedList.get(M-K-1);\\n            } else if (pos < M - K) {\\n                sum = sum + n - sortedList.get(M-K-1);\\n            }\\n        }\\n        sortedList.add(pos, n);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156267,
                "title": "python-naiive-and-neat-solution-tc-mlogm",
                "content": "addElement: TC O(m) SC O(m)\\ncalculateMKAverage: TC O(mlogm) SC O(m)\\n\\nThe point in this question is that we need to maintain two factors which are the input orders and the number order.\\nThe input order can be kept by a stack when function `addElement` is being called and the number order can be calculated when `calculateMKAverage` is being called.\\n\\nIt is suprisingly accpeted in this complexity.\\n\\n```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.n = 0\\n        self.stack = []\\n\\n    def addElement(self, num: int) -> None:\\n        # O(m)\\n        if self.n == self.m:\\n            self.stack.pop(0)\\n            self.stack.append(num)\\n        else:\\n            self.n += 1\\n            self.stack.append(num)\\n        \\n    def calculateMKAverage(self) -> int:\\n        if self.n < self.m:\\n            return -1\\n        \\n        #O(nlogn)\\n        return round(sum(sorted(self.stack)[self.k:self.m-self.k])//(self.m-2*self.k))\\n\\n```\\n\\np.s.\\nIn the very begining and has not been tested yet, I thought this should be made by a self-maintaned AVL tree which contains at most `m` numbers to keep the ascending order with a prefix sum value kept in each node and a list to keep the index order. When `addElement` is being called, we delete the oldest number and insert the latest number. When `calculateMKAverage` is being called, we can get the `k` and `m-k` prefix numbers with TC O(logn) to get the result.",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.n = 0\\n        self.stack = []\\n\\n    def addElement(self, num: int) -> None:\\n        # O(m)\\n        if self.n == self.m:\\n            self.stack.pop(0)\\n            self.stack.append(num)\\n        else:\\n            self.n += 1\\n            self.stack.append(num)\\n        \\n    def calculateMKAverage(self) -> int:\\n        if self.n < self.m:\\n            return -1\\n        \\n        #O(nlogn)\\n        return round(sum(sorted(self.stack)[self.k:self.m-self.k])//(self.m-2*self.k))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155807,
                "title": "java-treemap-state-transition",
                "content": "```\\nclass MKAverage {\\n    Queue<Integer> queue = new LinkedList<Integer>();\\n    TreeMap<Integer,Integer> hm = new TreeMap<>();\\n    int m, k;\\n    int ss  = 0;\\n    long[] sum = new long[2]; // sum[0] - sum of first k smallest elements, sum[1] - sum of first m-k smallest element\\n    int[] arr1 = new int[2]; // arr1[0] - key in map, arr1[1] - value in map, which matches kth smallest element in treemap \\n    int[] arr2 = new int[2];\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        ss++;\\n        queue.offer(num);\\n        hm.put(num, hm.getOrDefault(num, 0)+1);\\n        if(ss < m) return;\\n        else if(ss == m) {\\n            initiate(arr1, k, sum, 0); // initializee arr1 with kth smallest element, add the sum at index 0\\n            initiate(arr2, m-k, sum, 1);\\n        } else {\\n            int remove = queue.poll();\\n            int cc = hm.get(remove);\\n            if(cc == 1) \\n                hm.remove(remove);\\n            else \\n                hm.put(remove, cc-1);\\n            int st1 = getState(arr1[0], remove, num);\\n            goToNextState(st1, arr1, remove, num, sum, 0);\\n            int st2 = getState(arr2[0], remove, num);\\n            goToNextState(st2, arr2, remove, num, sum, 1);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(ss < m) return -1;\\n        long val = (sum[1] - sum[0]) / (m - 2*k);\\n        return (int)val;\\n    }\\n    \\n    private void goToNextState(int st, int[] arr, int remove, int add, long[] sum, int si) {;\\n        switch(st) {\\n            case 1:\\n                sum[si] += add - remove;\\n                break;\\n            case 3:\\n                sum[si] += add;\\n                sum[si] -= arr[0];\\n                moveBack(arr);\\n                break;\\n            case 4:\\n                sum[si] -= remove;\\n                moveForward(arr);\\n                sum[si] += arr[0];\\n                break;\\n            case 5:\\n                if(arr[1] > hm.getOrDefault(arr[0], 0)) {\\n                    sum[si] -= arr[0];\\n                    moveForward(arr);\\n                    sum[si] += arr[0];\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n    \\n    private void moveBack(int[] arr) {\\n        if(--arr[1] <= 0) {\\n            Integer prev = hm.floorKey(arr[0]-1);\\n            arr[0] = prev;\\n            arr[1] = hm.get(prev);\\n        }\\n    }\\n    \\n    private void moveForward(int[] arr) {\\n        if(++arr[1] > hm.getOrDefault(arr[0], 0)) {\\n            Integer next = hm.ceilingKey(arr[0]+1);\\n            arr[0] = next;\\n            arr[1] = 1;\\n        }\\n    }\\n    \\n    private int getState(int key, int remove, int add) {\\n        if(add < key && remove < key) return 1;\\n        if(add > key && remove > key) return 2;\\n        if(add == key && remove == key) return 2;\\n        if(add < key) return 3;\\n        if(remove < key) return 4;\\n        if(remove == key && add > key) return 5;\\n        return 6;\\n    }\\n    \\n    private void initiate(int[] arr, int co, long[] sum, int si) {\\n        // find (co)th smallest element in the map.\\n        // Map {1 -> 2, 2 -> 3, 3 -> 2} for k = 4, arr[0] = 2, arr[1] = 2;\\n        long ss = 0;\\n        long cc = 0;\\n        int lkey = 0;\\n        for(int key : hm.keySet()) {\\n            if(co == 0) break;\\n            cc = Math.min(co, hm.get(key));\\n            ss += cc * key;\\n            co -= (int)cc;\\n            lkey = key;\\n        }\\n        arr[0] = lkey;\\n        arr[1] = (int)cc;\\n        sum[si] = ss;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    Queue<Integer> queue = new LinkedList<Integer>();\\n    TreeMap<Integer,Integer> hm = new TreeMap<>();\\n    int m, k;\\n    int ss  = 0;\\n    long[] sum = new long[2]; // sum[0] - sum of first k smallest elements, sum[1] - sum of first m-k smallest element\\n    int[] arr1 = new int[2]; // arr1[0] - key in map, arr1[1] - value in map, which matches kth smallest element in treemap \\n    int[] arr2 = new int[2];\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n    }\\n    \\n    public void addElement(int num) {\\n        ss++;\\n        queue.offer(num);\\n        hm.put(num, hm.getOrDefault(num, 0)+1);\\n        if(ss < m) return;\\n        else if(ss == m) {\\n            initiate(arr1, k, sum, 0); // initializee arr1 with kth smallest element, add the sum at index 0\\n            initiate(arr2, m-k, sum, 1);\\n        } else {\\n            int remove = queue.poll();\\n            int cc = hm.get(remove);\\n            if(cc == 1) \\n                hm.remove(remove);\\n            else \\n                hm.put(remove, cc-1);\\n            int st1 = getState(arr1[0], remove, num);\\n            goToNextState(st1, arr1, remove, num, sum, 0);\\n            int st2 = getState(arr2[0], remove, num);\\n            goToNextState(st2, arr2, remove, num, sum, 1);\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(ss < m) return -1;\\n        long val = (sum[1] - sum[0]) / (m - 2*k);\\n        return (int)val;\\n    }\\n    \\n    private void goToNextState(int st, int[] arr, int remove, int add, long[] sum, int si) {;\\n        switch(st) {\\n            case 1:\\n                sum[si] += add - remove;\\n                break;\\n            case 3:\\n                sum[si] += add;\\n                sum[si] -= arr[0];\\n                moveBack(arr);\\n                break;\\n            case 4:\\n                sum[si] -= remove;\\n                moveForward(arr);\\n                sum[si] += arr[0];\\n                break;\\n            case 5:\\n                if(arr[1] > hm.getOrDefault(arr[0], 0)) {\\n                    sum[si] -= arr[0];\\n                    moveForward(arr);\\n                    sum[si] += arr[0];\\n                }\\n                break;\\n            default:\\n                break;\\n        }\\n    }\\n    \\n    private void moveBack(int[] arr) {\\n        if(--arr[1] <= 0) {\\n            Integer prev = hm.floorKey(arr[0]-1);\\n            arr[0] = prev;\\n            arr[1] = hm.get(prev);\\n        }\\n    }\\n    \\n    private void moveForward(int[] arr) {\\n        if(++arr[1] > hm.getOrDefault(arr[0], 0)) {\\n            Integer next = hm.ceilingKey(arr[0]+1);\\n            arr[0] = next;\\n            arr[1] = 1;\\n        }\\n    }\\n    \\n    private int getState(int key, int remove, int add) {\\n        if(add < key && remove < key) return 1;\\n        if(add > key && remove > key) return 2;\\n        if(add == key && remove == key) return 2;\\n        if(add < key) return 3;\\n        if(remove < key) return 4;\\n        if(remove == key && add > key) return 5;\\n        return 6;\\n    }\\n    \\n    private void initiate(int[] arr, int co, long[] sum, int si) {\\n        // find (co)th smallest element in the map.\\n        // Map {1 -> 2, 2 -> 3, 3 -> 2} for k = 4, arr[0] = 2, arr[1] = 2;\\n        long ss = 0;\\n        long cc = 0;\\n        int lkey = 0;\\n        for(int key : hm.keySet()) {\\n            if(co == 0) break;\\n            cc = Math.min(co, hm.get(key));\\n            ss += cc * key;\\n            co -= (int)cc;\\n            lkey = key;\\n        }\\n        arr[0] = lkey;\\n        arr[1] = (int)cc;\\n        sum[si] = ss;\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155397,
                "title": "java-binary-search-copied-from-arrays-class-arraylist-as-slidingwindow",
                "content": "```\\n/**\\n * n: 10^5\\n * m: 10^5\\n * k: 10^5 / 2\\n * save sliding window elements as sorted list as BS array ?\\n * similar to this: https://leetcode.com/problems/sliding-window-maximum/, how do I persist the rest of k-2 elements ?\\n */\\nclass MKAverage { // space: O(n), time: O(n) for BS insertion and deletion (move complexity from calculateMKAverage to addElement)\\n\\n\\tint m;\\n\\tint k;\\n\\tint restLength;\\n\\n\\tList<Integer> nums = new ArrayList<>(); // n\\n\\tList<Integer> sortedSlidingWindowIndexes = new ArrayList<>(); // m\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tthis.restLength = m - 2 * k;\\n\\t}\\n\\n\\tpublic void addElement(int num) {\\n\\t\\tslideByRemovingElement();\\n\\n\\t\\tsortedSlidingWindowIndexes.add(binarySearch(num), nums.size()); // O(n)\\n\\t\\tnums.add(num);\\n\\t}\\n\\n\\tvoid slideByRemovingElement() {\\n\\t\\tint n = nums.size();\\n\\t\\tif (n >= m) sortedSlidingWindowIndexes.remove((Integer) (n - m)); // O(n)\\n\\t}\\n\\n\\tint binarySearch(int key) {  // O(log m)\\n\\t\\tint low = 0;\\n\\t\\tint high = sortedSlidingWindowIndexes.size() - 1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tint mid = (low + high) >>> 1;\\n\\t\\t\\tlong midVal = nums.get(sortedSlidingWindowIndexes.get(mid));\\n\\n\\t\\t\\tif (midVal < key)\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse if (midVal > key)\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn mid;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}\\n\\n\\tint calculateMKAverage() { // O(k)\\n\\t\\tif (nums.size() < m) return -1;\\n\\n\\t\\tlong sum = 0L;\\n\\t\\tfor (int i = k; i <= m - k - 1; i++) sum += (long) nums.get(sortedSlidingWindowIndexes.get(i));\\n\\n\\t\\treturn Math.round(sum / restLength);\\n\\t}\\n}\\n```\\n\\n```\\n// bruteforce no idea why the person in the first place passed the TLE?\\nclass MKAverage { // space: O(n), time: O(n) but for sorting alone: O(klogk)\\n\\n\\tint m;\\n\\tint k;\\n\\tList<Integer> intList;\\n\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tthis.intList = new ArrayList<>();\\n\\t}\\n\\n\\tpublic void addElement(int num) { // calc max and min here ?\\n\\t\\tthis.intList.add(num);\\n\\t}\\n\\n\\tpublic int calculateMKAverage() {\\n\\t\\tint n = intList.size();\\n\\t\\tif (n < m) return -1;\\n\\n\\t\\tList<Integer> lastElems = new ArrayList<>();\\n\\t\\tfor (int i = n - 1; i >= n - m; i--) {\\n\\t\\t\\tlastElems.add(intList.get(i));\\n\\t\\t}\\n\\n\\t\\tCollections.sort(lastElems); // bottleneck !\\n//\\t\\tSystem.out.println(lastElems);\\n\\t\\treturn average(lastElems, k, lastElems.size() - k - 1);\\n\\t}\\n\\n\\tint average(List<Integer> l, int from, int to) {\\n\\t\\tlong sum = 0L;\\n\\t\\tfor (int i = from; i <= to; i++) sum += (long) l.get(i);\\n\\n\\t\\treturn Math.round(sum / (to - from + 1));\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * n: 10^5\\n * m: 10^5\\n * k: 10^5 / 2\\n * save sliding window elements as sorted list as BS array ?\\n * similar to this: https://leetcode.com/problems/sliding-window-maximum/, how do I persist the rest of k-2 elements ?\\n */\\nclass MKAverage { // space: O(n), time: O(n) for BS insertion and deletion (move complexity from calculateMKAverage to addElement)\\n\\n\\tint m;\\n\\tint k;\\n\\tint restLength;\\n\\n\\tList<Integer> nums = new ArrayList<>(); // n\\n\\tList<Integer> sortedSlidingWindowIndexes = new ArrayList<>(); // m\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tthis.restLength = m - 2 * k;\\n\\t}\\n\\n\\tpublic void addElement(int num) {\\n\\t\\tslideByRemovingElement();\\n\\n\\t\\tsortedSlidingWindowIndexes.add(binarySearch(num), nums.size()); // O(n)\\n\\t\\tnums.add(num);\\n\\t}\\n\\n\\tvoid slideByRemovingElement() {\\n\\t\\tint n = nums.size();\\n\\t\\tif (n >= m) sortedSlidingWindowIndexes.remove((Integer) (n - m)); // O(n)\\n\\t}\\n\\n\\tint binarySearch(int key) {  // O(log m)\\n\\t\\tint low = 0;\\n\\t\\tint high = sortedSlidingWindowIndexes.size() - 1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tint mid = (low + high) >>> 1;\\n\\t\\t\\tlong midVal = nums.get(sortedSlidingWindowIndexes.get(mid));\\n\\n\\t\\t\\tif (midVal < key)\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\telse if (midVal > key)\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn mid;\\n\\t\\t}\\n\\t\\treturn low;\\n\\t}\\n\\n\\tint calculateMKAverage() { // O(k)\\n\\t\\tif (nums.size() < m) return -1;\\n\\n\\t\\tlong sum = 0L;\\n\\t\\tfor (int i = k; i <= m - k - 1; i++) sum += (long) nums.get(sortedSlidingWindowIndexes.get(i));\\n\\n\\t\\treturn Math.round(sum / restLength);\\n\\t}\\n}\\n```\n```\\n// bruteforce no idea why the person in the first place passed the TLE?\\nclass MKAverage { // space: O(n), time: O(n) but for sorting alone: O(klogk)\\n\\n\\tint m;\\n\\tint k;\\n\\tList<Integer> intList;\\n\\n\\n\\tpublic MKAverage(int m, int k) {\\n\\t\\tthis.m = m;\\n\\t\\tthis.k = k;\\n\\t\\tthis.intList = new ArrayList<>();\\n\\t}\\n\\n\\tpublic void addElement(int num) { // calc max and min here ?\\n\\t\\tthis.intList.add(num);\\n\\t}\\n\\n\\tpublic int calculateMKAverage() {\\n\\t\\tint n = intList.size();\\n\\t\\tif (n < m) return -1;\\n\\n\\t\\tList<Integer> lastElems = new ArrayList<>();\\n\\t\\tfor (int i = n - 1; i >= n - m; i--) {\\n\\t\\t\\tlastElems.add(intList.get(i));\\n\\t\\t}\\n\\n\\t\\tCollections.sort(lastElems); // bottleneck !\\n//\\t\\tSystem.out.println(lastElems);\\n\\t\\treturn average(lastElems, k, lastElems.size() - k - 1);\\n\\t}\\n\\n\\tint average(List<Integer> l, int from, int to) {\\n\\t\\tlong sum = 0L;\\n\\t\\tfor (int i = from; i <= to; i++) sum += (long) l.get(i);\\n\\n\\t\\treturn Math.round(sum / (to - from + 1));\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155190,
                "title": "segment-tree-java-68ms",
                "content": "```\\nclass MKAverage {\\n    LinkedList<Integer> queue;\\n    int[] count;\\n    long[] sum;\\n    int m,k;\\n    public MKAverage(int m, int k) {\\n        queue=new LinkedList<>();\\n        count=new int[400001];\\n        sum=new long[400001];\\n        this.m=m;\\n        this.k=k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if(queue.size()==m){\\n            int v=queue.pollFirst();\\n            insert(1,0,100000,v,-1);\\n        }\\n        insert(1,0,100000,num,1);\\n        queue.addLast(num);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size()<m)return -1;\\n        int s=k+1,e=m-k;\\n        return (int)(query(1,0,100000,s,e)/(m-2*k));\\n    }\\n    \\n    void insert(int node,int l,int r,int v,long d){\\n        count[node]+=d;\\n        sum[node]+=d*v;\\n        if(l==r){\\n            return;\\n        }\\n        int m=(l+r)/2;\\n        if(v<=m){\\n            insert(node<<1,l,m,v,d);        \\n        }else{\\n            insert(node<<1|1,m+1,r,v,d);     \\n        }\\n    }\\n    \\n    long query(int node,int l,int r,int s,int e){//\\u7EBF\\u6BB5\\u4E2D\\u7B2Cs\\u4E2A\\u5230\\u7B2Ce\\u4E2A\\n        if(l==r){//\\u8D77\\u59CB\\u548C\\u7ED3\\u675F\\u6700\\u591A\\u51FA\\u73B02\\u6B21\\u6B64\\u60C5\\u51B5\\n            int c=e-s+1;\\n            return (long)c*l;\\n        }else if(count[node]==e-s+1){\\n            return sum[node];\\n        }else{\\n            int m=(l+r)/2;\\n            int c1=count[node<<1];\\n            int c2=count[node<<1|1];\\n            if(c1>=e){\\n                return query(node<<1,l,m,s,e);\\n            }else if(c1>=s){\\n                return query(node<<1,l,m,s,c1)+query(node<<1|1,m+1,r,1,e-c1);\\n            }else{//c1<s\\n                return query(node<<1|1,m+1,r,s-c1,e-c1);\\n            }\\n        }\\n    }\\n}\\n \\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n    LinkedList<Integer> queue;\\n    int[] count;\\n    long[] sum;\\n    int m,k;\\n    public MKAverage(int m, int k) {\\n        queue=new LinkedList<>();\\n        count=new int[400001];\\n        sum=new long[400001];\\n        this.m=m;\\n        this.k=k;\\n    }\\n    \\n    public void addElement(int num) {\\n        if(queue.size()==m){\\n            int v=queue.pollFirst();\\n            insert(1,0,100000,v,-1);\\n        }\\n        insert(1,0,100000,num,1);\\n        queue.addLast(num);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if(queue.size()<m)return -1;\\n        int s=k+1,e=m-k;\\n        return (int)(query(1,0,100000,s,e)/(m-2*k));\\n    }\\n    \\n    void insert(int node,int l,int r,int v,long d){\\n        count[node]+=d;\\n        sum[node]+=d*v;\\n        if(l==r){\\n            return;\\n        }\\n        int m=(l+r)/2;\\n        if(v<=m){\\n            insert(node<<1,l,m,v,d);        \\n        }else{\\n            insert(node<<1|1,m+1,r,v,d);     \\n        }\\n    }\\n    \\n    long query(int node,int l,int r,int s,int e){//\\u7EBF\\u6BB5\\u4E2D\\u7B2Cs\\u4E2A\\u5230\\u7B2Ce\\u4E2A\\n        if(l==r){//\\u8D77\\u59CB\\u548C\\u7ED3\\u675F\\u6700\\u591A\\u51FA\\u73B02\\u6B21\\u6B64\\u60C5\\u51B5\\n            int c=e-s+1;\\n            return (long)c*l;\\n        }else if(count[node]==e-s+1){\\n            return sum[node];\\n        }else{\\n            int m=(l+r)/2;\\n            int c1=count[node<<1];\\n            int c2=count[node<<1|1];\\n            if(c1>=e){\\n                return query(node<<1,l,m,s,e);\\n            }else if(c1>=s){\\n                return query(node<<1,l,m,s,c1)+query(node<<1|1,m+1,r,1,e-c1);\\n            }else{//c1<s\\n                return query(node<<1|1,m+1,r,s-c1,e-c1);\\n            }\\n        }\\n    }\\n}\\n \\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155053,
                "title": "c-solution-with-queue-and-multisets-with-comments-for-explaination-faster-than-87-50",
                "content": "```\\n//multiset keeps elements in increasing order\\n#define ll long long\\n#define pb push_back\\n\\nclass MKAverage {\\n    public:\\n        int m,k;\\n        queue<int> window;//has the m elements or less in orignal order\\n        \\n        multiset<int> smaller;\\n        multiset<int> middle;\\n        multiset<int> larger;\\n        \\n        ll middleSum;\\n        \\n        MKAverage(int m, int k) {\\n            this->m=m;\\n            this->k=k;\\n        }\\n        \\n        int calculateMKAverage() {\\n            if(window.size() < m) return -1;\\n            \\n            return (middleSum/middle.size());\\n        }\\n        \\n        //called only 1 time\\n        void initialiseMultisets(){\\n            middleSum=0;\\n            queue<int> windowCopy = window;\\n            \\n            vector<int> mElementsSorted;\\n            \\n            while(windowCopy.size() > 0){\\n                mElementsSorted.pb(windowCopy.front());\\n                windowCopy.pop();\\n            }\\n            \\n            sort(mElementsSorted.begin(),mElementsSorted.end());\\n            int n = mElementsSorted.size();\\n            \\n            int i=0;\\n            for(;i<k;i++) smaller.insert(mElementsSorted[i]);\\n            \\n            for(;i<(n-k);i++){\\n                middle.insert(mElementsSorted[i]);\\n                middleSum += mElementsSorted[i];\\n            }\\n            \\n            for(;i<n;i++) larger.insert(mElementsSorted[i]);\\n        }\\n        \\n        void newElementAdjust(int num){\\n            //this num is also there at the window end\\n            int smallerLast = *(smaller.rbegin());\\n            int largerFirst = *(larger.begin());\\n            \\n            if(num < smallerLast){\\n                //insert num in smaller\\n                smaller.insert(num);\\n                //move last element of smaller to middle\\n                // smaller.erase(smaller.rbegin()); not working\\n                smaller.erase(--smaller.end());\\n                middle.insert(smallerLast);\\n                middleSum += smallerLast;\\n            }\\n            else if(num > largerFirst){\\n                //insert num in larger\\n                larger.insert(num);\\n                //move first element of larger to middle\\n                larger.erase(larger.begin());\\n                middle.insert(largerFirst);\\n                middleSum += largerFirst;\\n            }\\n            else{\\n                //insert in middle\\n                middle.insert(num);\\n                middleSum += num;\\n            }\\n        }\\n        \\n        void removeElementAdjust(){\\n            //window ka first element remove\\n            int windowFirst = window.front();\\n            window.pop();\\n            \\n            int smallerLast = *(smaller.rbegin());\\n            int largerFirst = *(larger.begin());\\n            \\n            int middleFirst = *(middle.begin());\\n            int middleLast = *(--middle.end());\\n            \\n            //now search this windowFirst in the 3 multisets. Jahan bhi mile remove it\\n            //if found in smaller, smaller ka size decreased by 1 so middle ka first ko move to smaller.\\n            if(windowFirst <= smallerLast){\\n                smaller.erase(smaller.lower_bound(windowFirst));\\n                \\n                middle.erase(middle.begin());\\n                middleSum -= middleFirst;\\n                \\n                smaller.insert(middleFirst);\\n            }\\n            else if(windowFirst >= largerFirst){\\n                larger.erase(larger.lower_bound(windowFirst));\\n                \\n                middle.erase(--middle.end());\\n                middleSum -= middleLast;\\n                \\n                larger.insert(middleLast);\\n            }\\n            else{\\n                middle.erase(middle.lower_bound(windowFirst));\\n                middleSum -= windowFirst;\\n            }\\n        }\\n        \\n        //m elements to hone do\\n        void addElement(int num) {\\n            //i\\'ll first add then remove to keep the sizes maintaned\\n            window.push(num);\\n            if(window.size() < m) return;\\n            \\n            if(window.size() == m){\\n                initialiseMultisets();\\n            }\\n            else{\\n                //adjust the new elements in the multisets\\n                newElementAdjust(num);\\n                \\n                //remove the first element of window and adjust the multisets\\n                removeElementAdjust();\\n            }\\n        }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//multiset keeps elements in increasing order\\n#define ll long long\\n#define pb push_back\\n\\nclass MKAverage {\\n    public:\\n        int m,k;\\n        queue<int> window;//has the m elements or less in orignal order\\n        \\n        multiset<int> smaller;\\n        multiset<int> middle;\\n        multiset<int> larger;\\n        \\n        ll middleSum;\\n        \\n        MKAverage(int m, int k) {\\n            this->m=m;\\n            this->k=k;\\n        }\\n        \\n        int calculateMKAverage() {\\n            if(window.size() < m) return -1;\\n            \\n            return (middleSum/middle.size());\\n        }\\n        \\n        //called only 1 time\\n        void initialiseMultisets(){\\n            middleSum=0;\\n            queue<int> windowCopy = window;\\n            \\n            vector<int> mElementsSorted;\\n            \\n            while(windowCopy.size() > 0){\\n                mElementsSorted.pb(windowCopy.front());\\n                windowCopy.pop();\\n            }\\n            \\n            sort(mElementsSorted.begin(),mElementsSorted.end());\\n            int n = mElementsSorted.size();\\n            \\n            int i=0;\\n            for(;i<k;i++) smaller.insert(mElementsSorted[i]);\\n            \\n            for(;i<(n-k);i++){\\n                middle.insert(mElementsSorted[i]);\\n                middleSum += mElementsSorted[i];\\n            }\\n            \\n            for(;i<n;i++) larger.insert(mElementsSorted[i]);\\n        }\\n        \\n        void newElementAdjust(int num){\\n            //this num is also there at the window end\\n            int smallerLast = *(smaller.rbegin());\\n            int largerFirst = *(larger.begin());\\n            \\n            if(num < smallerLast){\\n                //insert num in smaller\\n                smaller.insert(num);\\n                //move last element of smaller to middle\\n                // smaller.erase(smaller.rbegin()); not working\\n                smaller.erase(--smaller.end());\\n                middle.insert(smallerLast);\\n                middleSum += smallerLast;\\n            }\\n            else if(num > largerFirst){\\n                //insert num in larger\\n                larger.insert(num);\\n                //move first element of larger to middle\\n                larger.erase(larger.begin());\\n                middle.insert(largerFirst);\\n                middleSum += largerFirst;\\n            }\\n            else{\\n                //insert in middle\\n                middle.insert(num);\\n                middleSum += num;\\n            }\\n        }\\n        \\n        void removeElementAdjust(){\\n            //window ka first element remove\\n            int windowFirst = window.front();\\n            window.pop();\\n            \\n            int smallerLast = *(smaller.rbegin());\\n            int largerFirst = *(larger.begin());\\n            \\n            int middleFirst = *(middle.begin());\\n            int middleLast = *(--middle.end());\\n            \\n            //now search this windowFirst in the 3 multisets. Jahan bhi mile remove it\\n            //if found in smaller, smaller ka size decreased by 1 so middle ka first ko move to smaller.\\n            if(windowFirst <= smallerLast){\\n                smaller.erase(smaller.lower_bound(windowFirst));\\n                \\n                middle.erase(middle.begin());\\n                middleSum -= middleFirst;\\n                \\n                smaller.insert(middleFirst);\\n            }\\n            else if(windowFirst >= largerFirst){\\n                larger.erase(larger.lower_bound(windowFirst));\\n                \\n                middle.erase(--middle.end());\\n                middleSum -= middleLast;\\n                \\n                larger.insert(middleLast);\\n            }\\n            else{\\n                middle.erase(middle.lower_bound(windowFirst));\\n                middleSum -= windowFirst;\\n            }\\n        }\\n        \\n        //m elements to hone do\\n        void addElement(int num) {\\n            //i\\'ll first add then remove to keep the sizes maintaned\\n            window.push(num);\\n            if(window.size() < m) return;\\n            \\n            if(window.size() == m){\\n                initialiseMultisets();\\n            }\\n            else{\\n                //adjust the new elements in the multisets\\n                newElementAdjust(num);\\n                \\n                //remove the first element of window and adjust the multisets\\n                removeElementAdjust();\\n            }\\n        }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154451,
                "title": "java-timelimit-exceeded-for-last-test-case",
                "content": "```\\nclass MKAverage {\\n\\n    int m; int k;\\n    Deque<Integer> deque;\\n    public MKAverage(int m, int k) {\\n        \\n        this.m = m;\\n        this.k = k;\\n        deque = new LinkedList<>();\\n    }\\n    \\n    public void addElement(int num) {\\n        deque.add(num);\\n        if(deque.size() > m){\\n            deque.removeFirst();\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        \\n        if(deque.size() < m) { return -1; }\\n        \\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>((a,b) -> a-b);\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>((a,b) -> b-a);\\n        \\n        for(int el: deque){\\n            pq1.offer(el);\\n        }\\n        //delete k small elements\\n        for(int i=0; i<k; i++){ pq1.poll(); }\\n        \\n        while(!pq1.isEmpty()){ pq2.offer(pq1.poll()); }\\n        //delete k big elements\\n        for(int i=0; i<k; i++){ pq2.poll(); }\\n        \\n        int count = pq2.size();\\n        \\n        long sum = 0;\\n        \\n        while(!pq2.isEmpty()){ sum+=pq2.poll();}\\n        \\n        return (int) (sum/count);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\n\\n    int m; int k;\\n    Deque<Integer> deque;\\n    public MKAverage(int m, int k) {\\n        \\n        this.m = m;\\n        this.k = k;\\n        deque = new LinkedList<>();\\n    }\\n    \\n    public void addElement(int num) {\\n        deque.add(num);\\n        if(deque.size() > m){\\n            deque.removeFirst();\\n        }\\n    }\\n    \\n    public int calculateMKAverage() {\\n        \\n        if(deque.size() < m) { return -1; }\\n        \\n        PriorityQueue<Integer> pq1 = new PriorityQueue<>((a,b) -> a-b);\\n        PriorityQueue<Integer> pq2 = new PriorityQueue<>((a,b) -> b-a);\\n        \\n        for(int el: deque){\\n            pq1.offer(el);\\n        }\\n        //delete k small elements\\n        for(int i=0; i<k; i++){ pq1.poll(); }\\n        \\n        while(!pq1.isEmpty()){ pq2.offer(pq1.poll()); }\\n        //delete k big elements\\n        for(int i=0; i<k; i++){ pq2.poll(); }\\n        \\n        int count = pq2.size();\\n        \\n        long sum = 0;\\n        \\n        while(!pq2.isEmpty()){ sum+=pq2.poll();}\\n        \\n        return (int) (sum/count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154230,
                "title": "very-simple-sort-time-o-mlogm",
                "content": "brute force solution and passed because of small dataset.\\n\\n```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        self.arr.append(num)\\n        \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        \\n        cur = self.arr[-self.m:]\\n        cur.sort()\\n        cur = cur[self.k:-self.k]\\n        return round(sum([x for x in cur])/(len(cur)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        self.arr.append(num)\\n        \\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.arr) < self.m:\\n            return -1\\n        \\n        cur = self.arr[-self.m:]\\n        cur.sort()\\n        cur = cur[self.k:-self.k]\\n        return round(sum([x for x in cur])/(len(cur)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153907,
                "title": "java-using-treemap-for-removable-priorityqueue",
                "content": "We put the tricky logics into a wrapped data type called RemovablePq to note down size, sum, and elements.\\nWe balance twice: once after the polling of earlier elements, once after the insertion of latest element\\n```\\n    class MKAverage {\\n        class RemovablePq {\\n            private TreeMap<Long, Long> tm = new TreeMap<>();\\n            private long sum = 0;\\n            private long size = 0;\\n\\n            public void offer(long x) {\\n                update(tm, x, 1);\\n                sum += x;\\n                size++;\\n            }\\n\\n            public void remove(long x) {\\n                if (tm.containsKey(x)) {\\n                    update(tm, x, -1);\\n                    sum -= x;\\n                    size--;\\n                }\\n            }\\n\\n            public boolean contains(long x) {\\n                return tm.containsKey(x);\\n            }\\n\\n            public long size() {\\n                return size;\\n            }\\n\\n            public long sum() {\\n                return sum;\\n            }\\n\\n            public Long min() {\\n                return tm.isEmpty() ? null : tm.firstKey();\\n            }\\n\\n            public Long max() {\\n                return tm.isEmpty() ? null : tm.lastKey();\\n            }\\n\\n            private void update(TreeMap<Long, Long> tm, long k, long d) {\\n                long nv = tm.getOrDefault(k, 0L) + d;\\n                if (nv <= 0) {\\n                    tm.remove(k);\\n                } else {\\n                    tm.put(k, nv);\\n                }\\n            }\\n\\n            public boolean isEmpty() {\\n                return size == 0;\\n            }\\n\\n            public void pollMax() {\\n                if (isEmpty()) {\\n                    return;\\n                }\\n                remove(max());\\n            }\\n\\n            public void pollMin() {\\n                if (isEmpty()) {\\n                    return;\\n                }\\n                remove(min());\\n            }\\n        }\\n\\n        private RemovablePq small = new RemovablePq();\\n        private RemovablePq big = new RemovablePq();\\n        private RemovablePq mid = new RemovablePq();\\n\\n        private Deque<Integer> dq = new ArrayDeque<>();\\n        private int m = 0;\\n        private int k = 0;\\n        private long sum = 0;\\n\\n\\n        public MKAverage(int m, int k) {\\n            this.m = m;\\n            this.k = k;\\n        }\\n\\n        public void addElement(int num) {\\n\\n            sum += num;\\n            dq.offerLast(num);\\n            if (dq.size() > m) {\\n                int top = dq.pollFirst();\\n                sum -= top;\\n                if (small.contains(top)) {\\n                    small.remove(top);\\n\\n                } else if (big.contains(top)) {\\n                    big.remove(top);\\n                } else {\\n                    mid.remove(top);\\n                }\\n            }\\n            adjust();\\n            if (small.isEmpty() || num < small.max()) {\\n                small.offer(num);\\n            } else if (big.isEmpty() || num > big.min()) {\\n                big.offer(num);\\n            } else {\\n                mid.offer(num);\\n            }\\n            adjust();\\n        }\\n\\n        private void adjust() {\\n            if (small.size > k) {\\n                mid.offer(small.max());\\n                small.pollMax();\\n            }\\n            if (big.size > k) {\\n                mid.offer(big.min());\\n                big.pollMin();\\n            }\\n            if (small.size < k && !mid.isEmpty()) {\\n                small.offer(mid.min());\\n                mid.pollMin();\\n            }\\n            if (big.size < k && !mid.isEmpty()) {\\n                big.offer((mid.max()));\\n                mid.pollMax();\\n            }\\n        }\\n\\n        public int calculateMKAverage() {\\n\\n            if (dq.size() < m) {\\n                return -1;\\n            }\\n            return (int) ((sum - big.sum() - small.sum()) / (m - 2 * k));\\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "We put the tricky logics into a wrapped data type called RemovablePq to note down size, sum, and elements.\\nWe balance twice: once after the polling of earlier elements, once after the insertion of latest element\\n```\\n    class MKAverage {\\n        class RemovablePq {\\n            private TreeMap<Long, Long> tm = new TreeMap<>();\\n            private long sum = 0;\\n            private long size = 0;\\n\\n            public void offer(long x) {\\n                update(tm, x, 1);\\n                sum += x;\\n                size++;\\n            }\\n\\n            public void remove(long x) {\\n                if (tm.containsKey(x)) {\\n                    update(tm, x, -1);\\n                    sum -= x;\\n                    size--;\\n                }\\n            }\\n\\n            public boolean contains(long x) {\\n                return tm.containsKey(x);\\n            }\\n\\n            public long size() {\\n                return size;\\n            }\\n\\n            public long sum() {\\n                return sum;\\n            }\\n\\n            public Long min() {\\n                return tm.isEmpty() ? null : tm.firstKey();\\n            }\\n\\n            public Long max() {\\n                return tm.isEmpty() ? null : tm.lastKey();\\n            }\\n\\n            private void update(TreeMap<Long, Long> tm, long k, long d) {\\n                long nv = tm.getOrDefault(k, 0L) + d;\\n                if (nv <= 0) {\\n                    tm.remove(k);\\n                } else {\\n                    tm.put(k, nv);\\n                }\\n            }\\n\\n            public boolean isEmpty() {\\n                return size == 0;\\n            }\\n\\n            public void pollMax() {\\n                if (isEmpty()) {\\n                    return;\\n                }\\n                remove(max());\\n            }\\n\\n            public void pollMin() {\\n                if (isEmpty()) {\\n                    return;\\n                }\\n                remove(min());\\n            }\\n        }\\n\\n        private RemovablePq small = new RemovablePq();\\n        private RemovablePq big = new RemovablePq();\\n        private RemovablePq mid = new RemovablePq();\\n\\n        private Deque<Integer> dq = new ArrayDeque<>();\\n        private int m = 0;\\n        private int k = 0;\\n        private long sum = 0;\\n\\n\\n        public MKAverage(int m, int k) {\\n            this.m = m;\\n            this.k = k;\\n        }\\n\\n        public void addElement(int num) {\\n\\n            sum += num;\\n            dq.offerLast(num);\\n            if (dq.size() > m) {\\n                int top = dq.pollFirst();\\n                sum -= top;\\n                if (small.contains(top)) {\\n                    small.remove(top);\\n\\n                } else if (big.contains(top)) {\\n                    big.remove(top);\\n                } else {\\n                    mid.remove(top);\\n                }\\n            }\\n            adjust();\\n            if (small.isEmpty() || num < small.max()) {\\n                small.offer(num);\\n            } else if (big.isEmpty() || num > big.min()) {\\n                big.offer(num);\\n            } else {\\n                mid.offer(num);\\n            }\\n            adjust();\\n        }\\n\\n        private void adjust() {\\n            if (small.size > k) {\\n                mid.offer(small.max());\\n                small.pollMax();\\n            }\\n            if (big.size > k) {\\n                mid.offer(big.min());\\n                big.pollMin();\\n            }\\n            if (small.size < k && !mid.isEmpty()) {\\n                small.offer(mid.min());\\n                mid.pollMin();\\n            }\\n            if (big.size < k && !mid.isEmpty()) {\\n                big.offer((mid.max()));\\n                mid.pollMax();\\n            }\\n        }\\n\\n        public int calculateMKAverage() {\\n\\n            if (dq.size() < m) {\\n                return -1;\\n            }\\n            return (int) ((sum - big.sum() - small.sum()) / (m - 2 * k));\\n        }\\n    }\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1153852,
                "title": "sortedcontainers-o-log-n-add-o-n-log-n-calculate",
                "content": "May improve the calculateMKAverage to O(1).\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.sl = SortedList()\\n        self.m = m\\n        self.k = k\\n        self.tot = 0\\n        self.q = deque()\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        v = num\\n        q = self.q\\n        self.sl.add(v)\\n        self.tot += v\\n        self.q.append(v)\\n        \\n        if len(q) > self.m:\\n            v = q.popleft()\\n            self.tot -= v\\n            self.sl.remove(v)\\n        \\n        # print(\"sl\", self.sl)\\n        # print(\"q\", q)\\n        \\n\\n    def calculateMKAverage(self) -> int:\\n        sl, m, k, tot = self.sl, self.m, self.k, self.tot\\n        n = len(sl)\\n        if n < m:\\n            return -1\\n        t = sum(sl[k:-k])\\n        # print(\"mid list\", sl[k:-k])\\n        \\n        return t//(n - 2*k)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass MKAverage:\\n\\n    def __init__(self, m: int, k: int):\\n        self.sl = SortedList()\\n        self.m = m\\n        self.k = k\\n        self.tot = 0\\n        self.q = deque()\\n        \\n\\n    def addElement(self, num: int) -> None:\\n        v = num\\n        q = self.q\\n        self.sl.add(v)\\n        self.tot += v\\n        self.q.append(v)\\n        \\n        if len(q) > self.m:\\n            v = q.popleft()\\n            self.tot -= v\\n            self.sl.remove(v)\\n        \\n        # print(\"sl\", self.sl)\\n        # print(\"q\", q)\\n        \\n\\n    def calculateMKAverage(self) -> int:\\n        sl, m, k, tot = self.sl, self.m, self.k, self.tot\\n        n = len(sl)\\n        if n < m:\\n            return -1\\n        t = sum(sl[k:-k])\\n        # print(\"mid list\", sl[k:-k])\\n        \\n        return t//(n - 2*k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153297,
                "title": "javascript-improved-o-m-and-previous-sort-tle-o-mlogm-but-now-passed",
                "content": "### Improved O(m) - firstK, mid, lastK\\nReferenced this idea to maintain and sort only the firstK and lastK.\\n- Init when first m numbers: sort - `O(mlogm)`\\n- delete a number in 3 section: findexIndex in firstK, lastK, mid - `n* O(m) = O(m*n)`\\n- add a number in 3 section - worst `O(n * m)`\\n   - sort firstK/lastK- `O(klogk)`\\n   - findIndex to insert in mid - `O(m)`:  due to [MDN-doc](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) here, in JavaScript `findIndex()` time should be `O(n)`.\\n\\n```js\\nvar MKAverage = function(m, k) {\\n    this.m = m;\\n    this.k = k;\\n    this.mq = []; // keep last m size in original order\\n    this.firstK = [];\\n    this.lastK = [];\\n    this.mid = [];\\n    this.sum = 0; // sum for the middle part\\n    \\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n    var k = this.k;\\n    if(this.mq.length < this.m)\\n    {\\n        this.mq.push(num);\\n        if(this.mq.length===this.m) {\\n            var tmp = this.mq.slice().sort((a,b)=>a-b);\\n            this.firstK = tmp.slice(0,k);\\n            this.lastK = tmp.slice(tmp.length-k, tmp.length);\\n            this.mid = tmp.slice(k, tmp.length-k);\\n            this.sum  = this.mid.reduce((a,b)=>a+b);\\n        }\\n    }\\n    else\\n    {\\n        var toDelete = this.mq[0];\\n        this.mq.shift();\\n        this.mq.push(num);\\n        \\n        // Delete old num\\n        // findexIndex in firstK, lastK, mid - Min(O(k), O(m-2k))\\n        if(toDelete <= this.firstK[k-1])\\n        {\\n            var out =  this.mid.shift();\\n            this.sum -= out;\\n            var idx = this.firstK.findIndex(el=>el>=toDelete);\\n            var first = this.firstK.slice(0, idx).concat(this.firstK.slice(idx+1, k));\\n            first.push(out);\\n            this.firstK = first.slice();\\n        }\\n        else if( toDelete >= this.lastK[0])\\n        {            \\n            var out =  this.mid.pop();\\n            this.sum -= out;\\n            var idx = this.lastK.findIndex(el=>el>=toDelete);\\n            var last = this.lastK.slice(0, idx).concat(this.lastK.slice(idx+1, k));\\n            last.unshift(out);\\n            this.lastK = last.slice();\\n        }\\n        else\\n        {\\n            var idx = this.mid.findIndex(el=>el>=toDelete);\\n            var newMid = this.mid.slice(0, idx).concat(this.mid.slice(idx+1, this.mid.length));\\n            this.sum -= toDelete;\\n            this.mid = newMid.slice();\\n        }\\n       \\n        // Insert new Num:\\n        // sort firstK/lastK- O(klogk)\\n        // findIndex to insert in mid - O(log(m-2*k))\\n        if(num<this.firstK[k-1])\\n        {\\n            var last = this.firstK.pop();\\n            this.mid.unshift(last);\\n            this.sum += last;\\n            this.firstK.push(num);\\n            this.firstK.sort((a,b)=>a-b);\\n        }\\n        else if(num > this.lastK[0])\\n        {\\n            var first = this.lastK[0];\\n            this.mid.push(first);\\n            this.sum += first;\\n            this.lastK.shift();\\n            this.lastK.unshift(num);\\n            this.lastK.sort((a,b)=>a-b);\\n        }\\n        else\\n        {\\n            var idx = this.mid.findIndex(el=> el>=num);\\n            if(idx===-1)\\n            {\\n                this.mid.push(num);\\n            }\\n            else if(idx===0)\\n            {\\n                this.mid.unshift(num);\\n            }\\n            else\\n            {\\n                var tmp = this.mid.slice(0, idx);\\n                tmp.push(num);\\n                tmp = tmp.concat(this.mid.slice(idx, this.mid.length));\\n                this.mid = tmp.slice();\\n            }\\n            this.sum += num;\\n        } \\n    }\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n    var k = this.k;\\n    var len = this.mq.length;\\n    if(len < this.m)\\n    {\\n        return -1;\\n    }\\n    var n = this.mid.length;\\n    var avg = Math.floor(this.sum / n);\\n    return avg;\\n};\\n```\\n\\n### Previous TLE solution, but maybe LeetCode passed it now - Straightforward sorting solution\\n\\nThis straight forward solution gets TLE a short time after the contest, but maybe due to some discussion here to complain about the test case for this problem, now it also allow this Timeout solution `O(mlogm)` to pass.\\n\\n```js\\nvar MKAverage = function(m, k) {\\n    this.m = m;\\n    this.k = k;\\n    this.nums = [];\\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n    this.nums.push(num);\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n    var k = this.k;\\n    var len = this.nums.length;\\n    if(len < this.m)\\n    {\\n        return -1;\\n    }\\n    var arr = this.nums.slice(len-this.m, len);\\n    arr.sort((a,b)=>a-b); // O(m*logm)\\n    var tmp = arr.slice(k, arr.length-k);\\n    var sum = tmp.reduce((a,b)=>a+b);\\n    var avg = Math.floor(sum / tmp.length);\\n    return avg;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar MKAverage = function(m, k) {\\n    this.m = m;\\n    this.k = k;\\n    this.mq = []; // keep last m size in original order\\n    this.firstK = [];\\n    this.lastK = [];\\n    this.mid = [];\\n    this.sum = 0; // sum for the middle part\\n    \\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n    var k = this.k;\\n    if(this.mq.length < this.m)\\n    {\\n        this.mq.push(num);\\n        if(this.mq.length===this.m) {\\n            var tmp = this.mq.slice().sort((a,b)=>a-b);\\n            this.firstK = tmp.slice(0,k);\\n            this.lastK = tmp.slice(tmp.length-k, tmp.length);\\n            this.mid = tmp.slice(k, tmp.length-k);\\n            this.sum  = this.mid.reduce((a,b)=>a+b);\\n        }\\n    }\\n    else\\n    {\\n        var toDelete = this.mq[0];\\n        this.mq.shift();\\n        this.mq.push(num);\\n        \\n        // Delete old num\\n        // findexIndex in firstK, lastK, mid - Min(O(k), O(m-2k))\\n        if(toDelete <= this.firstK[k-1])\\n        {\\n            var out =  this.mid.shift();\\n            this.sum -= out;\\n            var idx = this.firstK.findIndex(el=>el>=toDelete);\\n            var first = this.firstK.slice(0, idx).concat(this.firstK.slice(idx+1, k));\\n            first.push(out);\\n            this.firstK = first.slice();\\n        }\\n        else if( toDelete >= this.lastK[0])\\n        {            \\n            var out =  this.mid.pop();\\n            this.sum -= out;\\n            var idx = this.lastK.findIndex(el=>el>=toDelete);\\n            var last = this.lastK.slice(0, idx).concat(this.lastK.slice(idx+1, k));\\n            last.unshift(out);\\n            this.lastK = last.slice();\\n        }\\n        else\\n        {\\n            var idx = this.mid.findIndex(el=>el>=toDelete);\\n            var newMid = this.mid.slice(0, idx).concat(this.mid.slice(idx+1, this.mid.length));\\n            this.sum -= toDelete;\\n            this.mid = newMid.slice();\\n        }\\n       \\n        // Insert new Num:\\n        // sort firstK/lastK- O(klogk)\\n        // findIndex to insert in mid - O(log(m-2*k))\\n        if(num<this.firstK[k-1])\\n        {\\n            var last = this.firstK.pop();\\n            this.mid.unshift(last);\\n            this.sum += last;\\n            this.firstK.push(num);\\n            this.firstK.sort((a,b)=>a-b);\\n        }\\n        else if(num > this.lastK[0])\\n        {\\n            var first = this.lastK[0];\\n            this.mid.push(first);\\n            this.sum += first;\\n            this.lastK.shift();\\n            this.lastK.unshift(num);\\n            this.lastK.sort((a,b)=>a-b);\\n        }\\n        else\\n        {\\n            var idx = this.mid.findIndex(el=> el>=num);\\n            if(idx===-1)\\n            {\\n                this.mid.push(num);\\n            }\\n            else if(idx===0)\\n            {\\n                this.mid.unshift(num);\\n            }\\n            else\\n            {\\n                var tmp = this.mid.slice(0, idx);\\n                tmp.push(num);\\n                tmp = tmp.concat(this.mid.slice(idx, this.mid.length));\\n                this.mid = tmp.slice();\\n            }\\n            this.sum += num;\\n        } \\n    }\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n    var k = this.k;\\n    var len = this.mq.length;\\n    if(len < this.m)\\n    {\\n        return -1;\\n    }\\n    var n = this.mid.length;\\n    var avg = Math.floor(this.sum / n);\\n    return avg;\\n};\\n```\n```js\\nvar MKAverage = function(m, k) {\\n    this.m = m;\\n    this.k = k;\\n    this.nums = [];\\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n    this.nums.push(num);\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n    var k = this.k;\\n    var len = this.nums.length;\\n    if(len < this.m)\\n    {\\n        return -1;\\n    }\\n    var arr = this.nums.slice(len-this.m, len);\\n    arr.sort((a,b)=>a-b); // O(m*logm)\\n    var tmp = arr.slice(k, arr.length-k);\\n    var sum = tmp.reduce((a,b)=>a+b);\\n    var avg = Math.floor(sum / tmp.length);\\n    return avg;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153141,
                "title": "java-beats-100-fenwick-and-binary-search",
                "content": "```\\n\\nclass MKAverage {\\n\\n    ArrayList<Integer> data;\\n    int []sumf;\\n    int []countf;\\n    int m, k, avgSize;\\n\\n    public MKAverage(int m, int k) {\\n        \\n         data = new ArrayList<>();\\n         sumf = new int[(int)(1e5 + 5)];\\n         countf = new int[(int)(1e5 + 5)];\\n         this.m = m;\\n         this.k = k;\\n         avgSize = m - 2*k;\\n    }\\n    \\n    public void addElement(int num) {\\n        \\n         data.add(num);\\n         update(num);\\n        \\n         if(data.size() > m)\\n              remove(data.get(data.size()-m-1));\\n         \\n    }\\n    public int calculateMKAverage() {\\n      \\n         if(data.size() < m)\\n              return -1;\\n        \\n         \\n         int idx1 = giveIndex(k);\\n         int idx2 = giveIndex(k + avgSize);\\n        \\n         int count1 = countQuery(idx1);\\n         int count2 = countQuery(idx2);\\n        \\n         long sum1 = sumQuery(idx1);\\n         long sum2 = sumQuery(idx2);\\n        \\n         if(count1 > k)\\n              sum1 -= (long)idx1*(count1 - k)*1L;\\n        \\n         if(count2 > k + avgSize)\\n              sum2 -= (long)idx1*(count2 - (k+avgSize))*1L;\\n        \\n         double sum = sum2-sum1;\\n         sum /= avgSize; \\n        \\n         return (int)(Math.floor(sum));\\n    }\\n    \\n    public  int giveIndex(int k){\\n        \\n         int lo = 1, hi = sumf.length - 1;\\n         int idxK = -1;\\n        \\n         while(lo <= hi){\\n             \\n             int mid = (lo+hi) >> 1;\\n             \\n             int count  = countQuery(mid);\\n             \\n             if(count >= k){\\n                 hi = mid - 1;\\n                 idxK = mid;\\n             }\\n             else\\n                 lo = mid + 1;\\n             \\n         }\\n        \\n        return idxK;\\n    }\\n    \\n    public void update(int val){\\n        \\n         int idx = val;\\n        \\n         while(idx < sumf.length){\\n             \\n              sumf[idx] += val;\\n              countf[idx] += 1;\\n             \\n              idx += idx&-idx;\\n         }\\n    }\\n    \\n     public void remove(int val){\\n        \\n         int idx = val;\\n        \\n         while(idx < sumf.length){\\n             \\n              sumf[idx] -= val;\\n              countf[idx] -= 1;\\n             \\n              idx += idx&-idx;\\n         }\\n    }\\n    \\n   public int countQuery(int idx){\\n       int ans = 0;\\n       \\n        while(idx > 0){\\n            \\n            ans += countf[idx];\\n            idx -= idx&-idx;\\n        }\\n       return ans;\\n   }\\n    \\n   public long sumQuery(int idx){\\n       \\n       long sum = 0;\\n       \\n       while(idx > 0){\\n           \\n            sum += (long)sumf[idx];\\n            idx -= idx&-idx;\\n           \\n       }\\n       return sum;\\n   }\\n}\\n\\n```\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass MKAverage {\\n\\n    ArrayList<Integer> data;\\n    int []sumf;\\n    int []countf;\\n    int m, k, avgSize;\\n\\n    public MKAverage(int m, int k) {\\n        \\n         data = new ArrayList<>();\\n         sumf = new int[(int)(1e5 + 5)];\\n         countf = new int[(int)(1e5 + 5)];\\n         this.m = m;\\n         this.k = k;\\n         avgSize = m - 2*k;\\n    }\\n    \\n    public void addElement(int num) {\\n        \\n         data.add(num);\\n         update(num);\\n        \\n         if(data.size() > m)\\n              remove(data.get(data.size()-m-1));\\n         \\n    }\\n    public int calculateMKAverage() {\\n      \\n         if(data.size() < m)\\n              return -1;\\n        \\n         \\n         int idx1 = giveIndex(k);\\n         int idx2 = giveIndex(k + avgSize);\\n        \\n         int count1 = countQuery(idx1);\\n         int count2 = countQuery(idx2);\\n        \\n         long sum1 = sumQuery(idx1);\\n         long sum2 = sumQuery(idx2);\\n        \\n         if(count1 > k)\\n              sum1 -= (long)idx1*(count1 - k)*1L;\\n        \\n         if(count2 > k + avgSize)\\n              sum2 -= (long)idx1*(count2 - (k+avgSize))*1L;\\n        \\n         double sum = sum2-sum1;\\n         sum /= avgSize; \\n        \\n         return (int)(Math.floor(sum));\\n    }\\n    \\n    public  int giveIndex(int k){\\n        \\n         int lo = 1, hi = sumf.length - 1;\\n         int idxK = -1;\\n        \\n         while(lo <= hi){\\n             \\n             int mid = (lo+hi) >> 1;\\n             \\n             int count  = countQuery(mid);\\n             \\n             if(count >= k){\\n                 hi = mid - 1;\\n                 idxK = mid;\\n             }\\n             else\\n                 lo = mid + 1;\\n             \\n         }\\n        \\n        return idxK;\\n    }\\n    \\n    public void update(int val){\\n        \\n         int idx = val;\\n        \\n         while(idx < sumf.length){\\n             \\n              sumf[idx] += val;\\n              countf[idx] += 1;\\n             \\n              idx += idx&-idx;\\n         }\\n    }\\n    \\n     public void remove(int val){\\n        \\n         int idx = val;\\n        \\n         while(idx < sumf.length){\\n             \\n              sumf[idx] -= val;\\n              countf[idx] -= 1;\\n             \\n              idx += idx&-idx;\\n         }\\n    }\\n    \\n   public int countQuery(int idx){\\n       int ans = 0;\\n       \\n        while(idx > 0){\\n            \\n            ans += countf[idx];\\n            idx -= idx&-idx;\\n        }\\n       return ans;\\n   }\\n    \\n   public long sumQuery(int idx){\\n       \\n       long sum = 0;\\n       \\n       while(idx > 0){\\n           \\n            sum += (long)sumf[idx];\\n            idx -= idx&-idx;\\n           \\n       }\\n       return sum;\\n   }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153127,
                "title": "java-treemap-easy-understand-solution-and-100-beat",
                "content": "\\nThis solution uses 3 TreeMaps to simulate 3 segements calculation. Easyly understand and effecency.\\n\\n> Runtime: 95 ms, faster than `100.00%` of Java online submissions for Finding MK Average.\\n\\n```java\\n\\nclass MyTreeMap extends TreeMap<Integer, Integer> {\\n    int numberCont = 0;\\n    \\n    public void increase(Integer k) {\\n        numberCont += 1;\\n        if (super.containsKey(k)) {\\n            super.put(k, super.get(k) + 1);\\n        } else {\\n            super.put(k, 1);\\n        }\\n    }\\n    \\n    public void decrease(Integer k) {\\n        numberCont -= 1;\\n        assert super.containsKey(k);\\n        int v = super.get(k);\\n        if (v - 1 == 0) {\\n            super.remove(k);\\n        } else {\\n            super.put(k, super.get(k) - 1);\\n        }\\n    }\\n    \\n    @Override\\n    public int size() {\\n        return numberCont;\\n    }\\n}\\n\\nclass MKAverage {\\n    int m, k, x;\\n    long s = 0;\\n    Deque<Integer> q;\\n    MyTreeMap lt, mi, gt;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.q = new ArrayDeque(m + 1);\\n        this.x = m - 2 * k;\\n        this.lt = new MyTreeMap();\\n        this.mi = new MyTreeMap();\\n        this.gt = new MyTreeMap();\\n    }\\n    \\n    public void shuffle() {\\n        // move exceed little elements from lt ==> mi\\n        while ( lt.size() > k) {\\n            int x = lt.lastKey();\\n            lt.decrease(x);\\n            mi.increase(x);\\n            s += x;\\n        }\\n        // move exceed great elements from gt ==> mi\\n        while ( gt.size() > k) {\\n            int x = gt.firstKey();\\n            gt.decrease(x);\\n            mi.increase(x);\\n            s += x;\\n        }\\n        \\n        // padding first k little elements\\n        while (lt.size() < k && !mi.isEmpty()) {\\n            int x = mi.firstKey();\\n            mi.decrease(x);\\n            s -= x;\\n            lt.increase(x);\\n        }\\n        // padding last k great elements\\n        while(gt.size() < k && !mi.isEmpty()) {\\n            int x = mi.lastKey();\\n            mi.decrease(x);\\n            s -= x;\\n            gt.increase(x);\\n        }\\n    }\\n    \\n    public void remove() {\\n        int x = q.removeFirst();\\n        // System.out.println(\"removing:\" + x);\\n        if (lt.containsKey(x)) {\\n            lt.decrease(x);\\n        } else if (mi.containsKey(x)) {\\n            mi.decrease(x);      \\n            s -= x;\\n        } else {\\n            gt.decrease(x);\\n        }\\n        \\n    }\\n    \\n    public void add(int n) {\\n        q.addLast(n);\\n        if (lt.isEmpty() || n <= lt.lastKey()) {\\n            lt.increase(n);\\n        } else if (gt.isEmpty() || n >= gt.firstKey()) {\\n            gt.increase(n);\\n        } else {\\n            mi.increase(n);\\n            s += n;\\n        }\\n    }\\n    \\n    public void addElement(int n) {\\n        add(n);\\n        \\n        // remove\\n        if (q.size() > m) {\\n            remove();\\n        }\\n        \\n        if ( q.size() >= m) {\\n            shuffle();\\n        }\\n        //System.out.println(q);\\n        //System.out.println(lt);\\n        //System.out.println(mi);\\n        //System.out.println(gt);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size() < m) {\\n            return -1;\\n        }\\n        return (int)(s / x);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```java\\n\\nclass MyTreeMap extends TreeMap<Integer, Integer> {\\n    int numberCont = 0;\\n    \\n    public void increase(Integer k) {\\n        numberCont += 1;\\n        if (super.containsKey(k)) {\\n            super.put(k, super.get(k) + 1);\\n        } else {\\n            super.put(k, 1);\\n        }\\n    }\\n    \\n    public void decrease(Integer k) {\\n        numberCont -= 1;\\n        assert super.containsKey(k);\\n        int v = super.get(k);\\n        if (v - 1 == 0) {\\n            super.remove(k);\\n        } else {\\n            super.put(k, super.get(k) - 1);\\n        }\\n    }\\n    \\n    @Override\\n    public int size() {\\n        return numberCont;\\n    }\\n}\\n\\nclass MKAverage {\\n    int m, k, x;\\n    long s = 0;\\n    Deque<Integer> q;\\n    MyTreeMap lt, mi, gt;\\n\\n    public MKAverage(int m, int k) {\\n        this.m = m;\\n        this.k = k;\\n        this.q = new ArrayDeque(m + 1);\\n        this.x = m - 2 * k;\\n        this.lt = new MyTreeMap();\\n        this.mi = new MyTreeMap();\\n        this.gt = new MyTreeMap();\\n    }\\n    \\n    public void shuffle() {\\n        // move exceed little elements from lt ==> mi\\n        while ( lt.size() > k) {\\n            int x = lt.lastKey();\\n            lt.decrease(x);\\n            mi.increase(x);\\n            s += x;\\n        }\\n        // move exceed great elements from gt ==> mi\\n        while ( gt.size() > k) {\\n            int x = gt.firstKey();\\n            gt.decrease(x);\\n            mi.increase(x);\\n            s += x;\\n        }\\n        \\n        // padding first k little elements\\n        while (lt.size() < k && !mi.isEmpty()) {\\n            int x = mi.firstKey();\\n            mi.decrease(x);\\n            s -= x;\\n            lt.increase(x);\\n        }\\n        // padding last k great elements\\n        while(gt.size() < k && !mi.isEmpty()) {\\n            int x = mi.lastKey();\\n            mi.decrease(x);\\n            s -= x;\\n            gt.increase(x);\\n        }\\n    }\\n    \\n    public void remove() {\\n        int x = q.removeFirst();\\n        // System.out.println(\"removing:\" + x);\\n        if (lt.containsKey(x)) {\\n            lt.decrease(x);\\n        } else if (mi.containsKey(x)) {\\n            mi.decrease(x);      \\n            s -= x;\\n        } else {\\n            gt.decrease(x);\\n        }\\n        \\n    }\\n    \\n    public void add(int n) {\\n        q.addLast(n);\\n        if (lt.isEmpty() || n <= lt.lastKey()) {\\n            lt.increase(n);\\n        } else if (gt.isEmpty() || n >= gt.firstKey()) {\\n            gt.increase(n);\\n        } else {\\n            mi.increase(n);\\n            s += n;\\n        }\\n    }\\n    \\n    public void addElement(int n) {\\n        add(n);\\n        \\n        // remove\\n        if (q.size() > m) {\\n            remove();\\n        }\\n        \\n        if ( q.size() >= m) {\\n            shuffle();\\n        }\\n        //System.out.println(q);\\n        //System.out.println(lt);\\n        //System.out.println(mi);\\n        //System.out.println(gt);\\n    }\\n    \\n    public int calculateMKAverage() {\\n        if (q.size() < m) {\\n            return -1;\\n        }\\n        return (int)(s / x);\\n    }\\n}\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage obj = new MKAverage(m, k);\\n * obj.addElement(num);\\n * int param_2 = obj.calculateMKAverage();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153106,
                "title": "javascript-brute-force",
                "content": "8424 ms\\n```\\nfunction MKAverage(m, k) {\\n    let data = [];\\n    return { addElement, calculateMKAverage }\\n    function addElement(num) {\\n        data.push(num);\\n        if (data.length > m) data.shift();\\n    }\\n\\n    function calculateMKAverage() {\\n        if (data.length < m) return -1;\\n        let a = [...data].sort((x, y) => x - y).slice(k, -k);\\n        let sum = a.reduce(((x, y) => x + y), 0);\\n        return sum / a.length >> 0;\\n    }\\n}\\n```\\nAnother version: 9156 ms\\n```\\nfunction MKAverage(m, k) {\\n    let data = [];\\n    return { addElement, calculateMKAverage }\\n    function addElement(num) {\\n        data.push(num);\\n        if (data.length > m) data = data.slice(-m);\\n    }\\n\\n    function calculateMKAverage() {\\n        if (data.length < m) return -1;\\n        let a = [...data].sort((x, y) => x - y).slice(k, -k);\\n        let sum = a.reduce(((x, y) => x + y), 0);\\n        return sum / a.length >> 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction MKAverage(m, k) {\\n    let data = [];\\n    return { addElement, calculateMKAverage }\\n    function addElement(num) {\\n        data.push(num);\\n        if (data.length > m) data.shift();\\n    }\\n\\n    function calculateMKAverage() {\\n        if (data.length < m) return -1;\\n        let a = [...data].sort((x, y) => x - y).slice(k, -k);\\n        let sum = a.reduce(((x, y) => x + y), 0);\\n        return sum / a.length >> 0;\\n    }\\n}\\n```\n```\\nfunction MKAverage(m, k) {\\n    let data = [];\\n    return { addElement, calculateMKAverage }\\n    function addElement(num) {\\n        data.push(num);\\n        if (data.length > m) data = data.slice(-m);\\n    }\\n\\n    function calculateMKAverage() {\\n        if (data.length < m) return -1;\\n        let a = [...data].sort((x, y) => x - y).slice(k, -k);\\n        let sum = a.reduce(((x, y) => x + y), 0);\\n        return sum / a.length >> 0;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153044,
                "title": "binary-search",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} k\\n */\\nvar MKAverage = function(m, k) {\\n  this.m = m;\\n  this.k = k;\\n  this.mPool = [];\\n  this.mSum = 0;\\n  this.kHeadSum = 0;\\n  this.kTailSum = 0;\\n  this.allElement = [];\\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n  let allElement = this.allElement;\\n  let mPool = this.mPool;\\n  allElement.push(num);\\n  this.mSum += num;\\n  if (allElement.length <= this.m) {\\n    mPool.push(num);\\n    if (allElement.length === this.m) {\\n      mPool.sort((a, b) => a - b);\\n      this.kHeadSum = mPool.slice(0, this.k).reduce((a, b) => a + b);\\n      this.kTailSum = mPool.slice(mPool.length - this.k).reduce((a, b) => a + b);\\n    }\\n    return this;\\n  }\\n  let delIndex = this.findIndex(mPool, allElement[allElement.length - this.m - 1]);\\n  if (delIndex < this.k) {\\n    this.kHeadSum -= mPool[delIndex];\\n    this.kHeadSum += mPool[this.k];\\n  } else if (delIndex >= mPool.length - this.k) {\\n    this.kTailSum -= mPool[delIndex];\\n    this.kTailSum += mPool[mPool.length - this.k - 1];\\n  }\\n  mPool.splice(delIndex, 1);\\n  this.mSum -= allElement[allElement.length - this.m - 1];\\n  let insertIndex = this.findCloseOrEqualIndex(mPool, num);\\n  if (insertIndex < this.k) {\\n    this.kHeadSum -= mPool[this.k - 1];\\n    this.kHeadSum += num;\\n  } else if (insertIndex > mPool.length - this.k) {\\n    this.kTailSum -= mPool[mPool.length - this.k];\\n    this.kTailSum += num;\\n  }\\n  mPool.splice(insertIndex, 0, num);\\n  return this;\\n};\\n\\nMKAverage.prototype.findCloseOrEqualIndex = function(arr, val) {\\n  if (val < arr[0]) return 0;\\n  else if (val > arr[arr.length - 1]) return arr.length;\\n  let l = 0;\\n  let r = arr.length - 1;\\n  while (l < r) {\\n    let m = Math.floor((l + r) / 2);\\n    if (val > arr[m] && val <= arr[m + 1]) {\\n      l = r = m;\\n    } else if (val > arr[m]) {\\n      l = m + 1;\\n    } else {\\n      r = m;\\n    }\\n  }\\n  return l + 1;\\n};\\n\\nMKAverage.prototype.findIndex = function(arr, val) {\\n  let l = 0;\\n  let r = arr.length;\\n  while (l < r) {\\n    let m = Math.floor((l + r) / 2);\\n    if (arr[m] < val) {\\n      l = m + 1;\\n    } else {\\n      r = m;\\n    }\\n  }\\n  return l;\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n  if (this.mPool.length < this.m) return -1;\\n  return Math.floor((this.mSum - this.kHeadSum - this.kTailSum) / (this.m - this.k * 2));\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * var obj = new MKAverage(m, k)\\n * obj.addElement(num)\\n * var param_2 = obj.calculateMKAverage()\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} k\\n */\\nvar MKAverage = function(m, k) {\\n  this.m = m;\\n  this.k = k;\\n  this.mPool = [];\\n  this.mSum = 0;\\n  this.kHeadSum = 0;\\n  this.kTailSum = 0;\\n  this.allElement = [];\\n};\\n\\nMKAverage.prototype.addElement = function(num) {\\n  let allElement = this.allElement;\\n  let mPool = this.mPool;\\n  allElement.push(num);\\n  this.mSum += num;\\n  if (allElement.length <= this.m) {\\n    mPool.push(num);\\n    if (allElement.length === this.m) {\\n      mPool.sort((a, b) => a - b);\\n      this.kHeadSum = mPool.slice(0, this.k).reduce((a, b) => a + b);\\n      this.kTailSum = mPool.slice(mPool.length - this.k).reduce((a, b) => a + b);\\n    }\\n    return this;\\n  }\\n  let delIndex = this.findIndex(mPool, allElement[allElement.length - this.m - 1]);\\n  if (delIndex < this.k) {\\n    this.kHeadSum -= mPool[delIndex];\\n    this.kHeadSum += mPool[this.k];\\n  } else if (delIndex >= mPool.length - this.k) {\\n    this.kTailSum -= mPool[delIndex];\\n    this.kTailSum += mPool[mPool.length - this.k - 1];\\n  }\\n  mPool.splice(delIndex, 1);\\n  this.mSum -= allElement[allElement.length - this.m - 1];\\n  let insertIndex = this.findCloseOrEqualIndex(mPool, num);\\n  if (insertIndex < this.k) {\\n    this.kHeadSum -= mPool[this.k - 1];\\n    this.kHeadSum += num;\\n  } else if (insertIndex > mPool.length - this.k) {\\n    this.kTailSum -= mPool[mPool.length - this.k];\\n    this.kTailSum += num;\\n  }\\n  mPool.splice(insertIndex, 0, num);\\n  return this;\\n};\\n\\nMKAverage.prototype.findCloseOrEqualIndex = function(arr, val) {\\n  if (val < arr[0]) return 0;\\n  else if (val > arr[arr.length - 1]) return arr.length;\\n  let l = 0;\\n  let r = arr.length - 1;\\n  while (l < r) {\\n    let m = Math.floor((l + r) / 2);\\n    if (val > arr[m] && val <= arr[m + 1]) {\\n      l = r = m;\\n    } else if (val > arr[m]) {\\n      l = m + 1;\\n    } else {\\n      r = m;\\n    }\\n  }\\n  return l + 1;\\n};\\n\\nMKAverage.prototype.findIndex = function(arr, val) {\\n  let l = 0;\\n  let r = arr.length;\\n  while (l < r) {\\n    let m = Math.floor((l + r) / 2);\\n    if (arr[m] < val) {\\n      l = m + 1;\\n    } else {\\n      r = m;\\n    }\\n  }\\n  return l;\\n};\\n\\nMKAverage.prototype.calculateMKAverage = function() {\\n  if (this.mPool.length < this.m) return -1;\\n  return Math.floor((this.mSum - this.kHeadSum - this.kTailSum) / (this.m - this.k * 2));\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * var obj = new MKAverage(m, k)\\n * obj.addElement(num)\\n * var param_2 = obj.calculateMKAverage()\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152991,
                "title": "easy-c-solution-using-3-multisets",
                "content": "Add the new element in one of 3 sets: \\n\\t1. sml (smallest k elements)\\n\\t2. mid (mid m-2*k elements)\\n\\t3. lrg (largest k elements)\\n\\nKeep a queue of all elements.\\nWhenever new element is added, check if the window size is more than m and delete the expired element from queue as well as from the 1 container out of above 3 that contains that element.\\n\\nKeep a running sum.\\n\\nTime complexity:\\n1. calculateMKAverage: ```O(1)```\\n2. addElement: ```O(logm + logk)```\\n\\nSpace complexity: ```O(m)```\\n```\\nclass MKAverage {\\npublic:\\n    typedef long long LL;\\n    multiset<int> sml,mid,lrg;\\n    int m,k;\\n    int n=0;\\n    LL sum=0;\\n    queue<int> q;\\n    int getlg(multiset<int> &se)\\n    {\\n        return *--se.end();\\n    }\\n    int getsm(multiset<int> &se)\\n    {\\n        return *se.begin();\\n    }\\n    \\n    void insert(int x)\\n    {\\n        if(sml.size()<k || x<=getlg(sml))\\n        {\\n            sml.insert(x);\\n            if(sml.size()<=k) return;\\n            x=getlg(sml);\\n            sml.erase(sml.find(x));\\n        }\\n        if(mid.size()<m-k*2 || x<=getlg(mid))\\n        {\\n            mid.insert(x);\\n            sum+=x;\\n            if(mid.size()<=m-k*2) return;\\n            x=getlg(mid);\\n            sum-=x;\\n            mid.erase(mid.find(x));\\n        }\\n        lrg.insert(x);\\n    }\\n    void erase(int x)\\n    {\\n        if(x<=getlg(sml))\\n        {\\n            sml.erase(sml.find(x));\\n            if(sml.size()<=k)\\n            {\\n                x=getsm(mid);\\n                sml.insert(x);\\n            }\\n            else\\n                return;\\n        }\\n\\n        if(x<=getlg(mid))\\n        {\\n            mid.erase(mid.find(x));\\n            sum-=x;\\n            if(mid.size()<=m-k*2)\\n            {\\n                x=getsm(lrg);\\n                sum+=x;\\n                mid.insert(x);\\n            }\\n            else\\n                return;\\n        }\\n        lrg.erase(lrg.find(x));\\n    }\\n    \\n    MKAverage(int m, int k) {\\n        this->m=m;\\n        this->k=k;\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        n++;\\n        insert(num);\\n        if(n<=m) return;\\n        \\n        erase(q.front());\\n        q.pop();\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(n<m) return -1;\\n        return sum/(m-2*k);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```O(1)```\n```O(logm + logk)```\n```O(m)```\n```\\nclass MKAverage {\\npublic:\\n    typedef long long LL;\\n    multiset<int> sml,mid,lrg;\\n    int m,k;\\n    int n=0;\\n    LL sum=0;\\n    queue<int> q;\\n    int getlg(multiset<int> &se)\\n    {\\n        return *--se.end();\\n    }\\n    int getsm(multiset<int> &se)\\n    {\\n        return *se.begin();\\n    }\\n    \\n    void insert(int x)\\n    {\\n        if(sml.size()<k || x<=getlg(sml))\\n        {\\n            sml.insert(x);\\n            if(sml.size()<=k) return;\\n            x=getlg(sml);\\n            sml.erase(sml.find(x));\\n        }\\n        if(mid.size()<m-k*2 || x<=getlg(mid))\\n        {\\n            mid.insert(x);\\n            sum+=x;\\n            if(mid.size()<=m-k*2) return;\\n            x=getlg(mid);\\n            sum-=x;\\n            mid.erase(mid.find(x));\\n        }\\n        lrg.insert(x);\\n    }\\n    void erase(int x)\\n    {\\n        if(x<=getlg(sml))\\n        {\\n            sml.erase(sml.find(x));\\n            if(sml.size()<=k)\\n            {\\n                x=getsm(mid);\\n                sml.insert(x);\\n            }\\n            else\\n                return;\\n        }\\n\\n        if(x<=getlg(mid))\\n        {\\n            mid.erase(mid.find(x));\\n            sum-=x;\\n            if(mid.size()<=m-k*2)\\n            {\\n                x=getsm(lrg);\\n                sum+=x;\\n                mid.insert(x);\\n            }\\n            else\\n                return;\\n        }\\n        lrg.erase(lrg.find(x));\\n    }\\n    \\n    MKAverage(int m, int k) {\\n        this->m=m;\\n        this->k=k;\\n    }\\n    \\n    void addElement(int num) {\\n        q.push(num);\\n        n++;\\n        insert(num);\\n        if(n<=m) return;\\n        \\n        erase(q.front());\\n        q.pop();\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(n<m) return -1;\\n        return sum/(m-2*k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152984,
                "title": "getting-tle-using-priority-queue-please-help-me",
                "content": "Is my approch is wrong or right?\\nIf right then anybody can optimize it?\\nThanks in advance\\n```\\nclass MKAverage {\\npublic:\\n     vector<int> v;\\n       int m,k;\\n    MKAverage(int x, int y) {\\n        m=x;\\n        k=y;\\n     \\n    }\\n    \\n    void addElement(int num) {\\n        v.push_back(num);\\n     \\n    }\\n    \\n    int calculateMKAverage() {\\n        if(m>v.size())\\n            return -1;\\n        \\n        priority_queue <pair<int,int>> Max; // for max k elemets\\n        priority_queue <pair<int,int>, vector<pair<int,int>> , greater <pair<int,int>> > Min; // for min k elements\\n        int t=m,i=v.size()-1,num;\\n         unordered_set<int> s;\\n        // last m elemets copying\\n        while(t--)\\n        {\\n            num=v[i];\\n           \\n             Max.push(make_pair(num,i));\\n            Min.push(make_pair(num,i));\\n           \\n            s.insert(i);\\n             i--;\\n        }\\n      \\n        // max k elements\\n        t=k;\\n        pair<int,int> p;\\n        while(t--)\\n        {\\n            p=Max.top();\\n            Max.pop();\\n            s.erase(p.second);\\n        }\\n       // min k elements\\n        t=k;\\n        while(t--)\\n        {\\n            p=Min.top();\\n            Min.pop();\\n            s.erase(p.second);\\n        }\\n   \\n        double sum=0;\\n        for(auto i :s)\\n        {\\n            sum+=v[i];\\n        }\\n     \\n        return floor(sum/(m-2*k));\\n    }\\n};\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\npublic:\\n     vector<int> v;\\n       int m,k;\\n    MKAverage(int x, int y) {\\n        m=x;\\n        k=y;\\n     \\n    }\\n    \\n    void addElement(int num) {\\n        v.push_back(num);\\n     \\n    }\\n    \\n    int calculateMKAverage() {\\n        if(m>v.size())\\n            return -1;\\n        \\n        priority_queue <pair<int,int>> Max; // for max k elemets\\n        priority_queue <pair<int,int>, vector<pair<int,int>> , greater <pair<int,int>> > Min; // for min k elements\\n        int t=m,i=v.size()-1,num;\\n         unordered_set<int> s;\\n        // last m elemets copying\\n        while(t--)\\n        {\\n            num=v[i];\\n           \\n             Max.push(make_pair(num,i));\\n            Min.push(make_pair(num,i));\\n           \\n            s.insert(i);\\n             i--;\\n        }\\n      \\n        // max k elements\\n        t=k;\\n        pair<int,int> p;\\n        while(t--)\\n        {\\n            p=Max.top();\\n            Max.pop();\\n            s.erase(p.second);\\n        }\\n       // min k elements\\n        t=k;\\n        while(t--)\\n        {\\n            p=Min.top();\\n            Min.pop();\\n            s.erase(p.second);\\n        }\\n   \\n        double sum=0;\\n        for(auto i :s)\\n        {\\n            sum+=v[i];\\n        }\\n     \\n        return floor(sum/(m-2*k));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152862,
                "title": "c-maintain-topk",
                "content": "```\\nclass MKAverage {\\nprivate:\\n    queue<int> data;\\n    int m, k;\\n    multiset<int> com;\\n    long long sum;\\n    long long ex;\\n    multiset<int>::iterator it;\\n    multiset<int>::iterator it1;\\npublic:\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        sum = 0;\\n        ex = 0;\\n        \\n    }\\n    \\n    void addElement(int num) {\\n        //printf(\"%d:\", num);\\n        data.push(num);\\n        com.insert(num);\\n        sum += num;\\n        if(com.size()==k){\\n            it = com.find(*com.begin());\\n            it1 = com.end();\\n            it1--;\\n            ex = (sum<<1);\\n        } else if(com.size()>k){\\n            if(num<(*it1)){\\n                // shift left\\n                //printf(\"shift left\");\\n                //printf(\"-%d %d %d\", *it, *it1, num);\\n                ex -= (*it1);\\n                ex += num;\\n                it1--;\\n            }\\n            if(num>=*it){\\n                // shift right\\n                //printf(\"shift right\");\\n                //printf(\"-%d %d %d\", *it, *it1, num);\\n                ex -= (*it);\\n                ex += num;\\n                it++;\\n            }\\n        }\\n        if(data.size()>m){\\n            num = data.front();\\n            data.pop();\\n            \\n            //printf(\"-%d %d %d\", *it, *it1, num);\\n                \\n            sum -= num;\\n            \\n            auto tt = com.find(num);\\n            if(num<=*it1){\\n                ex -= num;\\n                it1++;\\n                if(it1==tt)  it1++;\\n                ex += (*it1);\\n            }\\n            if(num>*it || it==tt){\\n                ex -= num;\\n                it--;\\n                if(it==tt)  it--;\\n                ex += (*it);\\n            }\\n            com.erase(tt);\\n        }\\n        /*\\n        if(com.size()>=k)\\n            printf(\"--%d %d %d\", *it, *it1, num);\\n        printf(\"\\\\n\");\\n        */\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(data.size()<m)   return -1;\\n        long long temp = sum;\\n        \\n        //printf(\"%lld %lld %lld\\\\n\", l, r, (sum-l-r)/(m-(k<<1)));\\n        \\n        return (sum-ex)/(m-(k<<1));\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MKAverage {\\nprivate:\\n    queue<int> data;\\n    int m, k;\\n    multiset<int> com;\\n    long long sum;\\n    long long ex;\\n    multiset<int>::iterator it;\\n    multiset<int>::iterator it1;\\npublic:\\n    MKAverage(int m, int k) {\\n        this->m = m;\\n        this->k = k;\\n        sum = 0;\\n        ex = 0;\\n        \\n    }\\n    \\n    void addElement(int num) {\\n        //printf(\"%d:\", num);\\n        data.push(num);\\n        com.insert(num);\\n        sum += num;\\n        if(com.size()==k){\\n            it = com.find(*com.begin());\\n            it1 = com.end();\\n            it1--;\\n            ex = (sum<<1);\\n        } else if(com.size()>k){\\n            if(num<(*it1)){\\n                // shift left\\n                //printf(\"shift left\");\\n                //printf(\"-%d %d %d\", *it, *it1, num);\\n                ex -= (*it1);\\n                ex += num;\\n                it1--;\\n            }\\n            if(num>=*it){\\n                // shift right\\n                //printf(\"shift right\");\\n                //printf(\"-%d %d %d\", *it, *it1, num);\\n                ex -= (*it);\\n                ex += num;\\n                it++;\\n            }\\n        }\\n        if(data.size()>m){\\n            num = data.front();\\n            data.pop();\\n            \\n            //printf(\"-%d %d %d\", *it, *it1, num);\\n                \\n            sum -= num;\\n            \\n            auto tt = com.find(num);\\n            if(num<=*it1){\\n                ex -= num;\\n                it1++;\\n                if(it1==tt)  it1++;\\n                ex += (*it1);\\n            }\\n            if(num>*it || it==tt){\\n                ex -= num;\\n                it--;\\n                if(it==tt)  it--;\\n                ex += (*it);\\n            }\\n            com.erase(tt);\\n        }\\n        /*\\n        if(com.size()>=k)\\n            printf(\"--%d %d %d\", *it, *it1, num);\\n        printf(\"\\\\n\");\\n        */\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(data.size()<m)   return -1;\\n        long long temp = sum;\\n        \\n        //printf(\"%lld %lld %lld\\\\n\", l, r, (sum-l-r)/(m-(k<<1)));\\n        \\n        return (sum-ex)/(m-(k<<1));\\n    }\\n};\\n\\n/**\\n * Your MKAverage object will be instantiated and called as such:\\n * MKAverage* obj = new MKAverage(m, k);\\n * obj->addElement(num);\\n * int param_2 = obj->calculateMKAverage();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152501,
                "title": "python-sorted-array-and-deque",
                "content": "Very straightforwar. 580ms.\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        self.q = deque()\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        bisect.insort(self.arr, num)\\n        if len(self.q) > self.m:\\n            last = self.q.popleft()\\n            idx = bisect.bisect_left(self.arr, last)\\n            self.arr.pop(idx)\\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n    \\n        return sum(self.arr[self.k:self.m-self.k])//(self.m-2*self.k)",
                "solutionTags": [],
                "code": "Very straightforwar. 580ms.\\n\\n\\n    def __init__(self, m: int, k: int):\\n        self.m = m\\n        self.k = k\\n        self.arr = []\\n        self.q = deque()\\n\\n    def addElement(self, num: int) -> None:\\n        self.q.append(num)\\n        bisect.insort(self.arr, num)\\n        if len(self.q) > self.m:\\n            last = self.q.popleft()\\n            idx = bisect.bisect_left(self.arr, last)\\n            self.arr.pop(idx)\\n        return\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.q) < self.m:\\n            return -1\\n    \\n        return sum(self.arr[self.k:self.m-self.k])//(self.m-2*self.k)",
                "codeTag": "Python3"
            },
            {
                "id": 1152485,
                "title": "c-solution-using-multiset-with-explanation-simple-code",
                "content": "Just maintain 3 multisets one will consist of smallest k elements, one for largest k elements and one for the rest of the elements.\\nAlso maintain the sum of the elements in these multisets. When the number of elements exceeds m then we need to remove the (cur-m)th element so if we have to remove from the multiset of largest k elements we don\\'t need to do anything. If we need to remove from the rest of the elements multiset then we have to remove the smallest number from the lg multiset and insert into the md multiset. Similarly if we need to remove from sm multiset then we have to remove smallest from md and insert into sm and remove smallest from lg and insert into md.\\n\\nDon\\'t miss out using long long here.\\n\\n```\\n#define ll long long\\nclass MKAverage {\\npublic:\\n    ll m,k;\\n    multiset<ll> sm,md,lg;\\n    map<ll,ll> stream;\\n    ll cur,ssm,smd,slg;\\n    MKAverage(int _m, int _k) {\\n        m=_m;k=_k;\\n        cur=0;ssm=0;smd=0;slg=0;\\n        stream.clear();\\n        sm.clear();md.clear();lg.clear();\\n    }\\n    \\n    void addElement(int num) {\\n        cur++;\\n        stream[cur]=num;\\n        if(cur>m){\\n            ll val=stream[cur-m];\\n            if(lg.find(val)!=lg.end()){\\n                lg.erase(lg.lower_bound(val));slg-=val;\\n            }\\n            else if(md.find(val)!=md.end()){\\n                md.erase(md.lower_bound(val));smd-=val;\\n                auto x=lg.begin();\\n                ll xv=*x;\\n                lg.erase(x);slg-=xv;\\n                md.insert(xv);smd+=xv;\\n            }\\n            else if(sm.find(val)!=sm.end()){\\n                sm.erase(sm.lower_bound(val));ssm-=val;\\n                auto x=md.begin();\\n                ll xv=*x;\\n                md.erase(x);smd-=xv;\\n                sm.insert(xv);ssm+=xv;\\n                auto y=lg.begin();\\n                ll yv=*y;\\n                lg.erase(y);slg-=yv;\\n                md.insert(yv);smd+=yv;\\n            }\\n        }\\n        sm.insert(num);ssm+=num;\\n        while(sm.size()>k){\\n            auto x=prev(sm.end());\\n            ll xv=*x;\\n            sm.erase(x);\\n            ssm-=xv;\\n            md.insert(xv);smd+=xv;\\n        }\\n        while(md.size()>(m-2*k)){\\n            auto x=prev(md.end());\\n            ll xv=*x;\\n            md.erase(x);\\n            smd-=xv;\\n            lg.insert(xv);slg+=xv;\\n        }\\n        // cout<<cur<<\" \"<<*sm.begin()<<\" \"<<*md.begin()<<\" \"<<*lg.begin()<<endl;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(cur<m) return -1;\\n        ll len=md.size();\\n        ll ans=smd/len;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass MKAverage {\\npublic:\\n    ll m,k;\\n    multiset<ll> sm,md,lg;\\n    map<ll,ll> stream;\\n    ll cur,ssm,smd,slg;\\n    MKAverage(int _m, int _k) {\\n        m=_m;k=_k;\\n        cur=0;ssm=0;smd=0;slg=0;\\n        stream.clear();\\n        sm.clear();md.clear();lg.clear();\\n    }\\n    \\n    void addElement(int num) {\\n        cur++;\\n        stream[cur]=num;\\n        if(cur>m){\\n            ll val=stream[cur-m];\\n            if(lg.find(val)!=lg.end()){\\n                lg.erase(lg.lower_bound(val));slg-=val;\\n            }\\n            else if(md.find(val)!=md.end()){\\n                md.erase(md.lower_bound(val));smd-=val;\\n                auto x=lg.begin();\\n                ll xv=*x;\\n                lg.erase(x);slg-=xv;\\n                md.insert(xv);smd+=xv;\\n            }\\n            else if(sm.find(val)!=sm.end()){\\n                sm.erase(sm.lower_bound(val));ssm-=val;\\n                auto x=md.begin();\\n                ll xv=*x;\\n                md.erase(x);smd-=xv;\\n                sm.insert(xv);ssm+=xv;\\n                auto y=lg.begin();\\n                ll yv=*y;\\n                lg.erase(y);slg-=yv;\\n                md.insert(yv);smd+=yv;\\n            }\\n        }\\n        sm.insert(num);ssm+=num;\\n        while(sm.size()>k){\\n            auto x=prev(sm.end());\\n            ll xv=*x;\\n            sm.erase(x);\\n            ssm-=xv;\\n            md.insert(xv);smd+=xv;\\n        }\\n        while(md.size()>(m-2*k)){\\n            auto x=prev(md.end());\\n            ll xv=*x;\\n            md.erase(x);\\n            smd-=xv;\\n            lg.insert(xv);slg+=xv;\\n        }\\n        // cout<<cur<<\" \"<<*sm.begin()<<\" \"<<*md.begin()<<\" \"<<*lg.begin()<<endl;\\n    }\\n    \\n    int calculateMKAverage() {\\n        if(cur<m) return -1;\\n        ll len=md.size();\\n        ll ans=smd/len;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1152452,
                "title": "python-sortedlist-and-deque",
                "content": "```\\nimport collections\\nimport math\\nimport statistics\\nfrom typing import Deque\\n\\nimport sortedcontainers\\n\\n\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m: int = m\\n        self.k: int = k\\n        self.sl = sortedcontainers.SortedList()\\n        self.dq: Deque[int] = collections.deque()\\n\\n    def addElement(self, num: int) -> None:\\n        self.sl.add(num)\\n        self.dq.append(num)\\n        if len(self.dq) > self.m:\\n            item: int = self.dq.popleft()\\n            self.sl.remove(item)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.dq) < self.m:\\n            return -1\\n        mean = statistics.mean(self.sl[self.k:-self.k])\\n        return math.floor(mean)\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nimport collections\\nimport math\\nimport statistics\\nfrom typing import Deque\\n\\nimport sortedcontainers\\n\\n\\nclass MKAverage:\\n    def __init__(self, m: int, k: int):\\n        self.m: int = m\\n        self.k: int = k\\n        self.sl = sortedcontainers.SortedList()\\n        self.dq: Deque[int] = collections.deque()\\n\\n    def addElement(self, num: int) -> None:\\n        self.sl.add(num)\\n        self.dq.append(num)\\n        if len(self.dq) > self.m:\\n            item: int = self.dq.popleft()\\n            self.sl.remove(item)\\n\\n    def calculateMKAverage(self) -> int:\\n        if len(self.dq) < self.m:\\n            return -1\\n        mean = statistics.mean(self.sl[self.k:-self.k])\\n        return math.floor(mean)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564751,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1565791,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1575141,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1706463,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1575126,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1575144,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1951277,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1829099,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            },
            {
                "id": 1632258,
                "content": [
                    {
                        "username": "lee215",
                        "content": "# **1. Toe made data set**\\n10^5 operation, but even python can pass with O(n^2) solution\\n\\n# **2. Blind translation**\\nOn LC CN, it transaltes to **rounded to the nearest integer** instead of **rounded down to the nearest integer.**\\n(Even Leetcode itself highlight the word)"
                    },
                    {
                        "username": "jaadu",
                        "content": "This problem states round to the nearest integer. Instead it meant round down (floor) to the nearest integer.\\nAlso, the test cases are too weak. O(n^2) is passing. Even the first ranked did it with brute force.\\n"
                    },
                    {
                        "username": "andrerong",
                        "content": "multiset::erase(int key) will remove all elements with key\\n\\nmultiset::count() is logarithmic but linear in the number of elements found, so use multiset::find(int key)"
                    },
                    {
                        "username": "since1991sanchit",
                        "content": "# Suggestion for better tags: Binary Indexed Tree, Binary Search\n\nTestcases should be added to filter out **brute-force** and justify the **hard** classification.\n"
                    },
                    {
                        "username": "chermetz",
                        "content": "A naive solutions without sophisticated data structures seems to work - consequently I would reclassify it as a Medium difficulty problem."
                    },
                    {
                        "username": "liketheflower",
                        "content": "![image](https://assets.leetcode.com/users/images/d8543719-a7f6-4004-bd75-9670d55ac2eb_1618629919.7696753.png)\\nCode can be found in [my medium post](https://jimmy-shen.medium.com/using-three-multisets-74cd5da0d01)\\nThanks for reading."
                    },
                    {
                        "username": "NeilChang",
                        "content": "From the example:\\nobj.addElement(5);        // current elements are [3,1,10,5,5,5]\\nobj.calculateMKAverage(); // The last 3 elements are [5,5,5].\\n\\nwhy the last 3 is [5,5,5] ? \\nfrom the rule ,  1 and 10 are removed. why not copy [3,5,5]. anyone knows it ?\\n\\nIf the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\\nRemove the smallest k elements and the largest k elements from the container."
                    },
                    {
                        "username": "eternal-lct",
                        "content": "I cant pass this problem in Go (Time limit exceeded)."
                    },
                    {
                        "username": "hercules95",
                        "content": "Check these two tests for \\n1st -> 15/4 is expected to 3\\n2nd -> 18/4 is expected to 5\\n\\nI am doing Math.floor operation\\nPlease suggest\\n_________________1st__________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[6,1],[3],[1],[12],[5],[3],[4],[]]\\n\\nOutput\\n[null,null,null,null,null,null,null,3]\\nExpected\\n[null,null,null,null,null,null,null,3]\\n\\n_______________2nd____________________\\n\\n[\"MKAverage\",\"addElement\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"calculateMKAverage\",\"addElement\",\"addElement\",\"addElement\",\"calculateMKAverage\"]\\n[[3,1],[3],[1],[],[10],[],[5],[5],[5],[]]\\n\\nOutput\\n[null,null,null,-1,null,3,null,null,null,4]\\nExpected\\n[null,null,null,-1,null,3,null,null,null,5]\\n"
                    }
                ]
            }
        ]
    }
]